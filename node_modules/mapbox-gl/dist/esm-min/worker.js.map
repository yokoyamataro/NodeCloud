{"version":3,"file":"worker.js","sources":["../../src/util/performance.ts","../../src/style-spec/group_by_layout.ts","../../src/style/style_layer_index.ts","../../src/render/glyph_atlas.ts","../../src/render/indoor_parser.ts","../../src/source/worker_tile.ts","../../src/source/vector_tile_worker_source.ts","../../src/source/raster_dem_tile_worker_source.ts","../../src/source/raster_array_tile_worker_source.ts","../../src/source/geojson_wrapper.ts","../../src/source/geojson_rt.ts","../../src/source/vector_tile_to_pbf.ts","../../node_modules/supercluster/index.js","../../node_modules/geojson-vt/src/simplify.js","../../node_modules/geojson-vt/src/feature.js","../../node_modules/geojson-vt/src/convert.js","../../node_modules/geojson-vt/src/clip.js","../../node_modules/geojson-vt/src/wrap.js","../../node_modules/geojson-vt/src/transform.js","../../node_modules/geojson-vt/src/tile.js","../../node_modules/geojson-vt/src/index.js","../../src/source/geojson_worker_source.ts","../../3d-style/source/tiled_3d_model_worker_source.ts","../../src/source/worker.ts"],"sourcesContent":["import {isWorker} from '../util/util';\nimport {LivePerformanceMarkers} from '../util/live_performance';\n\nimport type {RequestParameters} from '../util/ajax';\n\nexport const PerformanceMarkers = {\n    libraryEvaluate: 'library-evaluate',\n    frameGPU: 'frame-gpu',\n    frame: 'frame'\n} as const;\n\nexport type PerformanceMarker =\n    | typeof PerformanceMarkers[keyof typeof PerformanceMarkers]\n    | typeof LivePerformanceMarkers[keyof typeof LivePerformanceMarkers];\n\nexport type PerformanceMetrics = {\n    loadTime: number;\n    fullLoadTime: number;\n    percentDroppedFrames: number;\n    parseTile: number;\n    parseTile1: number;\n    parseTile2: number;\n    workerTask: number;\n    workerInitialization: number;\n    workerEvaluateScript: number;\n    workerIdle: number;\n    workerIdlePercent: number;\n    placementTime: number;\n    timelines: WorkerPerformanceMetrics[];\n};\n\nexport type WorkerPerformanceMetrics = {\n    timeOrigin: number;\n    entries: Array<PerformanceEntry & PerformanceMarkOptions>;\n    scope: string;\n};\n\nexport type PerformanceMark = {\n    mark: string;\n    name: string;\n};\n\nexport type PerformanceMarkDetail = {\n    gpuTime?: number;\n    cpuTime?: number;\n    timestamp?: number\n    isRenderFrame?: boolean;\n};\n\ntype PerformanceMarkOptions = {\n    detail?: PerformanceMarkDetail;\n    startTime?: number;\n};\n\nlet fullLoadFinished = false;\nlet placementTime = 0;\n\nexport type PerformanceMeasureDevToolsColor =\n  \"primary\" | \"primary-light\" | \"primary-dark\"\n  | \"secondary\" | \"secondary-light\" | \"secondary-dark\"\n  | \"tertiary\" | \"tertiary-light\" | \"tertiary-dark\"\n  | \"error\";\n\n// To ensure there is not overlap in zones, use worker name or 'Main' as track and actual track name as trackgroup\nfunction trackNameOrDefault() {\n    return (isWorker(self) && self.name) ? `${self.name}` : \"Main\";\n}\n\nlet performanceUtilsGroupsMask: number = 0;\n\nexport const PerformanceUtils = {\n    GROUP_NONE: 0,\n    GROUP_COMMON: 1 << 1,\n    GROUP_RENDERING: 1 << 2,\n    GROUP_RENDERING_DETAILED: 1 << 3,\n\n    now() {\n        return performance.now();\n    },\n\n    mark(marker: PerformanceMarker, markOptions?: PerformanceMarkOptions) {\n        performance.mark(marker, markOptions);\n\n        if (marker === LivePerformanceMarkers.fullLoad) {\n            fullLoadFinished = true;\n        }\n    },\n\n    // Bitmask to enable profiling groups\n    // e.g. PerformanceUtils.GROUP_COMMON | PerformanceUtils.GROUP_RENDERING\n    setEnabledGroupsMask(mask: number) {\n        performanceUtilsGroupsMask = mask;\n    },\n\n    enabledGroupsMask(): number {\n        return performanceUtilsGroupsMask;\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    measureWithDetails(grpMask: number, name: string, track: string, startTime: number, properties?: any[][], color?: PerformanceMeasureDevToolsColor) {\n        if ((grpMask & performanceUtilsGroupsMask) === 0) return;\n        performance.measure(name, {start: startTime, detail: {\n            devtools: {\n                trackGroup: track,\n                track: trackNameOrDefault(),\n                properties,\n                color\n            }\n        }});\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    markWithDetails(grpMask: number, name: string, properties?: any[][], color?: PerformanceMeasureDevToolsColor) {\n        if ((grpMask & performanceUtilsGroupsMask) === 0) return;\n        performance.mark(name, {\n            detail: {\n                devtools: {\n                    dataType: \"marker\",\n                    color,\n                    properties,\n                }\n            }\n        });\n    },\n\n    // Based on console.timeStamp()\n    // Records timing measures to DevTools performance panel only\n    // Low overhead, but not recorded on Chrome timeline.\n    measureLowOverhead(grpMask: number,\n                label: string,\n                  start?: string | number,\n                  end?: string | number,\n                  trackName?: string) {\n        if ((grpMask & performanceUtilsGroupsMask) === 0) return;\n        // @ts-expect-error: TS2554 Chrome extension of console.timeStamp\n        console.timeStamp(label, start, end !== undefined ? end : performance.now(), trackNameOrDefault());\n    },\n\n    measure(name: string, begin?: string, end?: string) {\n        performance.measure(name, begin, end);\n    },\n    beginMeasure(name: string): PerformanceMark {\n        const mark = name;\n        performance.mark(mark);\n        return {\n            mark,\n            name\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    endMeasure(m: PerformanceMark, properties?: any[][]) {\n        performance.measure(m.name, {\n            start: m.mark,\n            detail: {\n                devtools: {\n                    track: trackNameOrDefault(),\n                    properties\n                }\n            }\n        });\n    },\n    recordPlacementTime(time: number) {\n        // Ignore placementTimes during loading\n        if (!fullLoadFinished) {\n            return;\n        }\n\n        placementTime += time;\n    },\n    frame(timestamp: number, isRenderFrame: boolean) {\n        performance.mark(PerformanceMarkers.frame, {\n            detail: {\n                timestamp,\n                isRenderFrame\n            }\n        });\n    },\n    clearMetrics() {\n        placementTime = 0;\n        fullLoadFinished = false;\n\n        performance.clearMeasures('loadTime');\n        performance.clearMeasures('fullLoadTime');\n\n        for (const marker in LivePerformanceMarkers) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            performance.clearMarks(LivePerformanceMarkers[marker]);\n        }\n    },\n\n    getPerformanceMetrics(): PerformanceMetrics {\n        const metrics: Partial<PerformanceMetrics> = {};\n\n        performance.measure('loadTime', LivePerformanceMarkers.create, LivePerformanceMarkers.load);\n        performance.measure('fullLoadTime', LivePerformanceMarkers.create, LivePerformanceMarkers.fullLoad);\n\n        const measures = performance.getEntriesByType('measure');\n        for (const measure of measures) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metrics[measure.name] = (metrics[measure.name] || 0) + measure.duration;\n        }\n\n        metrics.placementTime = placementTime;\n\n        return metrics as PerformanceMetrics;\n    },\n\n    getWorkerPerformanceMetrics(): WorkerPerformanceMetrics {\n        const entries = performance.getEntries().map((entry: PerformanceEntry & PerformanceMarkOptions) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const result: PerformanceEntry & PerformanceMarkOptions = entry.toJSON();\n            if (entry.detail) Object.assign(result, {detail: entry.detail});\n            return result;\n        });\n\n        return {\n            scope: isWorker(self) ? 'Worker' : 'Window',\n            timeOrigin: performance.timeOrigin,\n            entries\n        };\n    }\n} as const;\n\nPerformanceUtils.mark(PerformanceMarkers.libraryEvaluate);\n\nexport function getPerformanceMeasurement(request?: RequestParameters | null): Array<PerformanceEntry> {\n    const url = request ? request.url.toString() : undefined;\n    if (!url) {\n        return [];\n    }\n    return performance.getEntriesByName(url);\n}\n\nexport default performance;\n","import refProperties from './util/ref_properties';\n\nimport type {LayerSpecification} from './types';\n\nfunction stringify(obj: unknown) {\n    if (typeof obj === 'number' || typeof obj === 'boolean' || typeof obj === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify(val)},`;\n        }\n        return `${str}]`;\n    }\n\n    let str = '{';\n    for (const key of Object.keys(obj as Record<string, unknown>).sort()) {\n        str += `${key}:${stringify((obj as Record<string, unknown>)[key])},`;\n    }\n    return `${str}}`;\n}\n\nfunction getKey(layer: LayerSpecification) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify(layer[k])}`;\n    }\n    return key;\n}\n\nfunction containsKey(obj: unknown, key: string) {\n    function recursiveSearch(item: unknown): boolean {\n        if (typeof item === 'string' && item === key) {\n            return true;\n        }\n\n        if (Array.isArray(item)) {\n            return item.some(recursiveSearch);\n        }\n\n        if (item && typeof item === 'object') {\n            return Object.values(item).some(recursiveSearch);\n        }\n\n        return false;\n    }\n    return recursiveSearch(obj);\n}\n\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @param {Object} [cachedKeys] - an object to keep already calculated keys.\n * @returns {Array<Array<Layer>>}\n */\nexport default function groupByLayout(\n    layers: Array<LayerSpecification>,\n    cachedKeys: {\n        [id: string]: string;\n    },\n): Array<Array<LayerSpecification>> {\n    const groups: Record<string, LayerSpecification[]> = {};\n\n    for (let i = 0; i < layers.length; i++) {\n        const layer = layers[i];\n        let k = cachedKeys && cachedKeys[layer.id];\n\n        if (!k) {\n            // Do not group symbol layers together, as their paint properties affect placement\n            if (layer.type === 'symbol') {\n                k = layer.id;\n            } else {\n                k =  getKey(layer);\n                // The usage of \"line-progress\" inside \"line-width\" makes the property act like a layout property.\n                // We need to split it from the group to avoid conflicts in the bucket creation.\n                if (layer.type === 'line' && layer[\"paint\"]) {\n                    const lineWidth = layer[\"paint\"]['line-width'];\n                    if (containsKey(lineWidth, 'line-progress')) {\n                        k += `/${stringify(layer[\"paint\"]['line-width'])}`;\n                    }\n                }\n            }\n        }\n\n        // update the cache if there is one\n        if (cachedKeys)\n            cachedKeys[layer.id] = k;\n\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layer);\n    }\n\n    const result: LayerSpecification[][] = [];\n\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n\n    return result;\n}\n","import createStyleLayer from './create_style_layer';\nimport groupByLayout from '../style-spec/group_by_layout';\n\nimport type {TypedStyleLayer} from './style_layer/typed_style_layer';\nimport type {LayerSpecification} from '../style-spec/types';\nimport type {ConfigOptions} from './properties';\n\nexport type LayerConfigs = {\n    [_: string]: LayerSpecification;\n};\n\nexport type Family<Layer extends TypedStyleLayer> = Array<Layer>;\n\nclass StyleLayerIndex {\n    scope: string;\n    familiesBySource: {\n        [source: string]: {\n            [sourceLayer: string]: Array<Family<TypedStyleLayer>>;\n        };\n    };\n    keyCache: {\n        [source: string]: string;\n    };\n\n    _layerConfigs: LayerConfigs;\n    _layers: {\n        [_: string]: TypedStyleLayer;\n    };\n    _options: ConfigOptions | null | undefined;\n\n    constructor(layerConfigs?: Array<LayerSpecification> | null) {\n        this.keyCache = {};\n        this._layers = {};\n        this._layerConfigs = {};\n        if (layerConfigs) {\n            this.replace(layerConfigs);\n        }\n    }\n\n    replace(layerConfigs: Array<LayerSpecification>, options?: ConfigOptions | null) {\n        this._layerConfigs = {};\n        this._layers = {};\n        this.update(layerConfigs, [], options);\n    }\n\n    update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>, options?: ConfigOptions | null) {\n        this._options = options;\n\n        for (const layerConfig of layerConfigs) {\n            this._layerConfigs[layerConfig.id] = layerConfig;\n\n            const layer = this._layers[layerConfig.id] = createStyleLayer(layerConfig, this.scope, null, this._options);\n            layer.compileFilter(options);\n            if (this.keyCache[layerConfig.id])\n                delete this.keyCache[layerConfig.id];\n        }\n        for (const id of removedIds) {\n            delete this.keyCache[id];\n            delete this._layerConfigs[id];\n            delete this._layers[id];\n        }\n\n        this.familiesBySource = {};\n\n        const groups = groupByLayout(Object.values(this._layerConfigs), this.keyCache);\n\n        for (const layerConfigs of groups) {\n            const layers = layerConfigs.map((layerConfig) => this._layers[layerConfig.id]);\n\n            const layer = layers[0];\n            if (layer.visibility === 'none') {\n                continue;\n            }\n\n            const sourceId = layer.source || '';\n            let sourceGroup = this.familiesBySource[sourceId];\n            if (!sourceGroup) {\n                sourceGroup = this.familiesBySource[sourceId] = {};\n            }\n\n            const sourceLayerId = layer.sourceLayer || '_geojsonTileLayer';\n            let sourceLayerFamilies = sourceGroup[sourceLayerId];\n            if (!sourceLayerFamilies) {\n                sourceLayerFamilies = sourceGroup[sourceLayerId] = [];\n            }\n\n            sourceLayerFamilies.push(layers);\n        }\n    }\n}\n\nexport default StyleLayerIndex;\n","import {SDF_SCALE} from '../render/glyph_manager';\nimport {AlphaImage} from '../util/image';\nimport {register} from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {GlyphMap} from './glyph_manager';\n\nconst glyphPadding = 1;\n/*\n    The glyph padding is just to prevent sampling errors at the boundaries between\n    glyphs in the atlas texture, and for that purpose there's no need to make it\n    bigger with high-res SDFs. However, layout is done based on the glyph size\n    including this padding, so scaling this padding is the easiest way to keep\n    layout exactly the same as the SDF_SCALE changes.\n*/\nconst localGlyphPadding = glyphPadding * SDF_SCALE;\n\nexport type GlyphRect = {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n};\n// {glyphID: glyphRect}\nexport type GlyphPositionMap = {\n    [_: number]: GlyphRect;\n};\n\n// {fontStack: glyphPoistionMap}\nexport type GlyphPositions = {\n    [_: string]: GlyphPositionMap;\n};\n\nexport default class GlyphAtlas {\n    image: AlphaImage;\n    positions: GlyphPositions;\n\n    constructor(stacks: GlyphMap) {\n        const positions: GlyphPositions = {};\n        const bins = [];\n\n        for (const stack in stacks) {\n            const glyphData = stacks[stack];\n            const glyphPositionMap = positions[stack] = {};\n\n            for (const id in glyphData.glyphs) {\n                const src = glyphData.glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n\n                const padding = src.metrics.localGlyph ? localGlyphPadding : glyphPadding;\n                const bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding\n                };\n                bins.push(bin);\n                glyphPositionMap[id] = bin;\n            }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        const {w, h} = potpack(bins);\n        const image = new AlphaImage({width: w || 1, height: h || 1});\n\n        for (const stack in stacks) {\n            const glyphData = stacks[stack];\n\n            for (const id in glyphData.glyphs) {\n                const src = glyphData.glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n                const bin = positions[stack][id];\n                const padding = src.metrics.localGlyph ? localGlyphPadding : glyphPadding;\n                AlphaImage.copy(src.bitmap, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.bitmap);\n            }\n        }\n\n        this.image = image;\n        this.positions = positions;\n    }\n}\n\nregister(GlyphAtlas, 'GlyphAtlas');\n","import {warnOnce} from \"../util/util\";\n\nimport type {VectorTile, VectorTileFeature} from \"@mapbox/vector-tile\";\nimport type {IndoorBuilding, IndoorData, IndoorTileOptions} from \"../style/indoor_data\";\nimport type Actor from \"../util/actor\";\n\nexport function parseIndoorData(data: VectorTile, indoorTileOptions: IndoorTileOptions, actor: Actor): IndoorData {\n    const sourceLayers = calculateIndoorSourceLayers(indoorTileOptions.sourceLayers, new Set(Object.keys(data.layers)));\n    const indoorState = indoorTileOptions.indoorState;\n    const indoorData = parseData(data, sourceLayers, indoorState.lastActiveFloors, indoorState.selectedFloorId);\n    actor.send('setIndoorData', indoorData);\n    return indoorData;\n}\n\n// This function is used to parse the indoor data from the vector tile\n// And resolve set of currently active floors based on lastActiveFloors and selectedFloorId\n// 1. Parse the indoor data from the vector tile\n// 2. selectedFloorId will be used to determine if the floor is active (either directly or via connected_floor_ids)\n// 3. if lastActiveFloors is provided, we will also add floors from that set that are not conflicting with the new active floors from step 2\n// 4. we also add default floors that are not conflicting with the new active floors from steps 2 and 3\n// ResolveD data will be passed to the bucket and emitted to indoor manager to create new indoorState\nfunction parseData(\n    data: VectorTile,\n    sourceLayers: Set<string>,\n    lastActiveFloors: Set<string>,\n    selectedFloorId: string\n): IndoorData {\n    const newActiveFloors = new Set<string>();\n    const allFloors = new Set<string>();\n    const allDefaultFloors = new Set<string>();\n\n    const floorIdToConflicts = new Map<string, Set<string>>();\n    const buildings: Record<string, IndoorBuilding> = {};\n\n    // If any active floor lists candidate as conflict, or candidate lists any active as conflict\n    const conflictsWithActive = (candidateId: string): boolean => {\n        const candidateConflicts = floorIdToConflicts.get(candidateId) || new Set<string>();\n        for (const activeId of newActiveFloors) {\n            const activeConflicts = floorIdToConflicts.get(activeId) || new Set<string>();\n            if (activeConflicts.has(candidateId) || candidateConflicts.has(activeId)) return true;\n        }\n        return false;\n    };\n\n    for (const layerId of sourceLayers) {\n        const sourceLayer = data.layers[layerId];\n        if (!sourceLayer) {\n            warnOnce(`indoor source layer not found: ${layerId}`);\n            continue;\n        }\n\n        for (let index = 0; index < sourceLayer.length; index++) {\n            const feature = sourceLayer.feature(index);\n\n            if (isValidBuildingFeature(feature)) {\n                const {id, center} = parseBuilding(feature);\n                upsertBuilding(buildings, id, center);\n                newActiveFloors.add(id);\n                continue;\n            }\n\n            // Next step: Introduce better logging in case of invalid feature with valid type\n            if (isValidFloorFeature(feature)) {\n                const {id, isDefault, connections, conflicts, buildings: buildingIds, name, zIndex} = parseFloor(feature);\n                assignFloorToBuildings(buildings, buildingIds, id, {name, zIndex});\n\n                floorIdToConflicts.set(id, conflicts);\n\n                const isActiveFloor = (id === selectedFloorId) || connections.has(selectedFloorId);\n                if (isActiveFloor) {\n                    newActiveFloors.add(id);\n                }\n\n                allFloors.add(id);\n                if (isDefault) {\n                    allDefaultFloors.add(id);\n                }\n            }\n        }\n    }\n\n    // Add last active floors that still exist and don't conflict with current active floors\n    if (lastActiveFloors) {\n        for (const lastActiveFloorId of lastActiveFloors) {\n            // lastActiveFloors may contain floors that are not in the current tile data, so we need to check if they exist and skip if they don't\n            if (!allFloors.has(lastActiveFloorId)) continue;\n            if (!conflictsWithActive(lastActiveFloorId)) {\n                newActiveFloors.add(lastActiveFloorId);\n            }\n        }\n    }\n\n    // Add default floors that don't conflict with the active floors\n    for (const defaultFloorId of allDefaultFloors) {\n        if (newActiveFloors.has(defaultFloorId)) continue;\n        if (!conflictsWithActive(defaultFloorId)) {\n            newActiveFloors.add(defaultFloorId);\n        }\n    }\n\n    return {\n        buildings,\n        activeFloors: newActiveFloors\n    };\n}\n\nfunction upsertBuilding(\n    buildings: Record<string, IndoorBuilding>,\n    buildingId: string,\n    center?: [number, number]\n): void {\n    if (!buildings[buildingId]) {\n        buildings[buildingId] = {\n            floorIds: new Set(),\n            center: center ? center : [0, 0],\n            floors: {},\n        };\n    } else if (center) {\n        buildings[buildingId].center = center;\n    }\n}\n\nfunction assignFloorToBuildings(\n    buildings: Record<string, IndoorBuilding>,\n    buildingIds: Set<string>,\n    floorId: string,\n    floor: {name: string, zIndex: number}\n): void {\n    for (const buildingId of buildingIds) {\n        upsertBuilding(buildings, buildingId);\n        buildings[buildingId].floors[floorId] = floor;\n        buildings[buildingId].floorIds.add(floorId);\n    }\n}\n\nfunction parseBuilding(feature: VectorTileFeature): {id: string, center: [number, number]} {\n    const id = feature.properties.id.toString();\n    const center = feature.properties.center.toString().split(\";\").map(Number) as [number, number];\n    return {id, center};\n}\n\nfunction parseFloor(feature: VectorTileFeature): {id: string, isDefault: boolean, connections: Set<string>, conflicts: Set<string>, buildings: Set<string>, zIndex: number, name: string} {\n    const id = feature.properties.id.toString();\n    const isDefault = feature.properties.is_default ?\n        feature.properties.is_default as boolean :\n        false;\n    const connections: Set<string> = feature.properties.connected_floor_ids ?\n        new Set(feature.properties.connected_floor_ids.toString().split(\";\")) :\n        new Set();\n    const conflicts: Set<string> = feature.properties.conflicted_floor_ids ?\n        new Set(feature.properties.conflicted_floor_ids.toString().split(\";\")) :\n        new Set();\n    const buildings: Set<string> = feature.properties.building_ids ?\n        new Set(feature.properties.building_ids.toString().split(\";\")) :\n        new Set();\n    const name = feature.properties.name.toString();\n    const zIndex = feature.properties.z_index as number;\n\n    return {id, isDefault, connections, conflicts, buildings, name, zIndex};\n}\n\nfunction hasRequiredProperties(feature: VectorTileFeature, requiredProps: string[]): boolean {\n    return requiredProps.every(prop => feature.properties && feature.properties[prop] !== undefined && feature.properties[prop] !== null);\n}\n\nfunction isValidBuildingFeature(feature: VectorTileFeature): boolean {\n    return hasRequiredProperties(feature, ['type', 'id', 'name']) &&\n            feature.properties.type === \"building\";\n}\n\nfunction isValidFloorFeature(feature: VectorTileFeature): boolean {\n    return hasRequiredProperties(feature, ['type', 'id', 'name', 'z_index']) &&\n            feature.properties.type === \"floor\";\n}\n\nfunction calculateIndoorSourceLayers(sourceLayers: Set<string> | null, actualSourceLayers: Set<string>): Set<string> {\n    if (!sourceLayers) {\n        warnOnce('No source layers defined in indoor specification');\n        return actualSourceLayers;\n    }\n\n    // This is a valid case for GeoJSON, where we have single sourceLayer with special id, which we don't want to rely explicitly\n    if (sourceLayers.size === 0) {\n        return actualSourceLayers;\n    }\n\n    const missingSourceLayers = sourceLayers.difference(actualSourceLayers);\n    for (const missingSourceLayer of missingSourceLayers) {\n        warnOnce(`Missing source layer required in indoor specification: ${missingSourceLayer}`);\n    }\n\n    return actualSourceLayers.intersection(actualSourceLayers);\n}\n","import FeatureIndex from '../data/feature_index';\nimport {performSymbolLayout, postRasterizationSymbolLayout, type SymbolBucketData} from '../symbol/symbol_layout';\nimport {CollisionBoxArray} from '../data/array_types';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport LineBucket from '../data/bucket/line_bucket';\nimport FillBucket from '../data/bucket/fill_bucket';\nimport FillExtrusionBucket from '../data/bucket/fill_extrusion_bucket';\nimport {warnOnce, mapObject} from '../util/util';\nimport assert from 'assert';\nimport LineAtlas from '../render/line_atlas';\nimport ImageAtlas, {getImagePosition, ICON_PADDING} from '../render/image_atlas';\nimport GlyphAtlas from '../render/glyph_atlas';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {OverscaledTileID} from './tile_id';\nimport {PerformanceUtils, type PerformanceMark} from '../util/performance';\nimport tileTransform from '../geo/projection/tile_transform';\nimport {makeFQID} from \"../util/fqid\";\nimport {type SpritePositions} from '../util/image';\nimport {ElevationFeatures} from '../../3d-style/elevation/elevation_feature';\nimport {HD_ELEVATION_SOURCE_LAYER, PROPERTY_ELEVATION_ID} from '../../3d-style/elevation/elevation_constants';\nimport {ElevationPortalGraph} from '../../3d-style/elevation/elevation_graph';\nimport {ImageId} from '../style-spec/expression/types/image_id';\nimport {parseIndoorData} from '../render/indoor_parser';\n\nimport type {VectorTile} from '@mapbox/vector-tile';\nimport type {CanonicalTileID} from './tile_id';\nimport type Projection from '../geo/projection/projection';\nimport type {Bucket, PopulateParameters, ImageDependenciesMap} from '../data/bucket';\nimport type Actor from '../util/actor';\nimport type {TypedStyleLayer} from '../style/style_layer/typed_style_layer';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {StyleImage, StyleImageMap} from '../style/style_image';\nimport type {\n    WorkerSourceVectorTileRequest,\n    WorkerSourceVectorTileCallback,\n} from '../source/worker_source';\nimport type {PromoteIdSpecification} from '../style-spec/types';\nimport type {TileTransform} from '../geo/projection/tile_transform';\nimport type {LUT} from \"../util/lut\";\nimport type {GlyphMap} from '../render/glyph_manager';\nimport type {ImagePositionMap} from '../render/image_atlas';\nimport type {RasterizedImageMap, ImageRasterizationTasks} from '../render/image_manager';\nimport type {StringifiedImageId} from '../style-spec/expression/types/image_id';\nimport type {StringifiedImageVariant} from '../style-spec/expression/types/image_variant';\nimport type {StyleModelMap} from '../style/style_mode';\nimport type {IndoorTileOptions} from '../style/indoor_data';\n\ntype RasterizationStatus = {iconsPending: boolean, patternsPending: boolean};\nclass WorkerTile {\n    tileID: OverscaledTileID;\n    uid: number;\n    zoom: number;\n    lut: LUT | null;\n    tileZoom: number;\n    canonical: CanonicalTileID;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    scope: string;\n    promoteId: PromoteIdSpecification | null | undefined;\n    overscaling: number;\n    showCollisionBoxes: boolean;\n    collectResourceTiming: boolean;\n    isSymbolTile: boolean | null | undefined;\n    extraShadowCaster: boolean | null | undefined;\n    tessellationStep: number | null | undefined;\n    projection: Projection;\n    worldview?: string | null;\n    localizableLayerIds?: Set<string>;\n    tileTransform: TileTransform;\n    brightness: number;\n    scaleFactor: number;\n    indoor: IndoorTileOptions | null;\n\n    status: 'parsing' | 'done';\n    data: VectorTile;\n    collisionBoxArray: CollisionBoxArray;\n\n    abort: () => void | null | undefined;\n    reloadCallback?: WorkerSourceVectorTileCallback | null | undefined;\n    vectorTile: VectorTile;\n    rasterizeTask: {cancel: () => void} | null | undefined;\n\n    constructor(params: WorkerSourceVectorTileRequest) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.tileZoom = params.tileZoom;\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.lut = params.lut;\n        this.canonical = params.tileID.canonical;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.scope = params.scope;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.collectResourceTiming = params.request ? params.request.collectResourceTiming : false;\n        this.promoteId = params.promoteId;\n        this.isSymbolTile = params.isSymbolTile;\n        this.tileTransform = tileTransform(params.tileID.canonical, params.projection);\n        this.projection = params.projection;\n        this.worldview = params.worldview;\n        this.localizableLayerIds = params.localizableLayerIds;\n        this.brightness = params.brightness;\n        this.extraShadowCaster = !!params.extraShadowCaster;\n        this.tessellationStep = params.tessellationStep;\n        this.scaleFactor = params.scaleFactor;\n        this.worldview = params.worldview;\n        this.indoor = params.indoor;\n    }\n\n    parse(data: VectorTile, layerIndex: StyleLayerIndex, availableImages: ImageId[], availableModels: StyleModelMap, actor: Actor, callback: WorkerSourceVectorTileCallback) {\n        const m = PerformanceUtils.beginMeasure('parseTile1');\n        this.status = 'parsing';\n        this.data = data;\n\n        this.collisionBoxArray = new CollisionBoxArray();\n        const sourceLayerCoder = new DictionaryCoder(Object.keys(data.layers).sort());\n\n        const featureIndex = new FeatureIndex(this.tileID, this.promoteId);\n        featureIndex.bucketLayerIDs = [];\n\n        const buckets: Record<string, Bucket> = {};\n\n        // we initially reserve space for a 256x256 atlas, but trim it after processing all line features\n        const lineAtlas = new LineAtlas(256, 256);\n\n        const options: PopulateParameters = {\n            featureIndex,\n            iconDependencies: new Map(),\n            patternDependencies: new Map(),\n            glyphDependencies: {},\n            lineAtlas,\n            availableImages,\n            brightness: this.brightness,\n            scaleFactor: this.scaleFactor,\n            elevationFeatures: undefined,\n            activeFloors: undefined\n        };\n\n        if (this.indoor) {\n            const activeFloorsVisible = this.indoor.indoorState.activeFloorsVisible;\n            const indoorData = parseIndoorData(data, this.indoor, actor);\n            options.activeFloors = activeFloorsVisible ? indoorData.activeFloors : undefined;\n        }\n\n        const asyncBucketLoads: Promise<unknown>[] = [];\n        const layerFamilies = layerIndex.familiesBySource[this.source];\n\n        for (const sourceLayerId in layerFamilies) {\n            const sourceLayer = data.layers[sourceLayerId];\n            if (!sourceLayer) {\n                continue;\n            }\n\n            let anySymbolLayers = false;\n            let anyOtherLayers = false;\n            let any3DLayer = false;\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                if (family[0].type === 'symbol') {\n                    anySymbolLayers = true;\n                } else {\n                    anyOtherLayers = true;\n                }\n                if (family[0].is3D() && family[0].type !== 'model') {\n                    any3DLayer = true;\n                }\n            }\n\n            if (this.extraShadowCaster && !any3DLayer) {\n                continue;\n            }\n\n            if (this.isSymbolTile === true && !anySymbolLayers) {\n                continue;\n            } else if (this.isSymbolTile === false && !anyOtherLayers) {\n                continue;\n            }\n\n            if (sourceLayer.version === 1) {\n                warnOnce(`Vector tile source \"${this.source}\" layer \"${sourceLayerId}\" ` +\n                    `does not use vector tile spec v2 and therefore may have some rendering errors.`);\n            }\n\n            const sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);\n            const features = [];\n\n            const localizable = this.localizableLayerIds && this.localizableLayerIds.has(sourceLayerId);\n\n            let elevationDependency = false;\n            for (let index = 0, currentFeatureIndex = 0; index < sourceLayer.length; index++) {\n                const feature = sourceLayer.feature(index);\n                const id = featureIndex.getId(feature, sourceLayerId);\n                const worldview = feature.properties ? feature.properties.worldview : null;\n\n                // Handle feature localization based on the map worldview:\n                // 1. If the feature layer is localizable, check if it has a 'worldview' property\n                // 2. Check if the feature worldview is 'all' (visible in all worldviews) or matches the current map worldview\n                // 3. Mark the feature with '$localized' property or skip it otherwise\n                if (localizable && this.worldview && typeof worldview === 'string') {\n                    if (worldview === 'all') {\n                        feature.properties['$localized'] = true;\n                    } else if (worldview.split(',').includes(this.worldview)) {\n                        feature.properties['$localized'] = true;\n                        feature.properties['worldview'] = this.worldview;\n                    } else {\n                        continue; // Skip features that don't match the current worldview\n                    }\n                }\n\n                if (!elevationDependency && feature.properties && feature.properties.hasOwnProperty(PROPERTY_ELEVATION_ID)) {\n                    elevationDependency = true;\n                }\n\n                features.push({feature, id, index: currentFeatureIndex, sourceLayerIndex});\n                currentFeatureIndex++;\n            }\n\n            if (elevationDependency && !options.elevationFeatures && data.layers.hasOwnProperty(HD_ELEVATION_SOURCE_LAYER)) {\n                options.elevationFeatures = ElevationFeatures.parseFrom(data.layers[HD_ELEVATION_SOURCE_LAYER], this.canonical);\n            }\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                const layer = family[0];\n\n                if (this.extraShadowCaster && (!layer.is3D() || layer.type === 'model')) {\n                    // avoid to spend resources in 2D layers or 3D model layers (trees) for extra shadow casters\n                    continue;\n                }\n                if (this.isSymbolTile !== undefined && (layer.type === 'symbol') !== this.isSymbolTile) continue;\n                assert(layer.source === this.source);\n                if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) continue;\n                if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;\n                if (layer.visibility === 'none') continue;\n\n                recalculateLayers(family, this.zoom, options.brightness, availableImages, this.worldview);\n\n                // @ts-expect-error: Type 'TypedStyleLayer' doesn't have a 'createBucket' method in all of its subtypes\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n                const bucket: Bucket = buckets[layer.id] = layer.createBucket({\n                    index: featureIndex.bucketLayerIDs.length,\n                    layers: family,\n                    zoom: this.zoom,\n                    lut: this.lut,\n                    canonical: this.canonical,\n                    pixelRatio: this.pixelRatio,\n                    overscaling: this.overscaling,\n                    collisionBoxArray: this.collisionBoxArray,\n                    sourceLayerIndex,\n                    sourceID: this.source,\n                    projection: this.projection.spec,\n                    tessellationStep: this.tessellationStep,\n                    styleDefinedModelURLs: availableModels,\n                    worldview: this.worldview,\n                    localizable,\n                    availableImages\n                });\n\n                assert(this.tileTransform.projection.name === this.projection.name);\n                featureIndex.bucketLayerIDs.push(family.map((l) => makeFQID(l.id, l.scope)));\n\n                let bucketPromise = bucket.prepare ? bucket.prepare() : null;\n                if (bucketPromise != null) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    bucketPromise = bucketPromise.then(() => bucket.populate(features, options, this.tileID.canonical, this.tileTransform));\n                    asyncBucketLoads.push(bucketPromise);\n                } else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    bucket.populate(features, options, this.tileID.canonical, this.tileTransform);\n                }\n            }\n        }\n\n        const prepareTile = () => {\n            lineAtlas.trim();\n\n            let error: Error | null | undefined;\n            let glyphMap: GlyphMap;\n            let iconMap: StyleImageMap<StringifiedImageVariant>;\n            let patternMap: StyleImageMap<StringifiedImageVariant>;\n            let iconRasterizationTasks: ImageRasterizationTasks;\n            let patternRasterizationTasks: ImageRasterizationTasks;\n            const taskMetadata = {type: 'maybePrepare', isSymbolTile: this.isSymbolTile, zoom: this.zoom} as const;\n\n            const maybePrepare = () => {\n                if (error) {\n                    this.status = 'done';\n                    return callback(error);\n                } else if (this.extraShadowCaster) {\n                    const m = PerformanceUtils.beginMeasure('parseTile2');\n                    this.status = 'done';\n                    callback(null, {\n                        buckets: Object.values(buckets).filter(b => !b.isEmpty()),\n                        featureIndex,\n                        collisionBoxArray: null,\n                        glyphAtlasImage: null,\n                        lineAtlas: null,\n                        imageAtlas: null,\n                        brightness: options.brightness,\n                        // Only used for benchmarking:\n                        glyphMap: null,\n                        iconMap: null,\n                        glyphPositions: null\n                    });\n                    PerformanceUtils.endMeasure(m, [[\"tileID\", this.tileID.toString()], [\"source\", this.source]]);\n                } else if (glyphMap && iconMap && patternMap) {\n                    const m = PerformanceUtils.beginMeasure('parseTile2');\n                    const glyphAtlas = new GlyphAtlas(glyphMap);\n\n                    const iconPositions: ImagePositionMap = new Map();\n                    for (const [id, icon] of iconMap.entries()) {\n                        const {imagePosition} = getImagePosition(id, icon, ICON_PADDING);\n                        iconPositions.set(id, imagePosition);\n                    }\n\n                    const symbolLayoutData: Record<string, SymbolBucketData> = {};\n                    for (const key in buckets) {\n                        const bucket = buckets[key];\n                        if (bucket instanceof SymbolBucket) {\n                            recalculateLayers(bucket.layers, this.zoom, options.brightness, availableImages, this.worldview);\n                            symbolLayoutData[key] =\n                            performSymbolLayout(bucket,\n                                    glyphMap,\n                                    glyphAtlas.positions,\n                                    iconMap,\n                                    iconPositions,\n                                    this.tileID.canonical,\n                                    this.tileZoom,\n                                    this.scaleFactor,\n                                    this.pixelRatio,\n                                    iconRasterizationTasks,\n                                    this.worldview,\n                                    availableImages);\n                        }\n                    }\n\n                    const rasterizationStatus: RasterizationStatus = {iconsPending: true, patternsPending: true};\n                    this.rasterizeIfNeeded(actor, iconMap, iconRasterizationTasks, () => {\n                        rasterizationStatus.iconsPending = false;\n                        postRasterizationLayout(symbolLayoutData, glyphAtlas, rasterizationStatus, m);\n                    });\n                    this.rasterizeIfNeeded(actor, patternMap, patternRasterizationTasks, () => {\n                        rasterizationStatus.patternsPending = false;\n                        postRasterizationLayout(symbolLayoutData, glyphAtlas, rasterizationStatus, m);\n                    });\n\n                }\n            };\n\n            const postRasterizationLayout = (symbolLayoutData: Record<string, SymbolBucketData>, glyphAtlas: GlyphAtlas, rasterizationStatus: RasterizationStatus, m: PerformanceMark) => {\n                if (rasterizationStatus.iconsPending || rasterizationStatus.patternsPending) return;\n                const imageAtlas = new ImageAtlas(iconMap, patternMap, this.lut);\n                for (const key in buckets) {\n                    const bucket = buckets[key];\n                    if (key in symbolLayoutData) {\n                        postRasterizationSymbolLayout(bucket as SymbolBucket, symbolLayoutData[key], this.showCollisionBoxes, availableImages, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, iconMap, imageAtlas);\n                    } else if (bucket.hasPattern &&\n                        (bucket instanceof LineBucket ||\n                            bucket instanceof FillBucket ||\n                            bucket instanceof FillExtrusionBucket)) {\n                        recalculateLayers(bucket.layers, this.zoom, options.brightness, availableImages, this.worldview);\n                        const imagePositions: SpritePositions = Object.fromEntries(imageAtlas.patternPositions);\n                        bucket.addFeatures(options, this.tileID.canonical, imagePositions, availableImages, this.tileTransform, this.brightness);\n                    }\n                }\n\n                this.status = 'done';\n                callback(null, {\n                    buckets: Object.values(buckets).filter(b => !b.isEmpty()),\n                    featureIndex,\n                    collisionBoxArray: this.collisionBoxArray,\n                    glyphAtlasImage: glyphAtlas.image,\n                    lineAtlas,\n                    imageAtlas,\n                    brightness: options.brightness\n                });\n                PerformanceUtils.endMeasure(m, [[\"tileID\", this.tileID.toString()], [\"source\", this.source]]);\n            };\n\n            if (!this.extraShadowCaster) {\n                const stacks = mapObject(options.glyphDependencies, (glyphs) => Object.keys(glyphs).map(Number));\n                if (Object.keys(stacks).length) {\n                    actor.send('getGlyphs', {uid: this.uid, stacks}, (err, result: GlyphMap) => {\n                        if (!error) {\n                            error = err;\n                            glyphMap = result;\n                            maybePrepare();\n                        }\n                    }, undefined, false, taskMetadata);\n                } else {\n                    glyphMap = {};\n                }\n\n                const images = Array.from(options.iconDependencies.keys()).map((id) => ImageId.parse(id));\n                if (images.length) {\n                    const params = {images, source: this.source, scope: this.scope, tileID: this.tileID, type: 'icons'} as const;\n                    actor.send('getImages', params, (err: Error, result: StyleImageMap<StringifiedImageId>) => {\n                        if (error) {\n                            return;\n                        }\n\n                        error = err;\n                        iconMap = new Map();\n                        iconRasterizationTasks = this.updateImageMapAndGetImageTaskQueue(iconMap, result, options.iconDependencies);\n                        maybePrepare();\n                    }, undefined, false, taskMetadata);\n                } else {\n                    iconMap = new Map();\n                    iconRasterizationTasks = new Map();\n                }\n\n                const patterns = Array.from(options.patternDependencies.keys()).map((id) => ImageId.parse(id));\n                if (patterns.length) {\n                    const params = {images: patterns, source: this.source, scope: this.scope, tileID: this.tileID, type: 'patterns'} as const;\n                    actor.send('getImages', params, (err: Error, result: StyleImageMap<StringifiedImageId>) => {\n                        if (error) {\n                            return;\n                        }\n\n                        error = err;\n                        patternMap = new Map();\n                        patternRasterizationTasks = this.updateImageMapAndGetImageTaskQueue(patternMap, result, options.patternDependencies);\n                        maybePrepare();\n                    }, undefined, false, taskMetadata);\n                } else {\n                    patternMap = new Map();\n                    patternRasterizationTasks = new Map();\n                }\n            }\n\n            if (options.elevationFeatures && options.elevationFeatures.length > 0) {\n                // Multiple layers might contribute to the elevation of this tile. For this reason we need to combine\n                // unevaluated portals from available buckets into single graph that describes polygon connectivity of the whole\n                // tile\n                const unevaluatedPortals = [];\n\n                for (const bucket of Object.values(buckets)) {\n                    if (bucket instanceof FillBucket) {\n                        const graph = bucket.getUnevaluatedPortalGraph();\n                        if (graph) {\n                            unevaluatedPortals.push(graph);\n                        }\n                    }\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                const evaluatedPortals = ElevationPortalGraph.evaluate(unevaluatedPortals);\n\n                // Pass evaluated portals back to buckets and construct a separate acceleration structure\n                // for elevation queries.\n                for (const bucket of Object.values(buckets)) {\n                    if (bucket instanceof FillBucket) {\n                        const vtLayer = data.layers[sourceLayerCoder.decode(bucket.sourceLayerIndex)];\n                        assert(vtLayer);\n                        bucket.setEvaluatedPortalGraph(evaluatedPortals, vtLayer, this.tileID.canonical, options.availableImages, options.brightness);\n                    }\n                }\n            }\n\n            PerformanceUtils.endMeasure(m, [[\"tileID\", this.tileID.toString()], [\"source\", this.source]]);\n\n            maybePrepare();\n        };\n\n        if (asyncBucketLoads.length > 0) {\n            Promise.allSettled(asyncBucketLoads)\n                .then(prepareTile)\n                .catch(callback);\n        } else {\n            prepareTile();\n        }\n    }\n\n    updateParameters(params: WorkerSourceVectorTileRequest) {\n        this.scaleFactor = params.scaleFactor;\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.projection = params.projection;\n        this.brightness = params.brightness;\n        this.tileTransform = tileTransform(params.tileID.canonical, params.projection);\n        this.extraShadowCaster = params.extraShadowCaster;\n        this.lut = params.lut;\n        this.worldview = params.worldview;\n        this.indoor = params.indoor;\n    }\n\n    rasterizeIfNeeded(actor: Actor, outputMap: StyleImageMap<StringifiedImageVariant> | undefined, tasks: ImageRasterizationTasks, callback: () => void) {\n        const needRasterization = Array.from(outputMap.values()).some((image: StyleImage) => image.usvg);\n        if (needRasterization) {\n            this.rasterize(actor, outputMap, tasks, callback);\n        } else {\n            callback();\n        }\n    }\n\n    updateImageMapAndGetImageTaskQueue(imageMap: StyleImageMap<StringifiedImageVariant>, images: StyleImageMap<StringifiedImageId>, imageDependencies: ImageDependenciesMap): ImageRasterizationTasks {\n        const imageRasterizationTasks: ImageRasterizationTasks = new Map();\n        for (const imageName of images.keys()) {\n            const requiredImageVariants = imageDependencies.get(imageName) || [];\n            for (const imageVariant of requiredImageVariants) {\n                const imageVariantStr = imageVariant.toString();\n                const image = images.get(imageVariant.id.toString());\n                if (!image.usvg) {\n                    imageMap.set(imageVariantStr, image);\n                } else if (!imageRasterizationTasks.has(imageVariantStr)) {\n                    imageRasterizationTasks.set(imageVariantStr, imageVariant);\n                    imageMap.set(imageVariantStr, Object.assign({}, image));\n                }\n            }\n        }\n\n        return imageRasterizationTasks;\n    }\n\n    rasterize(actor: Actor, imageMap: StyleImageMap<StringifiedImageVariant>, tasks: ImageRasterizationTasks, callback: () => void) {\n        this.rasterizeTask = actor.send('rasterizeImages', {scope: this.scope, tasks}, (err: Error, rasterizedImages: RasterizedImageMap) => {\n            if (!err) {\n                for (const [id, data] of rasterizedImages.entries()) {\n                    const image = Object.assign(imageMap.get(id), {data});\n                    imageMap.set(id, image);\n                }\n            }\n\n            callback();\n        });\n    }\n\n    cancelRasterize() {\n        if (this.rasterizeTask) {\n            this.rasterizeTask.cancel();\n        }\n    }\n}\n\nfunction recalculateLayers(layers: ReadonlyArray<TypedStyleLayer>, zoom: number, brightness: number, availableImages: ImageId[], worldview: string | undefined) {\n    // Layers are shared and may have been used by a WorkerTile with a different zoom.\n    const parameters = new EvaluationParameters(zoom, {brightness, worldview});\n    for (const layer of layers) {\n        layer.recalculate(parameters, availableImages);\n    }\n}\n\nexport default WorkerTile;\n","import {VectorTile} from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport WorkerTile from './worker_tile';\nimport {getPerformanceMeasurement} from '../util/performance';\nimport {Evented} from '../util/evented';\nimport {loadVectorTile, DedupedRequest} from './load_vector_tile';\nimport {getExpiryDataFromHeaders} from '../util/util';\n\nimport type {\n    WorkerSource,\n    WorkerSourceTileRequest,\n    WorkerSourceVectorTileRequest,\n    WorkerSourceVectorTileResult,\n    WorkerSourceVectorTileCallback,\n} from './worker_source';\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type Scheduler from '../util/scheduler';\nimport type {TaskMetadata} from '../util/scheduler';\nimport type {LoadVectorData} from './load_vector_tile';\nimport type {ImageId} from '../style-spec/expression/types/image_id';\nimport type {StyleModelMap} from '../style/style_mode';\n\n/**\n * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory VectorTile\n * representation.  To do so, create it with\n * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.\n *\n * @private\n */\nclass VectorTileWorkerSource extends Evented implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    availableImages: ImageId[];\n    availableModels: StyleModelMap;\n    loadVectorData: LoadVectorData;\n    loading: Record<number, WorkerTile>;\n    loaded: Record<number, WorkerTile>;\n    deduped: DedupedRequest;\n    isSpriteLoaded: boolean;\n    scheduler?: Scheduler | null;\n    brightness?: number | null;\n\n    /**\n     * @param [loadVectorData] Optional method for custom loading of a VectorTile\n     * object based on parameters passed from the main-thread Source. See\n     * {@link VectorTileWorkerSource#loadTile}. The default implementation simply\n     * loads the pbf at `params.url`.\n     * @private\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, availableImages: ImageId[], availableModels: StyleModelMap, isSpriteLoaded: boolean, loadVectorData?: LoadVectorData | null, brightness?: number | null) {\n        super();\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.availableImages = availableImages;\n        this.availableModels = availableModels;\n        this.loadVectorData = loadVectorData || loadVectorTile;\n        this.loading = {};\n        this.loaded = {};\n        this.deduped = new DedupedRequest(actor.scheduler);\n        this.isSpriteLoaded = isSpriteLoaded;\n        this.scheduler = actor.scheduler;\n        this.brightness = brightness;\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}. Delegates to\n     * {@link VectorTileWorkerSource#loadVectorData} (which by default expects\n     * a `params.url` property) for fetching and producing a VectorTile object.\n     * @private\n     */\n    loadTile(params: WorkerSourceVectorTileRequest, callback: WorkerSourceVectorTileCallback) {\n        const uid = params.uid;\n\n        const requestParam = params && params.request;\n        const perf = requestParam && requestParam.collectResourceTiming;\n\n        const workerTile = this.loading[uid] = new WorkerTile(params);\n        workerTile.abort = this.loadVectorData(params, (err, response) => {\n            const aborted = !this.loading[uid];\n\n            delete this.loading[uid];\n\n            workerTile.cancelRasterize();\n\n            if (aborted || err || !response) {\n                workerTile.status = 'done';\n                if (!aborted) this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            const rawTileData = response.rawData;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const cacheControl: Record<string, any> = {};\n            const expiryData = getExpiryDataFromHeaders(response.responseHeaders);\n            if (expiryData && expiryData.expires) cacheControl.expires = expiryData.expires;\n            if (expiryData && expiryData.cacheControl) cacheControl.cacheControl = expiryData.cacheControl;\n\n            // response.vectorTile will be present in the GeoJSON worker case (which inherits from this class)\n            // because we stub the vector tile interface around JSON data instead of parsing it directly\n            workerTile.vectorTile = response.vectorTile || new VectorTile(new Protobuf(rawTileData));\n            const parseTile = () => {\n                const WorkerSourceVectorTileCallback = (err?: Error | null, result?: WorkerSourceVectorTileResult | null) => {\n                    if (err || !result) return callback(err);\n\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const resourceTiming: Record<string, any> = {};\n                    if (perf) {\n                        // Transferring a copy of rawTileData because the worker needs to retain its copy.\n                        const resourceTimingData = getPerformanceMeasurement(requestParam);\n                        // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                        // late evaluation in the main thread causes TypeError: illegal invocation\n                        if (resourceTimingData.length > 0) {\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));\n                        }\n                    }\n                    callback(null, Object.assign({rawTileData: rawTileData.slice(0), responseHeaders: response.responseHeaders}, result, cacheControl, resourceTiming));\n                };\n                workerTile.parse(workerTile.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, WorkerSourceVectorTileCallback);\n            };\n\n            if (this.isSpriteLoaded) {\n                parseTile();\n            } else {\n                // Defer tile parsing until sprite is ready. Style emits 'spriteLoaded' event, which triggers the 'isSpriteLoaded' event here.\n                this.once('isSpriteLoaded', () => {\n                    if (this.scheduler) {\n                        const metadata: TaskMetadata = {type: 'parseTile', isSymbolTile: params.isSymbolTile, zoom: params.tileZoom};\n                        this.scheduler.add(parseTile, metadata);\n                    } else {\n                        parseTile();\n                    }\n                });\n            }\n\n            this.loaded = this.loaded || {};\n            this.loaded[uid] = workerTile;\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     * @private\n     */\n    reloadTile(params: WorkerSourceVectorTileRequest, callback: WorkerSourceVectorTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.updateParameters(params);\n            const done = (err?: Error | null, data?: WorkerSourceVectorTileResult | null) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, reloadCallback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // if there was no vector tile data on the initial load, don't try and re-parse tile\n                if (workerTile.vectorTile) {\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, done);\n                } else {\n                    done();\n                }\n            }\n        } else {\n            callback(null, undefined);\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     * @private\n     */\n    abortTile(params: WorkerSourceTileRequest, callback: WorkerSourceVectorTileCallback) {\n        const uid = params.uid;\n        const tile = this.loading[uid];\n        if (tile) {\n            if (tile.abort) tile.abort();\n            delete this.loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     * @private\n     */\n    removeTile(params: WorkerSourceTileRequest, callback: WorkerSourceVectorTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n}\n\nexport default VectorTileWorkerSource;\n","import DEMData from '../data/dem_data';\n\nimport type Actor from '../util/actor';\nimport type {\n    WorkerSource,\n    WorkerSourceTileRequest,\n    WorkerSourceVectorTileCallback,\n    WorkerSourceDEMTileRequest,\n    WorkerSourceDEMTileCallback\n} from './worker_source';\n\nclass RasterDEMTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    offscreenCanvas: OffscreenCanvas;\n    offscreenCanvasContext: OffscreenCanvasRenderingContext2D;\n\n    loadTile(params: WorkerSourceDEMTileRequest, callback: WorkerSourceDEMTileCallback) {\n        const {uid, encoding, rawImageData, padding} = params;\n        // Main thread will transfer ImageBitmap if offscreen decode with OffscreenCanvas is supported, else it will transfer an already decoded image.\n        // Flow struggles to refine ImageBitmap type\n        const imagePixels = ImageBitmap && rawImageData instanceof ImageBitmap ? this.getImageData(rawImageData, padding) : (rawImageData as ImageData);\n        const dem = new DEMData(uid, imagePixels, encoding, padding < 1);\n        callback(null, dem);\n    }\n\n    reloadTile(params: WorkerSourceDEMTileRequest, callback: WorkerSourceDEMTileCallback) {\n        // No-op in the RasterDEMTileWorkerSource class\n        callback(null, null);\n    }\n\n    abortTile(params: WorkerSourceTileRequest, callback: WorkerSourceVectorTileCallback) {\n        // No-op in the RasterDEMTileWorkerSource class\n        callback();\n    }\n\n    removeTile(params: WorkerSourceTileRequest, callback: WorkerSourceVectorTileCallback) {\n        // No-op in the RasterDEMTileWorkerSource class\n        callback();\n    }\n\n    getImageData(imgBitmap: ImageBitmap, padding: number): ImageData {\n        // Lazily initialize OffscreenCanvas\n        if (!this.offscreenCanvas || !this.offscreenCanvasContext) {\n            // Dem tiles are typically 256x256\n            this.offscreenCanvas = new OffscreenCanvas(imgBitmap.width, imgBitmap.height);\n            this.offscreenCanvasContext = this.offscreenCanvas.getContext('2d', {willReadFrequently: true});\n        }\n\n        this.offscreenCanvas.width = imgBitmap.width;\n        this.offscreenCanvas.height = imgBitmap.height;\n\n        this.offscreenCanvasContext.drawImage(imgBitmap, 0, 0, imgBitmap.width, imgBitmap.height);\n        // Insert or remove defined padding around the image to allow backfilling for neighboring data.\n        const imgData = this.offscreenCanvasContext.getImageData(-padding, -padding, imgBitmap.width + 2 * padding, imgBitmap.height + 2 * padding);\n        this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);\n        return imgData;\n    }\n}\n\nexport default RasterDEMTileWorkerSource;\n","import '../data/mrt_data';\nimport Pbf from 'pbf';\nimport {getArrayBuffer} from '../util/ajax';\nimport {MapboxRasterTile} from '../data/mrt/mrt.esm.js';\n\nimport type Actor from '../util/actor';\nimport type {Callback} from '../types/callback';\nimport type {ActorMessages} from '../util/actor_messages';\nimport type {OverscaledTileID} from './tile_id';\nimport type {\n    WorkerSource,\n    WorkerSourceTileRequest,\n    WorkerSourceRasterArrayTileRequest,\n    WorkerSourceRasterArrayTileCallback,\n} from './worker_source';\n\nMapboxRasterTile.setPbf(Pbf);\n\nconst MRT_DECODED_BAND_CACHE_SIZE = 30;\n\nclass RasterArrayWorkerTile {\n    tileID: OverscaledTileID;\n    uid: number;\n    source: string;\n    status: 'parsing' | 'done';\n\n    _mrt: MapboxRasterTile;\n    _isHeaderLoaded: boolean;\n    _entireBuffer?: ArrayBuffer;\n\n    abort: () => void;\n\n    constructor(params: WorkerSourceRasterArrayTileRequest) {\n        // If the tile request is partial, set the cacheSize to MRT_DECODED_BAND_CACHE_SIZE.\n        // Otherwise, keep all decoded bands in memory.\n        const cacheSize = params.partial ? MRT_DECODED_BAND_CACHE_SIZE : Infinity;\n        this._mrt = new MapboxRasterTile(cacheSize);\n        this._isHeaderLoaded = false;\n\n        this.uid = params.uid;\n        this.tileID = params.tileID;\n        this.source = params.source;\n    }\n\n    parse(buffer: ArrayBuffer, callback: Callback<MapboxRasterTile>) {\n        const mrt = this._mrt;\n        this.status = 'parsing';\n        this._entireBuffer = buffer;\n\n        try {\n            mrt.parseHeader(buffer);\n            this._isHeaderLoaded = true;\n\n            const decodingTasks = [];\n            for (const layerId in mrt.layers) {\n                const layer = mrt.getLayer(layerId);\n                const range = layer.getDataRange(layer.getBandList());\n                const task = mrt.createDecodingTask(range);\n\n                const bufferSlice = buffer.slice(range.firstByte, range.lastByte + 1);\n                const decodingTask = MapboxRasterTile.performDecoding(bufferSlice, task)\n                    .then(result => task.complete(null, result))\n                    .catch((error: Error) => task.complete(error, null));\n\n                decodingTasks.push(decodingTask);\n            }\n\n            Promise.allSettled(decodingTasks)\n                .then(() => callback(null, mrt))\n                .catch((error: Error) => callback(error));\n        } catch (error) {\n            callback(error as Error);\n        }\n    }\n}\n\nclass RasterArrayTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    loading: Record<number, RasterArrayWorkerTile>;\n    loaded: Record<number, RasterArrayWorkerTile>;\n\n    constructor(actor: Actor) {\n        this.actor = actor;\n        this.loading = {};\n        this.loaded = {};\n    }\n\n    loadTile(params: WorkerSourceRasterArrayTileRequest, callback: WorkerSourceRasterArrayTileCallback) {\n        const uid = params.uid;\n        const requestParam = params.request;\n\n        const workerTile = this.loading[uid] = new RasterArrayWorkerTile(params);\n        const {cancel} = getArrayBuffer(requestParam, (error?: Error, buffer?: ArrayBuffer, headers?: Headers) => {\n            const aborted = !this.loading[uid];\n            delete this.loading[uid];\n\n            if (aborted || error || !buffer) {\n                workerTile.status = 'done';\n                if (!aborted) this.loaded[uid] = workerTile;\n                return callback(error);\n            }\n\n            workerTile.parse(buffer, (error?: Error | null, mrt?: MapboxRasterTile) => {\n                if (error || !mrt) return callback(error);\n                callback(null, mrt, headers);\n            });\n\n            this.loaded[uid] = workerTile;\n        });\n\n        workerTile.abort = cancel;\n    }\n\n    reloadTile(params: WorkerSourceRasterArrayTileRequest, callback: WorkerSourceRasterArrayTileCallback) {\n        // No-op in the RasterArrayTileWorkerSource class\n        callback(null, undefined);\n    }\n\n    abortTile(params: WorkerSourceTileRequest, callback: Callback<void>) {\n        const uid = params.uid;\n        const workerTile = this.loading[uid];\n        if (workerTile) {\n            if (workerTile.abort) workerTile.abort();\n            delete this.loading[uid];\n        }\n        callback();\n    }\n\n    removeTile(params: WorkerSourceTileRequest, callback: Callback<void>) {\n        const uid = params.uid;\n        if (this.loaded[uid]) {\n            delete this.loaded[uid];\n        }\n        callback();\n    }\n\n    decodeRasterArray(params: ActorMessages['decodeRasterArray']['params'], callback: ActorMessages['decodeRasterArray']['callback']) {\n        MapboxRasterTile.performDecoding(params.buffer, params.task)\n            .then(result => callback(null, result))\n            .catch((error: Error) => callback(error));\n    }\n}\n\nexport default RasterArrayTileWorkerSource;\n","import Point from '@mapbox/point-geometry';\nimport {VectorTileFeature} from '@mapbox/vector-tile';\nconst toGeoJSON = VectorTileFeature.prototype.toGeoJSON;\nimport EXTENT from '../style-spec/data/extent';\n\nimport type {VectorTile, VectorTileLayer} from '@mapbox/vector-tile';\n\n// The feature type used by geojson-vt and supercluster. Should be extracted to\n// global type and used in module definitions for those two modules.\nexport type Feature = {\n    type: 1;\n    id: unknown;\n    tags: {\n        [_: string]: string | number | boolean;\n    };\n    geometry: Array<[number, number]>;\n} | {\n    type: 2 | 3;\n    id: unknown;\n    tags: {\n        [_: string]: string | number | boolean;\n    };\n    geometry: Array<Array<[number, number]>>;\n};\n\n// @ts-expect-error TS2739\nclass FeatureWrapper implements VectorTileFeature {\n    _feature: Feature;\n\n    extent: number;\n    type: 1 | 2 | 3;\n    id: number;\n    properties: {\n        [_: string]: string | number | boolean;\n    };\n\n    constructor(feature: Feature) {\n        this._feature = feature;\n\n        this.extent = EXTENT;\n        this.type = feature.type;\n        this.properties = feature.tags;\n\n        // If the feature has a top-level `id` property, copy it over, but only\n        // if it can be coerced to an integer, because this wrapper is used for\n        // serializing geojson feature data into vector tile PBF data, and the\n        // vector tile spec only supports integer values for feature ids --\n        // allowing non-integer values here results in a non-compliant PBF\n        // that causes an exception when it is parsed with vector-tile-js\n        // @ts-expect-error - TS2345 - Argument of type 'unknown' is not assignable to parameter of type 'number'.\n        if ('id' in feature && !isNaN(feature.id)) {\n            // @ts-expect-error - TS2345 - Argument of type 'unknown' is not assignable to parameter of type 'string'.\n            this.id = parseInt(feature.id, 10);\n        }\n    }\n\n    loadGeometry(): Array<Array<Point>> {\n        if (this._feature.type === 1) {\n            const geometry: Array<Array<Point>> = [];\n            for (const point of this._feature.geometry) {\n                geometry.push([new Point(point[0], point[1])]);\n            }\n            return geometry;\n        } else {\n            const geometry: Array<Array<Point>> = [];\n            for (const ring of this._feature.geometry) {\n                const newRing: Array<Point> = [];\n                for (const point of ring) {\n                    newRing.push(new Point(point[0], point[1]));\n                }\n                geometry.push(newRing);\n            }\n            return geometry;\n        }\n    }\n\n    toGeoJSON(x: number, y: number, z: number): GeoJSON.Feature {\n        return toGeoJSON.call(this, x, y, z);\n    }\n}\n\n// @ts-expect-error TS2739\nclass LayerWrapper implements VectorTileLayer {\n    name: string;\n    extent: number;\n    length: number;\n    _jsonFeatures: Array<Feature>;\n\n    constructor(name: string, features: Array<Feature>) {\n        this.name = name;\n        this.extent = EXTENT;\n        this.length = features.length;\n        this._jsonFeatures = features;\n    }\n\n    feature(i: number): VectorTileFeature {\n        // @ts-expect-error TS2739: Type 'FeatureWrapper' is missing the following properties from type 'VectorTileFeature': _pbf, _geometry, _keys, _values, bbox\n        return new FeatureWrapper(this._jsonFeatures[i]);\n    }\n}\n\nclass GeoJSONWrapper implements VectorTile {\n    layers: Record<string, VectorTileLayer>;\n    extent: number;\n\n    constructor(layers: {[_: string]: Array<Feature>}) {\n        this.layers = {};\n        this.extent = EXTENT;\n\n        for (const name of Object.keys(layers)) {\n            // @ts-expect-error TS2739\n            this.layers[name] = new LayerWrapper(name, layers[name]);\n        }\n    }\n}\n\nexport default GeoJSONWrapper;\n","\nimport EXTENT from '../style-spec/data/extent';\nimport {mercatorXfromLng, mercatorYfromLat} from '../geo/mercator_coordinate';\n\nimport type WorkerTile from './worker_tile';\nimport type {Feature} from './geojson_wrapper';\n\ntype BBox = {\n    minX: number,\n    minY: number,\n    maxX: number,\n    maxY: number\n};\n\ntype InternalFeature = BBox & {\n    id: string | number,\n    tags: {[_: string]: string | number | boolean},\n    type: 1 | 2 | 3,\n    geometry: number[] | number[][]\n    properties?: object\n};\n\nconst PAD = 64 / 4096; // geojson-vt default tile buffer\nconst PAD_PX = 128; // the same buffer relative to EXTENT\n\n/*\n * A GeoJSON index tailored to \"small data, updated frequently\" use cases\n * which gets used with GeoJSON sources in `dynamic` mode\n */\nexport default class GeoJSONRT {\n    features: Map<number | string, InternalFeature>;\n\n    constructor() {\n        this.features = new Map();\n    }\n\n    clear() {\n        this.features.clear();\n    }\n\n    load(features: GeoJSON.Feature[] = [], cache: {[_: number]: WorkerTile}) {\n        for (const feature of features) {\n            const id = feature.id;\n            if (id == null) continue;\n\n            let updated = this.features.get(id);\n\n            // update tile cache for the old position\n            if (updated) this.updateCache(updated, cache);\n\n            if (!feature.geometry) {\n                this.features.delete(id);\n            } else {\n                updated = convertFeature(feature);\n                // update tile cache for the new position\n                this.updateCache(updated, cache);\n                this.features.set(id, updated);\n            }\n\n            this.updateCache(updated, cache);\n        }\n    }\n\n    // clear all tiles that contain a given feature from the tile cache\n    updateCache(feature: InternalFeature, cache: {[_: number]: WorkerTile}) {\n        for (const {canonical, uid} of Object.values(cache)) {\n            const {z, x, y} = canonical;\n            const z2 = Math.pow(2, z);\n\n            if (intersectsTile(feature, z2, x, y)) {\n                delete cache[uid];\n            }\n        }\n    }\n\n    // return all features that fit in the tile (plus a small padding) by bbox; since dynamic mode is\n    // for \"small data, frequently updated\" case, linear loop through all features should be fast enough\n    getTile(z: number, tx: number, ty: number) {\n        const z2 = Math.pow(2, z);\n        const features = [];\n        for (const feature of this.features.values()) {\n            if (intersectsTile(feature, z2, tx, ty)) {\n                features.push(outputFeature(feature, z2, tx, ty));\n            }\n        }\n        return {features};\n    }\n\n    getFeatures() {\n        return [...this.features.values()];\n    }\n}\n\nfunction intersectsTile({minX, minY, maxX, maxY}: BBox, z2: number, tx: number, ty: number) {\n    const x0 = (tx - PAD) / z2;\n    const y0 = (ty - PAD) / z2;\n    const x1 = (tx + 1 + PAD) / z2;\n    const y1 = (ty + 1 + PAD) / z2;\n    return minX < x1 && minY < y1 && maxX > x0 && maxY > y0;\n}\n\nfunction convertFeature(originalFeature: GeoJSON.Feature): InternalFeature {\n    const {id, geometry, properties} = originalFeature;\n    if (!geometry) return;\n    if (geometry.type === 'GeometryCollection') {\n        throw new Error('GeometryCollection not supported in dynamic mode.');\n    }\n    const {type, coordinates} = geometry;\n\n    const feature: InternalFeature = {\n        id,\n        type: 1,\n        geometry: [],\n        tags: properties,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n    const geom = feature.geometry;\n\n    if (type === 'Point') {\n        convertPoint(coordinates, geom as number[], feature);\n\n    } else if (type === 'MultiPoint') {\n        for (const p of coordinates) {\n            convertPoint(p, geom as number[], feature);\n        }\n\n    } else if (type === 'LineString') {\n        feature.type = 2;\n        convertLine(coordinates, geom as number[][], feature);\n\n    } else if (type === 'MultiLineString') {\n        feature.type = 2;\n        convertLines(coordinates, geom as number[][], feature);\n\n    } else if (type === 'Polygon') {\n        feature.type = 3;\n        convertLines(coordinates, geom as number[][], feature, true);\n\n    } else if (type === 'MultiPolygon') {\n        feature.type = 3;\n        for (const polygon of coordinates) {\n            convertLines(polygon, geom as number[][], feature, true);\n        }\n\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n\n    return feature;\n}\n\nfunction convertPoint([lng, lat]: GeoJSON.Position, out: number[], bbox: BBox) {\n    const x = mercatorXfromLng(lng);\n    let y = mercatorYfromLat(lat);\n    y = y < 0 ? 0 : y > 1 ? 1 : y;\n    out.push(x, y);\n\n    bbox.minX = Math.min(bbox.minX, x);\n    bbox.minY = Math.min(bbox.minY, y);\n    bbox.maxX = Math.max(bbox.maxX, x);\n    bbox.maxY = Math.max(bbox.maxY, y);\n}\n\nfunction convertLine(ring: GeoJSON.Position[], out: number[][], bbox: BBox, isPolygon: boolean = false, isOuter: boolean = false) {\n    const newLine: number[] = [];\n    for (const p of ring) {\n        convertPoint(p, newLine, bbox);\n    }\n    out.push(newLine);\n    if (isPolygon) rewind(newLine, isOuter);\n}\n\nfunction convertLines(lines: GeoJSON.Position[][], out: number[][], bbox: BBox, isPolygon: boolean = false) {\n    for (let i = 0; i < lines.length; i++) {\n        convertLine(lines[i], out, bbox, isPolygon, i === 0);\n    }\n}\n\nfunction outputFeature(feature: InternalFeature, z2: number, tx: number, ty: number): Feature {\n    const {id, type, geometry, tags} = feature;\n    const tileGeom = [];\n\n    if (type === 1) {\n        transformPoints(geometry as number[], z2, tx, ty, tileGeom as [number, number][]);\n    } else if (type === 2) {\n        for (const ring of geometry) {\n            transformAndClipLine(ring as number[], z2, tx, ty, tileGeom as [number, number][][]);\n        }\n    } else if (type === 3) {\n        for (const ring of geometry) {\n            transformAndClipPolygon(ring as number[], z2, tx, ty, tileGeom as [number, number][][]);\n        }\n    }\n\n    return {\n        id,\n        type,\n        geometry: tileGeom,\n        tags\n    };\n}\n\nfunction transformPoints(line: number[], z2: number, tx: number, ty: number, out: [number, number][]) {\n    for (let i = 0; i < line.length; i += 2) {\n        const ox = Math.round(EXTENT * (line[i + 0] * z2 - tx));\n        const oy = Math.round(EXTENT * (line[i + 1] * z2 - ty));\n        out.push([ox, oy]);\n    }\n}\n\nfunction transformAndClipLine(line: number[], z2: number, tx: number, ty: number, out: [number, number][][]) {\n    const min = -PAD_PX;\n    const max = EXTENT + PAD_PX;\n    let part;\n\n    for (let i = 0; i < line.length - 2; i += 2) {\n        let x0 = Math.round(EXTENT * (line[i + 0] * z2 - tx));\n        let y0 = Math.round(EXTENT * (line[i + 1] * z2 - ty));\n        let x1 = Math.round(EXTENT * (line[i + 2] * z2 - tx));\n        let y1 = Math.round(EXTENT * (line[i + 3] * z2 - ty));\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        if (x0 < min && x1 < min) {\n            continue;\n        } else if (x0 < min) {\n            y0 = y0 + Math.round(dy * ((min - x0) / dx));\n            x0 = min;\n        } else if (x1 < min) {\n            y1 = y0 + Math.round(dy * ((min - x0) / dx));\n            x1 = min;\n        }\n\n        if (y0 < min && y1 < min) {\n            continue;\n        } else if (y0 < min) {\n            x0 = x0 + Math.round(dx * ((min - y0) / dy));\n            y0 = min;\n        } else if (y1 < min) {\n            x1 = x0 + Math.round(dx * ((min - y0) / dy));\n            y1 = min;\n        }\n\n        if (x0 >= max && x1 >= max) {\n            continue;\n        } else if (x0 >= max) {\n            y0 = y0 + Math.round(dy * ((max - x0) / dx));\n            x0 = max;\n        } else if (x1 >= max) {\n            y1 = y0 + Math.round(dy * ((max - x0) / dx));\n            x1 = max;\n        }\n\n        if (y0 >= max && y1 >= max) {\n            continue;\n        } else if (y0 >= max) {\n            x0 = x0 + Math.round(dx * ((max - y0) / dy));\n            y0 = max;\n        } else if (y1 >= max) {\n            x1 = x0 + Math.round(dx * ((max - y0) / dy));\n            y1 = max;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (!part || x0 !== part[part.length - 1][0] || y0 !== part[part.length - 1][1]) {\n            part = [[x0, y0]];\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            out.push(part);\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        part.push([x1, y1]);\n    }\n}\n\nfunction transformAndClipPolygon(input: number[], z2: number, tx: number, ty: number, out: [number, number][][]) {\n    const minX = (tx - PAD) / z2;\n    const minY = (ty - PAD) / z2;\n    const maxX = (tx + 1 + PAD) / z2;\n    const maxY = (ty + 1 + PAD) / z2;\n\n    function bitCode(x, y) {\n        let code = 0;\n\n        if (x < minX) code |= 1; // left\n        else if (x > maxX) code |= 2; // right\n\n        if (y < minY) code |= 4; // top\n        else if (y > maxY) code |= 8; // bottom\n\n        return code;\n    }\n\n    let clipped: number[] = [];\n\n    // clip against each side of the clip rectangle\n    for (let edge = 1; edge <= 8; edge *= 2) {\n        let x0 = input[input.length - 2];\n        let y0 = input[input.length - 1];\n        let prevInside = !(bitCode(x0, y0) & edge);\n\n        for (let i = 0; i < input.length; i += 2) {\n            const x1 = input[i];\n            const y1 = input[i + 1];\n            const inside = !(bitCode(x1, y1) & edge);\n\n            // if segment goes through the clip window, add an intersection\n            if (inside !== prevInside) {\n                if (edge & 8) clipped.push(x0 + (x1 - x0) * (maxY - y0) / (y1 - y0), maxY); // bottom\n                else if (edge & 4) clipped.push(x0 + (x1 - x0) * (minY - y0) / (y1 - y0), minY); // top\n                else if (edge & 2) clipped.push(maxX, y0 + (y1 - y0) * (maxX - x0) / (x1 - x0)); // right\n                else if (edge & 1) clipped.push(minX, y0 + (y1 - y0) * (minX - x0) / (x1 - x0)); // left\n            }\n\n            if (inside) clipped.push(x1, y1); // add a point if it's inside\n\n            x0 = x1;\n            y0 = y1;\n            prevInside = inside;\n        }\n\n        input = clipped;\n\n        if (!input.length || edge === 8) break;\n        clipped = [];\n    }\n\n    const ring: [number, number][] = [];\n    for (let i = 0; i < clipped.length; i += 2) ring.push([\n        Math.round(EXTENT * (clipped[i] * z2 - tx)),\n        Math.round(EXTENT * (clipped[i + 1] * z2 - ty))\n    ]);\n    if (ring.length) out.push(ring);\n}\n\n// rewind a polygon ring to a given winding order (clockwise or anti-clockwise)\nfunction rewind(ring: number[], clockwise: boolean) {\n    let area = 0;\n    for (let i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (let i = 0, len = ring.length; i < len / 2; i += 2) {\n            const x = ring[i];\n            const y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n","import EXTENT from '../style-spec/data/extent';\nimport Pbf from 'pbf';\n\nimport type {Feature} from './geojson_wrapper';\n\n/**\n * Encodes a set of GeoJSON-like features as vector tiles.\n * @private\n */\nexport default function writeFeatures(layers: Record<string, Feature[]>) {\n    const pbf = new Pbf();\n    for (const name of Object.keys(layers)) {\n        const features = layers[name];\n        pbf.writeMessage(3, writeLayer, {name, features});\n    }\n    return pbf.finish();\n}\n\nfunction writeLayer({name, features}: {name: string, features: Feature[]}, pbf: Pbf) {\n    pbf.writeStringField(1, name);\n    pbf.writeVarintField(5, EXTENT);\n\n    const keys = new Map();\n    const values = new Map();\n\n    const context = {\n        keys,\n        values,\n        feature: null\n    };\n    for (const feature of features) {\n        context.feature = feature;\n        pbf.writeMessage(2, writeFeature, context);\n    }\n    for (const key of keys.keys()) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        pbf.writeStringField(3, key);\n    }\n    for (const value of values.keys()) {\n        pbf.writeMessage(4, writeValue, value);\n    }\n}\n\ntype FeatureContext = {keys: Map<string, number>, values: Map<unknown, number>, feature: Feature};\n\nfunction writeFeature(context: FeatureContext, pbf: Pbf) {\n    const feature = context.feature;\n\n    // vector tile spec only supports integer values for feature ids -\n    // allowing non-integer values here results in a non-compliant PBF\n    // that causes an exception when it is parsed with vector-tile-js\n    if (feature.id !== undefined && Number.isSafeInteger(+feature.id)) {\n        pbf.writeVarintField(1, +feature.id);\n    }\n\n    if (feature.tags) pbf.writeMessage(2, writeProperties, context);\n    pbf.writeVarintField(3, feature.type);\n    pbf.writeMessage(4, writeGeometry, feature);\n}\n\nfunction writeProperties({keys, values, feature}: FeatureContext, pbf: Pbf) {\n    for (const key of Object.keys(feature.tags)) {\n        let value = feature.tags[key];\n        if (value === null) continue; // don't encode null value properties\n\n        let keyIndex = keys.get(key);\n\n        if (keyIndex === undefined) {\n            keyIndex = keys.size;\n            keys.set(key, keyIndex);\n        }\n        pbf.writeVarint(keyIndex);\n\n        const type = typeof value;\n        if (type !== 'string' && type !== 'boolean' && type !== 'number') {\n            value = JSON.stringify(value);\n        }\n\n        let valueIndex = values.get(value);\n\n        if (valueIndex === undefined) {\n            valueIndex = values.size;\n            values.set(value, valueIndex);\n        }\n        pbf.writeVarint(valueIndex);\n    }\n}\n\nfunction command(cmd: number, length: number): number {\n    return (length << 3) + (cmd & 0x7);\n}\n\nfunction zigzag(num: number): number {\n    return (num << 1) ^ (num >> 31);\n}\n\nfunction writeGeometry(feature: Feature, pbf: Pbf) {\n    const {geometry, type} = feature;\n    let x = 0;\n    let y = 0;\n\n    if (type === 1) {\n        pbf.writeVarint(command(1, geometry.length)); // moveto\n\n        for (const p of geometry) {\n            const dx = p[0] - x;\n            const dy = p[1] - y;\n            pbf.writeVarint(zigzag(dx));\n            pbf.writeVarint(zigzag(dy));\n            x += dx;\n            y += dy;\n        }\n\n    } else {\n        for (const ring of geometry) {\n            if (ring.length === 0) continue;\n            pbf.writeVarint(command(1, 1));\n            const lineCount = ring.length - (type === 3 ? 1 : 0); // do not write polygon closing path as lineto\n            for (let i = 0; i < lineCount; i++) {\n                if (i === 1) pbf.writeVarint(command(2, lineCount - 1));\n                const dx = ring[i][0] - x;\n                const dy = ring[i][1] - y;\n                pbf.writeVarint(zigzag(dx));\n                pbf.writeVarint(zigzag(dy));\n                x += dx;\n                y += dy;\n            }\n            if (type === 3) {\n                pbf.writeVarint(command(7, 1)); // closepath\n            }\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction writeValue(value: any, pbf: Pbf) {\n    const type = typeof value;\n    if (type === 'string') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        pbf.writeStringField(1, value);\n    } else if (type === 'boolean') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        pbf.writeBooleanField(7, value);\n    } else if (type === 'number') {\n        if (value % 1 !== 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            pbf.writeDoubleField(3, value);\n        } else if (value < 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            pbf.writeSVarintField(6, value);\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            pbf.writeVarintField(5, value);\n        }\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n","\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nexport default function simplify(coords, first, last, sqTolerance) {\n    let maxSqDist = sqTolerance;\n    const mid = first + ((last - first) >> 1);\n    let minPosToMid = last - first;\n    let index;\n\n    const ax = coords[first];\n    const ay = coords[first + 1];\n    const bx = coords[last];\n    const by = coords[last + 1];\n\n    for (let i = first + 3; i < last; i += 3) {\n        const d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n\n        } else if (d === maxSqDist) {\n            // a workaround to ensure we choose a pivot close to the middle of the list,\n            // reducing recursion depth, for certain degenerate inputs\n            // https://github.com/mapbox/geojson-vt/issues/104\n            const posToMid = Math.abs(i - mid);\n            if (posToMid < minPosToMid) {\n                index = i;\n                minPosToMid = posToMid;\n            }\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 3) simplify(coords, first, index, sqTolerance);\n        coords[index + 2] = maxSqDist;\n        if (last - index > 3) simplify(coords, index, last, sqTolerance);\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(px, py, x, y, bx, by) {\n\n    let dx = bx - x;\n    let dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n","\nexport default function createFeature(id, type, geom, tags) {\n    const feature = {\n        id: id == null ? null : id,\n        type,\n        geometry: geom,\n        tags,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n        calcLineBBox(feature, geom);\n\n    } else if (type === 'Polygon') {\n        // the outer ring (ie [0]) contains all inner rings\n        calcLineBBox(feature, geom[0]);\n\n    } else if (type === 'MultiLineString') {\n        for (const line of geom) {\n            calcLineBBox(feature, line);\n        }\n\n    } else if (type === 'MultiPolygon') {\n        for (const polygon of geom) {\n            // the outer ring (ie [0]) contains all inner rings\n            calcLineBBox(feature, polygon[0]);\n        }\n    }\n\n    return feature;\n}\n\nfunction calcLineBBox(feature, geom) {\n    for (let i = 0; i < geom.length; i += 3) {\n        feature.minX = Math.min(feature.minX, geom[i]);\n        feature.minY = Math.min(feature.minY, geom[i + 1]);\n        feature.maxX = Math.max(feature.maxX, geom[i]);\n        feature.maxY = Math.max(feature.maxY, geom[i + 1]);\n    }\n}\n","\nimport simplify from './simplify.js';\nimport createFeature from './feature.js';\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nexport default function convert(data, options) {\n    const features = [];\n    if (data.type === 'FeatureCollection') {\n        for (let i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], options, i);\n        }\n\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, options);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, options);\n    }\n\n    return features;\n}\n\nfunction convertFeature(features, geojson, options, index) {\n    if (!geojson.geometry) return;\n\n    const coords = geojson.geometry.coordinates;\n    if (coords && coords.length === 0) return;\n\n    const type = geojson.geometry.type;\n    const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n    let geometry = [];\n    let id = geojson.id;\n    if (options.promoteId) {\n        id = geojson.properties[options.promoteId];\n    } else if (options.generateId) {\n        id = index || 0;\n    }\n    if (type === 'Point') {\n        convertPoint(coords, geometry);\n\n    } else if (type === 'MultiPoint') {\n        for (const p of coords) {\n            convertPoint(p, geometry);\n        }\n\n    } else if (type === 'LineString') {\n        convertLine(coords, geometry, tolerance, false);\n\n    } else if (type === 'MultiLineString') {\n        if (options.lineMetrics) {\n            // explode into linestrings to be able to track metrics\n            for (const line of coords) {\n                geometry = [];\n                convertLine(line, geometry, tolerance, false);\n                features.push(createFeature(id, 'LineString', geometry, geojson.properties));\n            }\n            return;\n        } else {\n            convertLines(coords, geometry, tolerance, false);\n        }\n\n    } else if (type === 'Polygon') {\n        convertLines(coords, geometry, tolerance, true);\n\n    } else if (type === 'MultiPolygon') {\n        for (const polygon of coords) {\n            const newPolygon = [];\n            convertLines(polygon, newPolygon, tolerance, true);\n            geometry.push(newPolygon);\n        }\n    } else if (type === 'GeometryCollection') {\n        for (const singleGeometry of geojson.geometry.geometries) {\n            convertFeature(features, {\n                id,\n                geometry: singleGeometry,\n                properties: geojson.properties\n            }, options, index);\n        }\n        return;\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n\n    features.push(createFeature(id, type, geometry, geojson.properties));\n}\n\nfunction convertPoint(coords, out) {\n    out.push(projectX(coords[0]), projectY(coords[1]), 0);\n}\n\nfunction convertLine(ring, out, tolerance, isPolygon) {\n    let x0, y0;\n    let size = 0;\n\n    for (let j = 0; j < ring.length; j++) {\n        const x = projectX(ring[j][0]);\n        const y = projectY(ring[j][1]);\n\n        out.push(x, y, 0);\n\n        if (j > 0) {\n            if (isPolygon) {\n                size += (x0 * y - x * y0) / 2; // area\n            } else {\n                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n            }\n        }\n        x0 = x;\n        y0 = y;\n    }\n\n    const last = out.length - 3;\n    out[2] = 1;\n    simplify(out, 0, last, tolerance);\n    out[last + 2] = 1;\n\n    out.size = Math.abs(size);\n    out.start = 0;\n    out.end = out.size;\n}\n\nfunction convertLines(rings, out, tolerance, isPolygon) {\n    for (let i = 0; i < rings.length; i++) {\n        const geom = [];\n        convertLine(rings[i], geom, tolerance, isPolygon);\n        out.push(geom);\n    }\n}\n\nfunction projectX(x) {\n    return x / 360 + 0.5;\n}\n\nfunction projectY(y) {\n    const sin = Math.sin(y * Math.PI / 180);\n    const y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}\n","\nimport createFeature from './feature.js';\n\n/* clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * k1 and k2 are the line coordinates\n * axis: 0 for x, 1 for y\n * minAll and maxAll: minimum and maximum coordinate value for all features\n */\nexport default function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll < k2) return features; // trivial accept\n    else if (maxAll < k1 || minAll >= k2) return null; // trivial reject\n\n    const clipped = [];\n\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        let type = feature.type;\n\n        const min = axis === 0 ? feature.minX : feature.minY;\n        const max = axis === 0 ? feature.maxX : feature.maxY;\n\n        if (min >= k1 && max < k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (max < k1 || min >= k2) { // trivial reject\n            continue;\n        }\n\n        let newGeometry = [];\n\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n\n        } else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n\n        } else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n\n        } else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n\n        } else if (type === 'MultiPolygon') {\n            for (const polygon of geometry) {\n                const newPolygon = [];\n                clipLines(polygon, newPolygon, k1, k2, axis, true);\n                if (newPolygon.length) {\n                    newGeometry.push(newPolygon);\n                }\n            }\n        }\n\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (const line of newGeometry) {\n                    clipped.push(createFeature(feature.id, type, line, feature.tags));\n                }\n                continue;\n            }\n\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    newGeometry = newGeometry[0];\n                } else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n\n            clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (let i = 0; i < geom.length; i += 3) {\n        const a = geom[i + axis];\n\n        if (a >= k1 && a <= k2) {\n            addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n        }\n    }\n}\n\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n\n    let slice = newSlice(geom);\n    const intersect = axis === 0 ? intersectX : intersectY;\n    let len = geom.start;\n    let segLen, t;\n\n    for (let i = 0; i < geom.length - 3; i += 3) {\n        const ax = geom[i];\n        const ay = geom[i + 1];\n        const az = geom[i + 2];\n        const bx = geom[i + 3];\n        const by = geom[i + 4];\n        const a = axis === 0 ? ax : ay;\n        const b = axis === 0 ? bx : by;\n        let exited = false;\n\n        if (trackMetrics) segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n\n        if (!isPolygon && exited) {\n            if (trackMetrics) slice.end = len + segLen * t;\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n\n        if (trackMetrics) len += segLen;\n    }\n\n    // add the last point\n    let last = geom.length - 3;\n    const ax = geom[last];\n    const ay = geom[last + 1];\n    const az = geom[last + 2];\n    const a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\n\nfunction newSlice(line) {\n    const slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (const line of geom) {\n        clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\n\nfunction addPoint(out, x, y, z) {\n    out.push(x, y, z);\n}\n\nfunction intersectX(out, ax, ay, bx, by, x) {\n    const t = (x - ax) / (bx - ax);\n    addPoint(out, x, ay + (by - ay) * t, 1);\n    return t;\n}\n\nfunction intersectY(out, ax, ay, bx, by, y) {\n    const t = (y - ay) / (by - ay);\n    addPoint(out, ax + (bx - ax) * t, y, 1);\n    return t;\n}\n","\nimport clip from './clip.js';\nimport createFeature from './feature.js';\n\nexport default function wrap(features, options) {\n    const buffer = options.buffer / options.extent;\n    let merged = features;\n    const left  = clip(features, 1, -1 - buffer, buffer,     0, -1, 2, options); // left world copy\n    const right = clip(features, 1,  1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n\n    if (left || right) {\n        merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n\n        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    const newFeatures = [];\n\n    for (let i = 0; i < features.length; i++) {\n        const feature = features[i];\n        const type = feature.type;\n\n        let newGeometry;\n\n        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n            newGeometry = shiftCoords(feature.geometry, offset);\n\n        } else if (type === 'MultiLineString' || type === 'Polygon') {\n            newGeometry = [];\n            for (const line of feature.geometry) {\n                newGeometry.push(shiftCoords(line, offset));\n            }\n        } else if (type === 'MultiPolygon') {\n            newGeometry = [];\n            for (const polygon of feature.geometry) {\n                const newPolygon = [];\n                for (const line of polygon) {\n                    newPolygon.push(shiftCoords(line, offset));\n                }\n                newGeometry.push(newPolygon);\n            }\n        }\n\n        newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    const newPoints = [];\n    newPoints.size = points.size;\n\n    if (points.start !== undefined) {\n        newPoints.start = points.start;\n        newPoints.end = points.end;\n    }\n\n    for (let i = 0; i < points.length; i += 3) {\n        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n    }\n    return newPoints;\n}\n","\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nexport default function transformTile(tile, extent) {\n    if (tile.transformed) return tile;\n\n    const z2 = 1 << tile.z;\n    const tx = tile.x;\n    const ty = tile.y;\n\n    for (const feature of tile.features) {\n        const geom = feature.geometry;\n        const type = feature.type;\n\n        feature.geometry = [];\n\n        if (type === 1) {\n            for (let j = 0; j < geom.length; j += 2) {\n                feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n            }\n        } else {\n            for (let j = 0; j < geom.length; j++) {\n                const ring = [];\n                for (let k = 0; k < geom[j].length; k += 2) {\n                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                }\n                feature.geometry.push(ring);\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(x, y, extent, z2, tx, ty) {\n    return [\n        Math.round(extent * (x * z2 - tx)),\n        Math.round(extent * (y * z2 - ty))];\n}\n","\nexport default function createTile(features, z, tx, ty, options) {\n    const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n    const tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: features.length,\n        source: null,\n        x: tx,\n        y: ty,\n        z,\n        transformed: false,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n    };\n    for (const feature of features) {\n        addFeature(tile, feature, tolerance, options);\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, options) {\n    const geom = feature.geometry;\n    const type = feature.type;\n    const simplified = [];\n\n    tile.minX = Math.min(tile.minX, feature.minX);\n    tile.minY = Math.min(tile.minY, feature.minY);\n    tile.maxX = Math.max(tile.maxX, feature.maxX);\n    tile.maxY = Math.max(tile.maxY, feature.maxY);\n\n    if (type === 'Point' || type === 'MultiPoint') {\n        for (let i = 0; i < geom.length; i += 3) {\n            simplified.push(geom[i], geom[i + 1]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else if (type === 'LineString') {\n        addLine(simplified, geom, tile, tolerance, false, false);\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        for (let i = 0; i < geom.length; i++) {\n            addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0);\n        }\n\n    } else if (type === 'MultiPolygon') {\n\n        for (let k = 0; k < geom.length; k++) {\n            const polygon = geom[k];\n            for (let i = 0; i < polygon.length; i++) {\n                addLine(simplified, polygon[i], tile, tolerance, true, i === 0);\n            }\n        }\n    }\n\n    if (simplified.length) {\n        let tags = feature.tags || null;\n\n        if (type === 'LineString' && options.lineMetrics) {\n            tags = {};\n            for (const key in feature.tags) tags[key] = feature.tags[key];\n            tags['mapbox_clip_start'] = geom.start / geom.size;\n            tags['mapbox_clip_end'] = geom.end / geom.size;\n        }\n\n        const tileFeature = {\n            geometry: simplified,\n            type: type === 'Polygon' || type === 'MultiPolygon' ? 3 :\n            (type === 'LineString' || type === 'MultiLineString' ? 2 : 1),\n            tags\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.features.push(tileFeature);\n    }\n}\n\nfunction addLine(result, geom, tile, tolerance, isPolygon, isOuter) {\n    const sqTolerance = tolerance * tolerance;\n\n    if (tolerance > 0 && (geom.size < (isPolygon ? sqTolerance : tolerance))) {\n        tile.numPoints += geom.length / 3;\n        return;\n    }\n\n    const ring = [];\n\n    for (let i = 0; i < geom.length; i += 3) {\n        if (tolerance === 0 || geom[i + 2] > sqTolerance) {\n            tile.numSimplified++;\n            ring.push(geom[i], geom[i + 1]);\n        }\n        tile.numPoints++;\n    }\n\n    if (isPolygon) rewind(ring, isOuter);\n\n    result.push(ring);\n}\n\nfunction rewind(ring, clockwise) {\n    let area = 0;\n    for (let i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (let i = 0, len = ring.length; i < len / 2; i += 2) {\n            const x = ring[i];\n            const y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n","\nimport convert from './convert.js';     // GeoJSON conversion and preprocessing\nimport clip from './clip.js';           // stripe clipping algorithm\nimport wrap from './wrap.js';           // date line processing\nimport transform from './transform.js'; // coordinate transformation\nimport createTile from './tile.js';     // final simplified tile generation\n\nconst defaultOptions = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    lineMetrics: false,     // whether to calculate line metrics\n    promoteId: null,        // name of a feature property to be promoted to feature.id\n    generateId: false,      // whether to generate feature ids. Cannot be used with promoteId\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nclass GeoJSONVT {\n    constructor(data, options) {\n        options = this.options = extend(Object.create(defaultOptions), options);\n\n        const debug = options.debug;\n\n        if (debug) console.time('preprocess data');\n\n        if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n        if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n\n        // projects and adds simplification info\n        let features = convert(data, options);\n\n        // tiles and tileCoords are part of the public API\n        this.tiles = {};\n        this.tileCoords = [];\n\n        if (debug) {\n            console.timeEnd('preprocess data');\n            console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n            console.time('generate tiles');\n            this.stats = {};\n            this.total = 0;\n        }\n\n        // wraps features (ie extreme west and extreme east)\n        features = wrap(features, options);\n\n        // start slicing from the top tile down\n        if (features.length) this.splitTile(features, 0, 0, 0);\n\n        if (debug) {\n            if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n            console.timeEnd('generate tiles');\n            console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n        }\n    }\n\n    // splits features from a parent tile to sub-tiles.\n    // z, x, and y are the coordinates of the parent tile\n    // cz, cx, and cy are the coordinates of the target tile\n    //\n    // If no target tile is specified, splitting stops when we reach the maximum\n    // zoom or the number of points is low as specified in the options.\n    splitTile(features, z, x, y, cz, cx, cy) {\n\n        const stack = [features, z, x, y];\n        const options = this.options;\n        const debug = options.debug;\n\n        // avoid recursion by using a processing queue\n        while (stack.length) {\n            y = stack.pop();\n            x = stack.pop();\n            z = stack.pop();\n            features = stack.pop();\n\n            const z2 = 1 << z;\n            const id = toID(z, x, y);\n            let tile = this.tiles[id];\n\n            if (!tile) {\n                if (debug > 1) console.time('creation');\n\n                tile = this.tiles[id] = createTile(features, z, x, y, options);\n                this.tileCoords.push({z, x, y});\n\n                if (debug) {\n                    if (debug > 1) {\n                        console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                            z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                        console.timeEnd('creation');\n                    }\n                    const key = `z${  z}`;\n                    this.stats[key] = (this.stats[key] || 0) + 1;\n                    this.total++;\n                }\n            }\n\n            // save reference to original geometry in tile so that we can drill down later if we stop now\n            tile.source = features;\n\n            // if it's the first-pass tiling\n            if (cz == null) {\n                // stop tiling if we reached max zoom, or if the tile is too simple\n                if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n            // if a drilldown to a specific tile\n            } else if (z === options.maxZoom || z === cz) {\n                // stop tiling if we reached base zoom or our target tile zoom\n                continue;\n            } else if (cz != null) {\n                // stop tiling if it's not an ancestor of the target tile\n                const zoomSteps = cz - z;\n                if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) continue;\n            }\n\n            // if we slice further down, no need to keep source geometry\n            tile.source = null;\n\n            if (features.length === 0) continue;\n\n            if (debug > 1) console.time('clipping');\n\n            // values we'll use for clipping\n            const k1 = 0.5 * options.buffer / options.extent;\n            const k2 = 0.5 - k1;\n            const k3 = 0.5 + k1;\n            const k4 = 1 + k1;\n\n            let tl = null;\n            let bl = null;\n            let tr = null;\n            let br = null;\n\n            let left  = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n            let right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n            features = null;\n\n            if (left) {\n                tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                left = null;\n            }\n\n            if (right) {\n                tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                right = null;\n            }\n\n            if (debug > 1) console.timeEnd('clipping');\n\n            stack.push(tl || [], z + 1, x * 2,     y * 2);\n            stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n            stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n            stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n        }\n    }\n\n    getTile(z, x, y) {\n        z = +z;\n        x = +x;\n        y = +y;\n\n        const options = this.options;\n        const {extent, debug} = options;\n\n        if (z < 0 || z > 24) return null;\n\n        const z2 = 1 << z;\n        x = (x + z2) & (z2 - 1); // wrap tile x coordinate\n\n        const id = toID(z, x, y);\n        if (this.tiles[id]) return transform(this.tiles[id], extent);\n\n        if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n        let z0 = z;\n        let x0 = x;\n        let y0 = y;\n        let parent;\n\n        while (!parent && z0 > 0) {\n            z0--;\n            x0 = x0 >> 1;\n            y0 = y0 >> 1;\n            parent = this.tiles[toID(z0, x0, y0)];\n        }\n\n        if (!parent || !parent.source) return null;\n\n        // if we found a parent tile containing the original geometry, we can drill down from it\n        if (debug > 1) {\n            console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n            console.time('drilling down');\n        }\n        this.splitTile(parent.source, z0, x0, y0, z, x, y);\n        if (debug > 1) console.timeEnd('drilling down');\n\n        return this.tiles[id] ? transform(this.tiles[id], extent) : null;\n    }\n}\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction extend(dest, src) {\n    for (const i in src) dest[i] = src[i];\n    return dest;\n}\n\nexport default function geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n","import {getJSON} from '../util/ajax';\nimport {getPerformanceMeasurement} from '../util/performance';\nimport GeoJSONWrapper from './geojson_wrapper';\nimport GeoJSONRT from './geojson_rt';\nimport writePbf from './vector_tile_to_pbf';\nimport Supercluster from 'supercluster';\nimport geojsonvt from 'geojson-vt';\nimport assert from 'assert';\nimport VectorTileWorkerSource from './vector_tile_worker_source';\nimport {createExpression} from '../style-spec/expression/index';\n\nimport type {\n    WorkerSourceVectorTileRequest,\n    WorkerSourceVectorTileCallback,\n} from '../source/worker_source';\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {Feature} from './geojson_wrapper';\nimport type {Feature as ExpressionFeature} from '../style-spec/expression/index';\nimport type {LoadVectorDataCallback} from './load_vector_tile';\nimport type {RequestParameters, ResponseCallback} from '../util/ajax';\nimport type {Callback} from '../types/callback';\nimport type {ImageId} from '../style-spec/expression/types/image_id';\nimport type {StyleModelMap} from '../style/style_mode';\n\nexport type GeoJSONWorkerOptions = {\n    source: string;\n    scope: string;\n    cluster: boolean;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    superclusterOptions?: any;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    geojsonVtOptions?: any;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    clusterProperties?: any;\n    filter?: Array<unknown>;\n    dynamic?: boolean;\n};\n\nexport type LoadGeoJSONParameters = GeoJSONWorkerOptions & {\n    request?: RequestParameters;\n    data?: string;\n    append?: boolean;\n};\n\ntype FeatureCollectionOrFeature = GeoJSON.FeatureCollection | GeoJSON.Feature;\n\ntype ResourceTiming = Record<string, PerformanceResourceTiming[]>;\n\nexport type LoadGeoJSONResult = FeatureCollectionOrFeature & {resourceTiming?: ResourceTiming};\n\nexport type LoadGeoJSON = (params: LoadGeoJSONParameters, callback: ResponseCallback<LoadGeoJSONResult>) => void;\n\nexport interface GeoJSONIndex {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getTile: (z: number, x: number, y: number) => any;\n    // supercluster methods\n    getClusterExpansionZoom?: (clusterId: number) => number;\n    getChildren?: (clusterId: number) => Array<GeoJSON.Feature>;\n    getLeaves?: (clusterId: number, limit: number, offset: number) => Array<GeoJSON.Feature>;\n}\n\nfunction loadGeoJSONTile(this: GeoJSONWorkerSource, params: WorkerSourceVectorTileRequest, callback: LoadVectorDataCallback): undefined {\n    const canonical = params.tileID.canonical;\n\n    if (!this._geoJSONIndex) {\n        callback(null, null); // we couldn't load the file\n        return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const geoJSONTile = this._geoJSONIndex.getTile(canonical.z, canonical.x, canonical.y);\n    if (!geoJSONTile) {\n        callback(null, null); // nothing in the given tile\n        return;\n    }\n\n    // HACK: separate elevation features into separate layer\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const isElevationfeature = (f) => f.tags && '3d_elevation_id' in f.tags && 'source' in f.tags && f.tags.source === 'elevation';\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n    const elevationFeatures = geoJSONTile.features.filter(f => isElevationfeature(f));\n\n    let layers: Record<string, Feature[]> = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        _geojsonTileLayer: geoJSONTile.features\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (elevationFeatures.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        const nonElevationFeatures = geoJSONTile.features.filter(f => !isElevationfeature(f));\n        layers = {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            _geojsonTileLayer: nonElevationFeatures,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            'hd_road_elevation': elevationFeatures\n        };\n    }\n    const vectorTile = new GeoJSONWrapper(layers);\n\n    // Encode the geojson-vt tile into binary vector tile form.  This\n    // is a convenience that allows `FeatureIndex` to operate the same way\n    // across `VectorTileSource` and `GeoJSONSource` data.\n    const rawData = writePbf(layers).buffer as ArrayBuffer;\n\n    callback(null, {vectorTile, rawData});\n}\n\n/**\n * The {@link WorkerSource} implementation that supports {@link GeoJSONSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory GeoJSON\n * representation.  To do so, create it with\n * `new GeoJSONWorkerSource(actor, layerIndex, customLoadGeoJSONFunction)`.\n * For a full example, see [mapbox-gl-topojson](https://github.com/developmentseed/mapbox-gl-topojson).\n *\n * @private\n */\nclass GeoJSONWorkerSource extends VectorTileWorkerSource {\n    _geoJSONIndex: GeoJSONIndex;\n    _dynamicIndex: GeoJSONRT;\n\n    /**\n     * @param [loadGeoJSON] Optional method for custom loading/parsing of\n     * GeoJSON based on parameters passed from the main-thread Source.\n     * See {@link GeoJSONWorkerSource#loadGeoJSON}.\n     * @private\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, availableImages: ImageId[], availableModels: StyleModelMap, isSpriteLoaded: boolean, loadGeoJSON?: LoadGeoJSON | null, brightness?: number | null) {\n        super(actor, layerIndex, availableImages, availableModels, isSpriteLoaded, loadGeoJSONTile, brightness);\n        if (loadGeoJSON) {\n            this.loadGeoJSON = loadGeoJSON;\n        }\n        this._dynamicIndex = new GeoJSONRT();\n    }\n\n    /**\n     * Fetches (if appropriate), parses, and index geojson data into tiles. This\n     * preparatory method must be called before {@link GeoJSONWorkerSource#loadTile}\n     * can correctly serve up tiles.\n     *\n     * Defers to {@link GeoJSONWorkerSource#loadGeoJSON} for the fetching/parsing,\n     * expecting `callback(error, data)` to be called with either an error or a\n     * parsed GeoJSON object.\n     *\n     * When `loadData` requests come in faster than they can be processed,\n     * they are coalesced into a single request using the latest data.\n     * See {@link GeoJSONWorkerSource#coalesce}\n     *\n     * @private\n     */\n    loadData(params: LoadGeoJSONParameters, callback: ResponseCallback<{resourceTiming?: ResourceTiming}>): void {\n        const requestParam = params && params.request;\n        const perf = requestParam && requestParam.collectResourceTiming;\n\n        this._geoJSONIndex = null;\n\n        this.loadGeoJSON(params, (err?: Error, data?: FeatureCollectionOrFeature) => {\n            if (err || !data) {\n                return callback(err);\n\n            } else if (typeof data !== 'object') {\n                return callback(new Error(`Input data given to '${params.source}' is not a valid GeoJSON object.`));\n\n            } else {\n                try {\n                    if (params.filter) {\n                        const compiled = createExpression(params.filter, {type: 'boolean', 'property-type': 'data-driven', overridable: false, transition: false});\n                        if (compiled.result === 'error')\n                            throw new Error(compiled.value.map(err => `${err.key}: ${err.message}`).join(', '));\n\n                        (data as GeoJSON.FeatureCollection).features = (data as GeoJSON.FeatureCollection).features.filter(feature => compiled.value.evaluate({zoom: 0}, feature as unknown as ExpressionFeature));\n                    }\n\n                    // for GeoJSON sources that are marked as dynamic, we retain the GeoJSON data\n                    // as a id-to-feature map so that we can later update features by id individually\n                    if (params.dynamic) {\n                        if (data.type === 'Feature') data = {type: 'FeatureCollection', features: [data]};\n\n                        if (!params.append) {\n                            this._dynamicIndex.clear();\n                            this.loaded = {};\n                        }\n\n                        this._dynamicIndex.load(data.features, this.loaded);\n\n                        if (params.cluster) data.features = this._dynamicIndex.getFeatures() as unknown as GeoJSON.Feature[];\n\n                    } else {\n                        this.loaded = {};\n                    }\n\n                    this._geoJSONIndex =\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                        params.cluster ? new Supercluster(getSuperclusterOptions(params)).load((data as GeoJSON.FeatureCollection).features as Array<GeoJSON.Feature<GeoJSON.Point, object>>) :\n                        params.dynamic ? this._dynamicIndex :\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                        geojsonvt(data, params.geojsonVtOptions);\n\n                } catch (err) {\n                    return callback(err as Error);\n                }\n\n                const result: {resourceTiming?: ResourceTiming} = {};\n                if (perf) {\n                    const resourceTimingData = getPerformanceMeasurement(requestParam);\n                    // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                    // late evaluation in the main thread causes TypeError: illegal invocation\n                    if (resourceTimingData) {\n                        result.resourceTiming = {};\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        result.resourceTiming[params.source] = JSON.parse(JSON.stringify(resourceTimingData));\n                    }\n                }\n                callback(null, result);\n            }\n        });\n    }\n\n    /**\n    * Implements {@link WorkerSource#reloadTile}.\n    *\n    * If the tile is loaded, uses the implementation in VectorTileWorkerSource.\n    * Otherwise, such as after a setData() call, we load the tile fresh.\n    *\n    * @private\n    */\n    override reloadTile(params: WorkerSourceVectorTileRequest, callback: WorkerSourceVectorTileCallback): void {\n        const loaded = this.loaded,\n            uid = params.uid;\n\n        if (loaded && loaded[uid]) {\n            if (params.partial) {\n                return callback(null, undefined);\n            }\n            return super.reloadTile(params, callback);\n        } else {\n            return this.loadTile(params, callback);\n        }\n    }\n\n    /**\n     * Fetch and parse GeoJSON according to the given params.  Calls `callback`\n     * with `(err, data)`, where `data` is a parsed GeoJSON object.\n     *\n     * GeoJSON is loaded and parsed from `params.url` if it exists, or else\n     * expected as a literal (string or object) `params.data`.\n     *\n     * @param params\n     * @param [params.url] A URL to the remote GeoJSON data.\n     * @param [params.data] Literal GeoJSON data. Must be provided if `params.url` is not.\n     * @private\n     */\n    loadGeoJSON(params: LoadGeoJSONParameters, callback: ResponseCallback<FeatureCollectionOrFeature>): void {\n        // Because of same origin issues, urls must either include an explicit\n        // origin or absolute path.\n        // ie: /foo/bar.json or http://example.com/bar.json\n        // but not ../foo/bar.json\n        if (params.request) {\n            getJSON(params.request, callback);\n        } else if (typeof params.data === 'string') {\n            // delay loading by one tick to hopefully let GC clean up the previous index (if present)\n            setTimeout(() => {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    return callback(null, JSON.parse(params.data));\n                } catch (e) {\n                    return callback(new Error(`Input data given to '${params.source}' is not a valid GeoJSON object.`));\n                }\n            }, 0);\n        } else {\n            return callback(new Error(`Input data given to '${params.source}' is not a valid GeoJSON object.`));\n        }\n    }\n\n    getClusterExpansionZoom(params: {\n        clusterId: number;\n    }, callback: Callback<number>) {\n        try {\n            callback(null, this._geoJSONIndex.getClusterExpansionZoom(params.clusterId));\n        } catch (e) {\n            callback(e as Error);\n        }\n    }\n\n    getClusterChildren(params: {\n        clusterId: number;\n    }, callback: Callback<Array<GeoJSON.Feature>>) {\n        try {\n            callback(null, this._geoJSONIndex.getChildren(params.clusterId));\n        } catch (e) {\n            callback(e as Error);\n        }\n    }\n\n    getClusterLeaves(params: {\n        clusterId: number;\n        limit: number;\n        offset: number;\n    }, callback: Callback<Array<GeoJSON.Feature>>) {\n        try {\n            callback(null, this._geoJSONIndex.getLeaves(params.clusterId, params.limit, params.offset));\n        } catch (e) {\n            callback(e as Error);\n        }\n    }\n}\n\nfunction getSuperclusterOptions({\n    superclusterOptions,\n    clusterProperties,\n}: LoadGeoJSONParameters) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (!clusterProperties || !superclusterOptions) return superclusterOptions;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const mapExpressions: Record<string, any> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const reduceExpressions: Record<string, any> = {};\n    const globals = {accumulated: null, zoom: 0};\n    const feature = {properties: null};\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    const propertyNames = Object.keys(clusterProperties);\n\n    for (const key of propertyNames) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        const [operator, mapExpression] = clusterProperties[key];\n\n        const mapExpressionParsed = createExpression(mapExpression);\n        const reduceExpressionParsed = createExpression(\n            typeof operator === 'string' ? [operator, ['accumulated'], ['get', key]] : operator);\n\n        assert(mapExpressionParsed.result === 'success');\n        assert(reduceExpressionParsed.result === 'success');\n\n        mapExpressions[key] = mapExpressionParsed.value;\n        reduceExpressions[key] = reduceExpressionParsed.value;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    superclusterOptions.map = (pointProperties) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        feature.properties = pointProperties;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const properties: Record<string, any> = {};\n        for (const key of propertyNames) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            properties[key] = mapExpressions[key].evaluate(globals, feature);\n        }\n        return properties;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    superclusterOptions.reduce = (accumulated, clusterProperties) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        feature.properties = clusterProperties;\n        for (const key of propertyNames) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            globals.accumulated = accumulated[key];\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n            accumulated[key] = reduceExpressions[key].evaluate(globals, feature);\n        }\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return superclusterOptions;\n}\n\nexport default GeoJSONWorkerSource;\n","import {getArrayBuffer} from '../../src/util/ajax';\nimport FeatureIndex from '../../src/data/feature_index';\nimport {process3DTile} from './model_loader';\nimport {tileToMeter} from '../../src/geo/mercator_coordinate';\nimport Tiled3dModelBucket from '../data/bucket/tiled_3d_model_bucket';\nimport {OverscaledTileID} from '../../src/source/tile_id';\nimport {load3DTile} from '../util/loaders';\nimport EvaluationParameters from '../../src/style/evaluation_parameters';\nimport {makeFQID} from \"../../src/util/fqid\";\n\nimport type {CanonicalTileID} from '../../src/source/tile_id';\nimport type Actor from '../../src/util/actor';\nimport type StyleLayerIndex from '../../src/style/style_layer_index';\nimport type {\n    WorkerSource,\n    WorkerSourceTileRequest,\n    WorkerSourceTiled3dModelRequest,\n    WorkerSourceVectorTileCallback,\n    WorkerSourceVectorTileResult\n} from '../../src/source/worker_source';\nimport type {LoadVectorData} from '../../src/source/load_vector_tile';\nimport type Projection from '../../src/geo/projection/projection';\nimport type ModelStyleLayer from '../style/style_layer/model_style_layer';\nimport type {ImageId} from '../../src/style-spec/expression/types/image_id';\nimport type {StyleModelMap} from '../../src/style/style_mode';\n\nclass Tiled3dWorkerTile {\n    tileID: OverscaledTileID;\n    uid: number;\n    zoom: number;\n    tileZoom: number;\n    canonical: CanonicalTileID;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    overscaling: number;\n    projection: Projection;\n    status: 'parsing' | 'done';\n    reloadCallback: WorkerSourceVectorTileCallback | null | undefined;\n    brightness: number | null | undefined;\n    worldview: string | undefined;\n\n    constructor(params: WorkerSourceTiled3dModelRequest, brightness?: number | null, worldview?: string) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.tileZoom = params.tileZoom;\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.canonical = params.tileID.canonical;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.projection = params.projection;\n        this.brightness = brightness;\n        this.worldview = worldview;\n    }\n\n    parse(\n        data: ArrayBuffer,\n        layerIndex: StyleLayerIndex,\n        params: WorkerSourceTiled3dModelRequest,\n        callback: WorkerSourceVectorTileCallback,\n    ): void {\n        this.status = 'parsing';\n        const tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        const buckets: Tiled3dModelBucket[] = [];\n        const layerFamilies = layerIndex.familiesBySource[params.source];\n        const featureIndex = new FeatureIndex(tileID, params.promoteId);\n        featureIndex.bucketLayerIDs = [];\n        featureIndex.is3DTile = true;\n\n        load3DTile(data)\n            .then(gltf => {\n                if (!gltf) return callback(new Error('Could not parse tile'));\n                const hasMapboxMeshFeatures: boolean = (gltf.json.extensionsUsed && gltf.json.extensionsUsed.includes('MAPBOX_mesh_features')) ||\n                                            (gltf.json.asset.extras && gltf.json.asset.extras['MAPBOX_mesh_features']);\n\n                const hasMeshoptCompression = gltf.json.extensionsUsed && gltf.json.extensionsUsed.includes('EXT_meshopt_compression');\n\n                const parameters = new EvaluationParameters(this.zoom, {brightness: this.brightness, worldview: this.worldview});\n                for (const sourceLayerId in layerFamilies) {\n                    for (const family of layerFamilies[sourceLayerId]) {\n                        const layer = family[0] as ModelStyleLayer;\n                        featureIndex.bucketLayerIDs.push(family.map((l) => makeFQID(l.id, l.scope)));\n                        layer.recalculate(parameters, []);\n                        // Nodes are created per layer which allows styling when multiple model layers are referencing the same source\n                        const nodes = process3DTile(gltf, 1.0 / tileToMeter(params.tileID.canonical));\n\n                        const bucket = new Tiled3dModelBucket(family as Array<ModelStyleLayer>, nodes, tileID, hasMapboxMeshFeatures, hasMeshoptCompression, this.brightness, featureIndex, this.worldview);\n                        // Upload to GPU without waiting for evaluation if we are in diffuse path\n                        if (!hasMapboxMeshFeatures) bucket.needsUpload = true;\n                        buckets.push(bucket);\n                        // do the first evaluation in the worker to avoid stuttering\n                        bucket.evaluate(layer);\n                    }\n                }\n\n                this.status = 'done';\n\n                callback(null, {\n                    buckets,\n                    featureIndex,\n                    collisionBoxArray: null,\n                    glyphAtlasImage: null,\n                    lineAtlas: null,\n                    imageAtlas: null,\n                    brightness: null,\n                });\n            })\n            .catch((err: Error) => callback(new Error(err.message)));\n    }\n}\n\nclass Tiled3dModelWorkerSource implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    availableImages: ImageId[];\n    availableModels: StyleModelMap;\n    loading: Record<number, Tiled3dWorkerTile>;\n    loaded: Record<number, Tiled3dWorkerTile>;\n    brightness?: number;\n    worldview: string | undefined;\n\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, availableImages: ImageId[], availableModels: StyleModelMap, isSpriteLoaded: boolean, loadVectorData?: LoadVectorData, brightness?: number, worldview?: string) {\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.availableImages = availableImages;\n        this.availableModels = availableModels;\n        this.brightness = brightness;\n        this.loading = {};\n        this.loaded = {};\n\n        this.worldview = worldview;\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}.\n     * @private\n     */\n    loadTile(params: WorkerSourceTiled3dModelRequest, callback: WorkerSourceVectorTileCallback) {\n        const uid = params.uid;\n        const workerTile = this.loading[uid] = new Tiled3dWorkerTile(params, this.brightness, this.worldview);\n        getArrayBuffer(params.request, (err?: Error | null, data?: ArrayBuffer | null) => {\n            const aborted = !this.loading[uid];\n            delete this.loading[uid];\n\n            if (aborted || err) {\n                workerTile.status = 'done';\n                if (!aborted) this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            if (!data || data.byteLength === 0) {\n                workerTile.status = 'done';\n                this.loaded[uid] = workerTile;\n                return callback();\n            }\n\n            const workerSourceVectorTileCallback = (err?: Error | null, result?: WorkerSourceVectorTileResult | null) => {\n                workerTile.status = 'done';\n                this.loaded = this.loaded || {};\n                this.loaded[uid] = workerTile;\n\n                if (err || !result) callback(err);\n                else callback(null, result);\n            };\n\n            workerTile.parse(data, this.layerIndex, params, workerSourceVectorTileCallback);\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     * Re-parses a tile that has already been loaded. Yields the same data as {@link WorkerSource#loadTile}.\n     * @private\n     */\n    reloadTile(params: WorkerSourceTiled3dModelRequest, callback: WorkerSourceVectorTileCallback) {\n        const loaded = this.loaded;\n        const uid = params.uid;\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.projection = params.projection;\n            workerTile.brightness = params.brightness;\n\n            const done = (err?: Error | null, data?: WorkerSourceVectorTileResult | null) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    this.loadTile(params, callback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // do the request again\n                this.loadTile(params, callback);\n            }\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     * Aborts loading a tile that is in progress.\n     * @private\n     */\n    abortTile(params: WorkerSourceTileRequest, callback: WorkerSourceVectorTileCallback) {\n        const uid = params.uid;\n        const tile = this.loading[uid];\n        if (tile) {\n            delete this.loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     * Removes this tile from any local caches.\n     * @private\n     */\n    removeTile(params: WorkerSourceTileRequest, callback: WorkerSourceVectorTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n\n}\n\nexport default Tiled3dModelWorkerSource;\n","import Actor from '../util/actor';\nimport StyleLayerIndex from '../style/style_layer_index';\nimport VectorTileWorkerSource from './vector_tile_worker_source';\nimport RasterDEMTileWorkerSource from './raster_dem_tile_worker_source';\nimport RasterArrayTileWorkerSource from './raster_array_tile_worker_source';\nimport GeoJSONWorkerSource from './geojson_worker_source';\nimport Tiled3dModelWorkerSource from '../../3d-style/source/tiled_3d_model_worker_source';\nimport assert from 'assert';\nimport {plugin as globalRTLTextPlugin, rtlPluginStatus} from './rtl_text_plugin';\nimport {enforceCacheSizeLimit} from '../util/tile_request_cache';\nimport {PerformanceUtils} from '../util/performance';\nimport {Event} from '../util/evented';\nimport {getProjection} from '../geo/projection/index';\nimport {ImageRasterizer} from '../render/image_rasterizer';\nimport {isWorker} from '../util/util';\n\nimport type Projection from '../geo/projection/projection';\nimport type {ImageId} from '../style-spec/expression/types/image_id';\nimport type {TaskMetadata} from '../util/scheduler';\nimport type {RtlTextPlugin} from './rtl_text_plugin';\nimport type {RasterizedImageMap} from '../render/image_manager';\nimport type {ActorMessage, ActorMessages} from '../util/actor_messages';\nimport type {WorkerSource, WorkerSourceConstructor} from './worker_source';\nimport type {StyleModelMap} from '../style/style_mode';\nimport type {Callback} from '../types/callback';\n\n/**\n * Source types that can instantiate a {@link WorkerSource} in {@link MapWorker}.\n */\ntype WorkerSourceType =\n    | 'vector'\n    | 'geojson'\n    | 'raster-dem'\n    | 'raster-array'\n    | 'batched-model';\n\n/**\n * Generic type for grouping items by mapId and style scope.\n */\ntype WorkerScopeRegistry<T> = Record<string, Record<string, T>>;\n\n/**\n * WorkerSources grouped by mapId, style scope, sourceType, and sourceId.\n */\ntype WorkerSourceRegistry = WorkerScopeRegistry<Record<string, Record<string, WorkerSource>>>;\n\n/**\n * @private\n */\nexport default class MapWorker {\n    self: Worker;\n    actor: Actor;\n    layerIndexes: WorkerScopeRegistry<StyleLayerIndex>;\n    availableImages: WorkerScopeRegistry<ImageId[]>;\n    availableModels: WorkerScopeRegistry<StyleModelMap>;\n    workerSourceTypes: Record<WorkerSourceType, WorkerSourceConstructor>;\n    workerSources: WorkerSourceRegistry;\n    projections: Record<string, Projection>;\n    defaultProjection: Projection;\n    isSpriteLoaded: WorkerScopeRegistry<boolean>;\n    referrer: string | null | undefined;\n    dracoUrl: string | null | undefined;\n    meshoptUrl: string | null | undefined;\n    brightness: number | null | undefined;\n    imageRasterizer: ImageRasterizer;\n    worldview: string | undefined;\n    rtlPluginParsingListeners: Array<Callback<boolean>>;\n\n    constructor(self: Worker) {\n        PerformanceUtils.measure('workerEvaluateScript');\n        this.self = self;\n        this.actor = new Actor(self, this);\n\n        this.layerIndexes = {};\n        this.availableImages = {};\n        this.availableModels = {};\n        this.isSpriteLoaded = {};\n        this.imageRasterizer = new ImageRasterizer();\n        this.rtlPluginParsingListeners = [];\n\n        this.projections = {};\n        this.defaultProjection = getProjection({name: 'mercator'});\n\n        this.workerSourceTypes = {\n            'vector': VectorTileWorkerSource,\n            'geojson': GeoJSONWorkerSource,\n            'raster-dem': RasterDEMTileWorkerSource,\n            'raster-array': RasterArrayTileWorkerSource,\n            'batched-model': Tiled3dModelWorkerSource\n        };\n\n        // [mapId][scope][sourceType][sourceName] => worker source instance\n        this.workerSources = {};\n\n        this.self.registerWorkerSource = (name: string, WorkerSource: WorkerSourceConstructor) => {\n            if (this.workerSourceTypes[name]) {\n                throw new Error(`Worker source with name \"${name}\" already registered.`);\n            }\n            this.workerSourceTypes[name] = WorkerSource;\n        };\n\n        // This is invoked by the RTL text plugin when the download via the `importScripts` call has finished, and the code has been parsed.\n        this.self.registerRTLTextPlugin = (rtlTextPlugin: RtlTextPlugin) => {\n            if (globalRTLTextPlugin.isParsed()) {\n                throw new Error('RTL text plugin already registered.');\n            }\n\n            globalRTLTextPlugin.setState({\n                pluginStatus: rtlPluginStatus.parsed,\n                pluginURL: globalRTLTextPlugin.getPluginURL()\n            });\n            globalRTLTextPlugin['applyArabicShaping'] = rtlTextPlugin.applyArabicShaping;\n            globalRTLTextPlugin['processBidirectionalText'] = rtlTextPlugin.processBidirectionalText;\n            globalRTLTextPlugin['processStyledBidirectionalText'] = rtlTextPlugin.processStyledBidirectionalText;\n\n            for (const callback of this.rtlPluginParsingListeners) {\n                callback(null, true);\n            }\n            this.rtlPluginParsingListeners = [];\n        };\n    }\n\n    clearCaches(mapId: number, params: ActorMessages['clearCaches']['params'], callback: ActorMessages['clearCaches']['callback']) {\n        delete this.layerIndexes[mapId];\n        delete this.availableImages[mapId];\n        delete this.availableModels[mapId];\n        delete this.workerSources[mapId];\n        callback();\n    }\n\n    checkIfReady(mapID: string, params: ActorMessages['checkIfReady']['params'], callback: ActorMessages['checkIfReady']['callback']) {\n        // noop, used to check if a worker is fully set up and ready to receive messages\n        callback();\n    }\n\n    setReferrer(mapID: string, referrer: ActorMessages['setReferrer']['params']) {\n        this.referrer = referrer;\n    }\n\n    spriteLoaded(mapId: number, params: ActorMessages['spriteLoaded']['params']) {\n        if (!this.isSpriteLoaded[mapId])\n            this.isSpriteLoaded[mapId] = {};\n\n        const {scope, isLoaded} = params;\n        this.isSpriteLoaded[mapId][scope] = isLoaded;\n\n        if (!this.workerSources[mapId] || !this.workerSources[mapId][scope]) {\n            return;\n        }\n\n        for (const workerSource in this.workerSources[mapId][scope]) {\n            const ws = this.workerSources[mapId][scope][workerSource];\n            for (const source in ws) {\n                const workerSource = ws[source];\n                if (workerSource instanceof VectorTileWorkerSource) {\n                    workerSource.isSpriteLoaded = isLoaded;\n                    workerSource.fire(new Event('isSpriteLoaded'));\n                }\n            }\n        }\n    }\n\n    setImages(mapId: number, params: ActorMessages['setImages']['params'], callback: ActorMessages['setImages']['callback']) {\n        if (!this.availableImages[mapId]) {\n            this.availableImages[mapId] = {};\n        }\n\n        const {scope, images} = params;\n        this.availableImages[mapId][scope] = images;\n\n        if (!this.workerSources[mapId] || !this.workerSources[mapId][scope]) {\n            callback();\n            return;\n        }\n\n        for (const workerSource in this.workerSources[mapId][scope]) {\n            const ws = this.workerSources[mapId][scope][workerSource];\n            for (const source in ws) {\n                ws[source].availableImages = images;\n            }\n        }\n\n        callback();\n    }\n\n    setModels(mapId: number, {scope, models}: ActorMessages['setModels']['params'], callback: ActorMessages['setModels']['callback']) {\n        if (!this.availableModels[mapId]) {\n            this.availableModels[mapId] = {};\n        }\n\n        this.availableModels[mapId][scope] = models;\n\n        if (!this.workerSources[mapId] || !this.workerSources[mapId][scope]) {\n            callback();\n            return;\n        }\n\n        for (const workerSource in this.workerSources[mapId][scope]) {\n            const ws = this.workerSources[mapId][scope][workerSource];\n            for (const source in ws) {\n                ws[source].availableModels = models;\n            }\n        }\n\n        callback();\n    }\n\n    setProjection(mapId: number, config: ActorMessages['setProjection']['params']) {\n        this.projections[mapId] = getProjection(config);\n    }\n\n    setBrightness(mapId: number, brightness: ActorMessages['setBrightness']['params'], callback: ActorMessages['setBrightness']['callback']) {\n        this.brightness = brightness;\n        callback();\n    }\n\n    setWorldview(mapId: number, worldview: ActorMessages['setWorldview']['params'], callback: ActorMessages['setWorldview']['callback']) {\n        this.worldview = worldview;\n        callback();\n    }\n\n    setLayers(mapId: number, params: ActorMessages['setLayers']['params'], callback: ActorMessages['setLayers']['callback']) {\n        this.getLayerIndex(mapId, params.scope).replace(params.layers, params.options);\n        callback();\n    }\n\n    updateLayers(mapId: number, params: ActorMessages['updateLayers']['params'], callback: ActorMessages['updateLayers']['callback']) {\n        this.getLayerIndex(mapId, params.scope).update(params.layers, params.removedIds, params.options);\n        callback();\n    }\n\n    loadTile(mapId: number, params: ActorMessages['loadTile']['params'], callback: ActorMessages['loadTile']['callback']) {\n        assert(params.type);\n        params.projection = this.projections[mapId] || this.defaultProjection;\n        this.getWorkerSource(mapId, params.type, params.source, params.scope).loadTile(params, callback);\n    }\n\n    decodeRasterArray(mapId: number, params: ActorMessages['decodeRasterArray']['params'], callback: ActorMessages['decodeRasterArray']['callback']) {\n        (this.getWorkerSource(mapId, params.type, params.source, params.scope) as RasterArrayTileWorkerSource).decodeRasterArray(params, callback);\n    }\n\n    reloadTile(mapId: number, params: ActorMessages['reloadTile']['params'], callback: ActorMessages['reloadTile']['callback']) {\n        assert(params.type);\n        params.projection = this.projections[mapId] || this.defaultProjection;\n        this.getWorkerSource(mapId, params.type, params.source, params.scope).reloadTile(params, callback);\n    }\n\n    abortTile(mapId: number, params: ActorMessages['abortTile']['params'], callback: ActorMessages['abortTile']['callback']) {\n        assert(params.type);\n        this.getWorkerSource(mapId, params.type, params.source, params.scope).abortTile(params, callback);\n    }\n\n    removeTile(mapId: number, params: ActorMessages['removeTile']['params'], callback: ActorMessages['removeTile']['callback']) {\n        assert(params.type);\n        this.getWorkerSource(mapId, params.type, params.source, params.scope).removeTile(params, callback);\n    }\n\n    removeSource(mapId: number, params: ActorMessages['removeSource']['params'], callback: ActorMessages['removeSource']['callback']) {\n        assert(params.type);\n        assert(params.scope);\n        assert(params.source);\n\n        if (!this.workerSources[mapId] ||\n            !this.workerSources[mapId][params.scope] ||\n            !this.workerSources[mapId][params.scope][params.type] ||\n            !this.workerSources[mapId][params.scope][params.type][params.source]) {\n            return;\n        }\n\n        const worker = this.workerSources[mapId][params.scope][params.type][params.source];\n        delete this.workerSources[mapId][params.scope][params.type][params.source];\n\n        if (worker.removeSource !== undefined) {\n            worker.removeSource(params, callback);\n        } else {\n            callback();\n        }\n    }\n\n    /**\n     * Load a {@link WorkerSource} script at params.url.  The script is run\n     * (using importScripts) with `registerWorkerSource` in scope, which is a\n     * function taking `(name, workerSourceObject)`.\n     *  @private\n     */\n    loadWorkerSource(mapId: number, params: ActorMessages['loadWorkerSource']['params'], callback: ActorMessages['loadWorkerSource']['callback']) {\n        try {\n            this.self.importScripts(params.url);\n            callback();\n        } catch (e) {\n            callback(e as Error);\n        }\n    }\n\n    syncRTLPluginState(mapId: number, state: ActorMessages['syncRTLPluginState']['params'], callback: ActorMessages['syncRTLPluginState']['callback']) {\n        if (globalRTLTextPlugin.isParsed()) {\n            callback(null, true);\n            return;\n        }\n        if (globalRTLTextPlugin.isParsing()) {\n            this.rtlPluginParsingListeners.push(callback);\n            return;\n        }\n        try {\n            globalRTLTextPlugin.setState(state);\n            const pluginURL = globalRTLTextPlugin.getPluginURL();\n            if (\n                globalRTLTextPlugin.isLoaded() &&\n                !globalRTLTextPlugin.isParsed() &&\n                !globalRTLTextPlugin.isParsing() &&\n                pluginURL != null // Not possible when `isLoaded` is true, but keeps flow happy\n            ) {\n                globalRTLTextPlugin.setState({\n                    pluginStatus: rtlPluginStatus.parsing,\n                    pluginURL: globalRTLTextPlugin.getPluginURL()\n                });\n                this.self.importScripts(pluginURL);\n\n                if (globalRTLTextPlugin.isParsed()) {\n                    callback(null, true);\n                } else {\n                    this.rtlPluginParsingListeners.push(callback);\n                }\n            }\n        } catch (e) {\n            callback(e as Error);\n        }\n    }\n\n    setDracoUrl(mapId: number, dracoUrl: ActorMessages['setDracoUrl']['params']) {\n        this.dracoUrl = dracoUrl;\n    }\n\n    getAvailableImages(mapId: number, scope: string): ImageId[] {\n        if (!this.availableImages[mapId]) {\n            this.availableImages[mapId] = {};\n        }\n\n        let availableImages = this.availableImages[mapId][scope];\n\n        if (!availableImages) {\n            availableImages = [];\n        }\n\n        return availableImages;\n    }\n\n    getAvailableModels(mapId: number, scope: string): StyleModelMap {\n        if (!this.availableModels[mapId]) {\n            this.availableModels[mapId] = {};\n        }\n\n        let availableModels = this.availableModels[mapId][scope];\n\n        if (!availableModels) {\n            availableModels = {};\n        }\n\n        return availableModels;\n    }\n\n    getLayerIndex(mapId: number, scope: string): StyleLayerIndex {\n        if (!this.layerIndexes[mapId]) {\n            this.layerIndexes[mapId] = {};\n        }\n\n        let layerIndex = this.layerIndexes[mapId][scope];\n\n        if (!layerIndex) {\n            layerIndex = this.layerIndexes[mapId][scope] = new StyleLayerIndex();\n            layerIndex.scope = scope;\n        }\n\n        return layerIndex;\n    }\n\n    getWorkerSource(mapId: number, type: string, source: string, scope: string): WorkerSource {\n        const workerSources = this.workerSources;\n\n        if (!workerSources[mapId])\n            workerSources[mapId] = {};\n        if (!workerSources[mapId][scope])\n            workerSources[mapId][scope] = {} as Record<WorkerSourceType, {[sourceId: string]: WorkerSource}>;\n        if (!workerSources[mapId][scope][type])\n            workerSources[mapId][scope][type] = {};\n\n        if (!this.isSpriteLoaded[mapId])\n            this.isSpriteLoaded[mapId] = {};\n\n        if (!workerSources[mapId][scope][type][source]) {\n            // use a wrapped actor so that we can attach a target mapId param\n            // to any messages invoked by the WorkerSource\n            const actor = {\n                send: <T extends ActorMessage>(type: T, data: ActorMessages[T]['params'], callback: ActorMessages[T]['callback'], _targetMapId: number, mustQueue: boolean, metadata: TaskMetadata) => {\n                    return this.actor.send(type, data, callback, mapId, mustQueue, metadata);\n                },\n                scheduler: this.actor.scheduler\n            } as Actor;\n\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n            workerSources[mapId][scope][type][source] = new this.workerSourceTypes[type](\n                actor,\n                this.getLayerIndex(mapId, scope),\n                this.getAvailableImages(mapId, scope),\n                this.getAvailableModels(mapId, scope),\n                this.isSpriteLoaded[mapId][scope],\n                undefined,\n                this.brightness,\n                this.worldview\n            );\n        }\n\n        return workerSources[mapId][scope][type][source];\n    }\n\n    rasterizeImagesWorker(mapId: number, params: ActorMessages['rasterizeImagesWorker']['params'], callback: ActorMessages['rasterizeImagesWorker']['callback']) {\n        const rasterizedImages: RasterizedImageMap = new Map();\n        for (const [id, {image, imageVariant}] of params.tasks.entries()) {\n            const rasterizedImage = this.imageRasterizer.rasterize(imageVariant, image, params.scope, mapId);\n            rasterizedImages.set(id, rasterizedImage);\n        }\n        callback(undefined, rasterizedImages);\n    }\n\n    removeRasterizedImages(mapId: number, params: ActorMessages['removeRasterizedImages']['params'], callback: ActorMessages['removeRasterizedImages']['callback']) {\n        this.imageRasterizer.removeImagesFromCacheByIds(params.imageIds, params.scope, mapId);\n        callback();\n    }\n\n    enforceCacheSizeLimit(mapId: number, limit: ActorMessages['enforceCacheSizeLimit']['params']) {\n        enforceCacheSizeLimit(limit);\n    }\n\n    getWorkerPerformanceMetrics(mapId: number, params: ActorMessages['getWorkerPerformanceMetrics']['params'], callback: ActorMessages['getWorkerPerformanceMetrics']['callback']) {\n        callback(undefined, PerformanceUtils.getWorkerPerformanceMetrics());\n    }\n}\n\nif (isWorker(self)) {\n    self.worker = new MapWorker(self);\n}\n"],"names":["getPerformanceMeasurement","request","url","toString","performance","getEntriesByName","stringify","obj","JSON","Array","isArray","str","val","key","Object","keys","sort","getKey","layer","k","refProperties","containsKey","recursiveSearch","item","some","values","StyleLayerIndex","constructor","layerConfigs","this","keyCache","_layers","_layerConfigs","replace","options","update","removedIds","_options","layerConfig","id","createStyleLayer","scope","compileFilter","familiesBySource","groups","layers","cachedKeys","i","length","type","group","push","result","groupByLayout","map","visibility","sourceId","source","sourceGroup","sourceLayerId","sourceLayer","sourceLayerFamilies","localGlyphPadding","SDF_SCALE","GlyphAtlas","stacks","positions","bins","stack","glyphData","glyphPositionMap","glyphs","src","bitmap","width","height","padding","metrics","localGlyph","bin","x","y","w","h","potpack","image","AlphaImage","copy","upsertBuilding","buildings","buildingId","center","floorIds","Set","floors","assignFloorToBuildings","buildingIds","floorId","floor","add","parseBuilding","feature","properties","split","Number","parseFloor","isDefault","is_default","connections","connected_floor_ids","conflicts","conflicted_floor_ids","building_ids","name","zIndex","z_index","hasRequiredProperties","requiredProps","every","prop","isValidBuildingFeature","isValidFloorFeature","register","WorkerTile","params","tileID","OverscaledTileID","overscaledZ","wrap","canonical","z","tileZoom","uid","zoom","lut","pixelRatio","tileSize","overscaling","overscaleFactor","showCollisionBoxes","collectResourceTiming","promoteId","isSymbolTile","tileTransform","projection","worldview","localizableLayerIds","brightness","extraShadowCaster","tessellationStep","scaleFactor","indoor","parse","data","layerIndex","availableImages","availableModels","actor","callback","status","collisionBoxArray","CollisionBoxArray","sourceLayerCoder","DictionaryCoder","featureIndex","FeatureIndex","bucketLayerIDs","buckets","lineAtlas","LineAtlas","iconDependencies","Map","patternDependencies","glyphDependencies","elevationFeatures","activeFloors","activeFloorsVisible","indoorState","indoorData","indoorTileOptions","sourceLayers","actualSourceLayers","warnOnce","size","missingSourceLayers","difference","missingSourceLayer","intersection","calculateIndoorSourceLayers","lastActiveFloors","selectedFloorId","newActiveFloors","allFloors","allDefaultFloors","floorIdToConflicts","conflictsWithActive","candidateId","candidateConflicts","get","activeId","has","layerId","index","set","lastActiveFloorId","defaultFloorId","parseData","send","parseIndoorData","asyncBucketLoads","layerFamilies","anySymbolLayers","anyOtherLayers","any3DLayer","family","is3D","version","sourceLayerIndex","encode","features","localizable","elevationDependency","currentFeatureIndex","getId","includes","hasOwnProperty","PROPERTY_ELEVATION_ID","HD_ELEVATION_SOURCE_LAYER","ElevationFeatures","parseFrom","minzoom","Math","maxzoom","recalculateLayers","bucket","createBucket","sourceID","spec","styleDefinedModelURLs","l","makeFQID","bucketPromise","prepare","then","populate","prepareTile","error","glyphMap","iconMap","patternMap","iconRasterizationTasks","patternRasterizationTasks","trim","taskMetadata","maybePrepare","filter","b","isEmpty","glyphAtlasImage","imageAtlas","glyphPositions","glyphAtlas","iconPositions","icon","entries","imagePosition","getImagePosition","ICON_PADDING","symbolLayoutData","SymbolBucket","performSymbolLayout","rasterizationStatus","iconsPending","patternsPending","rasterizeIfNeeded","postRasterizationLayout","m","ImageAtlas","postRasterizationSymbolLayout","hasPattern","LineBucket","FillBucket","FillExtrusionBucket","imagePositions","fromEntries","patternPositions","addFeatures","mapObject","err","images","from","ImageId","updateImageMapAndGetImageTaskQueue","patterns","unevaluatedPortals","graph","getUnevaluatedPortalGraph","evaluatedPortals","ElevationPortalGraph","evaluate","vtLayer","decode","setEvaluatedPortalGraph","Promise","allSettled","catch","updateParameters","outputMap","tasks","usvg","rasterize","imageMap","imageDependencies","imageRasterizationTasks","imageName","requiredImageVariants","imageVariant","imageVariantStr","assign","rasterizeTask","rasterizedImages","cancelRasterize","cancel","parameters","EvaluationParameters","recalculate","VectorTileWorkerSource","Evented","isSpriteLoaded","loadVectorData","super","loadVectorTile","loading","loaded","deduped","DedupedRequest","scheduler","loadTile","requestParam","perf","workerTile","abort","response","aborted","rawTileData","rawData","cacheControl","expiryData","getExpiryDataFromHeaders","responseHeaders","expires","vectorTile","VectorTile","Protobuf","parseTile","resourceTiming","resourceTimingData","slice","once","reloadTile","done","reloadCallback","abortTile","tile","removeTile","RasterDEMTileWorkerSource","encoding","rawImageData","imagePixels","ImageBitmap","getImageData","DEMData","imgBitmap","offscreenCanvas","offscreenCanvasContext","OffscreenCanvas","getContext","willReadFrequently","drawImage","imgData","clearRect","MapboxRasterTile","setPbf","Pbf","RasterArrayWorkerTile","_mrt","partial","Infinity","_isHeaderLoaded","buffer","mrt","_entireBuffer","parseHeader","decodingTasks","getLayer","range","getDataRange","getBandList","task","createDecodingTask","bufferSlice","firstByte","lastByte","decodingTask","performDecoding","complete","RasterArrayTileWorkerSource","getArrayBuffer","headers","decodeRasterArray","toGeoJSON","VectorTileFeature","prototype","FeatureWrapper","_feature","extent","EXTENT","tags","isNaN","parseInt","loadGeometry","geometry","point","Point","ring","newRing","call","LayerWrapper","_jsonFeatures","GeoJSONWrapper","PAD","GeoJSONRT","clear","load","cache","updated","updateCache","convertFeature","delete","intersectsTile","pow","getTile","tx","ty","z2","outputFeature","getFeatures","minX","minY","maxX","maxY","originalFeature","Error","coordinates","geom","convertPoint","p","convertLine","convertLines","polygon","lng","lat","out","bbox","mercatorXfromLng","mercatorYfromLat","min","max","isPolygon","isOuter","newLine","clockwise","area","len","j","rewind","lines","tileGeom","line","ox","round","oy","transformPoints","transformAndClipLine","transformAndClipPolygon","part","x0","y0","x1","y1","dx","dy","input","bitCode","code","clipped","edge","prevInside","inside","writeLayer","pbf","writeStringField","writeVarintField","context","writeMessage","writeFeature","value","writeValue","isSafeInteger","writeProperties","writeGeometry","keyIndex","writeVarint","valueIndex","command","cmd","zigzag","num","lineCount","writeBooleanField","writeDoubleField","writeSVarintField","defaultOptions","minZoom","maxZoom","minPoints","radius","nodeSize","log","generateId","reduce","props","fround","tmp","Float32Array","Supercluster","create","trees","stride","clusterProps","points","console","time","timerId","lngX","latY","tree","_createTree","timeEnd","now","Date","_cluster","numItems","getClusters","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","_limitZoom","ids","clusters","getClusterJSON","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","r","within","children","getLeaves","limit","offset","leaves","_appendLeaves","top","bottom","_addTileFeatures","getClusterExpansionZoom","expansionZoom","cluster_id","skipped","child","cluster","point_count","KDBush","finish","isCluster","px","py","getClusterProperties","f","undefined","nextData","neighborIds","numPointsOrigin","numPoints","neighborId","clusterProperties","wx","wy","clusterPropIndex","numPoints2","_map","clone","original","yLat","count","abbrev","propIndex","point_count_abbreviated","sin","PI","y2","atan","exp","simplify","coords","first","last","sqTolerance","maxSqDist","mid","minPosToMid","ax","ay","bx","by","d","getSqSegDist","posToMid","abs","t","createFeature","calcLineBBox","geojson","tolerance","lineMetrics","singleGeometry","geometries","newPolygon","projectX","projectY","sqrt","start","end","rings","clip","scale","k1","k2","axis","minAll","maxAll","newGeometry","clipPoints","clipLine","clipLines","newGeom","a","addPoint","trackMetrics","newSlice","intersect","intersectX","intersectY","segLen","az","exited","shiftFeatureCoords","newFeatures","shiftCoords","newPoints","transformTile","transformed","transformPoint","createTile","numSimplified","numFeatures","addFeature","simplified","addLine","tileFeature","indexMaxZoom","indexMaxPoints","debug","GeoJSONVT","dest","extend","convert","tiles","tileCoords","stats","total","merged","left","right","splitTile","cz","cx","cy","pop","toID","zoomSteps","k3","k4","tl","bl","tr","br","transform","parent","z0","loadGeoJSONTile","_geoJSONIndex","geoJSONTile","isElevationfeature","_geojsonTileLayer","hd_road_elevation","writePbf","GeoJSONWorkerSource","loadGeoJSON","_dynamicIndex","loadData","compiled","createExpression","overridable","transition","message","join","dynamic","append","superclusterOptions","mapExpressions","reduceExpressions","globals","accumulated","propertyNames","operator","mapExpression","mapExpressionParsed","reduceExpressionParsed","pointProperties","getSuperclusterOptions","geojsonvt","geojsonVtOptions","getJSON","setTimeout","e","getClusterChildren","getClusterLeaves","Tiled3dWorkerTile","is3DTile","load3DTile","gltf","hasMapboxMeshFeatures","json","extensionsUsed","asset","extras","hasMeshoptCompression","nodes","process3DTile","tileToMeter","Tiled3dModelBucket","needsUpload","Tiled3dModelWorkerSource","byteLength","MapWorker","self","Actor","layerIndexes","imageRasterizer","ImageRasterizer","rtlPluginParsingListeners","projections","defaultProjection","getProjection","workerSourceTypes","vector","workerSources","registerWorkerSource","WorkerSource","registerRTLTextPlugin","rtlTextPlugin","globalRTLTextPlugin","isParsed","setState","pluginStatus","rtlPluginStatus","parsed","pluginURL","getPluginURL","applyArabicShaping","processBidirectionalText","processStyledBidirectionalText","clearCaches","mapId","checkIfReady","mapID","setReferrer","referrer","spriteLoaded","isLoaded","workerSource","ws","fire","Event","setImages","setModels","models","setProjection","config","setBrightness","setWorldview","setLayers","getLayerIndex","updateLayers","getWorkerSource","removeSource","worker","loadWorkerSource","importScripts","syncRTLPluginState","state","isParsing","parsing","setDracoUrl","dracoUrl","getAvailableImages","getAvailableModels","_targetMapId","mustQueue","metadata","rasterizeImagesWorker","rasterizedImage","removeRasterizedImages","removeImagesFromCacheByIds","imageIds","enforceCacheSizeLimit","getWorkerPerformanceMetrics","isWorker"],"mappings":"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","x_google_ignoreList":[12,13,14,15,16,17,18,19,20]}