(function(N,S){typeof exports=="object"&&typeof module<"u"?S(exports,require("splaytree"),require("robust-predicates"),require("tinyqueue")):typeof define=="function"&&define.amd?define(["exports","splaytree","robust-predicates","tinyqueue"],S):(N=typeof globalThis<"u"?globalThis:N||self,S(N.martinez={},N.Tree,N.robustPredicates,N.Queue))})(this,function(N,S,_,x){"use strict";function y(n,t,e){t===null?(n.inOut=!1,n.otherInOut=!0):(n.isSubject===t.isSubject?(n.inOut=!t.inOut,n.otherInOut=t.otherInOut):(n.inOut=!t.otherInOut,n.otherInOut=t.isVertical()?!t.inOut:t.inOut),t&&(n.prevInResult=!k(t,e)||t.isVertical()?t.prevInResult:t)),k(n,e)?n.resultTransition=X(n,e):n.resultTransition=0}function k(n,t){switch(n.type){case 0:switch(t){case 0:return!n.otherInOut;case 1:return n.otherInOut;case 2:return n.isSubject&&n.otherInOut||!n.isSubject&&!n.otherInOut;case 3:return!0}break;case 2:return t===0||t===1;case 3:return t===2;case 1:return!1}return!1}function X(n,t){let e=!n.inOut,i=!n.otherInOut,o;switch(t){case 0:o=e&&i;break;case 1:o=e||i;break;case 3:o=e!==i;break;case 2:n.isSubject?o=e&&!i:o=i&&!e;break}return o?1:-1}class g{constructor(t,e,i,o,r){this.left=e,this.point=t,this.otherEvent=i,this.isSubject=o??!1,this.type=r||0,this.inOut=!1,this.otherInOut=!1,this.prevInResult=null,this.resultTransition=0,this.otherPos=-1,this.outputContourId=-1,this.isExteriorRing=!0}isBelow(t){const e=this.point,i=this.otherEvent.point;return this.left?(e[0]-t[0])*(i[1]-t[1])-(i[0]-t[0])*(e[1]-t[1])>0:(i[0]-t[0])*(e[1]-t[1])-(e[0]-t[0])*(i[1]-t[1])>0}isAbove(t){return!this.isBelow(t)}isVertical(){return this.point[0]===this.otherEvent.point[0]}get inResult(){return this.resultTransition!==0}clone(){const t=new g(this.point,this.left,this.otherEvent,this.isSubject,this.type);return t.contourId=this.contourId,t.resultTransition=this.resultTransition,t.prevInResult=this.prevInResult,t.isExteriorRing=this.isExteriorRing,t.inOut=this.inOut,t.otherInOut=this.otherInOut,t}}function R(n,t){return n[0]===t[0]?n[1]===t[1]:!1}function P(n,t,e){const i=_.orient2d(n[0],n[1],t[0],t[1],e[0],e[1]);return i>0?-1:i<0?1:0}function a(n,t){const e=n.point,i=t.point;return e[0]>i[0]?1:e[0]<i[0]?-1:e[1]!==i[1]?e[1]>i[1]?1:-1:L(n,t,e)}function L(n,t,e,i){return n.left!==t.left?n.left?1:-1:P(e,n.otherEvent.point,t.otherEvent.point)!==0?n.isBelow(t.otherEvent.point)?-1:1:!n.isSubject&&t.isSubject?1:-1}function T(n,t,e){const i=new g(t,!1,n,n.isSubject),o=new g(t,!0,n.otherEvent,n.isSubject);return R(n.point,n.otherEvent.point)&&console.warn("what is that, a collapsed segment?",n),i.contourId=o.contourId=n.contourId,a(o,n.otherEvent)>0&&(n.otherEvent.left=!0,o.left=!1),n.otherEvent.otherEvent=o,n.otherEvent=i,e.push(o),e.push(i),e}function C(n,t){return n[0]*t[1]-n[1]*t[0]}function A(n,t){return n[0]*t[0]+n[1]*t[1]}function G(n,t,e,i,o){const r=[t[0]-n[0],t[1]-n[1]],s=[i[0]-e[0],i[1]-e[1]];function l(d,v,B){return[d[0]+v*B[0],d[1]+v*B[1]]}const c=[e[0]-n[0],e[1]-n[1]];let u=C(r,s),f=u*u;const E=A(r,r);if(f>0){const d=C(c,s)/u;if(d<0||d>1)return null;const v=C(c,r)/u;return v<0||v>1?null:d===0||d===1?[l(n,d,r)]:v===0||v===1?[l(e,v,s)]:[l(n,d,r)]}if(u=C(c,r),f=u*u,f>0)return null;const h=A(r,c)/E,p=h+A(r,s)/E,O=Math.min(h,p),I=Math.max(h,p);return O<=1&&I>=0?O===1?[l(n,O>0?O:0,r)]:I===0?[l(n,I<1?I:1,r)]:[l(n,O>0?O:0,r),l(n,I<1?I:1,r)]:null}function j(n,t,e){const i=G(n.point,n.otherEvent.point,t.point,t.otherEvent.point),o=i?i.length:0;if(o===0||o===1&&(R(n.point,t.point)||R(n.otherEvent.point,t.otherEvent.point))||o===2&&n.isSubject===t.isSubject)return 0;if(o===1)return!R(n.point,i[0])&&!R(n.otherEvent.point,i[0])&&T(n,i[0],e),!R(t.point,i[0])&&!R(t.otherEvent.point,i[0])&&T(t,i[0],e),1;const r=[];let s=!1,l=!1;return R(n.point,t.point)?s=!0:a(n,t)===1?r.push(t,n):r.push(n,t),R(n.otherEvent.point,t.otherEvent.point)?l=!0:a(n.otherEvent,t.otherEvent)===1?r.push(t.otherEvent,n.otherEvent):r.push(n.otherEvent,t.otherEvent),s&&l||s?(t.type=1,n.type=t.inOut===n.inOut?2:3,s&&!l&&T(r[1].otherEvent,r[0].point,e),2):l?(T(r[0],r[1].point,e),3):r[0]!==r[3].otherEvent?(T(r[0],r[1].point,e),T(r[1],r[2].point,e),3):(T(r[0],r[1].point,e),T(r[3].otherEvent,r[2].point,e),3)}function V(n,t){if(n===t)return 0;if(P(n.point,n.otherEvent.point,t.point)!==0||P(n.point,n.otherEvent.point,t.otherEvent.point)!==0)return R(n.point,t.point)?n.isBelow(t.otherEvent.point)?-1:1:n.point[0]===t.point[0]?n.point[1]<t.point[1]?-1:1:a(n,t)===1?t.isAbove(n.point)?-1:1:n.isBelow(t.point)?-1:1;if(n.isSubject===t.isSubject){let e=n.point,i=t.point;if(e[0]===i[0]&&e[1]===i[1])return e=n.otherEvent.point,i=t.otherEvent.point,e[0]===i[0]&&e[1]===i[1]?0:(n.contourId??0)>(t.contourId??0)?1:-1}else return n.isSubject?-1:1;return a(n,t)===1?1:-1}function z(n,t,e,i,o,r){const s=new S(V),l=[],c=Math.min(i[2],o[2]);let u,f,E;for(;n.length!==0;){let h=n.pop();if(l.push(h),r===0&&h.point[0]>c||r===2&&h.point[0]>i[2])break;if(h.left){f=u=s.insert(h),E=s.minNode(),u!==E?u=s.prev(u):u=null,f=s.next(f);const p=u?u.key:null;let O;if(y(h,p,r),f&&j(h,f.key,n)===2&&(y(h,p,r),y(f.key,h,r)),u&&j(u.key,h,n)===2){let I=u;I!==E?I=s.prev(I):I=null,O=I?I.key:null,y(p,O,r),y(h,p,r)}}else h=h.otherEvent,f=u=s.find(h),u&&f&&(u!==E?u=s.prev(u):u=null,f=s.next(f),s.remove(h),f&&u&&j(u.key,f.key,n))}return l}class K{constructor(){this.points=[],this.holeIds=[],this.holeOf=null,this.depth=null}isExterior(){return this.holeOf==null}}function Y(n){let t,e,i,o,r;const s=[];for(e=0,i=n.length;e<i;e++)t=n[e],(t.left&&t.inResult||!t.left&&t.otherEvent.inResult)&&s.push(t);let l=!1;for(;!l;)for(l=!0,e=0,i=s.length;e<i;e++)e+1<i&&a(s[e],s[e+1])===1&&(o=s[e],s[e]=s[e+1],s[e+1]=o,l=!1);for(e=0,i=s.length;e<i;e++)t=s[e],t.otherPos=e;for(e=0,i=s.length;e<i;e++)t=s[e],t.left||(r=t.otherPos,t.otherPos=t.otherEvent.otherPos,t.otherEvent.otherPos=r);return s}function b(n,t,e,i){let o=n+1,r=t[n].point,s;const l=t.length;for(o<l&&(s=t[o].point);o<l&&s[0]===r[0]&&s[1]===r[1];){if(e[o])o++;else return o;o<l&&(s=t[o].point)}for(o=n-1;e[o]&&o>i;)o--;return o}function J(n,t,e){const i=new K;if(n.prevInResult!=null){const o=n.prevInResult,r=o.outputContourId;if(o.resultTransition>0){const l=t[r];if(l.holeOf!=null){const c=l.holeOf;t[c].holeIds.push(e),i.holeOf=c,i.depth=t[r].depth}else t[r].holeIds.push(e),i.holeOf=r,i.depth=t[r].depth+1}else i.holeOf=null,i.depth=t[r].depth}else i.holeOf=null,i.depth=0;return i}function W(n){let t,e;const i=Y(n),o={},r=[];for(t=0,e=i.length;t<e;t++){if(o[t])continue;const s=r.length,l=J(i[t],r,s),c=h=>{o[h]=!0,h<i.length&&i[h]&&(i[h].outputContourId=s)};let u=t,f=t;const E=i[t].point;for(l.points.push(E);c(u),u=i[u].otherPos,c(u),l.points.push(i[u].point),u=b(u,i,o,f),!(u==f||u>=i.length||!i[u]););r.push(l)}return r}const M=Math.max,D=Math.min;let m=0;function U(n,t,e,i,o,r){let s,l,c,u,f,E;for(s=0,l=n.length-1;s<l;s++){if(c=n[s],u=n[s+1],f=new g(c,!1,void 0,t),E=new g(u,!1,f,t),f.otherEvent=E,c[0]===u[0]&&c[1]===u[1])continue;f.contourId=E.contourId=e,r||(f.isExteriorRing=!1,E.isExteriorRing=!1),a(f,E)>0?E.left=!0:f.left=!0;const h=c[0],p=c[1];o[0]=D(o[0],h),o[1]=D(o[1],p),o[2]=M(o[2],h),o[3]=M(o[3],p),i.push(f),i.push(E)}}function Z(n,t,e,i,o){const r=new x(void 0,a);let s,l,c,u,f,E;for(c=0,u=n.length;c<u;c++)for(s=n[c],f=0,E=s.length;f<E;f++)l=f===0,l&&m++,U(s[f],!0,m,r,e,l);for(c=0,u=t.length;c<u;c++)for(s=t[c],f=0,E=s.length;f<E;f++)l=f===0,o===2&&(l=!1),l&&m++,U(s[f],!1,m,r,i,l);return r}const w=[];function $(n,t,e){let i=null;return n.length*t.length===0&&(e===0?i=w:e===2?i=n:(e===1||e===3)&&(i=n.length===0?t:n)),i}function q(n,t,e,i,o){let r=null;return(e[0]>i[2]||i[0]>e[2]||e[1]>i[3]||i[1]>e[3])&&(o===0?r=w:o===2?r=n:(o===1||o===3)&&(r=n.concat(t))),r}function F(n,t,e){let i=n,o=t;typeof n[0][0][0]=="number"&&(i=[n]),typeof t[0][0][0]=="number"&&(o=[t]);let r=$(i,o,e);if(r)return r===w?null:r;const s=[1/0,1/0,-1/0,-1/0],l=[1/0,1/0,-1/0,-1/0],c=Z(i,o,s,l,e);if(r=q(i,o,s,l,e),r)return r===w?null:r;const u=z(c,i,o,s,l,e),f=W(u),E=[];for(let h=0;h<f.length;h++){let p=f[h];if(p.isExterior()){let O=[p.points];for(let I=0;I<p.holeIds.length;I++){let d=p.holeIds[I];O.push(f[d].points)}E.push(O)}}return E}function Q(n,t){return F(n,t,1)}function H(n,t){return F(n,t,2)}function tt(n,t){return F(n,t,3)}function nt(n,t){return F(n,t,0)}const et={UNION:1,DIFFERENCE:2,INTERSECTION:0,XOR:3};N.diff=H,N.intersection=nt,N.operations=et,N.union=Q,N.xor=tt,Object.defineProperty(N,Symbol.toStringTag,{value:"Module"})});
