import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, mapboxgl;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t) {
        var e = 1e-6, r = "undefined" != typeof Float32Array ? Float32Array : Array;
        function n(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 * s2 - i2 * n2;
          return a2 ? (t2[0] = s2 * (a2 = 1 / a2), t2[1] = -n2 * a2, t2[2] = -i2 * a2, t2[3] = r2 * a2, t2) : null;
        }
        function i() {
          var t2 = new r(9);
          return r != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        function s(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8];
          return t2[0] = a2 * c2 - o2 * u2, t2[1] = i2 * u2 - n2 * c2, t2[2] = n2 * o2 - i2 * a2, t2[3] = o2 * l2 - s2 * c2, t2[4] = r2 * c2 - i2 * l2, t2[5] = i2 * s2 - r2 * o2, t2[6] = s2 * u2 - a2 * l2, t2[7] = n2 * l2 - r2 * u2, t2[8] = r2 * a2 - n2 * s2, t2;
        }
        function a(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = r2[0], d2 = r2[1], f2 = r2[2], m2 = r2[3], y2 = r2[4], g2 = r2[5], x2 = r2[6], v2 = r2[7], b2 = r2[8];
          return t2[0] = p2 * n2 + d2 * a2 + f2 * u2, t2[1] = p2 * i2 + d2 * o2 + f2 * c2, t2[2] = p2 * s2 + d2 * l2 + f2 * h2, t2[3] = m2 * n2 + y2 * a2 + g2 * u2, t2[4] = m2 * i2 + y2 * o2 + g2 * c2, t2[5] = m2 * s2 + y2 * l2 + g2 * h2, t2[6] = x2 * n2 + v2 * a2 + b2 * u2, t2[7] = x2 * i2 + v2 * o2 + b2 * c2, t2[8] = x2 * s2 + v2 * l2 + b2 * h2, t2;
        }
        function o() {
          var t2 = new r(16);
          return r != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }
        function l(t2) {
          var e2 = new r(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }
        function u(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function c(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], d2 = e2[11], f2 = e2[12], m2 = e2[13], y2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, M2 = c2 * m2 - h2 * f2, I2 = c2 * y2 - p2 * f2, S2 = c2 * g2 - d2 * f2, P2 = h2 * y2 - p2 * m2, z2 = h2 * g2 - d2 * m2, B2 = p2 * g2 - d2 * y2, k2 = x2 * B2 - v2 * z2 + b2 * P2 + w2 * S2 - _2 * I2 + A2 * M2;
          return k2 ? (t2[0] = (o2 * B2 - l2 * z2 + u2 * P2) * (k2 = 1 / k2), t2[1] = (i2 * z2 - n2 * B2 - s2 * P2) * k2, t2[2] = (m2 * A2 - y2 * _2 + g2 * w2) * k2, t2[3] = (p2 * _2 - h2 * A2 - d2 * w2) * k2, t2[4] = (l2 * S2 - a2 * B2 - u2 * I2) * k2, t2[5] = (r2 * B2 - i2 * S2 + s2 * I2) * k2, t2[6] = (y2 * b2 - f2 * A2 - g2 * v2) * k2, t2[7] = (c2 * A2 - p2 * b2 + d2 * v2) * k2, t2[8] = (a2 * z2 - o2 * S2 + u2 * M2) * k2, t2[9] = (n2 * S2 - r2 * z2 - s2 * M2) * k2, t2[10] = (f2 * _2 - m2 * b2 + g2 * x2) * k2, t2[11] = (h2 * b2 - c2 * _2 - d2 * x2) * k2, t2[12] = (o2 * I2 - a2 * P2 - l2 * M2) * k2, t2[13] = (r2 * P2 - n2 * I2 + i2 * M2) * k2, t2[14] = (m2 * v2 - f2 * w2 - y2 * x2) * k2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * k2, t2) : null;
        }
        function h(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], d2 = e2[10], f2 = e2[11], m2 = e2[12], y2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * m2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * y2, t2[2] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * m2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * y2, t2[6] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * m2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * y2, t2[10] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * m2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * y2, t2[14] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2;
        }
        function p(t2, e2, r2) {
          var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2 = r2[0], y2 = r2[1], g2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * m2 + e2[4] * y2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * m2 + e2[5] * y2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * m2 + e2[6] * y2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * m2 + e2[7] * y2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], d2 = e2[10], f2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = d2, t2[11] = f2, t2[12] = n2 * m2 + o2 * y2 + h2 * g2 + e2[12], t2[13] = i2 * m2 + l2 * y2 + p2 * g2 + e2[13], t2[14] = s2 * m2 + u2 * y2 + d2 * g2 + e2[14], t2[15] = a2 * m2 + c2 * y2 + f2 * g2 + e2[15]), t2;
        }
        function d(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }
        function f(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
        }
        function m(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
        }
        function y(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
        }
        function g(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function x(t2, r2, n2) {
          var i2, s2, a2, o2 = n2[0], l2 = n2[1], u2 = n2[2], c2 = Math.sqrt(o2 * o2 + l2 * l2 + u2 * u2);
          return c2 < e ? null : (o2 *= c2 = 1 / c2, l2 *= c2, u2 *= c2, i2 = Math.sin(r2), s2 = Math.cos(r2), t2[0] = o2 * o2 * (a2 = 1 - s2) + s2, t2[1] = l2 * o2 * a2 + u2 * i2, t2[2] = u2 * o2 * a2 - l2 * i2, t2[3] = 0, t2[4] = o2 * l2 * a2 - u2 * i2, t2[5] = l2 * l2 * a2 + s2, t2[6] = u2 * l2 * a2 + o2 * i2, t2[7] = 0, t2[8] = o2 * u2 * a2 + l2 * i2, t2[9] = l2 * u2 * a2 - o2 * i2, t2[10] = u2 * u2 * a2 + s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
        }
        function v(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[8], u2 = e2[9], c2 = e2[10];
          return t2[0] = Math.sqrt(r2 * r2 + n2 * n2 + i2 * i2), t2[1] = Math.sqrt(s2 * s2 + a2 * a2 + o2 * o2), t2[2] = Math.sqrt(l2 * l2 + u2 * u2 + c2 * c2), t2;
        }
        function b(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 + r2, o2 = n2 + n2, l2 = i2 + i2, u2 = r2 * a2, c2 = n2 * a2, h2 = n2 * o2, p2 = i2 * a2, d2 = i2 * o2, f2 = i2 * l2, m2 = s2 * a2, y2 = s2 * o2, g2 = s2 * l2;
          return t2[0] = 1 - h2 - f2, t2[1] = c2 + g2, t2[2] = p2 - y2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - f2, t2[6] = d2 + m2, t2[7] = 0, t2[8] = p2 + y2, t2[9] = d2 - m2, t2[10] = 1 - u2 - h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        var w = h;
        function _() {
          var t2 = new r(3);
          return r != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
        }
        function A(t2) {
          var e2 = new r(3);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
        }
        function M(t2) {
          var e2 = t2[0], r2 = t2[1], n2 = t2[2];
          return Math.sqrt(e2 * e2 + r2 * r2 + n2 * n2);
        }
        function I(t2, e2, n2) {
          var i2 = new r(3);
          return i2[0] = t2, i2[1] = e2, i2[2] = n2, i2;
        }
        function S(t2, e2, r2, n2) {
          return t2[0] = e2, t2[1] = r2, t2[2] = n2, t2;
        }
        function P(t2, e2, r2) {
          return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
        }
        function z(t2, e2, r2) {
          return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
        }
        function B(t2, e2, r2) {
          return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2;
        }
        function k(t2, e2, r2) {
          return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2;
        }
        function T(t2, e2, r2) {
          return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2;
        }
        function V(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
        }
        function E(t2, e2, r2, n2) {
          return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
        }
        function F(t2, e2) {
          var r2 = e2[0] - t2[0], n2 = e2[1] - t2[1], i2 = e2[2] - t2[2];
          return Math.sqrt(r2 * r2 + n2 * n2 + i2 * i2);
        }
        function D(t2, e2) {
          var r2 = e2[0] - t2[0], n2 = e2[1] - t2[1], i2 = e2[2] - t2[2];
          return r2 * r2 + n2 * n2 + i2 * i2;
        }
        function C(t2) {
          var e2 = t2[0], r2 = t2[1], n2 = t2[2];
          return e2 * e2 + r2 * r2 + n2 * n2;
        }
        function R(t2, e2) {
          return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2;
        }
        function L(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
          return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
        }
        function O(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
        }
        function U(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
          return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
        }
        function N(t2, e2, r2, n2) {
          var i2 = e2[0], s2 = e2[1], a2 = e2[2];
          return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2[2] = a2 + n2 * (r2[2] - a2), t2;
        }
        function j(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
          return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
        }
        function G(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2];
          return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
        }
        function $(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = r2[3], o2 = e2[0], l2 = e2[1], u2 = e2[2], c2 = i2 * u2 - s2 * l2, h2 = s2 * o2 - n2 * u2, p2 = n2 * l2 - i2 * o2;
          return t2[0] = o2 + a2 * (c2 += c2) + i2 * (p2 += p2) - s2 * (h2 += h2), t2[1] = l2 + a2 * h2 + s2 * c2 - n2 * p2, t2[2] = u2 + a2 * p2 + n2 * h2 - i2 * c2, t2;
        }
        function q(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
        }
        function X(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
        }
        var H = z, Z = B, W = M;
        function Y() {
          var t2 = new r(4);
          return r != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
        }
        function J(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
        }
        function K(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
          return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r2 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
        }
        function Q(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
        }
        function tt(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
        }
        function et() {
          var t2 = new r(4);
          return r != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
        }
        function rt(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
        }
        function nt(t2, e2, r2) {
          r2 *= 0.5;
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
          return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
        }
        function it(t2, e2, r2) {
          r2 *= 0.5;
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
          return t2[0] = n2 * l2 - s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = s2 * l2 + n2 * o2, t2[3] = a2 * l2 - i2 * o2, t2;
        }
        _(), Y();
        var st, at, ot, lt = K, ut = (st = _(), at = I(1, 0, 0), ot = I(0, 1, 0), function(t2, e2, r2) {
          var n2 = O(e2, r2);
          return n2 < -0.999999 ? (U(st, at, e2), W(st) < 1e-6 && U(st, ot, e2), L(st, st), function(t3, e3, r3) {
            r3 *= 0.5;
            var n3 = Math.sin(r3);
            t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = Math.cos(r3);
          }(t2, st, Math.PI), t2) : n2 > 0.999999 ? (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2) : (U(st, e2, r2), t2[0] = st[0], t2[1] = st[1], t2[2] = st[2], t2[3] = 1 + n2, lt(t2, t2));
        });
        function ct() {
          var t2 = new r(2);
          return r != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
        }
        function ht(t2, e2) {
          var n2 = new r(2);
          return n2[0] = t2, n2[1] = e2, n2;
        }
        function pt(t2, e2, r2) {
          return t2[0] = e2, t2[1] = r2, t2;
        }
        function dt(t2, e2, r2) {
          return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2;
        }
        function ft(t2, e2, r2) {
          return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2;
        }
        function mt(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2;
        }
        function yt(t2) {
          var e2 = t2[0], r2 = t2[1];
          return Math.sqrt(e2 * e2 + r2 * r2);
        }
        function gt(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = r2 * r2 + n2 * n2;
          return i2 > 0 && (i2 = 1 / Math.sqrt(i2)), t2[0] = e2[0] * i2, t2[1] = e2[1] * i2, t2;
        }
        function xt(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1];
        }
        et(), et(), i();
        var vt, bt, wt = ft;
        function _t(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        ct();
        var At = function() {
          if (bt) return vt;
          function t2(t3, e2, r2, n2) {
            this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
          }
          return bt = 1, vt = t2, t2.prototype = { sampleCurveX: function(t3) {
            return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
          }, sampleCurveY: function(t3) {
            return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
          }, sampleCurveDerivativeX: function(t3) {
            return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
          }, solveCurveX: function(t3, e2) {
            if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
            if (t3 > 1) return 1;
            for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
              var i2 = this.sampleCurveX(r2) - t3;
              if (Math.abs(i2) < e2) return r2;
              var s2 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(s2) < 1e-6) break;
              r2 -= i2 / s2;
            }
            var a2 = 0, o2 = 1;
            for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++) t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
            return r2;
          }, solve: function(t3, e2) {
            return this.sampleCurveY(this.solveCurveX(t3, e2));
          } }, vt;
        }(), Mt = _t(At);
        function It(t2, e2) {
          this.x = t2, this.y = e2;
        }
        function St(t2, e2) {
          if (Array.isArray(t2)) {
            if (!Array.isArray(e2) || t2.length !== e2.length) return false;
            for (let r2 = 0; r2 < t2.length; r2++) if (!St(t2[r2], e2[r2])) return false;
            return true;
          }
          if ("object" == typeof t2 && null !== t2 && null !== e2) {
            if ("object" != typeof e2) return false;
            if (Object.keys(t2).length !== Object.keys(e2).length) return false;
            for (const r2 in t2) if (!St(t2[r2], e2[r2])) return false;
            return true;
          }
          return t2 === e2;
        }
        It.prototype = { clone() {
          return new It(this.x, this.y);
        }, add(t2) {
          return this.clone()._add(t2);
        }, sub(t2) {
          return this.clone()._sub(t2);
        }, multByPoint(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint(t2) {
          return this.clone()._divByPoint(t2);
        }, mult(t2) {
          return this.clone()._mult(t2);
        }, div(t2) {
          return this.clone()._div(t2);
        }, rotate(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult(t2) {
          return this.clone()._matMult(t2);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr(t2) {
          const e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult(t2) {
          const e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate(t2) {
          const e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround(t2, e2) {
          const r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: It }, It.convert = function(t2) {
          if (t2 instanceof It) return t2;
          if (Array.isArray(t2)) return new It(+t2[0], +t2[1]);
          if (void 0 !== t2.x && void 0 !== t2.y) return new It(+t2.x, +t2.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        const Pt = Math.PI / 180, zt = 180 / Math.PI;
        function Bt(t2) {
          return t2 * Pt;
        }
        function kt(t2) {
          return t2 * zt;
        }
        const Tt = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function Vt(t2) {
          if (t2 <= 0) return 0;
          if (t2 >= 1) return 1;
          const e2 = t2 * t2, r2 = e2 * t2;
          return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
        }
        function Et(t2, e2, r2, n2) {
          const i2 = new Mt(t2, e2, r2, n2);
          return function(t3) {
            return i2.solve(t3);
          };
        }
        const Ft = Et(0.25, 0.1, 0.25, 1);
        function Dt(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function Ct(t2, e2, r2) {
          return (r2 = Dt((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
        }
        function Rt(t2, e2, r2) {
          const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function Lt(t2, e2, r2) {
          if (!t2.length) return r2(null, []);
          let n2 = t2.length;
          const i2 = new Array(t2.length);
          let s2 = null;
          t2.forEach((t3, a2) => {
            e2(t3, (t4, e3) => {
              t4 && (s2 = t4), i2[a2] = e3, 0 === --n2 && r2(s2, i2);
            });
          });
        }
        let Ot = 1;
        function Ut() {
          return Ot++;
        }
        function Nt(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log2(t2)));
        }
        function jt(t2, e2) {
          t2.forEach((t3) => {
            e2[t3] && (e2[t3] = e2[t3].bind(e2));
          });
        }
        function Gt(t2, e2, r2) {
          const n2 = {};
          for (const r3 in t2) n2[r3] = e2.call(this, t2[r3], r3, t2);
          return n2;
        }
        function $t(t2, e2, r2) {
          const n2 = {};
          for (const r3 in t2) e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
          return n2;
        }
        function qt(t2) {
          return Array.isArray(t2) ? t2.map(qt) : "object" == typeof t2 && t2 ? Gt(t2, qt) : t2;
        }
        function Xt(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) if (e2.indexOf(t2[r2]) >= 0) return true;
          return false;
        }
        const Ht = {};
        function Zt(t2) {
          Ht[t2] || ("undefined" != typeof console && console.warn(t2), Ht[t2] = true);
        }
        function Wt(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function Yt(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        function Jt([t2, e2, r2]) {
          const n2 = Bt(e2 + 90), i2 = Bt(r2);
          return { x: t2 * Math.cos(n2) * Math.sin(i2), y: t2 * Math.sin(n2) * Math.sin(i2), z: t2 * Math.cos(i2), azimuthal: e2, polar: r2 };
        }
        function Kt(t2) {
          return ("undefined" != typeof self || void 0 !== t2) && "undefined" != typeof WorkerGlobalScope && (void 0 !== t2 ? t2 : self) instanceof WorkerGlobalScope;
        }
        function Qt(t2) {
          const e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
            const s2 = n2 || i2;
            return e2[r2] = !s2 || s2.toLowerCase(), "";
          }), e2["max-age"]) {
            const t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }
        let te = null;
        function ee(t2, e2) {
          return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
        }
        function re(t2, e2, r2, n2) {
          for (; e2 < r2; ) {
            const i2 = e2 + r2 >> 1;
            t2[i2] < n2 ? e2 = i2 + 1 : r2 = i2;
          }
          return e2;
        }
        function ne(t2, e2, r2, n2) {
          for (; e2 < r2; ) {
            const i2 = e2 + r2 >> 1;
            t2[i2] <= n2 ? e2 = i2 + 1 : r2 = i2;
          }
          return e2;
        }
        function ie(t2) {
          return t2 > 0 ? 1 / (1.001 - t2) : 1 + t2;
        }
        function se(t2) {
          return t2 > 0 ? 1 - 1 / (1.001 - t2) : -t2;
        }
        function ae(t2, e2, r2) {
          return (t2 - e2.min) * (r2.max - r2.min) / (e2.max - e2.min) + r2.min;
        }
        const oe = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!oe.API_URL) return null;
          try {
            const t2 = new URL(oe.API_URL);
            return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
          } catch (t2) {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", BUILDING_GEN_URL: "https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v1.2.4.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
        function le(t2) {
          return oe.API_URL_REGEX.test(t2);
        }
        function ue(t2) {
          return oe.API_SPRITE_REGEX.test(t2);
        }
        let ce, he, pe, de, fe, me;
        function ye() {
          return null == ce && (ce = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), ce;
        }
        const ge = { now: () => void 0 !== de ? de : performance.now(), setNow(t2) {
          de = t2;
        }, restoreNow() {
          de = void 0;
        }, frame(t2) {
          const e2 = requestAnimationFrame(t2);
          return { cancel: () => cancelAnimationFrame(e2) };
        }, getImageData(t2, e2 = 0) {
          const { width: r2, height: n2 } = t2;
          fe || (fe = document.createElement("canvas"));
          const i2 = fe.getContext("2d", { willReadFrequently: true });
          if (!i2) throw new Error("failed to create canvas 2d context");
          return (r2 > fe.width || n2 > fe.height) && (fe.width = r2, fe.height = n2), i2.clearRect(-e2, -e2, r2 + 2 * e2, n2 + 2 * e2), i2.drawImage(t2, 0, 0, r2, n2), i2.getImageData(-e2, -e2, r2 + 2 * e2, n2 + 2 * e2);
        }, resolveURL: (t2) => (he || (he = document.createElement("a")), he.href = t2, he.href), get devicePixelRatio() {
          return window.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!window.matchMedia && (null == pe && (pe = window.matchMedia("(prefers-reduced-motion: reduce)")), pe.matches);
        }, hasCanvasFingerprintNoise() {
          if (void 0 !== me) return me;
          if (!ye()) return me = false, false;
          const t2 = new OffscreenCanvas(85, 1), e2 = t2.getContext("2d", { willReadFrequently: true });
          let r2 = 0;
          for (let n3 = 0; n3 < t2.width; ++n3) e2.fillStyle = `rgba(${r2++},${r2++},${r2++}, 255)`, e2.fillRect(n3, 0, 1, 1);
          const n2 = e2.getImageData(0, 0, t2.width, t2.height);
          r2 = 0;
          for (let t3 = 0; t3 < n2.data.length; ++t3) if (t3 % 4 != 3 && r2++ !== n2.data[t3]) return me = true, true;
          return me = false, false;
        } };
        function xe(t2, e2) {
          const r2 = t2.indexOf("?");
          if (r2 < 0) return `${t2}?${new URLSearchParams(e2).toString()}`;
          const n2 = new URLSearchParams(t2.slice(r2));
          for (const t3 in e2) n2.set(t3, e2[t3]);
          return `${t2.slice(0, r2)}?${n2.toString()}`;
        }
        function ve(t2, e2 = { persistentParams: [] }) {
          const r2 = t2.indexOf("?");
          if (r2 < 0) return t2;
          const n2 = new URLSearchParams(), i2 = new URLSearchParams(t2.slice(r2));
          for (const t3 of e2.persistentParams) {
            const e3 = i2.get(t3);
            e3 && n2.set(t3, e3);
          }
          const s2 = n2.toString();
          return `${t2.slice(0, r2)}${s2.length > 0 ? `?${s2}` : ""}`;
        }
        const be = "mapbox-tiles";
        let we = 500, _e = 50;
        const Ae = ["language", "worldview", "jobid"];
        let Me, Ie;
        function Se() {
          try {
            return caches;
          } catch (t2) {
          }
        }
        function Pe() {
          const t2 = Se();
          t2 && null == Me && (Me = t2.open(be));
        }
        let ze = 1 / 0;
        const Be = { supported: false, testSupport: function(t2) {
          !Ve && Te && (Ee ? De(t2) : ke = t2);
        } };
        let ke, Te, Ve = false, Ee = false;
        const Fe = "undefined" != typeof self ? self : {};
        function De(t2) {
          const e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, Te), t2.isContextLost()) return;
            Be.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e2), Ve = true;
        }
        Fe.document && (Te = Fe.document.createElement("img"), Te.onload = function() {
          ke && De(ke), ke = null, Ee = true;
        }, Te.onerror = function() {
          Ve = true, ke = null;
        }, Te.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Ce = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
        "function" == typeof Object.freeze && Object.freeze(Ce);
        class Re extends Error {
          constructor(t2, e2, r2) {
            401 === e2 && le(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const Le = Kt() ? () => self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
        const Oe = function(t2, e2) {
          if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(Le()) && !/^\w+:/.test(r2))) {
            if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t3, e3) {
              const r3 = new AbortController(), n2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: Le(), referrerPolicy: t3.referrerPolicy, signal: r3.signal });
              let i2 = false, s2 = false;
              const a2 = (o2 = n2.url).indexOf("sku=") > 0 && le(o2);
              var o2;
              "json" === t3.type && n2.headers.set("Accept", "application/json");
              const l2 = (r4, i3, o3) => {
                if (s2) return;
                if (r4 && "SecurityError" !== r4.message && Zt(r4.toString()), i3 && o3) return u2(i3);
                const l3 = Date.now();
                fetch(n2).then((r5) => {
                  if (r5.ok) {
                    const t4 = a2 ? r5.clone() : null;
                    return u2(r5, t4, l3);
                  }
                  return e3(new Re(r5.statusText, r5.status, t3.url));
                }).catch((r5) => {
                  "AbortError" !== r5.name && e3(new Error(`${r5.message} ${t3.url}`));
                });
              }, u2 = (r4, a3, o3) => {
                ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                  s2 || (a3 && o3 && function(t5, e4, r5) {
                    if (Pe(), null == Me) return;
                    const n3 = Qt(e4.headers.get("Cache-Control") || "");
                    if (n3["no-store"]) return;
                    const i3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                    e4.headers.forEach((t6, e5) => i3.headers.set(e5, t6)), n3["max-age"] && i3.headers.set("Expires", new Date(r5 + 1e3 * n3["max-age"]).toUTCString());
                    const s3 = i3.headers.get("Expires");
                    if (!s3) return;
                    if (new Date(s3).getTime() - r5 < 42e4) return;
                    let a4 = ve(t5.url, { persistentParams: Ae });
                    if (206 === e4.status) {
                      const e5 = t5.headers.get("Range");
                      if (!e5) return;
                      i3.status = 200, a4 = xe(a4, { range: e5 });
                    }
                    !function(t6, e5) {
                      if (void 0 === Ie) try {
                        new Response(new ReadableStream()), Ie = true;
                      } catch (t7) {
                        Ie = false;
                      }
                      Ie ? e5(t6.body) : t6.blob().then(e5).catch((t7) => Zt(t7.message));
                    }(e4, (t6) => {
                      const r6 = new Response(200 !== (n4 = e4.status) && 404 !== n4 && [101, 103, 204, 205, 304].includes(n4) ? null : t6, i3);
                      var n4;
                      Pe(), null != Me && Me.then((t7) => t7.put(a4, r6)).catch((t7) => Zt(t7.message));
                    });
                  }(n2, a3, o3), i2 = true, e3(null, t4, r4.headers));
                }).catch((t4) => {
                  s2 || e3(new Error(t4.message));
                });
              };
              return a2 ? function(t4, e4) {
                if (Pe(), null == Me) return e4(null);
                Me.then((r4) => {
                  let n3 = ve(t4.url, { persistentParams: Ae });
                  const i3 = t4.headers.get("Range");
                  i3 && (n3 = xe(n3, { range: i3 })), r4.match(n3).then((t5) => {
                    const i4 = function(t6) {
                      if (!t6) return false;
                      const e5 = new Date(t6.headers.get("Expires") || 0), r5 = Qt(t6.headers.get("Cache-Control") || "");
                      return Number(e5) > Date.now() && !r5["no-cache"];
                    }(t5);
                    r4.delete(n3).catch(e4), i4 && r4.put(n3, t5.clone()).catch(e4), e4(null, t5, i4);
                  }).catch(e4);
                }).catch(e4);
              }(n2, l2) : l2(null, null), { cancel: () => {
                s2 = true, i2 || r3.abort();
              } };
            }(t2, e2);
            if (Kt(self) && self.worker.actor) return self.worker.actor.send("getResource", t2, e2, void 0, true);
          }
          var r2;
          return function(t3, e3) {
            const r3 = new XMLHttpRequest();
            r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
            for (const e4 in t3.headers) r3.setRequestHeader(e4, t3.headers[e4]);
            return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
              e3(new Error(r3.statusText));
            }, r3.onload = () => {
              if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                let n2 = r3.response;
                if ("json" === t3.type) try {
                  n2 = JSON.parse(r3.response);
                } catch (t4) {
                  return e3(t4);
                }
                const i2 = new Headers();
                r3.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((t4) => {
                  const e4 = t4.split(": "), r4 = e4.shift(), n3 = e4.join(": ");
                  i2.append(r4, n3);
                }), e3(null, n2, i2);
              } else e3(new Re(r3.statusText, r3.status, t3.url));
            }, r3.send(t3.body), { cancel: () => r3.abort() };
          }(t2, e2);
        }, Ue = function(t2, e2) {
          return Oe(Object.assign(t2, { type: "arrayBuffer" }), e2);
        };
        function Ne(t2) {
          const e2 = document.createElement("a");
          return e2.href = t2, e2.protocol === location.protocol && e2.host === location.host;
        }
        const je = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let Ge, $e;
        Ge = [], $e = 0;
        const qe = function(t2, e2) {
          if (Be.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), $e >= oe.MAX_PARALLEL_IMAGE_REQUESTS) {
            const r3 = { requestParameters: t2, callback: e2, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return Ge.push(r3), r3;
          }
          $e++;
          let r2 = false;
          const n2 = () => {
            if (!r2) for (r2 = true, $e--; Ge.length && $e < oe.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t3 = Ge.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
              n3 || (t3.cancel = qe(e3, r3).cancel);
            }
          }, i2 = Ue(t2, (t3, r3, i3) => {
            n2(), t3 ? e2(t3) : r3 && (self.createImageBitmap ? function(t4, e3) {
              const r4 = new Blob([new Uint8Array(t4)], { type: "image/png" });
              createImageBitmap(r4).then((t5) => {
                e3(null, t5);
              }).catch((t5) => {
                e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(r3, (t4, r4) => e2(t4, r4, i3)) : function(t4, e3) {
              const r4 = new Image();
              r4.onload = () => {
                e3(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, requestAnimationFrame(() => {
                  r4.src = je;
                });
              }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
              r4.src = t4.byteLength ? URL.createObjectURL(n3) : je;
            }(r3, (t4, r4) => e2(t4, r4, i3)));
          });
          return { cancel: () => {
            i2.cancel(), n2();
          } };
        };
        var Xe, He, Ze, We = { exports: {} }, Ye = { exports: {} }, Je = { exports: {} }, Ke = function() {
          if (Ze) return We.exports;
          Ze = 1;
          var t2 = (Xe || (Xe = 1, Ye.exports = function(t3, e3) {
            var r2, n2, i2, s2, a2, o2, l2, u2;
            for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; ) l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + (((s2 >>> 16) + 58964 & 65535) << 16);
            switch (l2 = 0, r2) {
              case 3:
                l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
              case 1:
                i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
          }), Ye.exports), e2 = (He || (He = 1, Je.exports = function(t3, e3) {
            for (var r2, n2 = t3.length, i2 = e3 ^ n2, s2 = 0; n2 >= 4; ) r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
            switch (n2) {
              case 3:
                i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
              case 2:
                i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
              case 1:
                i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
            }
            return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
          }), Je.exports);
          return We.exports = t2, We.exports.murmur3 = t2, We.exports.murmur2 = e2, We.exports;
        }(), Qe = _t(Ke);
        class tr {
          constructor(t2, ...e2) {
            Object.assign(this, e2[0] || {}), this.type = t2;
          }
        }
        class er extends tr {
          constructor(t2, e2 = {}) {
            super("error", Object.assign({ error: t2 }, e2));
          }
        }
        function rr(t2, e2, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function nr(t2, e2, r2) {
          if (r2 && r2[t2]) {
            const n2 = r2[t2].indexOf(e2);
            -1 !== n2 && r2[t2].splice(n2, 1);
          }
        }
        class ir {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, rr(t2, e2, this._listeners), this;
          }
          off(t2, e2) {
            return nr(t2, e2, this._listeners), nr(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, rr(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => {
              this.once(t2, e3);
            });
          }
          fire(t2, e2) {
            const r2 = "string" == typeof t2 ? new tr(t2, e2) : t2, n2 = r2.type;
            if (this.listens(n2)) {
              r2.target = this;
              const t3 = this._listeners && this._listeners[n2] ? this._listeners[n2].slice() : [];
              for (const e4 of t3) e4.call(this, r2);
              const e3 = this._oneTimeListeners && this._oneTimeListeners[n2] ? this._oneTimeListeners[n2].slice() : [];
              for (const t4 of e3) nr(n2, t4, this._oneTimeListeners), t4.call(this, r2);
              const i2 = this._eventedParent;
              if (i2) {
                const t4 = "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData;
                Object.assign(r2, t4), i2.fire(r2);
              }
            } else r2 instanceof er && console.error(r2.error);
            return this;
          }
          listens(t2) {
            return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        class sr {
          constructor(t2) {
            "string" == typeof t2 ? this.name = t2 : (this.name = t2.name, this.iconsetId = t2.iconsetId);
          }
          static from(t2) {
            return new sr(t2);
          }
          static toString(t2) {
            return t2.iconsetId ? `${t2.name}${t2.iconsetId}` : t2.name;
          }
          static parse(t2) {
            const [e2, r2] = t2.split("");
            return new sr({ name: e2, iconsetId: r2 });
          }
          static isEqual(t2, e2) {
            return t2.name === e2.name && t2.iconsetId === e2.iconsetId;
          }
          toString() {
            return sr.toString(this);
          }
          serialize() {
            return { name: this.name, iconsetId: this.iconsetId };
          }
        }
        var ar, or = {}, lr = function() {
          if (ar) return or;
          ar = 1;
          var t2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function e2(t3) {
            return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
          }
          function r2(t3) {
            return e2("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
          }
          function n2(t3) {
            return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
            var e3;
          }
          function i2(t3, e3, r3) {
            return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
          }
          try {
            or.parseCSSColor = function(s2) {
              var a2, o2 = s2.replace(/ /g, "").toLowerCase();
              if (o2 in t2) return t2[o2].slice();
              if ("#" === o2[0]) return 4 === o2.length ? (a2 = parseInt(o2.substr(1), 16)) >= 0 && a2 <= 4095 ? [(3840 & a2) >> 4 | (3840 & a2) >> 8, 240 & a2 | (240 & a2) >> 4, 15 & a2 | (15 & a2) << 4, 1] : null : 7 === o2.length && (a2 = parseInt(o2.substr(1), 16)) >= 0 && a2 <= 16777215 ? [(16711680 & a2) >> 16, (65280 & a2) >> 8, 255 & a2, 1] : null;
              var l2 = o2.indexOf("("), u2 = o2.indexOf(")");
              if (-1 !== l2 && u2 + 1 === o2.length) {
                var c2 = o2.substr(0, l2), h2 = o2.substr(l2 + 1, u2 - (l2 + 1)).split(","), p2 = 1;
                switch (c2) {
                  case "rgba":
                    if (4 !== h2.length) return null;
                    p2 = n2(h2.pop());
                  case "rgb":
                    return 3 !== h2.length ? null : [r2(h2[0]), r2(h2[1]), r2(h2[2]), p2];
                  case "hsla":
                    if (4 !== h2.length) return null;
                    p2 = n2(h2.pop());
                  case "hsl":
                    if (3 !== h2.length) return null;
                    var d2 = (parseFloat(h2[0]) % 360 + 360) % 360 / 360, f2 = n2(h2[1]), m2 = n2(h2[2]), y2 = m2 <= 0.5 ? m2 * (f2 + 1) : m2 + f2 - m2 * f2, g2 = 2 * m2 - y2;
                    return [e2(255 * i2(g2, y2, d2 + 1 / 3)), e2(255 * i2(g2, y2, d2)), e2(255 * i2(g2, y2, d2 - 1 / 3)), p2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t3) {
          }
          return or;
        }();
        class ur {
          constructor(t2, e2, r2, n2 = 1) {
            this.r = t2, this.g = e2, this.b = r2, this.a = n2;
          }
          static parse(t2) {
            if (!t2) return;
            if (t2 instanceof ur) return t2;
            if ("string" != typeof t2) return;
            const e2 = lr.parseCSSColor(t2);
            return e2 ? new ur(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]) : void 0;
          }
          toString() {
            const [t2, e2, r2, n2] = [this.r, this.g, this.b, this.a];
            return `rgba(${Math.round(255 * t2)},${Math.round(255 * e2)},${Math.round(255 * r2)},${n2})`;
          }
          toNonPremultipliedRenderColor(t2) {
            const { r: e2, g: r2, b: n2, a: i2 } = this;
            return new hr(t2, e2, r2, n2, i2);
          }
          toPremultipliedRenderColor(t2) {
            const { r: e2, g: r2, b: n2, a: i2 } = this;
            return new pr(t2, e2 * i2, r2 * i2, n2 * i2, i2);
          }
          clone() {
            return new ur(this.r, this.g, this.b, this.a);
          }
        }
        class cr {
          constructor(t2, e2, r2, n2, i2, s2 = false) {
            if (this.premultiplied = false, this.premultiplied = s2, t2) {
              const s3 = t2.image.height, a2 = s3 * s3;
              this.premultiplied ? (e2 = 0 === i2 ? 0 : e2 / i2 * (s3 - 1), r2 = 0 === i2 ? 0 : r2 / i2 * (s3 - 1), n2 = 0 === i2 ? 0 : n2 / i2 * (s3 - 1)) : (e2 *= s3 - 1, r2 *= s3 - 1, n2 *= s3 - 1), e2 = Math.max(0, Math.min(s3 - 1, e2)), r2 = Math.max(0, Math.min(s3 - 1, r2)), n2 = Math.max(0, Math.min(s3 - 1, n2));
              const o2 = Math.floor(e2), l2 = Math.floor(r2), u2 = Math.floor(n2), c2 = Math.ceil(e2), h2 = Math.ceil(r2), p2 = Math.ceil(n2), d2 = e2 - o2, f2 = r2 - l2, m2 = n2 - u2, y2 = t2.image.data, g2 = 4 * (o2 + l2 * a2 + u2 * s3), x2 = 4 * (o2 + l2 * a2 + p2 * s3), v2 = 4 * (o2 + h2 * a2 + u2 * s3), b2 = 4 * (o2 + h2 * a2 + p2 * s3), w2 = 4 * (c2 + l2 * a2 + u2 * s3), _2 = 4 * (c2 + l2 * a2 + p2 * s3), A2 = 4 * (c2 + h2 * a2 + u2 * s3), M2 = 4 * (c2 + h2 * a2 + p2 * s3);
              this.r = dr(dr(dr(y2[g2], y2[x2], m2), dr(y2[v2], y2[b2], m2), f2), dr(dr(y2[w2], y2[_2], m2), dr(y2[A2], y2[M2], m2), f2), d2) / 255 * (this.premultiplied ? i2 : 1), this.g = dr(dr(dr(y2[g2 + 1], y2[x2 + 1], m2), dr(y2[v2 + 1], y2[b2 + 1], m2), f2), dr(dr(y2[w2 + 1], y2[_2 + 1], m2), dr(y2[A2 + 1], y2[M2 + 1], m2), f2), d2) / 255 * (this.premultiplied ? i2 : 1), this.b = dr(dr(dr(y2[g2 + 2], y2[x2 + 2], m2), dr(y2[v2 + 2], y2[b2 + 2], m2), f2), dr(dr(y2[w2 + 2], y2[_2 + 2], m2), dr(y2[A2 + 2], y2[M2 + 2], m2), f2), d2) / 255 * (this.premultiplied ? i2 : 1), this.a = i2;
            } else this.r = e2, this.g = r2, this.b = n2, this.a = i2;
          }
          toArray() {
            const { r: t2, g: e2, b: r2, a: n2 } = this;
            return [255 * t2, 255 * e2, 255 * r2, n2];
          }
          toHslaArray() {
            let { r: t2, g: e2, b: r2, a: n2 } = this;
            if (this.premultiplied) {
              if (0 === n2) return [0, 0, 0, 0];
              const i3 = 1 / n2;
              t2 *= i3, e2 *= i3, r2 *= i3;
            }
            const i2 = Math.min(Math.max(t2, 0), 1), s2 = Math.min(Math.max(e2, 0), 1), a2 = Math.min(Math.max(r2, 0), 1), o2 = Math.min(i2, s2, a2), l2 = Math.max(i2, s2, a2), u2 = l2 - o2, c2 = 0.5 * (o2 + l2);
            if (0 === u2) return [0, 0, 100 * c2, n2];
            const h2 = c2 > 0.5 ? u2 / (2 - l2 - o2) : u2 / (l2 + o2);
            let p2;
            switch (l2) {
              case i2:
                p2 = 60 * ((s2 - a2) / u2 + (s2 < a2 ? 6 : 0));
                break;
              case s2:
                p2 = 60 * ((a2 - i2) / u2 + 2);
                break;
              default:
                p2 = 60 * ((i2 - s2) / u2 + 4);
            }
            return [p2, 100 * h2, 100 * c2, n2];
          }
          toArray01() {
            const { r: t2, g: e2, b: r2, a: n2 } = this;
            return [t2, e2, r2, n2];
          }
          toArray01Scaled(t2) {
            const { r: e2, g: r2, b: n2 } = this;
            return [e2 * t2, r2 * t2, n2 * t2];
          }
          toArray01Linear() {
            const { r: t2, g: e2, b: r2, a: n2 } = this;
            return [Math.pow(t2, 2.2), Math.pow(e2, 2.2), Math.pow(r2, 2.2), n2];
          }
        }
        class hr extends cr {
          constructor(t2, e2, r2, n2, i2) {
            super(t2, e2, r2, n2, i2, false);
          }
        }
        class pr extends cr {
          constructor(t2, e2, r2, n2, i2) {
            super(t2, e2, r2, n2, i2, true);
          }
        }
        function dr(t2, e2, r2) {
          return t2 * (1 - r2) + e2 * r2;
        }
        function fr(t2, e2, r2) {
          return t2.map((t3, n2) => dr(t3, e2[n2], r2));
        }
        ur.black = new ur(0, 0, 0, 1), ur.white = new ur(1, 1, 1, 1), ur.transparent = new ur(0, 0, 0, 0), ur.red = new ur(1, 0, 0, 1), ur.blue = new ur(0, 0, 1, 1);
        var mr = Object.freeze({ __proto__: null, array: fr, color: function(t2, e2, r2) {
          return new ur(dr(t2.r, e2.r, r2), dr(t2.g, e2.g, r2), dr(t2.b, e2.b, r2), dr(t2.a, e2.a, r2));
        }, number: dr });
        class yr extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        class gr {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r2] of e2) this.bindings[t3] = r2;
          }
          concat(t2) {
            return new gr(this, t2);
          }
          get(t2) {
            if (this.bindings[t2]) return this.bindings[t2];
            if (this.parent) return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        const xr = { kind: "null" }, vr = { kind: "number" }, br = { kind: "string" }, wr = { kind: "boolean" }, _r = { kind: "color" }, Ar = { kind: "object" }, Mr = { kind: "value" }, Ir = { kind: "collator" }, Sr = { kind: "formatted" }, Pr = { kind: "resolvedImage" };
        function zr(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function Br(t2) {
          if ("array" === t2.kind) {
            const e2 = Br(t2.itemType);
            return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t2.kind;
        }
        const kr = [xr, vr, br, wr, _r, Sr, Ar, zr(Mr), Pr];
        function Tr(t2, e2) {
          if ("error" === e2.kind) return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Tr(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N)) return null;
          } else {
            if (t2.kind === e2.kind) return null;
            if ("value" === t2.kind) {
              for (const t3 of kr) if (!Tr(t3, e2)) return null;
            }
          }
          return `Expected ${Br(t2)} but found ${Br(e2)} instead.`;
        }
        function Vr(t2, e2) {
          return e2.some((e3) => e3.kind === t2.kind);
        }
        function Er(t2, e2) {
          return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
        }
        function Fr(t2, e2) {
          return "array" === t2.kind && "array" === e2.kind ? t2.N === e2.N && Fr(t2.itemType, e2.itemType) : t2.kind === e2.kind;
        }
        class Dr {
          constructor(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Cr {
          constructor(t2, e2, r2, n2, i2) {
            this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
          }
        }
        class Rr {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new Rr([new Cr(t2, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || !!t2.image && t2.image.hasPrimary());
          }
          static factory(t2) {
            return t2 instanceof Rr ? t2 : Rr.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
          }
          serialize() {
            const t2 = ["format"];
            for (const e2 of this.sections) {
              if (e2.image) {
                const r3 = e2.image.getPrimary().id.toString();
                t2.push(["image", r3]);
                continue;
              }
              t2.push(e2.text);
              const r2 = {};
              e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toNonPremultipliedRenderColor(null).toArray())), t2.push(r2);
            }
            return t2;
          }
        }
        class Lr {
          constructor(t2, e2 = {}) {
            this.id = sr.from(t2), this.params = e2.params, this.sx = e2.sx || 1, this.sy = e2.sy || 1;
          }
          toString() {
            return JSON.stringify(this);
          }
          static parse(t2) {
            let e2, r2, n2, i2;
            try {
              ({ id: e2, params: r2, sx: n2, sy: i2 } = JSON.parse(t2) || {});
            } catch (t3) {
              return null;
            }
            return e2 ? new Lr(e2, { params: r2, sx: n2, sy: i2 }) : null;
          }
          scaleSelf(t2, e2 = t2) {
            return this.sx *= t2, this.sy *= e2, this;
          }
        }
        class Or {
          constructor(t2, e2, r2, n2, i2 = false) {
            this.primaryId = sr.from(t2), this.primaryOptions = e2, r2 && (this.secondaryId = sr.from(r2)), this.secondaryOptions = n2, this.available = i2;
          }
          toString() {
            return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;
          }
          hasPrimary() {
            return !!this.primaryId;
          }
          getPrimary() {
            return new Lr(this.primaryId, this.primaryOptions);
          }
          hasSecondary() {
            return !!this.secondaryId;
          }
          getSecondary() {
            return this.secondaryId ? new Lr(this.secondaryId, this.secondaryOptions) : null;
          }
          static from(t2) {
            return "string" == typeof t2 ? Or.build({ name: t2 }) : t2;
          }
          static build(t2, e2, r2, n2) {
            return !t2 || "object" == typeof t2 && !("name" in t2) ? null : new Or(t2, r2, e2, n2);
          }
        }
        function Ur(t2, e2, r2, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Nr(t2) {
          if (null === t2) return true;
          if ("string" == typeof t2) return true;
          if ("boolean" == typeof t2) return true;
          if ("number" == typeof t2) return true;
          if (t2 instanceof ur) return true;
          if (t2 instanceof Dr) return true;
          if (t2 instanceof Rr) return true;
          if (t2 instanceof Or) return true;
          if (Array.isArray(t2)) {
            for (const e2 of t2) if (!Nr(e2)) return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e2 in t2) if (!Nr(t2[e2])) return false;
            return true;
          }
          return false;
        }
        function jr(t2) {
          if (null === t2) return xr;
          if ("string" == typeof t2) return br;
          if ("boolean" == typeof t2) return wr;
          if ("number" == typeof t2) return vr;
          if (t2 instanceof ur) return _r;
          if (t2 instanceof Dr) return Ir;
          if (t2 instanceof Rr) return Sr;
          if (t2 instanceof Or) return Pr;
          if (Array.isArray(t2)) {
            const e2 = t2.length;
            let r2;
            for (const e3 of t2) {
              const t3 = jr(e3);
              if (r2) {
                if (r2 === t3) continue;
                r2 = Mr;
                break;
              }
              r2 = t3;
            }
            return zr(r2 || Mr, e2);
          }
          return Ar;
        }
        function Gr(t2) {
          const e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Rr || t2 instanceof Or || t2 instanceof ur ? t2.toString() : JSON.stringify(t2);
        }
        class $r {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!Nr(t2[1])) return e2.error("invalid value");
            const r2 = t2[1];
            let n2 = jr(r2);
            const i2 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new $r(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ur ? ["rgba"].concat(this.value.toNonPremultipliedRenderColor(null).toArray()) : this.value instanceof Rr ? this.value.serialize() : this.value;
          }
        }
        class qr {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        }
        const Xr = { string: br, number: vr, boolean: wr, object: Ar };
        class Hr {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            let r2, n2 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s3;
              if (t2.length > 2) {
                const r3 = t2[1];
                if ("string" != typeof r3 || !(r3 in Xr) || "object" === r3) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = Xr[r3], n2++;
              } else i3 = Mr;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                s3 = t2[2], n2++;
              }
              r2 = zr(i3, s3);
            } else r2 = Xr[i2];
            const s2 = [];
            for (; n2 < t2.length; n2++) {
              const r3 = e2.parse(t2[n2], n2, Mr);
              if (!r3) return null;
              s2.push(r3);
            }
            return new Hr(r2, s2);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r2 = this.args[e2].evaluate(t2);
              if (!Tr(this.type, jr(r2))) return r2;
              if (e2 === this.args.length - 1) throw new qr(`The expression ${JSON.stringify(this.args[e2].serialize())} evaluated to ${Br(jr(r2))} but was expected to be of type ${Br(this.type)}.`);
            }
            return null;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = this.type, e2 = [t2.kind];
            if ("array" === t2.kind) {
              const r2 = t2.itemType;
              if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                e2.push(r2.kind);
                const n2 = t2.N;
                ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
              }
            }
            return e2.concat(this.args.map((t3) => t3.serialize()));
          }
        }
        class Zr {
          constructor(t2) {
            this.type = Sr, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2) return e2.error("First argument must be an image or text section.");
            const n2 = [];
            let i2 = false;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              const s2 = t2[r3];
              if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                i2 = false;
                let t3 = null;
                if (s2["font-scale"] && (t3 = e2.parseObjectValue(s2["font-scale"], r3, "font-scale", vr), !t3)) return null;
                let a2 = null;
                if (s2["text-font"] && (a2 = e2.parseObjectValue(s2["text-font"], r3, "text-font", zr(br)), !a2)) return null;
                let o2 = null;
                if (s2["text-color"] && (o2 = e2.parseObjectValue(s2["text-color"], r3, "text-color", _r), !o2)) return null;
                const l2 = n2[n2.length - 1];
                l2.scale = t3, l2.font = a2, l2.textColor = o2;
              } else {
                const s3 = e2.parse(t2[r3], r3, Mr);
                if (!s3) return null;
                const a2 = s3.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
              }
            }
            return new Zr(n2);
          }
          evaluate(t2) {
            return new Rr(this.sections.map((e2) => {
              const r2 = e2.content.evaluate(t2);
              return Fr(jr(r2), Pr) ? new Cr("", r2, null, null, null) : new Cr(Gr(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (const e2 of this.sections) t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["format"];
            for (const e2 of this.sections) {
              t2.push(e2.content.serialize());
              const r2 = {};
              e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
            }
            return t2;
          }
        }
        class Wr {
          constructor(t2, e2, r2, n2) {
            this._imageWarnHistory = {}, this.type = Pr, this.namePrimary = t2, this.nameSecondary = e2, r2 && (this.paramsPrimary = r2.params, this.iconsetIdPrimary = r2.iconset ? r2.iconset.id : void 0), n2 && (this.paramsSecondary = n2.params, this.iconsetIdSecondary = n2.iconset ? n2.iconset.id : void 0);
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected two or more arguments.");
            let r2 = 1;
            const n2 = [];
            function i2() {
              if (r2 < t2.length) {
                const i3 = e2.parse(t2[r2], r2++, br);
                return i3 ? (n2.push({ image: i3, options: {} }), true) : (e2.error(n2.length ? "Secondary image variant is not a string." : "No image name provided."), false);
              }
              return true;
            }
            function s2() {
              if (r2 < t2.length) {
                const s3 = t2[r2];
                if (null === (i3 = s3) || "object" != typeof i3 || Array.isArray(i3)) return true;
                const a2 = s3.params, o2 = s3.iconset, l2 = e2.concat(r2);
                if (!a2 && !o2) return r2++, true;
                if (a2) {
                  if ("object" != typeof a2 || a2.constructor !== Object) return l2.error('Image options "params" should be an object'), false;
                  const t3 = {}, e3 = l2.concat(void 0, "params");
                  for (const r3 in a2) {
                    if (!r3) return e3.error("Image parameter name should be non-empty"), false;
                    const n3 = e3.concat(void 0, r3).parse(a2[r3], void 0, _r, void 0, { typeAnnotation: "coerce" });
                    if (!n3) return false;
                    t3[r3] = n3;
                  }
                  n2[n2.length - 1].options.params = t3;
                }
                if (o2) {
                  if ("object" != typeof o2 || o2.constructor !== Object) return l2.error('Image options "iconset" should be an object'), false;
                  if (!o2.id) return l2.error('Image options "iconset" should have an "id" property'), false;
                  n2[n2.length - 1].options.iconset = o2;
                }
                return r2++, true;
              }
              var i3;
              return true;
            }
            for (let t3 = 0; t3 < 2; t3++) if (!i2() || !s2()) return;
            return new Wr(n2[0].image, n2[1] ? n2[1].image : void 0, n2[0].options, n2[1] ? n2[1].options : void 0);
          }
          evaluateParams(t2, e2) {
            const r2 = {};
            if (e2) {
              for (const n2 in e2) if (e2[n2]) try {
                r2[n2] = e2[n2].evaluate(t2);
              } catch (t3) {
                continue;
              }
              if (0 !== Object.keys(r2).length) return { params: r2 };
            }
          }
          evaluate(t2) {
            const e2 = { name: this.namePrimary.evaluate(t2), iconsetId: this.iconsetIdPrimary }, r2 = this.nameSecondary ? { name: this.nameSecondary.evaluate(t2), iconsetId: this.iconsetIdSecondary } : void 0, n2 = Or.build(e2, r2, this.paramsPrimary ? this.evaluateParams(t2, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t2, this.paramsSecondary) : void 0);
            if (n2 && t2.availableImages) {
              const e3 = n2.getPrimary().id;
              if (n2.available = t2.availableImages.some((t3) => sr.isEqual(t3, e3)), n2.available) {
                const e4 = n2.getSecondary() ? n2.getSecondary().id : null;
                e4 && (n2.available = t2.availableImages.some((t3) => sr.isEqual(t3, e4)));
              }
            }
            return n2;
          }
          eachChild(t2) {
            if (t2(this.namePrimary), this.paramsPrimary) for (const e2 in this.paramsPrimary) this.paramsPrimary[e2] && t2(this.paramsPrimary[e2]);
            if (this.nameSecondary && (t2(this.nameSecondary), this.paramsSecondary)) for (const e2 in this.paramsSecondary) this.paramsSecondary[e2] && t2(this.paramsSecondary[e2]);
          }
          outputDefined() {
            return false;
          }
          serializeOptions(t2, e2) {
            const r2 = {};
            if (e2 && (r2.iconset = { id: e2 }), t2) {
              r2.params = {};
              for (const e3 in t2) t2[e3] && (r2.params[e3] = t2[e3].serialize());
            }
            return Object.keys(r2).length > 0 ? r2 : void 0;
          }
          serialize() {
            const t2 = ["image", this.namePrimary.serialize()];
            if (this.paramsPrimary || this.iconsetIdPrimary) {
              const e2 = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
              e2 && t2.push(e2);
            }
            if (this.nameSecondary && (t2.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
              const e2 = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
              e2 && t2.push(e2);
            }
            return t2;
          }
        }
        function Yr(t2) {
          return Kr(t2) ? "string" : Qr(t2) ? "number" : tn(t2) ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : Jr(t2) ? "object" : typeof t2;
        }
        function Jr(t2) {
          return null != t2 && !Array.isArray(t2) && "function" != typeof t2 && !(t2 instanceof String || t2 instanceof Number || t2 instanceof Boolean) && "object" == typeof t2;
        }
        function Kr(t2) {
          return "string" == typeof t2 || t2 instanceof String;
        }
        function Qr(t2) {
          return "number" == typeof t2 || t2 instanceof Number;
        }
        function tn(t2) {
          return "boolean" == typeof t2 || t2 instanceof Boolean;
        }
        const en = { "to-boolean": wr, "to-color": _r, "to-number": vr, "to-string": br };
        class rn {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expected at least one argument.");
            const r2 = t2[0], n2 = [];
            let i2 = xr;
            if ("to-array" === r2) {
              if (!Array.isArray(t2[1])) return null;
              const r3 = t2[1].length;
              if (e2.expectedType) {
                if ("array" !== e2.expectedType.kind) return e2.error(`Expected ${e2.expectedType.kind} but found array.`);
                i2 = zr(e2.expectedType.itemType, r3);
              } else {
                if (!(r3 > 0 && Nr(t2[1][0]))) return null;
                i2 = zr(jr(t2[1][0]), r3);
              }
              for (let s2 = 0; s2 < r3; s2++) {
                const r4 = t2[1][s2];
                let a2;
                if (Array.isArray(r4)) a2 = e2.parse(r4, void 0, i2.itemType);
                else {
                  const t3 = Yr(r4);
                  if (t3 !== i2.itemType.kind) return e2.error(`Expected ${i2.itemType.kind} but found ${t3}.`);
                  a2 = e2.registry.literal.parse(["literal", void 0 === r4 ? null : r4], e2);
                }
                if (!a2) return null;
                n2.push(a2);
              }
            } else {
              if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length) return e2.error("Expected one argument.");
              i2 = en[r2];
              for (let r3 = 1; r3 < t2.length; r3++) {
                const i3 = e2.parse(t2[r3], r3, Mr);
                if (!i3) return null;
                n2.push(i3);
              }
            }
            return new rn(i2, n2);
          }
          evaluate(t2) {
            if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t2));
            if ("color" === this.type.kind) {
              let e2, r2;
              for (const n2 of this.args) {
                if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof ur) return e2;
                if ("string" == typeof e2) {
                  const r3 = t2.parseColor(e2);
                  if (r3) return r3;
                } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Ur(e2[0], e2[1], e2[2], e2[3]), !r2)) return new ur(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new qr(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
            }
            if ("number" === this.type.kind) {
              let e2 = null;
              for (const r2 of this.args) {
                if (e2 = r2.evaluate(t2), null === e2) return 0;
                const n2 = Number(e2);
                if (!isNaN(n2)) return n2;
              }
              throw new qr(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            return "formatted" === this.type.kind ? Rr.fromString(Gr(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Or.build(Gr(this.args[0].evaluate(t2))) : "array" === this.type.kind ? this.args.map((e2) => e2.evaluate(t2)) : Gr(this.args[0].evaluate(t2));
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind) return new Zr([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind) return new Wr(this.args[0]).serialize();
            const t2 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        const nn = ["Unknown", "Point", "LineString", "Polygon"];
        class sn {
          constructor(t2, e2, r2) {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t2, this.options = e2, this.iconImageUseTheme = r2;
          }
          id() {
            return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? nn[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          measureLight(t2) {
            return this.globals.brightness || 0;
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r2, y: n2 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r2 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e2 - t2[1]);
            }
            return 0;
          }
          parseColor(t2) {
            let e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = ur.parse(t2)), e2;
          }
          getConfig(t2) {
            return this.options ? this.options.get(t2) : null;
          }
        }
        class an {
          constructor(t2, e2, r2, n2, i2) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2, this._overloadIndex = i2;
          }
          evaluate(t2) {
            if (!this._evaluate) {
              const t3 = an.definitions[this.name];
              this._evaluate = Array.isArray(t3) ? t3[2] : t3.overloads[this._overloadIndex][1];
            }
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t2) => t2.serialize()));
          }
          static parse(t2, e2) {
            const r2 = t2[0], n2 = an.definitions[r2];
            if (!n2) return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = [];
            let o2 = null, l2 = -1;
            for (const [n3, u2] of s2) {
              if (Array.isArray(n3) && n3.length !== t2.length - 1) continue;
              a2.push(n3), l2++, o2 = new Ii(e2.registry, e2.path, null, e2.scope, void 0, e2._scope, e2.options, e2.iconImageUseTheme);
              const s3 = [];
              let c2 = false;
              for (let e3 = 1; e3 < t2.length; e3++) {
                const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, a3 = o2.parse(r3, 1 + s3.length, i3);
                if (!a3) {
                  c2 = true;
                  break;
                }
                s3.push(a3);
              }
              if (!c2) if (Array.isArray(n3) && n3.length !== s3.length) o2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
              else {
                for (let t3 = 0; t3 < s3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (0 === o2.errors.length) return new an(r2, i2, u2, s3, l2);
              }
            }
            if (1 === a2.length) e2.errors.push(...o2.errors);
            else {
              const r3 = (a2.length ? a2 : s2.map(([t3]) => t3)).map(on).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const i3 = e2.parse(t2[r4], 1 + n3.length);
                if (!i3) return null;
                n3.push(Br(i3.type));
              }
              e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e2) {
            an.definitions = e2;
            for (const r2 in e2) t2[r2] = an;
          }
        }
        function on(t2) {
          return Array.isArray(t2) ? `(${t2.map(Br).join(", ")})` : `(${Br(t2.type)}...)`;
        }
        class ln {
          constructor(t2, e2, r2) {
            this.type = Ir, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error("Expected one argument.");
            const r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2)) return e2.error("Collator options argument must be an object.");
            const n2 = void 0 === r2["case-sensitive"] ? e2.parse(false, 1, wr) : e2.parseObjectValue(r2["case-sensitive"], 1, "case-sensitive", wr);
            if (!n2) return null;
            const i2 = void 0 === r2["diacritic-sensitive"] ? e2.parse(false, 1, wr) : e2.parseObjectValue(r2["diacritic-sensitive"], 1, "diacritic-sensitive", wr);
            if (!i2) return null;
            let s2 = null;
            return r2.locale && (s2 = e2.parseObjectValue(r2.locale, 1, "locale", br), !s2) ? null : new ln(n2, i2, s2);
          }
          evaluate(t2) {
            return new Dr(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
          }
        }
        function un(t2, e2, r2 = 0, n2 = t2.length - 1, i2 = hn) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              const s3 = n2 - r2 + 1, a3 = e2 - r2 + 1, o3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * o3 / 3), u2 = 0.5 * Math.sqrt(o3 * l2 * (s3 - l2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
              un(t2, e2, Math.max(r2, Math.floor(e2 - a3 * l2 / s3 + u2)), Math.min(n2, Math.floor(e2 + (s3 - a3) * l2 / s3 + u2)), i2);
            }
            const s2 = t2[e2];
            let a2 = r2, o2 = n2;
            for (cn(t2, r2, e2), i2(t2[n2], s2) > 0 && cn(t2, r2, n2); a2 < o2; ) {
              for (cn(t2, a2, o2), a2++, o2--; i2(t2[a2], s2) < 0; ) a2++;
              for (; i2(t2[o2], s2) > 0; ) o2--;
            }
            0 === i2(t2[r2], s2) ? cn(t2, r2, o2) : (o2++, cn(t2, o2, n2)), o2 <= e2 && (r2 = o2 + 1), e2 <= o2 && (n2 = o2 - 1);
          }
        }
        function cn(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function hn(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function pn(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        function dn(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function fn(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function mn(t2, e2, r2) {
          const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
          return n2 * a2 - s2 * i2 === 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
        }
        function yn(t2, e2, r2) {
          return e2[1] > t2[1] != r2[1] > t2[1] && t2[0] < (r2[0] - e2[0]) * (t2[1] - e2[1]) / (r2[1] - e2[1]) + e2[0];
        }
        function gn(t2, e2, r2 = false) {
          let n2 = false;
          for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
            const s3 = e2[i2];
            for (let e3 = 0, i3 = s3.length, a2 = i3 - 1; e3 < i3; a2 = e3++) {
              const i4 = s3[a2], o2 = s3[e3];
              if (mn(t2, i4, o2)) return r2;
              yn(t2, i4, o2) && (n2 = !n2);
            }
          }
          return n2;
        }
        function xn(t2, e2, r2, n2) {
          const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function vn(t2, e2, r2, n2) {
          return 0 !== (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] && !(!xn(t2, e2, r2, n2) || !xn(r2, n2, t2, e2));
          var i2, s2;
        }
        function bn(t2) {
          const e2 = new It(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r2 = new It(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
          for (const n2 of t2[0]) e2.x > n2.x && (e2.x = n2.x), e2.y > n2.y && (e2.y = n2.y), r2.x < n2.x && (r2.x = n2.x), r2.y < n2.y && (r2.y = n2.y);
          return { min: e2, max: r2 };
        }
        const wn = 8192;
        function _n(t2, e2) {
          const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r2 * i2 * wn), Math.round(n2 * i2 * wn)];
        }
        function An(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++) if (gn(t2, e2[r2])) return true;
          return false;
        }
        function Mn(t2, e2, r2) {
          for (const n2 of r2) for (let r3 = 0, i2 = n2.length, s2 = i2 - 1; r3 < i2; s2 = r3++) if (vn(t2, e2, n2[s2], n2[r3])) return true;
          return false;
        }
        function In(t2, e2) {
          for (let r2 = 0; r2 < t2.length; ++r2) if (!gn(t2[r2], e2)) return false;
          for (let r2 = 0; r2 < t2.length - 1; ++r2) if (Mn(t2[r2], t2[r2 + 1], e2)) return false;
          return true;
        }
        function Sn(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++) if (In(t2, e2[r2])) return true;
          return false;
        }
        function Pn(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              const a2 = _n(t2[i2][n3], r2);
              dn(e2, a2), s2.push(a2);
            }
            n2.push(s2);
          }
          return n2;
        }
        function zn(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = Pn(t2[i2], e2, r2);
            n2.push(s2);
          }
          return n2;
        }
        function Bn(t2, e2, r2, n2) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            const e3 = 0.5 * n2;
            let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
            0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
          }
          dn(e2, t2);
        }
        function kn(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * wn, s2 = [n2.x * wn, n2.y * wn], a2 = [];
          if (!t2) return a2;
          for (const n3 of t2) for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            Bn(n4, e2, r2, i2), a2.push(n4);
          }
          return a2;
        }
        function Tn(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * wn, s2 = [n2.x * wn, n2.y * wn], a2 = [];
          if (!t2) return a2;
          for (const r3 of t2) {
            const t3 = [];
            for (const n3 of r3) {
              const r4 = [n3.x + s2[0], n3.y + s2[1]];
              dn(e2, r4), t3.push(r4);
            }
            a2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2) for (const n3 of t3) Bn(n3, e2, r2, i2);
          }
          var o2;
          return a2;
        }
        class Vn {
          constructor(t2, e2) {
            this.type = wr, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (Nr(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) for (let t3 = 0; t3 < e3.features.length; ++t3) {
                const r2 = e3.features[t3].geometry.type;
                if ("Polygon" === r2 || "MultiPolygon" === r2) return new Vn(e3, e3.features[t3].geometry);
              }
              else if ("Feature" === e3.type) {
                const t3 = e3.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3) return new Vn(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new Vn(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType()) return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2) return false;
                if ("Polygon" === e2.type) {
                  const s2 = Pn(e2.coordinates, n2, i2), a2 = kn(t3.geometry(), r2, n2, i2);
                  if (!fn(r2, n2)) return false;
                  for (const t4 of a2) if (!gn(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = zn(e2.coordinates, n2, i2), a2 = kn(t3.geometry(), r2, n2, i2);
                  if (!fn(r2, n2)) return false;
                  for (const t4 of a2) if (!An(t4, s2)) return false;
                }
                return true;
              }(t2, this.geometries);
              if ("LineString" === t2.geometryType()) return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2) return false;
                if ("Polygon" === e2.type) {
                  const s2 = Pn(e2.coordinates, n2, i2), a2 = Tn(t3.geometry(), r2, n2, i2);
                  if (!fn(r2, n2)) return false;
                  for (const t4 of a2) if (!In(t4, s2)) return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = zn(e2.coordinates, n2, i2), a2 = Tn(t3.geometry(), r2, n2, i2);
                  if (!fn(r2, n2)) return false;
                  for (const t4 of a2) if (!Sn(t4, s2)) return false;
                }
                return true;
              }(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        const En = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, Fn = 1 / 298.257223563, Dn = Fn * (2 - Fn), Cn = Math.PI / 180;
        class Rn {
          static fromTile(t2, e2, r2) {
            const n2 = Math.PI * (1 - 2 * (t2 + 0.5) / Math.pow(2, e2)), i2 = Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2))) / Cn;
            return new Rn(i2, r2);
          }
          static get units() {
            return En;
          }
          constructor(t2, e2) {
            if (void 0 === t2) throw new Error("No latitude given.");
            if (e2 && !En[e2]) throw new Error(`Unknown unit ${e2}. Use one of: ${Object.keys(En).join(", ")}`);
            const r2 = 6378.137 * Cn * (e2 ? En[e2] : 1), n2 = Math.cos(t2 * Cn), i2 = 1 / (1 - Dn * (1 - n2 * n2)), s2 = Math.sqrt(i2);
            this.kx = r2 * s2 * n2, this.ky = r2 * s2 * i2 * (1 - Dn);
          }
          distance(t2, e2) {
            const r2 = Un(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
            return Math.sqrt(r2 * r2 + n2 * n2);
          }
          bearing(t2, e2) {
            const r2 = Un(e2[0] - t2[0]) * this.kx;
            return Math.atan2(r2, (e2[1] - t2[1]) * this.ky) / Cn;
          }
          destination(t2, e2, r2) {
            const n2 = r2 * Cn;
            return this.offset(t2, Math.sin(n2) * e2, Math.cos(n2) * e2);
          }
          offset(t2, e2, r2) {
            return [t2[0] + e2 / this.kx, t2[1] + r2 / this.ky];
          }
          lineDistance(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += this.distance(t2[r2], t2[r2 + 1]);
            return e2;
          }
          area(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length; r2++) {
              const n2 = t2[r2];
              for (let t3 = 0, i2 = n2.length, s2 = i2 - 1; t3 < i2; s2 = t3++) e2 += Un(n2[t3][0] - n2[s2][0]) * (n2[t3][1] + n2[s2][1]) * (r2 ? -1 : 1);
            }
            return Math.abs(e2) / 2 * this.kx * this.ky;
          }
          along(t2, e2) {
            let r2 = 0;
            if (e2 <= 0) return t2[0];
            for (let n2 = 0; n2 < t2.length - 1; n2++) {
              const i2 = t2[n2], s2 = t2[n2 + 1], a2 = this.distance(i2, s2);
              if (r2 += a2, r2 > e2) return On(i2, s2, (e2 - (r2 - a2)) / a2);
            }
            return t2[t2.length - 1];
          }
          pointToSegmentDistance(t2, e2, r2) {
            let [n2, i2] = e2, s2 = Un(r2[0] - n2) * this.kx, a2 = (r2[1] - i2) * this.ky;
            if (0 !== s2 || 0 !== a2) {
              const e3 = (Un(t2[0] - n2) * this.kx * s2 + (t2[1] - i2) * this.ky * a2) / (s2 * s2 + a2 * a2);
              e3 > 1 ? (n2 = r2[0], i2 = r2[1]) : e3 > 0 && (n2 += s2 / this.kx * e3, i2 += a2 / this.ky * e3);
            }
            return s2 = Un(t2[0] - n2) * this.kx, a2 = (t2[1] - i2) * this.ky, Math.sqrt(s2 * s2 + a2 * a2);
          }
          pointOnLine(t2, e2) {
            let r2 = 1 / 0, n2 = t2[0][0], i2 = t2[0][1], s2 = 0, a2 = 0;
            for (let o2 = 0; o2 < t2.length - 1; o2++) {
              let l2 = t2[o2][0], u2 = t2[o2][1], c2 = Un(t2[o2 + 1][0] - l2) * this.kx, h2 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
              0 === c2 && 0 === h2 || (p2 = (Un(e2[0] - l2) * this.kx * c2 + (e2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = Un(e2[0] - l2) * this.kx, h2 = (e2[1] - u2) * this.ky;
              const d2 = c2 * c2 + h2 * h2;
              d2 < r2 && (r2 = d2, n2 = l2, i2 = u2, s2 = o2, a2 = p2);
            }
            return { point: [n2, i2], index: s2, t: Math.max(0, Math.min(1, a2)) };
          }
          lineSlice(t2, e2, r2) {
            let n2 = this.pointOnLine(r2, t2), i2 = this.pointOnLine(r2, e2);
            if (n2.index > i2.index || n2.index === i2.index && n2.t > i2.t) {
              const t3 = n2;
              n2 = i2, i2 = t3;
            }
            const s2 = [n2.point], a2 = n2.index + 1, o2 = i2.index;
            !Ln(r2[a2], s2[0]) && a2 <= o2 && s2.push(r2[a2]);
            for (let t3 = a2 + 1; t3 <= o2; t3++) s2.push(r2[t3]);
            return Ln(r2[o2], i2.point) || s2.push(i2.point), s2;
          }
          lineSliceAlong(t2, e2, r2) {
            let n2 = 0;
            const i2 = [];
            for (let s2 = 0; s2 < r2.length - 1; s2++) {
              const a2 = r2[s2], o2 = r2[s2 + 1], l2 = this.distance(a2, o2);
              if (n2 += l2, n2 > t2 && 0 === i2.length && i2.push(On(a2, o2, (t2 - (n2 - l2)) / l2)), n2 >= e2) return i2.push(On(a2, o2, (e2 - (n2 - l2)) / l2)), i2;
              n2 > t2 && i2.push(o2);
            }
            return i2;
          }
          bufferPoint(t2, e2) {
            const r2 = e2 / this.ky, n2 = e2 / this.kx;
            return [t2[0] - n2, t2[1] - r2, t2[0] + n2, t2[1] + r2];
          }
          bufferBBox(t2, e2) {
            const r2 = e2 / this.ky, n2 = e2 / this.kx;
            return [t2[0] - n2, t2[1] - r2, t2[2] + n2, t2[3] + r2];
          }
          insideBBox(t2, e2) {
            return Un(t2[0] - e2[0]) >= 0 && Un(t2[0] - e2[2]) <= 0 && t2[1] >= e2[1] && t2[1] <= e2[3];
          }
        }
        function Ln(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1];
        }
        function On(t2, e2, r2) {
          const n2 = Un(e2[0] - t2[0]);
          return [t2[0] + n2 * r2, t2[1] + (e2[1] - t2[1]) * r2];
        }
        function Un(t2) {
          for (; t2 < -180; ) t2 += 360;
          for (; t2 > 180; ) t2 -= 360;
          return t2;
        }
        class Nn {
          constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t2 = this.data[0], e2 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r2(n2, s2) >= 0) break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1);
              const s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
              e2[t2] = e2[n3], t2 = n3;
            }
            e2[t2] = i2;
          }
        }
        var jn = 8192;
        function Gn(t2, e2) {
          return e2.dist - t2.dist;
        }
        function $n(t2) {
          const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (e2.length !== t2.length) return false;
          for (let r2 = 0; r2 < e2.length; r2++) if (e2[r2] !== t2[r2]) return false;
          return true;
        }
        function qn(t2) {
          return t2[1] - t2[0] + 1;
        }
        function Xn(t2, e2) {
          const r2 = t2[1] >= t2[0] && t2[1] < e2;
          return r2 || console.warn("Distance Expression: Index is out of range"), r2;
        }
        function Hn(t2, e2) {
          if (t2[0] > t2[1]) return [null, null];
          const r2 = qn(t2);
          if (e2) {
            if (2 === r2) return [t2, null];
            const e3 = Math.floor(r2 / 2);
            return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
          }
          {
            if (1 === r2) return [t2, null];
            const e3 = Math.floor(r2 / 2) - 1;
            return [[t2[0], t2[0] + e3], [t2[0] + e3 + 1, t2[1]]];
          }
        }
        function Zn(t2, e2) {
          const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (!Xn(e2, t2.length)) return r2;
          for (let n2 = e2[0]; n2 <= e2[1]; ++n2) dn(r2, t2[n2]);
          return r2;
        }
        function Wn(t2) {
          const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let r2 = 0; r2 < t2.length; ++r2) for (let n2 = 0; n2 < t2[r2].length; ++n2) dn(e2, t2[r2][n2]);
          return e2;
        }
        function Yn(t2, e2, r2) {
          if ($n(t2) || $n(e2)) return NaN;
          let n2 = 0, i2 = 0;
          return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
        }
        function Jn(t2) {
          return 360 * t2 - 180;
        }
        function Kn(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        function Qn(t2, e2) {
          const r2 = Math.pow(2, e2.z), n2 = (t2.y / jn + e2.y) / r2;
          return [Jn((t2.x / jn + e2.x) / r2), Kn(n2)];
        }
        function ti(t2, e2) {
          const r2 = [];
          for (let n2 = 0; n2 < t2.length; ++n2) r2.push(Qn(t2[n2], e2));
          return r2;
        }
        function ei(t2, e2, r2) {
          const n2 = r2.pointOnLine(e2, t2).point;
          return r2.distance(t2, n2);
        }
        function ri(t2, e2, r2, n2, i2) {
          const s2 = r2.slice(n2[0], n2[1] + 1);
          let a2 = 1 / 0;
          for (let r3 = e2[0]; r3 <= e2[1]; ++r3) if (0 === (a2 = Math.min(a2, ei(t2[r3], s2, i2)))) return 0;
          return a2;
        }
        function ni(t2, e2, r2, n2, i2) {
          const s2 = Math.min(i2.pointToSegmentDistance(t2, r2, n2), i2.pointToSegmentDistance(e2, r2, n2)), a2 = Math.min(i2.pointToSegmentDistance(r2, t2, e2), i2.pointToSegmentDistance(n2, t2, e2));
          return Math.min(s2, a2);
        }
        function ii(t2, e2, r2, n2, i2) {
          if (!Xn(e2, t2.length) || !Xn(n2, r2.length)) return NaN;
          let s2 = 1 / 0;
          for (let a2 = e2[0]; a2 < e2[1]; ++a2) for (let e3 = n2[0]; e3 < n2[1]; ++e3) {
            if (vn(t2[a2], t2[a2 + 1], r2[e3], r2[e3 + 1])) return 0;
            s2 = Math.min(s2, ni(t2[a2], t2[a2 + 1], r2[e3], r2[e3 + 1], i2));
          }
          return s2;
        }
        function si(t2, e2, r2, n2, i2) {
          if (!Xn(e2, t2.length) || !Xn(n2, r2.length)) return NaN;
          let s2 = 1 / 0;
          for (let a2 = e2[0]; a2 <= e2[1]; ++a2) for (let e3 = n2[0]; e3 <= n2[1]; ++e3) if (0 === (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])))) return s2;
          return s2;
        }
        function ai(t2, e2, r2) {
          if (gn(t2, e2, true)) return 0;
          let n2 = 1 / 0;
          for (const i2 of e2) {
            const e3 = i2.length;
            if (e3 < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
            if (i2[0] !== i2[e3 - 1] && 0 === (n2 = Math.min(n2, r2.pointToSegmentDistance(t2, i2[e3 - 1], i2[0])))) return n2;
            if (0 === (n2 = Math.min(n2, ei(t2, i2, r2)))) return n2;
          }
          return n2;
        }
        function oi(t2, e2, r2, n2) {
          if (!Xn(e2, t2.length)) return NaN;
          for (let n3 = e2[0]; n3 <= e2[1]; ++n3) if (gn(t2[n3], r2, true)) return 0;
          let i2 = 1 / 0;
          for (let s2 = e2[0]; s2 < e2[1]; ++s2) for (const e3 of r2) for (let r3 = 0, a2 = e3.length, o2 = a2 - 1; r3 < a2; o2 = r3++) {
            if (vn(t2[s2], t2[s2 + 1], e3[o2], e3[r3])) return 0;
            i2 = Math.min(i2, ni(t2[s2], t2[s2 + 1], e3[o2], e3[r3], n2));
          }
          return i2;
        }
        function li(t2, e2) {
          for (const r2 of t2) for (let t3 = 0; t3 <= r2.length - 1; ++t3) if (gn(r2[t3], e2, true)) return true;
          return false;
        }
        function ui(t2, e2, r2, n2 = 1 / 0) {
          const i2 = Wn(t2), s2 = Wn(e2);
          if (n2 !== 1 / 0 && Yn(i2, s2, r2) >= n2) return n2;
          if (fn(i2, s2)) {
            if (li(t2, e2)) return 0;
          } else if (li(e2, t2)) return 0;
          let a2 = n2;
          for (const n3 of t2) for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++) for (const i4 of e2) for (let e3 = 0, o2 = i4.length, l2 = o2 - 1; e3 < o2; l2 = e3++) {
            if (vn(n3[s3], n3[t3], i4[l2], i4[e3])) return 0;
            a2 = Math.min(a2, ni(n3[s3], n3[t3], i4[l2], i4[e3], r2));
          }
          return a2;
        }
        function ci(t2, e2, r2, n2, i2, s2, a2) {
          if (null === s2 || null === a2) return;
          const o2 = Yn(Zn(n2, s2), Zn(i2, a2), r2);
          o2 < e2 && t2.push({ dist: o2, range1: s2, range2: a2 });
        }
        function hi(t2, e2, r2, n2, i2 = 1 / 0) {
          let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
          if (0 === s2) return s2;
          const a2 = new Nn([{ dist: 0, range1: [0, t2.length - 1], range2: [0, 0] }], Gn), o2 = e2 ? 50 : 100, l2 = Wn(r2);
          for (; a2.length; ) {
            const i3 = a2.pop();
            if (i3.dist >= s2) continue;
            const u2 = i3.range1;
            if (qn(u2) <= o2) {
              if (!Xn(u2, t2.length)) return NaN;
              if (e2) {
                const e3 = oi(t2, u2, r2, n2);
                if (0 === (s2 = Math.min(s2, e3))) return s2;
              } else for (let e3 = u2[0]; e3 <= u2[1]; ++e3) {
                const i4 = ai(t2[e3], r2, n2);
                if (0 === (s2 = Math.min(s2, i4))) return s2;
              }
            } else {
              const r3 = Hn(u2, e2);
              if (null !== r3[0]) {
                const e3 = Yn(Zn(t2, r3[0]), l2, n2);
                e3 < s2 && a2.push({ dist: e3, range1: r3[0], range2: [0, 0] });
              }
              if (null !== r3[1]) {
                const e3 = Yn(Zn(t2, r3[1]), l2, n2);
                e3 < s2 && a2.push({ dist: e3, range1: r3[1], range2: [0, 0] });
              }
            }
          }
          return s2;
        }
        function pi(t2, e2, r2, n2, i2, s2 = 1 / 0) {
          let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
          if (0 === a2) return a2;
          const o2 = new Nn([{ dist: 0, range1: [0, t2.length - 1], range2: [0, r2.length - 1] }], Gn), l2 = e2 ? 50 : 100, u2 = n2 ? 50 : 100;
          for (; o2.length; ) {
            const s3 = o2.pop();
            if (s3.dist >= a2) continue;
            const c2 = s3.range1, h2 = s3.range2;
            if (qn(c2) <= l2 && qn(h2) <= u2) {
              if (!Xn(c2, t2.length) || !Xn(h2, r2.length)) return NaN;
              if (e2 && n2 ? a2 = Math.min(a2, ii(t2, c2, r2, h2, i2)) : e2 || n2 ? e2 && !n2 ? a2 = Math.min(a2, ri(r2, h2, t2, c2, i2)) : !e2 && n2 && (a2 = Math.min(a2, ri(t2, c2, r2, h2, i2))) : a2 = Math.min(a2, si(t2, c2, r2, h2, i2)), 0 === a2) return a2;
            } else {
              const s4 = Hn(c2, e2), l3 = Hn(h2, n2);
              ci(o2, a2, i2, t2, r2, s4[0], l3[0]), ci(o2, a2, i2, t2, r2, s4[0], l3[1]), ci(o2, a2, i2, t2, r2, s4[1], l3[0]), ci(o2, a2, i2, t2, r2, s4[1], l3[1]);
            }
          }
          return a2;
        }
        function di(t2, e2, r2, n2, i2 = 1 / 0) {
          let s2 = i2;
          const a2 = Zn(t2, [0, t2.length - 1]);
          for (const i3 of r2) if (!(s2 !== 1 / 0 && Yn(a2, Zn(i3, [0, i3.length - 1]), n2) >= s2) && (s2 = Math.min(s2, pi(t2, e2, i3, true, n2, s2)), 0 === s2)) return s2;
          return s2;
        }
        function fi(t2, e2, r2, n2, i2 = 1 / 0) {
          let s2 = i2;
          const a2 = Zn(t2, [0, t2.length - 1]);
          for (const i3 of r2) {
            if (s2 !== 1 / 0 && Yn(a2, Wn(i3), n2) >= s2) continue;
            const r3 = hi(t2, e2, i3, n2, s2);
            if (isNaN(r3)) return r3;
            if (0 === (s2 = Math.min(s2, r3))) return s2;
          }
          return s2;
        }
        function mi(t2) {
          return "Point" === t2 || "MultiPoint" === t2 || "LineString" === t2 || "MultiLineString" === t2 || "Polygon" === t2 || "MultiPolygon" === t2;
        }
        class yi {
          constructor(t2, e2) {
            this.type = vr, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`'distance' expression requires either one argument, but found ' ${t2.length - 1} instead.`);
            if (Nr(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) {
                for (let t3 = 0; t3 < e3.features.length; ++t3) if (mi(e3.features[t3].geometry.type)) return new yi(e3, e3.features[t3].geometry);
              } else if ("Feature" === e3.type) {
                if (mi(e3.geometry.type)) return new yi(e3, e3.geometry);
              } else if (mi(e3.type)) return new yi(e3, e3);
            }
            return e2.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
          }
          evaluate(t2) {
            const e2 = t2.geometry(), r2 = t2.canonicalID();
            if (null != e2 && null != r2) {
              if ("Point" === t2.geometryType()) return function(t3, e3, r3) {
                const n2 = [];
                for (const r4 of t3) for (const t4 of r4) n2.push(Qn(t4, e3));
                const i2 = new Rn(n2[0][1], "meters");
                return "Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type ? pi(n2, false, "Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, i2) : "MultiLineString" === r3.type ? di(n2, false, r3.coordinates, i2) : "Polygon" === r3.type || "MultiPolygon" === r3.type ? fi(n2, false, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2) : null;
              }(e2, r2, this.geometries);
              if ("LineString" === t2.geometryType()) return function(t3, e3, r3) {
                const n2 = [];
                for (const r4 of t3) {
                  const t4 = [];
                  for (const n3 of r4) t4.push(Qn(n3, e3));
                  n2.push(t4);
                }
                const i2 = new Rn(n2[0][0][1], "meters");
                if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type) return di("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                if ("MultiLineString" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                    const s2 = di(r3.coordinates[e4], true, n2, i2, t4);
                    if (isNaN(s2)) return s2;
                    if (0 === (t4 = Math.min(t4, s2))) return t4;
                  }
                  return t4;
                }
                if ("Polygon" === r3.type || "MultiPolygon" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < n2.length; e4++) {
                    const s2 = fi(n2[e4], true, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2, t4);
                    if (isNaN(s2)) return s2;
                    if (0 === (t4 = Math.min(t4, s2))) return t4;
                  }
                  return t4;
                }
                return null;
              }(e2, r2, this.geometries);
              if ("Polygon" === t2.geometryType()) return function(t3, e3, r3) {
                const n2 = [];
                for (const r4 of function(t4) {
                  const e4 = t4.length;
                  if (e4 <= 1) return [t4];
                  const r5 = [];
                  let n3, i3;
                  for (let s2 = 0; s2 < e4; s2++) {
                    const e5 = pn(t4[s2]);
                    0 !== e5 && (t4[s2].area = Math.abs(e5), void 0 === i3 && (i3 = e5 < 0), i3 === e5 < 0 ? (n3 && r5.push(n3), n3 = [t4[s2]]) : n3.push(t4[s2]));
                  }
                  return n3 && r5.push(n3), r5;
                }(t3)) {
                  const t4 = [];
                  for (let n3 = 0; n3 < r4.length; ++n3) t4.push(ti(r4[n3], e3));
                  n2.push(t4);
                }
                const i2 = new Rn(n2[0][0][0][1], "meters");
                if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type) return fi("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                if ("MultiLineString" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                    const s2 = fi(r3.coordinates[e4], true, n2, i2, t4);
                    if (isNaN(s2)) return s2;
                    if (0 === (t4 = Math.min(t4, s2))) return t4;
                  }
                  return t4;
                }
                return "Polygon" === r3.type || "MultiPolygon" === r3.type ? function(t4, e4, r4) {
                  let n3 = 1 / 0;
                  for (const i3 of t4) for (const t5 of e4) {
                    const e5 = ui(i3, t5, r4, n3);
                    if (isNaN(e5)) return e5;
                    if (0 === (n3 = Math.min(n3, e5))) return n3;
                  }
                  return n3;
                }("Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, n2, i2) : null;
              }(e2, r2, this.geometries);
              console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
            } else console.warn("Distance Expression: requirs valid feature and canonical information.");
            return null;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["distance", this.geojson];
          }
        }
        function gi(t2) {
          if (t2 instanceof an) {
            if ("get" === t2.name && 1 === t2.args.length) return false;
            if ("feature-state" === t2.name) return false;
            if ("has" === t2.name && 1 === t2.args.length) return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name) return false;
            if (/^filter-/.test(t2.name)) return false;
          }
          if (t2 instanceof Vn) return false;
          if (t2 instanceof yi) return false;
          if (t2 instanceof Ai) return t2.featureConstant;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !gi(t3) && (e2 = false);
          }), e2;
        }
        function xi(t2) {
          if (t2 instanceof an && "feature-state" === t2.name) return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !xi(t3) && (e2 = false);
          }), e2;
        }
        function vi(t2, e2) {
          if (t2 instanceof an && e2.indexOf(t2.name) >= 0) return false;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 && !vi(t3, e2) && (r2 = false);
          }), r2;
        }
        function bi(t2, e2, r2) {
          return [t2, e2, r2].filter(Boolean).join("");
        }
        function wi(t2, e2) {
          switch (t2) {
            case "string":
              return Gr(e2);
            case "number":
              return +e2;
            case "boolean":
              return !!e2;
            case "color":
              return ur.parse(e2);
            case "formatted":
              return Rr.fromString(Gr(e2));
            case "resolvedImage":
              return Or.build(Gr(e2));
          }
          return e2;
        }
        function _i(t2, e2, r2, n2) {
          return void 0 !== n2 && (t2 = n2 * Math.round(t2 / n2)), void 0 !== e2 && t2 < e2 && (t2 = e2), void 0 !== r2 && t2 > r2 && (t2 = r2), t2;
        }
        class Ai {
          constructor(t2, e2, r2, n2 = false) {
            this.type = t2, this.key = e2, this.scope = r2, this.featureConstant = n2;
          }
          static parse(t2, e2) {
            let r2 = e2.expectedType;
            if (null == r2 && (r2 = Mr), t2.length < 2 || t2.length > 3) return e2.error("Invalid number of arguments for 'config' expression.");
            const n2 = e2.parse(t2[1], 1);
            if (!(n2 instanceof $r)) return e2.error("Key name of 'config' expression must be a string literal.");
            let i2, s2 = true;
            const a2 = Gr(n2.value);
            if (t2.length >= 3) {
              const r3 = e2.parse(t2[2], 2);
              if (!(r3 instanceof $r)) return e2.error("Scope of 'config' expression must be a string literal.");
              i2 = Gr(r3.value);
            }
            if (e2.options) {
              const t3 = bi(a2, i2, e2._scope), r3 = e2.options.get(t3);
              r3 && (s2 = gi(r3.value || r3.default));
            }
            return new Ai(r2, a2, i2, s2);
          }
          evaluate(t2) {
            const e2 = bi(this.key, this.scope, t2.scope), r2 = t2.getConfig(e2);
            if (!r2) return null;
            const { type: n2, value: i2, values: s2, minValue: a2, maxValue: o2, stepValue: l2 } = r2, u2 = r2.default.evaluate(t2);
            let c2 = u2;
            if (i2) {
              const e3 = t2.scope;
              t2.scope = (e3 || "").split("").slice(1).join(""), c2 = i2.evaluate(t2), t2.scope = e3;
            }
            return n2 && (c2 = wi(n2, c2)), void 0 === c2 || void 0 === a2 && void 0 === o2 && void 0 === l2 || ("number" == typeof c2 ? c2 = _i(c2, a2, o2, l2) : Array.isArray(c2) && (c2 = c2.map((t3) => "number" == typeof t3 ? _i(t3, a2, o2, l2) : t3))), void 0 !== i2 && void 0 !== c2 && s2 && !s2.includes(c2) && (c2 = u2, n2 && (c2 = wi(n2, c2))), (n2 && n2 !== this.type || void 0 !== c2 && !Fr(jr(c2), this.type)) && (c2 = wi(this.type.kind, c2)), c2;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["config", this.key];
            return this.scope && t2.concat(this.scope), t2;
          }
        }
        class Mi {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1]) return e2.error("'var' expression requires exactly one string literal argument.");
            const r2 = t2[1];
            return e2.scope.has(r2) ? new Mi(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class Ii {
          constructor(t2, e2 = [], r2, n2 = new gr(), i2 = [], s2, a2, o2) {
            this.registry = t2, this.path = e2, this.key = e2.map((t3) => "string" == typeof t3 ? `['${t3}']` : `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2, this._scope = s2, this.options = a2, this.iconImageUseTheme = o2;
          }
          parse(t2, e2, r2, n2, i2 = {}) {
            return e2 || r2 ? this.concat(e2, null, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          parseObjectValue(t2, e2, r2, n2, i2, s2 = {}) {
            return this.concat(e2, r2, n2, i2)._parse(t2, s2);
          }
          _parse(t2, e2) {
            function r2(t3, e3, r3) {
              return "assert" === r3 ? new Hr(e3, [t3]) : "coerce" === r3 ? new rn(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = "string" == typeof t2[0] ? this.registry[t2[0]] : void 0;
              if (n2) {
                let i2 = n2.parse(t2, this);
                if (!i2) return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, n3 = i2.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== n3.kind) if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                    if (this.checkSubtype(t3, n3)) return null;
                  } else i2 = r2(i2, t3, e2.typeAnnotation || "coerce");
                  else i2 = r2(i2, t3, e2.typeAnnotation || "assert");
                }
                if (!(i2 instanceof $r) && "resolvedImage" !== i2.type.kind && Si(i2)) {
                  const t3 = new sn(this._scope, this.options, this.iconImageUseTheme);
                  try {
                    i2 = new $r(i2.type, i2.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return i2;
              }
              return rn.parse(["to-array", t2], this);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e2, r2, n2) {
            let i2 = "number" == typeof t2 ? this.path.concat(t2) : this.path;
            i2 = "string" == typeof e2 ? i2.concat(e2) : i2;
            const s2 = n2 ? this.scope.concat(n2) : this.scope;
            return new Ii(this.registry, i2, r2 || null, s2, this.errors, this._scope, this.options, this.iconImageUseTheme);
          }
          error(t2, ...e2) {
            const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
            this.errors.push(new yr(r2, t2));
          }
          checkSubtype(t2, e2) {
            const r2 = Tr(t2, e2);
            return r2 && this.error(r2), r2;
          }
        }
        function Si(t2) {
          if (t2 instanceof Mi) return Si(t2.boundExpression);
          if (t2 instanceof an && "error" === t2.name) return false;
          if (t2 instanceof ln) return false;
          if (t2 instanceof Vn) return false;
          if (t2 instanceof yi) return false;
          if (t2 instanceof Ai) return false;
          const e2 = t2 instanceof rn || t2 instanceof Hr;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 = e2 ? r2 && Si(t3) : r2 && t3 instanceof $r;
          }), !!r2 && gi(t2) && vi(t2, ["zoom", "heatmap-density", "worldview", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
        }
        function Pi(t2, e2) {
          const r2 = t2.length - 1;
          let n2, i2, s2 = 0, a2 = r2, o2 = 0;
          for (; s2 <= a2; ) if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2) return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2)) throw new qr("Input is not a number.");
            a2 = o2 - 1;
          }
          return 0;
        }
        class zi {
          constructor(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of r2) this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            const r2 = e2.parse(t2[1], 1, vr);
            if (!r2) return null;
            const n2 = [];
            let i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
              if ("number" != typeof s2) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s2) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e2.parse(a2, l2, i2);
              if (!u2) return null;
              i2 = i2 || u2.type, n2.push([s2, u2]);
            }
            return new zi(i2, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length) return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r2[0].evaluate(t2);
            const i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Pi(e2, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["step", this.input.serialize()];
            for (let e2 = 0; e2 < this.labels.length; e2++) e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
            return t2;
          }
        }
        const Bi = 0.95047, ki = 1.08883, Ti = 4 / 29, Vi = 6 / 29, Ei = 3 * Vi * Vi, Fi = Vi * Vi * Vi, Di = Math.PI / 180, Ci = 180 / Math.PI;
        function Ri(t2) {
          return t2 > Fi ? Math.pow(t2, 1 / 3) : t2 / Ei + Ti;
        }
        function Li(t2) {
          return t2 > Vi ? t2 * t2 * t2 : Ei * (t2 - Ti);
        }
        function Oi(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function Ui(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function Ni(t2) {
          const e2 = Ui(t2.r), r2 = Ui(t2.g), n2 = Ui(t2.b), i2 = Ri((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / Bi), s2 = Ri((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
          return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Ri((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / ki)), alpha: t2.a };
        }
        function ji(t2) {
          let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
          return e2 = 1 * Li(e2), r2 = Bi * Li(r2), n2 = ki * Li(n2), new ur(Oi(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Oi(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Oi(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
        }
        function Gi(t2, e2, r2) {
          const n2 = e2 - t2;
          return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        const $i = { forward: Ni, reverse: ji, interpolate: function(t2, e2, r2) {
          return { l: dr(t2.l, e2.l, r2), a: dr(t2.a, e2.a, r2), b: dr(t2.b, e2.b, r2), alpha: dr(t2.alpha, e2.alpha, r2) };
        } }, qi = { forward: function(t2) {
          const { l: e2, a: r2, b: n2 } = Ni(t2), i2 = Math.atan2(n2, r2) * Ci;
          return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
        }, reverse: function(t2) {
          const e2 = t2.h * Di, r2 = t2.c;
          return ji({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
        }, interpolate: function(t2, e2, r2) {
          return { h: Gi(t2.h, e2.h, r2), c: dr(t2.c, e2.c, r2), l: dr(t2.l, e2.l, r2), alpha: dr(t2.alpha, e2.alpha, r2) };
        } };
        var Xi = Object.freeze({ __proto__: null, hcl: qi, lab: $i });
        class Hi {
          constructor(t2, e2, r2, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of i2) this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, e2, r2, n2) {
            let i2 = 0;
            if ("exponential" === t2.name) i2 = Zi(e2, t2.base, r2, n2);
            else if ("linear" === t2.name) i2 = Zi(e2, 1, r2, n2);
            else if ("cubic-bezier" === t2.name) {
              const s2 = t2.controlPoints;
              i2 = new Mt(s2[0], s2[1], s2[2], s2[3]).solve(Zi(e2, 1, r2, n2));
            }
            return i2;
          }
          static parse(t2, e2) {
            let [r2, n2, i2, ...s2] = t2;
            if (!Array.isArray(n2) || 0 === n2.length) return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0]) n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t3 = n2[1];
              if ("number" != typeof t3) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n2[0]) return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t3 = n2.slice(1);
                if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length - 1 > 3 && (t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, vr), !i2) return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = _r : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
            for (let t3 = 0; t3 < s2.length; t3 += 2) {
              const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
              if ("number" != typeof r3) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r3) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u2 = e2.parse(n3, l2, o2);
              if (!u2) return null;
              o2 = o2 || u2.type, a2.push([r3, u2]);
            }
            return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new Hi(o2, r2, n2, i2, a2) : e2.error(`Type ${Br(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length) return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0]) return r2[0].evaluate(t2);
            const i2 = e2.length;
            if (n2 >= e2[i2 - 1]) return r2[i2 - 1].evaluate(t2);
            const s2 = Pi(e2, n2), a2 = Hi.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
            return "interpolate" === this.operator ? mr[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? qi.reverse(qi.interpolate(qi.forward(o2), qi.forward(l2), a2)) : $i.reverse($i.interpolate($i.forward(o2), $i.forward(l2), a2));
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs) t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            let t2;
            t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier", ...this.interpolation.controlPoints];
            const e2 = [this.operator, t2, this.input.serialize()];
            for (let t3 = 0; t3 < this.labels.length; t3++) e2.push(this.labels[t3], this.outputs[t3].serialize());
            return e2;
          }
        }
        function Zi(t2, e2, r2, n2) {
          const i2 = n2 - r2, s2 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
        }
        class Wi {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2) return e2.error("Expectected at least one argument.");
            let r2 = null;
            const n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            const i2 = [];
            for (const n3 of t2.slice(1)) {
              const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3) return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            const s2 = n2 && i2.some((t3) => Tr(n2, t3.type));
            return new Wi(s2 ? Mr : r2, i2);
          }
          evaluate(t2) {
            let e2, r2 = null, n2 = 0;
            for (const i2 of this.args) {
              if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Or && !r2.available && (e2 || (e2 = r2), r2 = null, n2 === this.args.length)) return e2;
              if (null !== r2) break;
            }
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["coalesce"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        class Yi {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e2 of this.bindings) t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              const i2 = t2[n3];
              if ("string" != typeof i2) return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i2)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s2 = e2.parse(t2[n3 + 1], n3 + 1);
              if (!s2) return null;
              r2.push([i2, s2]);
            }
            const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return n2 ? new Yi(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t2 = ["let"];
            for (const [e2, r2] of this.bindings) t2.push(e2, r2.serialize());
            return t2.push(this.result.serialize()), t2;
          }
        }
        class Ji {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, vr), n2 = e2.parse(t2[2], 2, zr(e2.expectedType || Mr));
            return r2 && n2 ? new Ji(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0) throw new qr("Array index out of bounds: negative index");
            if (e2 >= r2.length) throw new qr("Array index out of bounds: index exceeds array size");
            if (e2 !== Math.floor(e2)) throw new qr("Array index must be an integer. Use at-interpolated for fractional indices");
            return r2[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class Ki {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, vr), n2 = e2.parse(t2[2], 2, zr(e2.expectedType || Mr));
            return r2 && n2 ? new Ki(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0) throw new qr(`Array index out of bounds: ${e2} < 0.`);
            if (e2 > r2.length - 1) throw new qr(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
            if (e2 === Math.floor(e2)) return r2[e2];
            const n2 = Math.floor(e2), i2 = Math.ceil(e2), s2 = r2[n2], a2 = r2[i2];
            if ("number" != typeof s2 || "number" != typeof a2) throw new qr(`Cannot interpolate between non-number values at index ${e2}.`);
            const o2 = e2 - n2;
            return s2 * (1 - o2) + a2 * o2;
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at-interpolated", this.index.serialize(), this.input.serialize()];
          }
        }
        class Qi {
          constructor(t2, e2) {
            this.type = wr, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Mr), n2 = e2.parse(t2[2], 2, Mr);
            return r2 && n2 ? Vr(r2.type, [wr, br, vr, xr, Mr]) ? new Qi(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Br(r2.type)} instead`) : null;
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (null == r2) return false;
            if (!Er(e2, ["boolean", "string", "number", "null"])) throw new qr(`Expected first argument to be of type boolean, string, number or null, but found ${Br(jr(e2))} instead.`);
            if (!Er(r2, ["string", "array"])) throw new qr(`Expected second argument to be of type array or string, but found ${Br(jr(r2))} instead.`);
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class ts {
          constructor(t2, e2, r2) {
            this.type = vr, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Mr), n2 = e2.parse(t2[2], 2, Mr);
            if (!r2 || !n2) return null;
            if (!Vr(r2.type, [wr, br, vr, xr, Mr])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Br(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, vr);
              return i2 ? new ts(r2, n2, i2) : null;
            }
            return new ts(r2, n2);
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!Er(e2, ["boolean", "string", "number", "null"])) throw new qr(`Expected first argument to be of type boolean, string, number or null, but found ${Br(jr(e2))} instead.`);
            if (!Er(r2, ["string", "array"])) throw new qr(`Expected second argument to be of type array or string, but found ${Br(jr(r2))} instead.`);
            if (this.fromIndex) {
              const n2 = this.fromIndex.evaluate(t2);
              return r2.indexOf(e2, n2);
            }
            return r2.indexOf(e2);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t2 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class es {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
          }
          static parse(t2, e2) {
            if (t2.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1) return e2.error("Expected an even number of arguments.");
            let r2, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            const i2 = {}, s2 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l2 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e2.concat(a3);
              if (0 === o3.length) return u2.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3) return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t3 && Math.floor(t3) !== t3) return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, jr(t3))) return null;
                } else r2 = jr(t3);
                if (void 0 !== i2[String(t3)]) return u2.error("Branch labels must be unique.");
                i2[String(t3)] = s2.length;
              }
              const c2 = e2.parse(l2, a3, n2);
              if (!c2) return null;
              n2 = n2 || c2.type, s2.push(c2);
            }
            const a2 = e2.parse(t2[1], 1, Mr);
            if (!a2) return null;
            const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new es(r2, n2, a2, i2, s2, o2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            return (Fr(jr(e2), this.inputType) && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
            for (const t3 of e2) {
              const e3 = n2[this.cases[t3]];
              void 0 === e3 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
            }
            const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
            for (const [e3, n3] of r2) t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
            return t2.push(this.otherwise.serialize()), t2;
          }
        }
        class rs {
          constructor(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          }
          static parse(t2, e2) {
            if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            const n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s2 = e2.parse(t2[i3], i3, wr);
              if (!s2) return null;
              const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
              if (!a2) return null;
              n2.push([s2, a2]), r2 = r2 || a2.type;
            }
            const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            return i2 ? new rs(r2, n2, i2) : null;
          }
          evaluate(t2) {
            for (const [e2, r2] of this.branches) if (e2.evaluate(t2)) return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e2, r2] of this.branches) t2(e2), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["case"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        class ns {
          constructor(t2, e2, r2, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, Mr), n2 = e2.parse(t2[2], 2, vr);
            if (!r2 || !n2) return null;
            if (!Vr(r2.type, [zr(Mr), br, Mr])) return e2.error(`Expected first argument to be of type array or string, but found ${Br(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, vr);
              return i2 ? new ns(r2.type, r2, n2, i2) : null;
            }
            return new ns(r2.type, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            if (!Er(e2, ["string", "array"])) throw new qr(`Expected first argument to be of type array or string, but found ${Br(jr(e2))} instead.`);
            if (this.endIndex) {
              const n2 = this.endIndex.evaluate(t2);
              return e2.slice(r2, n2);
            }
            return e2.slice(r2);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t2 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        class is {
          constructor(t2, e2) {
            this.type = zr(br), this.str = t2, this.delimiter = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, br), n2 = e2.parse(t2[2], 2, br);
            return r2 && n2 ? new is(r2, n2) : void 0;
          }
          evaluate(t2) {
            const e2 = this.str.evaluate(t2), r2 = this.delimiter.evaluate(t2);
            return e2.split(r2);
          }
          eachChild(t2) {
            t2(this.str), t2(this.delimiter);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["split", this.str.serialize(), this.delimiter.serialize()];
          }
        }
        function ss(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function as(t2, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function os(t2, e2, r2) {
          const n2 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e3, r3) {
              this.type = wr, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            static parse(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
              const r3 = t3[0];
              let s2 = e3.parse(t3[1], 1, Mr);
              if (!s2) return null;
              if (!ss(r3, s2.type)) return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Br(s2.type)}'.`);
              let a2 = e3.parse(t3[2], 2, Mr);
              if (!a2) return null;
              if (!ss(r3, a2.type)) return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Br(a2.type)}'.`);
              if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error(`Cannot compare types '${Br(s2.type)}' and '${Br(a2.type)}'.`);
              n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new Hr(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new Hr(s2.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, Ir), !o2) return null;
              }
              return new i2(s2, a2, o2);
            }
            evaluate(i3) {
              const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                const e3 = jr(s2), r3 = jr(a2);
                if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind) throw new qr(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t3 = jr(s2), r3 = jr(a2);
                if ("string" !== t3.kind || "string" !== r3.kind) return e2(i3, s2, a2);
              }
              return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e3 = [t2];
              return this.eachChild((t3) => {
                e3.push(t3.serialize());
              }), e3;
            }
          };
        }
        const ls = os("==", function(t2, e2, r2) {
          return e2 === r2;
        }, as), us = os("!=", function(t2, e2, r2) {
          return e2 !== r2;
        }, function(t2, e2, r2, n2) {
          return !as(0, e2, r2, n2);
        }), cs = os("<", function(t2, e2, r2) {
          return e2 < r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), hs = os(">", function(t2, e2, r2) {
          return e2 > r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), ps = os("<=", function(t2, e2, r2) {
          return e2 <= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), ds = os(">=", function(t2, e2, r2) {
          return e2 >= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        });
        class fs {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.type = br, this.number = t2, this.locale = e2, this.currency = r2, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length) return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, vr);
            if (!r2) return null;
            const n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2)) return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e2.parseObjectValue(n2.locale, 2, "locale", br), !i2)) return null;
            let s2 = null;
            if (n2.currency && (s2 = e2.parseObjectValue(n2.currency, 2, "currency", br), !s2)) return null;
            let a2 = null;
            if (n2.unit && (a2 = e2.parseObjectValue(n2.unit, 2, "unit", br), !a2)) return null;
            let o2 = null;
            if (n2["min-fraction-digits"] && (o2 = e2.parseObjectValue(n2["min-fraction-digits"], 2, "min-fraction-digits", vr), !o2)) return null;
            let l2 = null;
            return n2["max-fraction-digits"] && (l2 = e2.parseObjectValue(n2["max-fraction-digits"], 2, "max-fraction-digits", vr), !l2) ? null : new fs(r2, i2, s2, a2, o2, l2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
          }
        }
        class ms {
          constructor(t2) {
            this.type = vr, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${Br(r2.type)} instead.`) : new ms(r2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            if ("string" == typeof e2) return e2.length;
            if (Array.isArray(e2)) return e2.length;
            throw new qr(`Expected value to be of type string or array, but found ${Br(jr(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["length"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        function ys(t2) {
          return function() {
            t2 = 1831565813 + (t2 |= 0) | 0;
            let e2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2);
            return e2 = e2 + Math.imul(e2 ^ e2 >>> 7, 61 | e2) ^ e2, ((e2 ^ e2 >>> 14) >>> 0) / 4294967296;
          };
        }
        const gs = { "==": ls, "!=": us, ">": hs, "<": cs, ">=": ds, "<=": ps, array: Hr, at: Ji, "at-interpolated": Ki, boolean: Hr, case: rs, coalesce: Wi, collator: ln, format: Zr, image: Wr, in: Qi, "index-of": ts, interpolate: Hi, "interpolate-hcl": Hi, "interpolate-lab": Hi, length: ms, let: Yi, literal: $r, match: es, number: Hr, "number-format": fs, object: Hr, slice: ns, step: zi, string: Hr, "to-boolean": rn, "to-color": rn, "to-number": rn, "to-string": rn, var: Mi, within: Vn, distance: yi, config: Ai, split: is };
        function xs(t2, [e2, r2, n2, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Ur(e2, r2, n2, s2);
          if (a2) throw new qr(a2);
          return new ur(e2 / 255, r2 / 255, n2 / 255, s2);
        }
        function vs(t2, [e2, r2, n2, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = function(t3, e3, r3, n3) {
            return "number" == typeof t3 && t3 >= 0 && t3 <= 360 ? "number" == typeof e3 && e3 >= 0 && e3 <= 100 && "number" == typeof r3 && r3 >= 0 && r3 <= 100 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid hsla value [${[t3, e3, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 'h' must be between 0 and 360.`;
          }(e2, r2, n2, s2);
          if (a2) throw new qr(a2);
          const o2 = `hsla(${e2}, ${r2}%, ${n2}%, ${s2})`, l2 = ur.parse(o2);
          if (!l2) throw new qr(`Failed to parse HSLA color: ${o2}`);
          return l2;
        }
        function bs(t2, e2) {
          return t2 in e2;
        }
        function ws(t2, e2) {
          const r2 = e2[t2];
          return void 0 === r2 ? null : r2;
        }
        function _s(t2) {
          return { type: t2 };
        }
        function As(t2) {
          if (t2 instanceof Ai) return /* @__PURE__ */ new Set([t2.key]);
          let e2 = /* @__PURE__ */ new Set();
          return t2.eachChild((t3) => {
            e2 = /* @__PURE__ */ new Set([...e2, ...As(t3)]);
          }), e2;
        }
        function Ms(t2) {
          if (t2 instanceof an && "is-active-floor" === t2.name) return true;
          let e2 = false;
          return t2.eachChild((t3) => {
            !e2 && Ms(t3) && (e2 = true);
          }), e2;
        }
        function Is(t2) {
          return { result: "success", value: t2 };
        }
        function Ss(t2) {
          return { result: "error", value: t2 };
        }
        function Ps(t2, e2) {
          return !!t2 && !!t2.parameters && t2.parameters.indexOf(e2) > -1;
        }
        function zs(t2) {
          return "data-driven" === t2["property-type"];
        }
        function Bs(t2) {
          return Ps(t2.expression, "measure-light");
        }
        function ks(t2) {
          return Ps(t2.expression, "zoom");
        }
        function Ts(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function Vs(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function Es(t2) {
          return t2;
        }
        function Fs(t2, e2) {
          const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Ts(e2) ? "exponential" : "interval");
          if (r2 && ((t2 = Object.assign({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], ur.parse(t3[1])])), t2.default = ur.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !Xi[t2.colorSpace]) throw new Error(`Unknown color space: ${t2.colorSpace}`);
          let a2, o2, l2;
          if ("exponential" === s2) a2 = Ls;
          else if ("interval" === s2) a2 = Rs;
          else if ("categorical" === s2) {
            a2 = Cs, o2 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t2.stops) o2[e3[0]] = e3[1];
            l2 = typeof t2.stops[0][0];
          } else {
            if ("identity" !== s2) throw new Error(`Unknown function type "${s2}"`);
            a2 = Os;
          }
          if (n2) {
            const r3 = {}, n3 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              const i4 = t2.stops[e3], s4 = i4[0].zoom;
              void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n3) i3.push([r3[t3].zoom, Fs(r3[t3], e2)]);
            const s3 = { name: "linear" };
            return { kind: "composite", interpolationType: s3, interpolationFactor: Hi.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Ls({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
          }
          if (i2) {
            const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Hi.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return void 0 === i3 ? Ds(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
          } };
        }
        function Ds(t2, e2, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function Cs(t2, e2, r2, n2, i2) {
          return Ds(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
        }
        function Rs(t2, e2, r2) {
          if (!Qr(r2)) return Ds(t2.default, e2.default);
          const n2 = t2.stops.length;
          if (1 === n2) return t2.stops[0][1];
          if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0]) return t2.stops[n2 - 1][1];
          const i2 = Pi(t2.stops.map((t3) => t3[0]), r2);
          return t2.stops[i2][1];
        }
        function Ls(t2, e2, r2) {
          const n2 = void 0 !== t2.base ? t2.base : 1;
          if (!Qr(r2)) return Ds(t2.default, e2.default);
          const i2 = t2.stops.length;
          if (1 === i2) return t2.stops[0][1];
          if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0]) return t2.stops[i2 - 1][1];
          const s2 = Pi(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
            const i3 = n3 - r3, s3 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
          }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
          let u2 = mr[e2.type] || Es;
          if (t2.colorSpace && "rgb" !== t2.colorSpace) {
            const e3 = Xi[t2.colorSpace];
            u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
          }
          return "function" == typeof o2.evaluate ? { evaluate(...t3) {
            const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
            if (void 0 !== e3 && void 0 !== r3) return u2(e3, r3, a2);
          } } : u2(o2, l2, a2);
        }
        function Os(t2, e2, r2) {
          return "color" === e2.type ? r2 = ur.parse(r2) : "formatted" === e2.type ? r2 = Rr.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = Or.build(r2.toString()) : Yr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), Ds(r2, t2.default, e2.default);
        }
        an.register(gs, { error: [{ kind: "error" }, [br], (t2, [e2]) => {
          throw new qr(e2.evaluate(t2));
        }], typeof: [br, [Mr], (t2, [e2]) => Br(jr(e2.evaluate(t2)))], "to-rgba": [zr(vr, 4), [_r], (t2, [e2]) => e2.evaluate(t2).toNonPremultipliedRenderColor(null).toArray()], "to-hsla": [zr(vr, 4), [_r], (t2, [e2]) => e2.evaluate(t2).toNonPremultipliedRenderColor(null).toHslaArray()], rgb: [_r, [vr, vr, vr], xs], rgba: [_r, [vr, vr, vr, vr], xs], hsl: [_r, [vr, vr, vr], vs], hsla: [_r, [vr, vr, vr, vr], vs], has: { type: wr, overloads: [[[br], (t2, [e2]) => bs(e2.evaluate(t2), t2.properties())], [[br, Ar], (t2, [e2, r2]) => bs(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: Mr, overloads: [[[br], (t2, [e2]) => ws(e2.evaluate(t2), t2.properties())], [[br, Ar], (t2, [e2, r2]) => ws(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [Mr, [br], (t2, [e2]) => ws(e2.evaluate(t2), t2.featureState || {})], properties: [Ar, [], (t2) => t2.properties()], "geometry-type": [br, [], (t2) => t2.geometryType()], worldview: [br, [], (t2) => t2.globals.worldview || ""], "is-active-floor": [wr, _s(br), (t2, e2) => {
          if (!(t2.globals.activeFloors && t2.globals.activeFloors.size > 0)) return false;
          const r2 = t2.globals.activeFloors;
          return e2.some((e3) => {
            const n2 = e3.evaluate(t2);
            return r2.has(n2);
          });
        }], id: [Mr, [], (t2) => t2.id()], zoom: [vr, [], (t2) => t2.globals.zoom], pitch: [vr, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [vr, [], (t2) => t2.distanceFromCenter()], "measure-light": [vr, [br], (t2, [e2]) => t2.measureLight(e2.evaluate(t2))], "heatmap-density": [vr, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [vr, [], (t2) => t2.globals.lineProgress || 0], "raster-value": [vr, [], (t2) => t2.globals.rasterValue || 0], "raster-particle-speed": [vr, [], (t2) => t2.globals.rasterParticleSpeed || 0], "sky-radial-progress": [vr, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [Mr, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [vr, _s(vr), (t2, e2) => {
          let r2 = 0;
          for (const n2 of e2) r2 += n2.evaluate(t2);
          return r2;
        }], "*": [vr, _s(vr), (t2, e2) => {
          let r2 = 1;
          for (const n2 of e2) r2 *= n2.evaluate(t2);
          return r2;
        }], "-": { type: vr, overloads: [[[vr, vr], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[vr], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [vr, [vr, vr], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [vr, [vr, vr], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [vr, [], () => Math.LN2], pi: [vr, [], () => Math.PI], e: [vr, [], () => Math.E], "^": [vr, [vr, vr], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [vr, [vr], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [vr, [vr], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [vr, [vr], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [vr, [vr], (t2, [e2]) => Math.log2(e2.evaluate(t2))], sin: [vr, [vr], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [vr, [vr], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [vr, [vr], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [vr, [vr], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [vr, [vr], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [vr, [vr], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [vr, _s(vr), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [vr, _s(vr), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [vr, [vr], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [vr, [vr], (t2, [e2]) => {
          const r2 = e2.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [vr, [vr], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [vr, [vr], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [wr, [br, Mr], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [wr, [Mr], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [wr, [br], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [wr, [br, Mr], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [wr, [Mr], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [wr, [br, Mr], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [wr, [Mr], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [wr, [br, Mr], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [wr, [Mr], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [wr, [br, Mr], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [wr, [Mr], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [wr, [Mr], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [wr, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [wr, [zr(br)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [wr, [zr(Mr)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [wr, [br, zr(Mr)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [wr, [br, zr(Mr)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
          for (; r3 <= n2; ) {
            const i2 = r3 + n2 >> 1;
            if (e3[i2] === t3) return true;
            e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: wr, overloads: [[[wr, wr], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [_s(wr), (t2, e2) => {
          for (const r2 of e2) if (!r2.evaluate(t2)) return false;
          return true;
        }]] }, any: { type: wr, overloads: [[[wr, wr], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [_s(wr), (t2, e2) => {
          for (const r2 of e2) if (r2.evaluate(t2)) return true;
          return false;
        }]] }, "!": [wr, [wr], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [wr, [br], (t2, [e2]) => {
          const r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t2));
        }], upcase: [br, [br], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [br, [br], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [br, _s(Mr), (t2, e2) => e2.map((e3) => Gr(e3.evaluate(t2))).join("")], "resolved-locale": [br, [Ir], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()], random: [vr, [vr, vr, Mr], (t2, e2) => {
          const [r2, n2, i2] = e2.map((e3) => e3.evaluate(t2));
          if (r2 > n2) return r2;
          if (r2 === n2) return r2;
          let s2;
          if ("string" == typeof i2) s2 = function(t3) {
            let e3 = 0;
            if (0 === t3.length) return e3;
            for (let r3 = 0; r3 < t3.length; r3++) e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 &= e3;
            return e3;
          }(i2);
          else {
            if ("number" != typeof i2) throw new qr(`Invalid seed input: ${i2}`);
            s2 = i2;
          }
          return r2 + ys(s2)() * (n2 - r2);
        }] });
        class Us {
          constructor(t2, e2, r2, n2, i2) {
            this.expression = t2, this._warningHistory = {}, this._scope = r2, this._options = n2, this._iconImageUseTheme = i2, this._evaluator = new sn(r2, n2, i2), this._defaultValue = e2 ? function(t3) {
              return "color" === t3.type && (Vs(t3.default) || Array.isArray(t3.default)) ? new ur(0, 0, 0, 0) : "color" === t3.type ? ur.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
            }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null, this.configDependencies = As(t2), this.isIndoorDependent = Ms(t2);
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2, a2, o2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            this._evaluator || (this._evaluator = new sn(this._scope, this._options, this._iconImageUseTheme)), this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this._evaluator.iconImageUseTheme = l2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues)) throw new qr(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              const e3 = t3;
              return this._warningHistory[e3.message] || (this._warningHistory[e3.message] = true, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${e3.message}`)), this._defaultValue;
            }
          }
        }
        function Ns(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in gs;
        }
        function js(t2, e2, r2, n2, i2) {
          const s2 = new Ii(gs, [], e2 ? function(t3) {
            const e3 = { color: _r, string: br, number: vr, enum: br, boolean: wr, formatted: Sr, resolvedImage: Pr };
            return "array" === t3.type ? zr(e3[t3.value] || Mr, t3.length) : e3[t3.type];
          }(e2) : void 0, void 0, void 0, r2, n2, i2), a2 = s2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return a2 ? Is(new Us(a2, e2, r2, n2, i2)) : Ss(s2.errors);
        }
        class Gs {
          constructor(t2, e2, r2, n2) {
            this.kind = t2, this._styleExpression = e2, this.isLightConstant = r2, this.isLineProgressConstant = n2, this.isStateDependent = "constant" !== t2 && !xi(e2.expression), this.configDependencies = As(e2.expression), this.isIndoorDependent = Ms(e2.expression);
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2, a2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2, void 0, void 0, a2);
          }
        }
        class $s {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !xi(e2.expression), this.isIndoorDependent = Ms(e2.expression), this.isLightConstant = i2, this.isLineProgressConstant = s2, this.configDependencies = As(e2.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
          interpolationFactor(t2, e2, r2) {
            return this.interpolationType ? Hi.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          }
        }
        function qs(t2, e2, r2, n2, i2) {
          if ("error" === (t2 = js(t2, e2, r2, n2, i2)).result) return t2;
          const s2 = t2.value.expression, a2 = gi(s2);
          if (!a2 && !zs(e2)) return Ss([new yr("", "data expressions not supported")]);
          const o2 = vi(s2, ["zoom", "pitch", "distance-from-center"]);
          if (!o2 && !ks(e2)) return Ss([new yr("", "zoom expressions not supported")]);
          const l2 = vi(s2, ["measure-light"]);
          if (!l2 && !Bs(e2)) return Ss([new yr("", "measure-light expression not supported")]);
          const u2 = vi(s2, ["line-progress"]);
          if (!u2 && !function(t3) {
            return Ps(t3.expression, "line-progress");
          }(e2)) return Ss([new yr("", "line-progress expression not supported")]);
          const c2 = e2.expression && e2.expression.relaxZoomRestriction, h2 = Hs(s2);
          return h2 || o2 || c2 ? h2 instanceof yr ? Ss([h2]) : h2 instanceof Hi && !Ts(e2) ? Ss([new yr("", '"interpolate" expressions cannot be used with this property')]) : Is(h2 ? new $s(a2 && u2 ? "camera" : "composite", t2.value, h2.labels, h2 instanceof Hi ? h2.interpolation : void 0, l2, u2) : new Gs(a2 && u2 ? "constant" : "source", t2.value, l2, u2)) : Ss([new yr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
        }
        class Xs {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, Object.assign(this, Fs(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new Xs(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function Hs(t2) {
          let e2 = null;
          if (t2 instanceof Yi) e2 = Hs(t2.result);
          else if (t2 instanceof Wi) {
            for (const r2 of t2.args) if (e2 = Hs(r2), e2) break;
          } else (t2 instanceof zi || t2 instanceof Hi) && t2.input instanceof an && "zoom" === t2.input.name && (e2 = t2);
          return e2 instanceof yr || t2.eachChild((t3) => {
            const r2 = Hs(t3);
            r2 instanceof yr ? e2 = r2 : e2 && r2 && e2 !== r2 && (e2 = new yr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        var Zs, Ws, Ys = function() {
          if (Ws) return Zs;
          Ws = 1, Zs = e2;
          var t2 = 3;
          function e2(e3, r2, n2) {
            var i2 = this.cells = [];
            if (e3 instanceof ArrayBuffer) {
              this.arrayBuffer = e3;
              var s2 = new Int32Array(this.arrayBuffer);
              e3 = s2[0], this.d = (r2 = s2[1]) + 2 * (n2 = s2[2]);
              for (var a2 = 0; a2 < this.d * this.d; a2++) {
                var o2 = s2[t2 + a2], l2 = s2[t2 + a2 + 1];
                i2.push(o2 === l2 ? null : s2.subarray(o2, l2));
              }
              var u2 = s2[t2 + i2.length + 1];
              this.keys = s2.subarray(s2[t2 + i2.length], u2), this.bboxes = s2.subarray(u2), this.insert = this._insertReadonly;
            } else {
              this.d = r2 + 2 * n2;
              for (var c2 = 0; c2 < this.d * this.d; c2++) i2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = r2, this.extent = e3, this.padding = n2, this.scale = r2 / e3, this.uid = 0;
            var h2 = n2 / r2 * e3;
            this.min = -h2, this.max = e3 + h2;
          }
          return e2.prototype.insert = function(t3, e3, r2, n2, i2) {
            this._forEachCell(e3, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }, e2.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
          }, e2.prototype._insertCell = function(t3, e3, r2, n2, i2, s2) {
            this.cells[i2].push(s2);
          }, e2.prototype.query = function(t3, e3, r2, n2, i2) {
            var s2 = this.min, a2 = this.max;
            if (t3 <= s2 && e3 <= s2 && a2 <= r2 && a2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
            var o2 = [];
            return this._forEachCell(t3, e3, r2, n2, this._queryCell, o2, {}, i2), o2;
          }, e2.prototype._queryCell = function(t3, e3, r2, n2, i2, s2, a2, o2) {
            var l2 = this.cells[i2];
            if (null !== l2) for (var u2 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
              var p2 = l2[h2];
              if (void 0 === a2[p2]) {
                var d2 = 4 * p2;
                (o2 ? o2(c2[d2 + 0], c2[d2 + 1], c2[d2 + 2], c2[d2 + 3]) : t3 <= c2[d2 + 2] && e3 <= c2[d2 + 3] && r2 >= c2[d2 + 0] && n2 >= c2[d2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
              }
            }
          }, e2.prototype._forEachCell = function(t3, e3, r2, n2, i2, s2, a2, o2) {
            for (var l2 = this._convertToCellCoord(t3), u2 = this._convertToCellCoord(e3), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++) for (var d2 = u2; d2 <= h2; d2++) {
              var f2 = this.d * d2 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(d2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(d2 + 1))) && i2.call(this, t3, e3, r2, n2, f2, s2, a2, o2)) return;
            }
          }, e2.prototype._convertFromCellCoord = function(t3) {
            return (t3 - this.padding) / this.scale;
          }, e2.prototype._convertToCellCoord = function(t3) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
          }, e2.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for (var e3 = this.cells, r2 = t2 + this.cells.length + 1 + 1, n2 = 0, i2 = 0; i2 < this.cells.length; i2++) n2 += this.cells[i2].length;
            var s2 = new Int32Array(r2 + n2 + this.keys.length + this.bboxes.length);
            s2[0] = this.extent, s2[1] = this.n, s2[2] = this.padding;
            for (var a2 = r2, o2 = 0; o2 < e3.length; o2++) {
              var l2 = e3[o2];
              s2[t2 + o2] = a2, s2.set(l2, a2), a2 += l2.length;
            }
            return s2[t2 + e3.length] = a2, s2.set(this.keys, a2), s2[t2 + e3.length + 1] = a2 += this.keys.length, s2.set(this.bboxes, a2), a2 += this.bboxes.length, s2.buffer;
          }, Zs;
        }(), Js = _t(Ys);
        const Ks = {};
        function Qs(t2, e2, r2 = {}) {
          Object.defineProperty(t2, "_classRegistryKey", { value: e2, writable: false }), Ks[e2] = { klass: t2, omit: r2.omit || [] };
        }
        Qs(Object, "Object"), Js.serialize = function(t2, e2) {
          const r2 = t2.toArrayBuffer();
          return e2 && e2.add(r2), { buffer: r2 };
        }, Js.deserialize = function(t2) {
          return new Js(t2.buffer);
        }, Object.defineProperty(Js, "name", { value: "Grid" }), Qs(Js, "Grid"), delete It.prototype.constructor, Qs(ur, "Color"), Qs(Error, "Error"), Qs(Rr, "Formatted"), Qs(Cr, "FormattedSection"), Qs(Re, "AJAXError"), Qs(Or, "ResolvedImage"), Qs(Xs, "StylePropertyFunction"), Qs(Us, "StyleExpression", { omit: ["_evaluator"] }), Qs(sr, "ImageId"), Qs(Lr, "ImageVariant"), Qs($s, "ZoomDependentExpression"), Qs(Gs, "ZoomConstantExpression"), Qs(an, "CompoundExpression", { omit: ["_evaluate"] });
        for (const t2 in gs) Ks[gs[t2]._classRegistryKey] || Qs(gs[t2], `Expression${t2}`);
        function ta(t2) {
          return t2 && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function ea(t2, e2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp) return t2;
          if (ta(t2) || t2 instanceof ImageBitmap) return e2 && e2.add(t2), t2;
          if (ArrayBuffer.isView(t2)) return e2 && e2.add(t2.buffer), t2;
          if (t2 instanceof ImageData) return e2 && e2.add(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const r2 = [];
            for (const n2 of t2) r2.push(ea(n2, e2));
            return r2;
          }
          if (t2 instanceof Map) {
            const r2 = { $name: "Map", entries: [] };
            for (const [n2, i2] of t2.entries()) r2.entries.push(ea(n2), ea(i2, e2));
            return r2;
          }
          if (t2 instanceof Set) {
            const e3 = { $name: "Set" };
            let r2 = 0;
            for (const n2 of t2.values()) e3[++r2] = ea(n2);
            return e3;
          }
          if ("bigint" == typeof t2) return { $name: "BigInt", value: t2.toString() };
          if ("object" == typeof t2) {
            const r2 = t2.constructor, n2 = r2._classRegistryKey;
            if (!n2) throw new Error(`Can't serialize object of unregistered class "${r2.name}".`);
            const i2 = r2.serialize ? r2.serialize(t2, e2) : {};
            if (!r2.serialize) {
              for (const r3 in t2) t2.hasOwnProperty(r3) && (Ks[n2].omit.indexOf(r3) >= 0 || (i2[r3] = ea(t2[r3], e2)));
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n2 && (i2.$name = n2), i2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function ra(t2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || ta(t2) || t2 instanceof ImageBitmap || ArrayBuffer.isView(t2) || t2 instanceof ImageData) return t2;
          if (Array.isArray(t2)) return t2.map(ra);
          if ("object" == typeof t2) {
            const e2 = t2.$name || "Object";
            if ("Map" === e2) {
              const e3 = t2.entries || [], r3 = /* @__PURE__ */ new Map();
              for (let t3 = 0; t3 < e3.length; t3 += 2) r3.set(ra(e3[t3]), ra(e3[t3 + 1]));
              return r3;
            }
            if ("Set" === e2) {
              const e3 = /* @__PURE__ */ new Set();
              for (const r3 of Object.keys(t2)) "$name" !== r3 && e3.add(ra(t2[r3]));
              return e3;
            }
            if ("BigInt" === e2) return BigInt(t2.value);
            const { klass: r2 } = Ks[e2];
            if (!r2) throw new Error(`Can't deserialize unregistered class "${e2}".`);
            if (r2.deserialize) return r2.deserialize(t2);
            const n2 = Object.create(r2.prototype);
            for (const e3 of Object.keys(t2)) "$name" !== e3 && (n2[e3] = ra(t2[e3]));
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        const na = (t2) => t2 >= 1536 && t2 <= 1791, ia = (t2) => t2 >= 1872 && t2 <= 1919, sa = (t2) => t2 >= 2208 && t2 <= 2303, aa = (t2) => t2 >= 11904 && t2 <= 12031, oa = (t2) => t2 >= 12032 && t2 <= 12255, la = (t2) => t2 >= 12272 && t2 <= 12287, ua = (t2) => t2 >= 12288 && t2 <= 12351, ca = (t2) => t2 >= 12352 && t2 <= 12447, ha = (t2) => t2 >= 12448 && t2 <= 12543, pa = (t2) => t2 >= 12544 && t2 <= 12591, da = (t2) => t2 >= 12704 && t2 <= 12735, fa = (t2) => t2 >= 12736 && t2 <= 12783, ma = (t2) => t2 >= 12784 && t2 <= 12799, ya = (t2) => t2 >= 12800 && t2 <= 13055, ga = (t2) => t2 >= 13056 && t2 <= 13311, xa = (t2) => t2 >= 13312 && t2 <= 19903, va = (t2) => t2 >= 19968 && t2 <= 40959, ba = (t2) => t2 >= 40960 && t2 <= 42127, wa = (t2) => t2 >= 42128 && t2 <= 42191, _a = (t2) => t2 >= 44032 && t2 <= 55215, Aa = (t2) => t2 >= 63744 && t2 <= 64255, Ma = (t2) => t2 >= 64336 && t2 <= 65023, Ia = (t2) => t2 >= 65040 && t2 <= 65055, Sa = (t2) => t2 >= 65072 && t2 <= 65103, Pa = (t2) => t2 >= 65104 && t2 <= 65135, za = (t2) => t2 >= 65136 && t2 <= 65279, Ba = (t2) => t2 >= 65280 && t2 <= 65519;
        function ka(t2) {
          for (const e2 of t2) if (Fa(e2.charCodeAt(0))) return true;
          return false;
        }
        function Ta(t2) {
          for (const e2 of t2) if (!Va(e2.charCodeAt(0))) return false;
          return true;
        }
        function Va(t2) {
          return !(na(t2) || ia(t2) || sa(t2) || Ma(t2) || za(t2));
        }
        function Ea(t2) {
          return !(t2 < 11904 || !(da(t2) || pa(t2) || Sa(t2) || Aa(t2) || ga(t2) || aa(t2) || fa(t2) || ua(t2) || xa(t2) || va(t2) || ya(t2) || Ba(t2) || ca(t2) || la(t2) || oa(t2) || ma(t2) || ha(t2) || Ia(t2) || wa(t2) || ba(t2)));
        }
        function Fa(t2) {
          return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(da(t2) || pa(t2) || Sa(t2) && !(t2 >= 65097 && t2 <= 65103) || Aa(t2) || ga(t2) || aa(t2) || fa(t2) || !(!ua(t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || xa(t2) || va(t2) || ya(t2) || ((t3) => t3 >= 12592 && t3 <= 12687)(t2) || ((t3) => t3 >= 43360 && t3 <= 43391)(t2) || ((t3) => t3 >= 55216 && t3 <= 55295)(t2) || ((t3) => t3 >= 4352 && t3 <= 4607)(t2) || _a(t2) || ca(t2) || la(t2) || ((t3) => t3 >= 12688 && t3 <= 12703)(t2) || oa(t2) || ma(t2) || ha(t2) && 12540 !== t2 || !(!Ba(t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Pa(t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ((t3) => t3 >= 5120 && t3 <= 5759)(t2) || ((t3) => t3 >= 6320 && t3 <= 6399)(t2) || Ia(t2) || ((t3) => t3 >= 19904 && t3 <= 19967)(t2) || ba(t2) || wa(t2))));
        }
        function Da(t2) {
          return 12312 === t2 || 12313 === t2 || 12316 === t2 || 12540 === t2 || 12448 === t2;
        }
        function Ca(t2) {
          return !(Fa(t2) || function(t3) {
            return !!(((t4) => t4 >= 128 && t4 <= 255)(t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ((t4) => t4 >= 8192 && t4 <= 8303)(t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ((t4) => t4 >= 8448 && t4 <= 8527)(t3) || ((t4) => t4 >= 8528 && t4 <= 8591)(t3) || ((t4) => t4 >= 8960 && t4 <= 9215)(t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ((t4) => t4 >= 9216 && t4 <= 9279)(t3) && 9251 !== t3 || ((t4) => t4 >= 9280 && t4 <= 9311)(t3) || ((t4) => t4 >= 9312 && t4 <= 9471)(t3) || ((t4) => t4 >= 9632 && t4 <= 9727)(t3) || ((t4) => t4 >= 9728 && t4 <= 9983)(t3) && !(t3 >= 9754 && t3 <= 9759) || ((t4) => t4 >= 11008 && t4 <= 11263)(t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || ua(t3) || ha(t3) || ((t4) => t4 >= 57344 && t4 <= 63743)(t3) || Sa(t3) || Pa(t3) || Ba(t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
          }(t2));
        }
        function Ra(t2) {
          return na(t2) || ia(t2) || sa(t2) || Ma(t2) || za(t2);
        }
        function La(t2) {
          return t2 >= 1424 && t2 <= 2303 || Ma(t2) || za(t2);
        }
        function Oa(t2, e2) {
          return !(!e2 && La(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ((t3) => t3 >= 6016 && t3 <= 6143)(t2));
        }
        function Ua(t2) {
          for (const e2 of t2) if (La(e2.charCodeAt(0))) return true;
          return false;
        }
        const Na = { unavailable: "unavailable", deferred: "deferred", loading: "loading", parsing: "parsing", parsed: "parsed", loaded: "loaded", error: "error" };
        let ja = null, Ga = Na.unavailable, $a = null;
        const qa = function(t2) {
          t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Ga = Na.error), ja && ja(t2);
        };
        function Xa() {
          Ha.fire(new tr("pluginStateChange", { pluginStatus: Ga, pluginURL: $a }));
        }
        const Ha = new ir(), Za = function() {
          return Ga;
        }, Wa = function() {
          if (Ga !== Na.deferred || !$a) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Ga = Na.loading, Xa(), $a && Ue({ url: $a }, (t2) => {
            t2 ? qa(t2) : (Ga = Na.loaded, Xa());
          });
        }, Ya = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ga === Na.loaded || null != Ya.applyArabicShaping, isLoading: () => Ga === Na.loading, setState(t2) {
          Ga = t2.pluginStatus, $a = t2.pluginURL;
        }, isParsing: () => Ga === Na.parsing, isParsed: () => Ga === Na.parsed, getPluginURL: () => $a };
        class Ja {
          constructor(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch, this.brightness = e2.brightness, this.worldview = e2.worldview, this.activeFloors = e2.activeFloors) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
          }
          isSupportedScript(t2) {
            return function(t3, e2) {
              for (const r2 of t3) if (!Oa(r2.charCodeAt(0), e2)) return false;
              return true;
            }(t2, Ya.isLoaded());
          }
        }
        class Ka {
          constructor(t2, e2, r2, n2, i2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3, r3, n3, i3) {
              if (Vs(t3)) return new Xs(t3, e3);
              if (Ns(t3) || Array.isArray(t3) && t3.length > 0) {
                const s2 = qs(t3, e3, r3, n3, i3);
                if ("error" === s2.result) throw new Error(s2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                return s2.value;
              }
              {
                let r4 = t3;
                return "string" == typeof t3 && "color" === e3.type && (r4 = ur.parse(t3)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), isIndoorDependent: false, evaluate: () => r4 };
              }
            }(void 0 === e2 ? t2.specification.default : e2, t2.specification, r2, n2, i2);
          }
          isIndoorDependent() {
            return this.expression.isIndoorDependent;
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2, n2);
          }
        }
        class Qa {
          constructor(t2, e2, r2, n2) {
            this.property = t2, this.value = new Ka(t2, void 0, e2, r2, n2);
          }
          transitioned(t2, e2) {
            return new eo(this.property, this.value, e2, Object.assign({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new eo(this.property, this.value, null, {}, 0);
          }
        }
        class to {
          constructor(t2, e2, r2, n2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues), this._scope = e2, this._options = r2, this._iconImageUseTheme = n2, this._isIndoorDependent = false, this.configDependencies = /* @__PURE__ */ new Set();
          }
          getValue(t2) {
            return qt(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new Qa(this._values[t2].property, this._scope, this._options, this._iconImageUseTheme)), this._values[t2].value = new Ka(this._values[t2].property, null === e2 ? void 0 : qt(e2), this._scope, this._options, this._iconImageUseTheme), this._values[t2].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t2].value.expression.configDependencies]), this._isIndoorDependent = this._isIndoorDependent || this._values[t2].value.isIndoorDependent());
          }
          setTransitionOrValue(t2, e2) {
            e2 && (this._options = e2);
            const r2 = this._properties.properties;
            if (t2) for (const e3 in t2) {
              const n2 = t2[e3];
              if (e3.endsWith("-transition")) {
                const t3 = e3.slice(0, -11);
                r2[t3] && this.setTransition(t3, n2);
              } else r2.hasOwnProperty(e3) && this.setValue(e3, n2);
            }
          }
          getTransition(t2) {
            return qt(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new Qa(this._values[t2].property)), this._values[t2].transition = qt(e2) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
              const n2 = this.getTransition(e2);
              void 0 !== n2 && (t2[`${e2}-transition`] = n2);
            }
            return t2;
          }
          transitioned(t2, e2) {
            const r2 = new ro(this._properties);
            for (const n2 of Object.keys(this._values)) r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
            return r2;
          }
          untransitioned() {
            const t2 = new ro(this._properties);
            for (const e2 of Object.keys(this._values)) t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
          isIndoorDependent() {
            return this._isIndoorDependent;
          }
        }
        class eo {
          constructor(t2, e2, r2, n2, i2) {
            const s2 = n2.delay || 0, a2 = n2.duration || 0;
            i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
            if (s2) {
              if (n2 > this.end) return this.prior = null, i2;
              if (this.value.isDataDriven()) return this.prior = null, i2;
              if (n2 < this.begin) return s2.possiblyEvaluate(t2, e2, r2);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, Vt(a2));
              }
            }
            return i2;
          }
        }
        class ro {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new so(this._properties);
            for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values)) if (this._values[t2].prior) return true;
            return false;
          }
        }
        class no {
          constructor(t2, e2, r2, n2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues), this._scope = e2, this._options = r2, this._iconImageUseTheme = n2, this._isIndoorDependent = false, this.configDependencies = /* @__PURE__ */ new Set();
          }
          getValue(t2) {
            return qt(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new Ka(this._values[t2].property, null === e2 ? void 0 : qt(e2), this._scope, this._options, this._iconImageUseTheme), this._values[t2].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t2].expression.configDependencies]), this._isIndoorDependent = this._isIndoorDependent || this._values[t2].isIndoorDependent());
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            const i2 = new so(this._properties);
            for (const s2 of Object.keys(this._values)) i2._values[s2] = this._values[s2].possiblyEvaluate(t2, e2, r2, n2);
            return i2;
          }
          isIndoorDependent() {
            return this._isIndoorDependent;
          }
        }
        class io {
          constructor(t2, e2, r2, n2) {
            this.property = t2, this.value = e2, this.parameters = r2, this.iconImageUseTheme = n2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2, this.iconImageUseTheme);
          }
        }
        class so {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class ao {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r2) {
            const n2 = mr[this.specification.type];
            return n2 ? n2(t2, e2, r2) : t2;
          }
        }
        class oo {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r2, n2, i2) {
            return "constant" === t2.expression.kind || "camera" === t2.expression.kind ? new io(this, { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2, void 0, i2) }, e2) : new io(this, t2.expression, e2, i2);
          }
          interpolate(t2, e2, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind) return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value) return new io(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n2 = mr[this.specification.type];
            return n2 ? new io(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
          }
          evaluate(t2, e2, r2, n2, i2, s2, a2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2, void 0, a2);
          }
        }
        class lo {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n2);
          }
          interpolate() {
            return false;
          }
        }
        class uo {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const e2 = new Ja(0, {});
            for (const r2 in t2) {
              const n2 = t2[r2];
              n2.specification.overridable && this.overridableProperties.push(r2);
              const i2 = this.defaultPropertyValues[r2] = new Ka(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r2] = new Qa(n2);
              this.defaultTransitioningPropertyValues[r2] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e2);
            }
          }
        }
        Qs(oo, "DataDrivenProperty"), Qs(ao, "DataConstantProperty"), Qs(lo, "ColorRampProperty");
        var co = JSON.parse('{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"shadow-draw-before-layer":{"type":"string"}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"modelNodeOverride":{"orientation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360}},"modelNodeOverrides":{"*":{"type":"modelNodeOverride"}},"modelMaterialOverride":{"model-color":{"type":"color"},"model-color-mix-intensity":{"type":"number"},"model-opacity":{"type":"number"},"model-emissive-strength":{"type":"number"}},"modelMaterialOverrides":{"*":{"type":"modelMaterialOverride"}},"modelSourceModel":{"uri":{"type":"string"},"position":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[-180,-90],"maximum":[180,90]},"orientation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360},"nodeOverrides":{"type":"modelNodeOverrides"},"materialOverrides":{"type":"modelMaterialOverrides"},"nodeOverrideNames":{"type":"array","value":"string"},"materialOverrideNames":{"type":"array","value":"string"},"featureProperties":{"type":"*"}},"modelSourceModels":{"*":{"type":"modelSourceModel"}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"url":{"type":"string"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"},"models":{"type":"modelSourceModels"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"appearances":{"type":"array","value":"appearance","supported-layer-types":["symbol"]}},"appearance":{"condition":{"type":"boolean","expression":{"interpolated":true,"parameters":["zoom","pitch","feature","feature-state","measure-light","distance-from-center"]},"property-type":"data-driven"},"name":{"type":"string"},"properties":{"type":"*"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"model-allow-density-reduction":{"type":"boolean","default":true}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-facade":{"type":"boolean","default":false,"expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-facade-floors":{"type":"number","minimum":1,"maximum":200,"default":3,"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-facade-unit-width":{"type":"number","minimum":1,"maximum":20,"default":3.1,"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-facade-window":{"type":"array","length":2,"value":"number","minimum":0.1,"maximum":1,"default":[0.9,0.9],"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"building-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"building-flip-roof-orientation":{"property-type":"data-driven","type":"boolean","default":false,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":[0.1,0.1],"maximum":[10,10],"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"appearance":true,"use-theme":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":[0.1,0.1],"maximum":[10,10],"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor_source":{"sourceId":{"type":"string"},"sourceLayers":{"type":"array","value":"string"}},"indoor":{"*":{"type":"indoor_source"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"parameters":[]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","use-theme":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-facade-emissive-chance":{"type":"number","default":0.35,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["measure-light","zoom"]}},"building-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"building-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"building-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"building-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-gradient":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"use-theme":true,"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"use-theme":true,"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white","use-theme":true},"sky-atmosphere-color":{"type":"color","default":"white","use-theme":true},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"use-theme":true,"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]},"model-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{}}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}');
        function ho(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function po(t2) {
          if (Array.isArray(t2)) return t2.map(po);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e2 = {};
            for (const r2 in t2) e2[r2] = po(t2[r2]);
            return e2;
          }
          return ho(t2);
        }
        function fo(t2) {
          if (true === t2 || false === t2) return true;
          if (!Array.isArray(t2) || 0 === t2.length) return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e2 of t2.slice(1)) if (!fo(e2) && "boolean" != typeof e2) return false;
              return true;
            default:
              return true;
          }
        }
        function mo(t2, e2 = "", r2 = null, n2 = "fill") {
          if (null == t2) return { filter: () => true, needGeometry: false, needFeature: false };
          fo(t2) || (t2 = _o(t2));
          const i2 = t2;
          let s2 = true;
          try {
            s2 = function(t3) {
              if (!xo(t3)) return t3;
              let e3 = po(t3);
              return go(e3), e3 = yo(e3), e3;
            }(i2);
          } catch (t3) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i2, null, 2)}
        `);
          }
          let a2 = null, o2 = null;
          if ("background" !== n2 && "sky" !== n2 && "slot" !== n2) {
            o2 = co[`filter_${n2}`];
            const t3 = js(s2, o2, e2, r2);
            if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
            a2 = (e3, r3, n3) => t3.value.evaluate(e3, r3, {}, n3);
          }
          let l2 = null, u2 = null;
          if (s2 !== i2) {
            const t3 = js(i2, o2, e2, r2);
            if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
            l2 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), u2 = !gi(t3.value.expression);
          }
          return { filter: a2, dynamicFilter: l2 || void 0, needGeometry: wo(s2), needFeature: !!u2 };
        }
        function yo(t2) {
          if (!Array.isArray(t2)) return t2;
          const e2 = function(t3) {
            if (vo.has(t3[0])) {
              for (let e3 = 1; e3 < t3.length; e3++) if (xo(t3[e3])) return true;
            }
            return t3;
          }(t2);
          return true === e2 ? e2 : e2.map((t3) => yo(t3));
        }
        function go(t2) {
          let e2 = false;
          const r2 = [];
          if ("case" === t2[0]) {
            for (let n2 = 1; n2 < t2.length - 1; n2 += 2) e2 = e2 || xo(t2[n2]), r2.push(t2[n2 + 1]);
            r2.push(t2[t2.length - 1]);
          } else if ("match" === t2[0]) {
            e2 = e2 || xo(t2[1]);
            for (let e3 = 2; e3 < t2.length - 1; e3 += 2) r2.push(t2[e3 + 1]);
            r2.push(t2[t2.length - 1]);
          } else if ("step" === t2[0]) {
            e2 = e2 || xo(t2[1]);
            for (let e3 = 1; e3 < t2.length - 1; e3 += 2) r2.push(t2[e3 + 1]);
          }
          e2 && (t2.length = 0, t2.push("any", ...r2));
          for (let e3 = 1; e3 < t2.length; e3++) go(t2[e3]);
        }
        function xo(t2) {
          if (!Array.isArray(t2)) return false;
          if ("pitch" === (e2 = t2[0]) || "distance-from-center" === e2) return true;
          var e2;
          for (let e3 = 1; e3 < t2.length; e3++) if (xo(t2[e3])) return true;
          return false;
        }
        const vo = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function bo(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function wo(t2) {
          if (!Array.isArray(t2)) return false;
          if ("within" === t2[0] || "distance" === t2[0]) return true;
          for (let e2 = 1; e2 < t2.length; e2++) if (wo(t2[e2])) return true;
          return false;
        }
        function _o(t2) {
          if (!t2) return true;
          const e2 = t2[0];
          return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? Ao(t2[1], t2[2], "==") : "!=" === e2 ? So(Ao(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Ao(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(_o))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(_o)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(_o).map(So)) : "in" === e2 ? Mo(t2[1], t2.slice(2)) : "!in" === e2 ? So(Mo(t2[1], t2.slice(2))) : "has" === e2 ? Io(t2[1]) : "!has" !== e2 || So(Io(t2[1]));
          var r2;
        }
        function Ao(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r2}`, e2];
            case "$id":
              return [`filter-id-${r2}`, e2];
            default:
              return [`filter-${r2}`, t2, e2];
          }
        }
        function Mo(t2, e2) {
          if (0 === e2.length) return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(bo)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function Io(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function So(t2) {
          return ["!", t2];
        }
        const Po = "";
        function zo(t2, e2) {
          return e2 ? `${t2}${Po}${e2}` : t2;
        }
        let Bo;
        const ko = () => Bo || (Bo = new uo({ "icon-size": new oo(co.layout_symbol["icon-size"]), "icon-image": new oo(co.layout_symbol["icon-image"]), "icon-rotate": new oo(co.layout_symbol["icon-rotate"]), "icon-offset": new oo(co.layout_symbol["icon-offset"]), "text-size": new oo(co.layout_symbol["text-size"]), "text-rotate": new oo(co.layout_symbol["text-rotate"]), "text-offset": new oo(co.layout_symbol["text-offset"]) }));
        class To {
          constructor(t2, e2, r2, n2, i2, s2) {
            const a2 = js(t2, co.appearance.condition);
            if ("success" === a2.result && (this.condition = a2.value), this.name = e2, r2) {
              this.properties = new so(ko()), this.unevaluatedLayout = new no(ko(), n2, i2, s2);
              for (const t3 in r2) this.unevaluatedLayout.setValue(t3, r2[t3]);
            }
          }
          isActive(t2) {
            return !(this.condition || !t2.isHidden || "hidden" !== this.name) || this.condition.evaluate(t2.globals, t2.feature, t2.featureState, t2.canonical);
          }
          getCondition() {
            return this.condition;
          }
          getName() {
            return this.name;
          }
          getProperty(t2) {
            return this.properties.get(t2);
          }
          getUnevaluatedProperties() {
            return this.unevaluatedLayout;
          }
          getUnevaluatedProperty(t2) {
            return this.unevaluatedLayout._values[t2];
          }
          recalculate(t2, e2, r2) {
            this.unevaluatedLayout && (this.properties = this.unevaluatedLayout.possiblyEvaluate(t2, void 0, e2, r2));
          }
          serialize() {
            const t2 = {};
            return t2.condition = this.condition.expression.serialize(), this.name && (t2.name = this.name), this.unevaluatedLayout && (t2.properties = this.unevaluatedLayout.serialize()), t2;
          }
          hasIconProperties() {
            const t2 = this.hasProperty("icon-image"), e2 = this.hasProperty("icon-size"), r2 = this.hasProperty("icon-offset"), n2 = this.hasProperty("icon-rotate");
            return t2 || e2 || r2 || n2;
          }
          hasTextProperties() {
            const t2 = this.hasProperty("text-size"), e2 = this.hasProperty("text-offset"), r2 = this.hasProperty("text-rotate");
            return t2 || e2 || r2;
          }
          hasProperty(t2) {
            return void 0 !== this.getUnevaluatedProperty(t2).value;
          }
        }
        const Vo = "-transition", Eo = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
        class Fo extends ir {
          constructor(t2, e2, r2, n2, i2, s2) {
            if (super(), this.id = t2.id, this.fqid = zo(this.id, r2), this.type = t2.type, this.scope = r2, this.lut = n2, this.options = i2, this.iconImageUseTheme = s2, this.appearances = new Array(), this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.expressionDependencies = { isIndoorDependent: false, configDependencies: /* @__PURE__ */ new Set() }, "custom" !== t2.type) {
              if (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type && "background" !== t2.type && "sky" !== t2.type && "slot" !== t2.type) {
                this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter;
                const e3 = js(this.filter, co[`filter_${t2.type}`]);
                "error" !== e3.result && (this.expressionDependencies.configDependencies = /* @__PURE__ */ new Set([...this.expressionDependencies.configDependencies, ...e3.value.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || e3.value.isIndoorDependent);
              }
              if (t2.slot && (this.slot = t2.slot), t2.appearances && this.setAppearances(t2.appearances), e2.layout && (this._unevaluatedLayout = new no(e2.layout, this.scope, i2, this.iconImageUseTheme), this.expressionDependencies.configDependencies = /* @__PURE__ */ new Set([...this.expressionDependencies.configDependencies, ...this._unevaluatedLayout.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || this._unevaluatedLayout.isIndoorDependent()), e2.paint) {
                this._transitionablePaint = new to(e2.paint, this.scope, i2);
                for (const e3 in t2.paint) this.setPaintProperty(e3, t2.paint[e3]);
                for (const e3 in t2.layout) this.setLayoutProperty(e3, t2.layout[e3]);
                this.expressionDependencies.configDependencies = /* @__PURE__ */ new Set([...this.expressionDependencies.configDependencies, ...this._transitionablePaint.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || this._transitionablePaint.isIndoorDependent(), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new so(e2.paint);
              }
            }
          }
          onAdd(t2) {
          }
          onRemove(t2) {
          }
          isDraped(t2) {
            return !this.is3D(true) && Eo.has(this.type);
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e2) {
            if ("custom" === this.type && "visibility" === t2) return void (this.visibility = e2);
            const r2 = this._unevaluatedLayout;
            r2._properties.properties[t2] && (r2.setValue(t2, e2), this.expressionDependencies.configDependencies = /* @__PURE__ */ new Set([...this.expressionDependencies.configDependencies, ...r2.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || r2.isIndoorDependent(), "visibility" === t2 && this.possiblyEvaluateVisibility());
          }
          setAppearances(t2) {
            this.appearances = [], t2.forEach((t3) => {
              this.appearances.push(new To(t3.condition, t3.name, t3.properties, this.scope, this.options, this.iconImageUseTheme));
            });
          }
          possiblyEvaluateVisibility() {
            this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
          }
          getPaintProperty(t2) {
            return t2.endsWith(Vo) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
          }
          isPaintProperty(t2) {
            return !!this._transitionablePaint._properties.properties[t2];
          }
          setPaintProperty(t2, e2) {
            const r2 = this._transitionablePaint, n2 = r2._properties.properties;
            if (t2.endsWith(Vo)) {
              const i3 = t2.slice(0, -11);
              return n2[i3] && r2.setTransition(i3, e2 || void 0), false;
            }
            if (!n2[t2]) return false;
            const i2 = r2._values[t2], s2 = i2.value.isDataDriven(), a2 = i2.value;
            r2.setValue(t2, e2), this.expressionDependencies.configDependencies = /* @__PURE__ */ new Set([...this.expressionDependencies.configDependencies, ...r2.configDependencies]), this.expressionDependencies.isIndoorDependent = this.expressionDependencies.isIndoorDependent || r2.isIndoorDependent(), this._handleSpecialPaintPropertyUpdate(t2);
            const o2 = r2._values[t2].value, l2 = o2.isDataDriven(), u2 = t2.endsWith("pattern") || "line-dasharray" === t2;
            return l2 || s2 || u2 || this._handleOverridablePaintPropertyUpdate(t2, a2, o2);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          getProgramIds() {
            return null;
          }
          getDefaultProgramParams(t2, e2, r2) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return false;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e2) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2, this.iconImageUseTheme)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return 0 !== this.appearances.length && (t2.appearances = this.appearances.map((t3) => t3.serialize())), $t(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
          }
          is3D(t2) {
            return false;
          }
          hasElevation() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          hasShadowPass() {
            return false;
          }
          canCastShadows() {
            return false;
          }
          hasLightBeamPass() {
            return false;
          }
          cutoffRange() {
            return 0;
          }
          tileCoverLift() {
            return 0;
          }
          resize() {
          }
          _clear() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e2 = this.paint.get(t2);
              if (e2 instanceof io && zs(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
            }
            for (const t2 of this.appearances) if (!xi(t2.condition.expression)) return true;
            return false;
          }
          compileFilter(t2) {
            this._filterCompiled || (this._featureFilter = mo(this.filter, this.scope, t2), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
          getLayerRenderingStats() {
            return this._stats;
          }
          resetLayerRenderingStats(t2) {
            this._stats && ("shadow" === t2.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
          }
          getAppearances() {
            return this.appearances;
          }
          queryRenderedFeatures(t2, e2, r2) {
            return {};
          }
          queryRadius(t2) {
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          }
        }
        const Do = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Co {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        const Ro = new ArrayBuffer(0);
        class Lo {
          constructor() {
            this._reallocCount = 0, this.capacity = 0, this.length = 0;
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && t2.arrayBuffer && e2.add(t2.arrayBuffer), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, t2.arrayBuffer ? e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement : (e2.capacity = 0, e2.arrayBuffer = Ro), e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this._reallocCount++, this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          reserveForAdditional(t2) {
            this.reserve(this.length + t2);
          }
          _refreshViews() {
            throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
          }
          emplace(...t2) {
            throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
          }
          emplaceBack(...t2) {
            throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function Oo(t2, e2 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t2.map((t3) => {
            const i2 = Do[t3.type].BYTES_PER_ELEMENT, s2 = r2 = Uo(r2, Math.max(e2, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          }), size: Uo(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function Uo(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class No extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
          }
        }
        No.prototype.bytesPerElement = 4, Qs(No, "StructArrayLayout2i4");
        class jo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        jo.prototype.bytesPerElement = 6, Qs(jo, "StructArrayLayout3i6");
        class Go extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
          }
        }
        Go.prototype.bytesPerElement = 8, Qs(Go, "StructArrayLayout4i8");
        class $o extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        $o.prototype.bytesPerElement = 4, Qs($o, "StructArrayLayout1f4");
        class qo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 4 * t2, s2 = 2 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.float32[s2 + 1] = n2, t2;
          }
        }
        qo.prototype.bytesPerElement = 8, Qs(qo, "StructArrayLayout2i1f8");
        class Xo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 4 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        Xo.prototype.bytesPerElement = 8, Qs(Xo, "StructArrayLayout3i8");
        class Ho extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 5 * t2;
            return this.int16[a2 + 0] = e2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, t2;
          }
        }
        Ho.prototype.bytesPerElement = 10, Qs(Ho, "StructArrayLayout5i10");
        class Zo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
            return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
          }
        }
        Zo.prototype.bytesPerElement = 12, Qs(Zo, "StructArrayLayout2i4ub1f12");
        class Wo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        Wo.prototype.bytesPerElement = 12, Qs(Wo, "StructArrayLayout3f12");
        class Yo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 6 * t2, o2 = 3 * t2;
            return this.uint16[a2 + 0] = e2, this.uint16[a2 + 1] = r2, this.uint16[a2 + 2] = n2, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t2;
          }
        }
        Yo.prototype.bytesPerElement = 12, Qs(Yo, "StructArrayLayout4ui1f12");
        class Jo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.uint16[s2 + 0] = e2, this.uint16[s2 + 1] = r2, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
          }
        }
        Jo.prototype.bytesPerElement = 8, Qs(Jo, "StructArrayLayout4ui8");
        class Ko extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        Ko.prototype.bytesPerElement = 12, Qs(Ko, "StructArrayLayout6i12");
        class Qo extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const d2 = 12 * t2;
            return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r2, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.uint16[d2 + 4] = s2, this.uint16[d2 + 5] = a2, this.uint16[d2 + 6] = o2, this.uint16[d2 + 7] = l2, this.int16[d2 + 8] = u2, this.int16[d2 + 9] = c2, this.int16[d2 + 10] = h2, this.int16[d2 + 11] = p2, t2;
          }
        }
        Qo.prototype.bytesPerElement = 24, Qs(Qo, "StructArrayLayout4i4ui4i24");
        class tl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 10 * t2, l2 = 5 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
          }
        }
        tl.prototype.bytesPerElement = 20, Qs(tl, "StructArrayLayout3i3f20");
        class el extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
          }
        }
        el.prototype.bytesPerElement = 16, Qs(el, "StructArrayLayout4f16");
        class rl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        rl.prototype.bytesPerElement = 4, Qs(rl, "StructArrayLayout1ul4");
        class nl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
          }
        }
        nl.prototype.bytesPerElement = 4, Qs(nl, "StructArrayLayout2ui4");
        class il extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const d2 = this.length;
            return this.resize(d2 + 1), this.emplace(d2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2) {
            const f2 = 20 * t2, m2 = 10 * t2;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.int16[f2 + 4] = s2, this.float32[m2 + 3] = a2, this.float32[m2 + 4] = o2, this.float32[m2 + 5] = l2, this.float32[m2 + 6] = u2, this.int16[f2 + 14] = c2, this.uint32[m2 + 8] = h2, this.uint16[f2 + 18] = p2, this.uint16[f2 + 19] = d2, t2;
          }
        }
        il.prototype.bytesPerElement = 40, Qs(il, "StructArrayLayout5i4f1i1ul2ui40");
        class sl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = 8 * t2;
            return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
          }
        }
        sl.prototype.bytesPerElement = 16, Qs(sl, "StructArrayLayout3i2i2i16");
        class al extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
          }
        }
        al.prototype.bytesPerElement = 16, Qs(al, "StructArrayLayout2f1f2i16");
        class ol extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 20 * t2, l2 = 5 * t2;
            return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
          }
        }
        ol.prototype.bytesPerElement = 20, Qs(ol, "StructArrayLayout2ub4f20");
        class ll extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
          }
        }
        ll.prototype.bytesPerElement = 6, Qs(ll, "StructArrayLayout3ui6");
        class ul extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2) {
            const w2 = this.length;
            return this.resize(w2 + 1), this.emplace(w2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2, w2) {
            const _2 = 30 * t2, A2 = 15 * t2, M2 = 60 * t2;
            return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r2, this.int16[_2 + 2] = n2, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u2, this.uint32[A2 + 7] = c2, this.uint16[_2 + 16] = h2, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = d2, this.float32[A2 + 10] = f2, this.float32[A2 + 11] = m2, this.uint8[M2 + 48] = y2, this.uint8[M2 + 49] = g2, this.uint8[M2 + 50] = x2, this.uint32[A2 + 13] = v2, this.int16[_2 + 28] = b2, this.uint8[M2 + 58] = w2, t2;
          }
        }
        ul.prototype.bytesPerElement = 60, Qs(ul, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class cl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2, w2, _2, A2, M2, I2, S2, P2, z2, B2, k2, T2, V2) {
            const E2 = this.length;
            return this.resize(E2 + 1), this.emplace(E2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2, w2, _2, A2, M2, I2, S2, P2, z2, B2, k2, T2, V2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2, w2, _2, A2, M2, I2, S2, P2, z2, B2, k2, T2, V2, E2) {
            const F2 = 20 * t2, D2 = 40 * t2, C2 = 80 * t2;
            return this.float32[F2 + 0] = e2, this.float32[F2 + 1] = r2, this.int16[D2 + 4] = n2, this.int16[D2 + 5] = i2, this.int16[D2 + 6] = s2, this.int16[D2 + 7] = a2, this.int16[D2 + 8] = o2, this.int16[D2 + 9] = l2, this.int16[D2 + 10] = u2, this.int16[D2 + 11] = c2, this.int16[D2 + 12] = h2, this.uint16[D2 + 13] = p2, this.uint16[D2 + 14] = d2, this.uint16[D2 + 15] = f2, this.uint16[D2 + 16] = m2, this.uint16[D2 + 17] = y2, this.uint16[D2 + 18] = g2, this.uint16[D2 + 19] = x2, this.uint16[D2 + 20] = v2, this.uint16[D2 + 21] = b2, this.uint16[D2 + 22] = w2, this.uint16[D2 + 23] = _2, this.uint16[D2 + 24] = A2, this.uint16[D2 + 25] = M2, this.uint16[D2 + 26] = I2, this.uint16[D2 + 27] = S2, this.uint32[F2 + 14] = P2, this.float32[F2 + 15] = z2, this.float32[F2 + 16] = B2, this.float32[F2 + 17] = k2, this.float32[F2 + 18] = T2, this.uint8[C2 + 76] = V2, this.uint16[D2 + 39] = E2, t2;
          }
        }
        cl.prototype.bytesPerElement = 80, Qs(cl, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
        class hl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.float32[o2 + 0] = e2, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.float32[o2 + 3] = i2, this.float32[o2 + 4] = s2, this.float32[o2 + 5] = a2, t2;
          }
        }
        hl.prototype.bytesPerElement = 24, Qs(hl, "StructArrayLayout6f24");
        class pl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 5 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
          }
        }
        pl.prototype.bytesPerElement = 20, Qs(pl, "StructArrayLayout5f20");
        class dl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = 7 * t2;
            return this.float32[l2 + 0] = e2, this.float32[l2 + 1] = r2, this.float32[l2 + 2] = n2, this.float32[l2 + 3] = i2, this.float32[l2 + 4] = s2, this.float32[l2 + 5] = a2, this.float32[l2 + 6] = o2, t2;
          }
        }
        dl.prototype.bytesPerElement = 28, Qs(dl, "StructArrayLayout7f28");
        class fl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = this.length;
            return this.resize(h2 + 1), this.emplace(h2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            const p2 = 11 * t2;
            return this.float32[p2 + 0] = e2, this.float32[p2 + 1] = r2, this.float32[p2 + 2] = n2, this.float32[p2 + 3] = i2, this.float32[p2 + 4] = s2, this.float32[p2 + 5] = a2, this.float32[p2 + 6] = o2, this.float32[p2 + 7] = l2, this.float32[p2 + 8] = u2, this.float32[p2 + 9] = c2, this.float32[p2 + 10] = h2, t2;
          }
        }
        fl.prototype.bytesPerElement = 44, Qs(fl, "StructArrayLayout11f44");
        class ml extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = 9 * t2;
            return this.float32[c2 + 0] = e2, this.float32[c2 + 1] = r2, this.float32[c2 + 2] = n2, this.float32[c2 + 3] = i2, this.float32[c2 + 4] = s2, this.float32[c2 + 5] = a2, this.float32[c2 + 6] = o2, this.float32[c2 + 7] = l2, this.float32[c2 + 8] = u2, t2;
          }
        }
        ml.prototype.bytesPerElement = 36, Qs(ml, "StructArrayLayout9f36");
        class yl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
          }
        }
        yl.prototype.bytesPerElement = 8, Qs(yl, "StructArrayLayout2f8");
        class gl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 6 * t2;
            return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
          }
        }
        gl.prototype.bytesPerElement = 12, Qs(gl, "StructArrayLayout1ul3ui12");
        class xl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        xl.prototype.bytesPerElement = 2, Qs(xl, "StructArrayLayout1ui2");
        class vl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2) {
            const y2 = this.length;
            return this.resize(y2 + 1), this.emplace(y2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2) {
            const g2 = 16 * t2;
            return this.float32[g2 + 0] = e2, this.float32[g2 + 1] = r2, this.float32[g2 + 2] = n2, this.float32[g2 + 3] = i2, this.float32[g2 + 4] = s2, this.float32[g2 + 5] = a2, this.float32[g2 + 6] = o2, this.float32[g2 + 7] = l2, this.float32[g2 + 8] = u2, this.float32[g2 + 9] = c2, this.float32[g2 + 10] = h2, this.float32[g2 + 11] = p2, this.float32[g2 + 12] = d2, this.float32[g2 + 13] = f2, this.float32[g2 + 14] = m2, this.float32[g2 + 15] = y2, t2;
          }
        }
        vl.prototype.bytesPerElement = 64, Qs(vl, "StructArrayLayout16f64");
        class bl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = 10 * t2, u2 = 5 * t2;
            return this.uint16[l2 + 0] = e2, this.uint16[l2 + 1] = r2, this.uint16[l2 + 2] = n2, this.uint16[l2 + 3] = i2, this.float32[u2 + 2] = s2, this.float32[u2 + 3] = a2, this.float32[u2 + 4] = o2, t2;
          }
        }
        bl.prototype.bytesPerElement = 20, Qs(bl, "StructArrayLayout4ui3f20");
        class wl extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.int16[1 * t2 + 0] = e2, t2;
          }
        }
        wl.prototype.bytesPerElement = 2, Qs(wl, "StructArrayLayout1i2");
        class _l extends Lo {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint8[1 * t2 + 0] = e2, t2;
          }
        }
        _l.prototype.bytesPerElement = 1, Qs(_l, "StructArrayLayout1ub1");
        class Al extends Co {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        Al.prototype.size = 40;
        class Ml extends il {
          get(t2) {
            return new Al(this, t2);
          }
        }
        Qs(Ml, "CollisionBoxArray");
        class Il extends Co {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 49] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 50] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 13] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t2) {
            this._structArray.uint8[this._pos1 + 58] = t2;
          }
        }
        Il.prototype.size = 60;
        class Sl extends ul {
          get(t2) {
            return new Il(this, t2);
          }
        }
        Qs(Sl, "PlacedSymbolArray");
        class Pl extends Co {
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 0];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 14];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 14] = t2;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get zOffset() {
            return this._structArray.float32[this._pos4 + 18];
          }
          set zOffset(t2) {
            this._structArray.float32[this._pos4 + 18] = t2;
          }
          get hasIconTextFit() {
            return this._structArray.uint8[this._pos1 + 76];
          }
          get elevationFeatureIndex() {
            return this._structArray.uint16[this._pos2 + 39];
          }
        }
        Pl.prototype.size = 80;
        class zl extends cl {
          get(t2) {
            return new Pl(this, t2);
          }
        }
        Qs(zl, "SymbolInstanceArray");
        class Bl extends $o {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        Qs(Bl, "GlyphOffsetArray");
        class kl extends No {
          getx(t2) {
            return this.int16[2 * t2 + 0];
          }
          gety(t2) {
            return this.int16[2 * t2 + 1];
          }
        }
        Qs(kl, "SymbolLineVertexArray");
        class Tl extends Co {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        Tl.prototype.size = 12;
        class Vl extends gl {
          get(t2) {
            return new Tl(this, t2);
          }
        }
        Qs(Vl, "FeatureIndexArray");
        class El extends nl {
          geta_centroid_pos0(t2) {
            return this.uint16[2 * t2 + 0];
          }
          geta_centroid_pos1(t2) {
            return this.uint16[2 * t2 + 1];
          }
        }
        Qs(El, "FillExtrusionCentroidArray");
        class Fl extends Co {
          get a_join_normal_inside0() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get a_join_normal_inside1() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get a_join_normal_inside2() {
            return this._structArray.int16[this._pos2 + 2];
          }
        }
        Fl.prototype.size = 6;
        class Dl extends jo {
          get(t2) {
            return new Fl(this, t2);
          }
        }
        Qs(Dl, "FillExtrusionWallArray");
        const Cl = Oo([{ name: "a_pos", components: 2, type: "Int16" }], 4), Rl = Oo([{ name: "a_circle_z_offset", components: 1, type: "Float32" }], 4), Ll = Oo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class Ol {
          constructor(t2 = []) {
            this.segments = t2;
          }
          _prepareSegment(t2, e2, r2, n2) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > Ol.MAX_VERTEX_ARRAY_LENGTH && Zt(`Max vertices per segment is ${Ol.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > Ol.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2, primitiveOffset: r2, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }
          prepareSegment(t2, e2, r2, n2) {
            return this._prepareSegment(t2, e2.length, r2.length, n2);
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments) for (const e2 in t2.vaos) t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r2, n2) {
            return new Ol([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function Ul(t2, e2) {
          return 256 * (t2 = Dt(Math.floor(t2), 0, 255)) + Dt(Math.floor(e2), 0, 255);
        }
        Ol.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Qs(Ol, "SegmentVector");
        const Nl = Oo([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), jl = Oo([{ name: "a_pattern_b", components: 4, type: "Uint16" }]), Gl = Oo([{ name: "a_dash", components: 4, type: "Uint16" }]);
        class $l {
          constructor() {
            this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
          }
          add(t2, e2, r2, n2) {
            this.ids.push(ql(t2)), this.positions.push(e2, r2, n2);
          }
          eachPosition(t2, e2) {
            const r2 = ql(t2);
            let n2 = 0, i2 = this.ids.length - 1;
            for (; n2 < i2; ) {
              const t3 = n2 + i2 >> 1;
              this.ids[t3] >= r2 ? i2 = t3 : n2 = t3 + 1;
            }
            for (; this.ids[n2] === r2; ) e2(this.positions[3 * n2], this.positions[3 * n2 + 1], this.positions[3 * n2 + 2]), n2++;
          }
          static serialize(t2, e2) {
            const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return Xl(r2, n2, 0, r2.length - 1), e2 && (e2.add(r2.buffer), e2.add(n2.buffer)), { ids: r2, positions: n2 };
          }
          static deserialize(t2) {
            const e2 = new $l();
            let r2;
            e2.ids = t2.ids, e2.positions = t2.positions;
            for (const t3 of e2.ids) t3 !== r2 && e2.uniqueIds.push(t3), r2 = t3;
            return e2.indexed = true, e2;
          }
        }
        function ql(t2) {
          const e2 = +t2;
          return Number.isSafeInteger(e2) ? e2 : Qe(String(t2));
        }
        function Xl(t2, e2, r2, n2) {
          for (; r2 < n2; ) {
            const i2 = t2[r2 + n2 >> 1];
            let s2 = r2 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s2++;
              } while (t2[s2] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s2 >= a2) break;
              Hl(t2, s2, a2), Hl(e2, 3 * s2, 3 * a2), Hl(e2, 3 * s2 + 1, 3 * a2 + 1), Hl(e2, 3 * s2 + 2, 3 * a2 + 2);
            }
            a2 - r2 < n2 - a2 ? (Xl(t2, e2, r2, a2), r2 = a2 + 1) : (Xl(t2, e2, a2 + 1, n2), n2 = a2);
          }
        }
        function Hl(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        Qs($l, "FeaturePositionMap");
        class Zl {
          constructor(t2) {
            this.gl = t2.gl, this.initialized = false;
          }
          fetchUniformLocation(t2, e2) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
          }
          set(t2, e2, r2) {
            throw new Error("Uniform#set() must be implemented by each concrete Uniform");
          }
        }
        class Wl extends Zl {
          constructor(t2) {
            super(t2), this.current = 0;
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
          }
        }
        class Yl extends Zl {
          constructor(t2) {
            super(t2), this.current = 0;
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
          }
        }
        class Jl extends Zl {
          constructor(t2) {
            super(t2), this.current = [0, 0];
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
          }
        }
        class Kl extends Zl {
          constructor(t2) {
            super(t2), this.current = [0, 0, 0];
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
          }
        }
        class Ql extends Zl {
          constructor(t2) {
            super(t2), this.current = [0, 0, 0, 0];
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
          }
        }
        class tu extends Zl {
          constructor(t2) {
            super(t2), this.current = ur.transparent.toPremultipliedRenderColor(null);
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
          }
        }
        const eu = new Float32Array(16);
        class ru extends Zl {
          constructor(t2) {
            super(t2), this.current = eu;
          }
          set(t2, e2, r2) {
            if (this.fetchUniformLocation(t2, e2)) {
              if (r2[12] !== this.current[12] || r2[0] !== this.current[0]) return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
              for (let t3 = 1; t3 < 16; t3++) if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                break;
              }
            }
          }
        }
        const nu = new Float32Array(9), iu = new Float32Array(4);
        class su extends Zl {
          constructor(t2) {
            super(t2), this.current = iu;
          }
          set(t2, e2, r2) {
            if (this.fetchUniformLocation(t2, e2)) {
              for (let t3 = 0; t3 < 4; t3++) if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                break;
              }
            }
          }
        }
        function au(t2) {
          return [Ul(255 * t2.r, 255 * t2.g), Ul(255 * t2.b, 255 * t2.a)];
        }
        function ou(t2, e2, r2, n2, i2, s2, a2, o2) {
          return !!t2 && ("composite" === t2.kind || "source" === t2.kind ? "none" === t2.evaluate(new Ja(0, { brightness: s2, worldview: o2 }), e2, r2, i2, n2, a2) : "none" === t2.value);
        }
        class lu {
          constructor(t2, e2, r2, n2) {
            this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2, this.context = n2;
          }
          setUniform(t2, e2, r2, n2, i2) {
            const s2 = n2.constantOr(this.value);
            e2.set(t2, i2, s2 instanceof ur ? s2.toPremultipliedRenderColor(this.lutExpression && "constant" === this.lutExpression.kind && "none" === this.lutExpression.value ? null : this.context.lut) : s2);
          }
          getBinding(t2, e2) {
            return "color" === this.type ? new tu(t2) : new Yl(t2);
          }
        }
        class uu {
          constructor(t2, e2) {
            this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(t2, e2) {
            this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br), this.patternTransition = e2 ? e2.tl.concat(e2.br) : this.pattern;
          }
          setUniform(t2, e2, r2, n2, i2) {
            let s2 = null;
            "u_pattern" !== i2 && "u_dash" !== i2 || (s2 = this.pattern), "u_pattern_b" === i2 && (s2 = this.patternTransition), "u_pixel_ratio" === i2 && (s2 = this.pixelRatio), s2 && e2.set(t2, i2, s2);
          }
          getBinding(t2, e2) {
            return "u_pattern" === e2 || "u_pattern_b" === e2 || "u_dash" === e2 ? new Ql(t2) : new Yl(t2);
          }
        }
        class cu {
          constructor(t2, e2, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.paintVertexArray.length, u2 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate(new Ja(0, { brightness: s2, worldview: o2 }), e2, {}, i2, n2, a2) : "constant" === this.expression.kind && this.expression.value, c2 = ou(this.lutExpression, e2, {}, n2, i2, s2, a2, o2);
            this.paintVertexArray.resize(t2), this._setPaintValue(l2, t2, u2, c2 ? null : this.context.lut);
          }
          updatePaintArray(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate({ zoom: 0, brightness: a2, worldview: o2 }, r2, n2, void 0, i2) : "constant" === this.expression.kind && this.expression.value, u2 = ou(this.lutExpression, r2, n2, i2, void 0, a2, void 0, o2);
            this._setPaintValue(t2, e2, l2, u2 ? null : this.context.lut);
          }
          _setPaintValue(t2, e2, r2, n2) {
            if ("color" === this.type) {
              const i2 = au(r2.toPremultipliedRenderColor(n2));
              for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, i2[0], i2[1]);
            } else {
              for (let n3 = t2; n3 < e2; n3++) this.paintVertexArray.emplace(n3, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && "constant" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || "constant" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class hu {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.context = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
          }
          populatePaintArray(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.expression.evaluate(new Ja(this.context.zoom, { brightness: s2, worldview: o2 }), e2, {}, i2, n2, a2), u2 = this.expression.evaluate(new Ja(this.context.zoom + 1, { brightness: s2, worldview: o2 }), e2, {}, i2, n2, a2), c2 = ou(this.lutExpression, e2, {}, n2, i2, s2, a2, o2), h2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(h2, t2, l2, u2, c2 ? null : this.context.lut);
          }
          updatePaintArray(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.expression.evaluate({ zoom: this.context.zoom, brightness: a2, worldview: o2 }, r2, n2, void 0, i2), u2 = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: a2, worldview: o2 }, r2, n2, void 0, i2), c2 = ou(this.lutExpression, r2, n2, i2, void 0, a2, void 0, o2);
            this._setPaintValue(t2, e2, l2, u2, c2 ? null : this.context.lut);
          }
          _setPaintValue(t2, e2, r2, n2, i2) {
            if ("color" === this.type) {
              const s2 = au(r2.toPremultipliedRenderColor(i2)), a2 = au(n2.toPremultipliedRenderColor(i2));
              for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, s2[0], s2[1], a2[0], a2[1]);
            } else {
              for (let i3 = t2; i3 < e2; i3++) this.paintVertexArray.emplace(i3, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2, r2, n2, i2) {
            const s2 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, a2 = Dt(this.expression.interpolationFactor(s2, this.context.zoom, this.context.zoom + 1), 0, 1);
            e2.set(t2, i2, a2);
          }
          getBinding(t2, e2) {
            return new Yl(t2);
          }
        }
        class pu {
          constructor(t2, e2, r2, n2, i2) {
            this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r2 ? Gl : Nl).members;
            for (let t3 = 0; t3 < e2.length; ++t3) ;
            this.paintVertexArray = new n2(), this.paintTransitionVertexArray = new Jo();
          }
          populatePaintArray(t2, e2, r2, n2) {
            const i2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValues(i2, t2, e2.patterns && e2.patterns[this.layerId], r2);
          }
          updatePaintArray(t2, e2, r2, n2, i2, s2, a2) {
            this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], s2);
          }
          _setPaintValues(t2, e2, r2, n2) {
            if (!n2 || !r2) return;
            const i2 = n2[r2[0]], s2 = n2[r2[1]];
            if (i2) {
              if (i2) {
                const { tl: r3, br: n3, pixelRatio: s3 } = i2;
                for (let i3 = t2; i3 < e2; i3++) this.paintVertexArray.emplace(i3, r3[0], r3[1], n3[0], n3[1], s3);
              }
              if (s2) {
                this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
                const { tl: r3, br: n3 } = s2;
                for (let i3 = t2; i3 < e2; i3++) this.paintTransitionVertexArray.emplace(i3, r3[0], r3[1], n3[0], n3[1]);
              }
            }
          }
          upload(t2) {
            const e2 = this.expression.isStateDependent || !this.expression.isLightConstant;
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e2)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t2.createVertexBuffer(this.paintTransitionVertexArray, jl.members, e2));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();
          }
        }
        class du {
          constructor(t2, e2, r2 = () => true) {
            this.binders = {}, this._buffers = [], this.context = e2;
            const n2 = [];
            for (const i2 in t2.paint._values) {
              const s2 = t2.paint.get(i2);
              if (i2.endsWith("-use-theme")) continue;
              if (!r2(i2)) continue;
              if (!(s2 instanceof io && zs(s2.property.specification))) continue;
              const a2 = yu(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = !!s2.property.useIntegerZoom, c2 = "line-dasharray" === i2 || i2.endsWith("pattern"), h2 = t2.paint.get(`${i2}-use-theme`), p2 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind || h2 && "constant" !== h2.value.kind;
              if ("constant" !== o2.kind || p2) if ("source" === o2.kind || p2 || c2) {
                const e3 = vu(i2, l2, "source");
                this.binders[i2] = c2 ? new pu(o2, a2, l2, e3, t2.id) : new cu(o2, a2, l2, e3), n2.push(`/a_${i2}`);
              } else {
                const t3 = vu(i2, l2, "composite");
                this.binders[i2] = new hu(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
              else this.binders[i2] = c2 ? new uu(o2.value, a2) : new lu(o2.value, a2, l2, e2), n2.push(`/u_${i2}`);
              h2 && (this.binders[i2].lutExpression = h2.value);
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof cu || e2 instanceof hu ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2) {
            for (const l2 in this.binders) {
              const u2 = this.binders[l2];
              u2.context = this.context, (u2 instanceof cu || u2 instanceof hu || u2 instanceof pu) && u2.populatePaintArray(t2, e2, r2, n2, i2, s2, a2, o2);
            }
          }
          setConstantPatternPositions(t2, e2) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof uu && n2.setConstantPatternPositions(t2, e2);
            }
          }
          getPatternTransitionVertexBuffer(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof pu ? e2.paintTransitionVertexBuffer : null;
          }
          updatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            let c2 = false;
            const h2 = Object.keys(t2), p2 = 0 !== h2.length && !o2, d2 = p2 ? h2 : e2.uniqueIds;
            this.context.lut = i2.lut;
            for (const o3 in this.binders) {
              const h3 = this.binders[o3];
              if (h3.context = this.context, (h3 instanceof cu || h3 instanceof hu || h3 instanceof pu) && h3.expression && h3.expression.kind && "constant" !== h3.expression.kind && (true === h3.expression.isStateDependent || false === h3.expression.isLightConstant)) {
                const f2 = i2.paint.get(o3);
                h3.expression = f2.value;
                for (const r3 of d2) {
                  const i3 = t2[r3.toString()];
                  e2.eachPosition(r3, (t3, e3, r4) => {
                    const o4 = n2.feature(t3);
                    h3.updatePaintArray(e3, r4, o4, i3, s2, a2, l2, u2);
                  });
                }
                if (!p2) for (const e3 of r2.uniqueIds) {
                  const i3 = t2[e3.toString()];
                  r2.eachPosition(e3, (t3, e4, r3) => {
                    const o4 = n2.feature(t3);
                    h3.updatePaintArray(e4, r3, o4, i3, s2, a2, l2, u2);
                  });
                }
                c2 = true;
              }
            }
            return c2;
          }
          defines() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof lu || r2 instanceof uu) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2) {
            const e2 = [];
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              if (n2 instanceof lu || n2 instanceof uu || n2 instanceof hu) for (const i2 of n2.uniformNames) e2.push({ name: i2, property: r2, binding: n2.getBinding(t2, i2) });
            }
            return e2;
          }
          setUniforms(t2, e2, r2, n2, i2) {
            for (const { name: e3, property: s2, binding: a2 } of r2) this.binders[s2].setUniform(t2, a2, i2, n2.get(s2), e3);
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof cu || e2 instanceof hu || e2 instanceof pu) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer), e2 instanceof pu && e2.paintTransitionVertexBuffer && this._buffers.push(e2.paintTransitionVertexBuffer);
            }
          }
          upload(t2) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof cu || r2 instanceof hu || r2 instanceof pu) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof cu || e2 instanceof hu || e2 instanceof pu) && e2.destroy();
            }
          }
        }
        class fu {
          constructor(t2, e2, r2 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t2) this.programConfigurations[n2.id] = new du(n2, e2, r2);
            this.needsUpload = false, this._featureMap = new $l(), this._featureMapWithoutIds = new $l(), this._bufferOffset = 0, this._idlessCounter = 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2, a2, o2, l2);
            void 0 !== e2.id ? this._featureMap.add(e2.id, r2, this._bufferOffset, t2) : (this._featureMapWithoutIds.add(this._idlessCounter, r2, this._bufferOffset, t2), this._idlessCounter += 1), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2) {
            for (const l2 of r2) this.needsUpload = this.programConfigurations[l2.id].updatePaintArrays(t2, this._featureMap, this._featureMapWithoutIds, e2, l2, n2, i2, s2, a2 || 0, o2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations) this.programConfigurations[t2].destroy();
          }
        }
        const mu = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-extrusion-pattern": ["pattern", "pixel_ratio", "pattern_b"], "line-dasharray": ["dash"], "fill-bridge-guard-rail-color": ["structure_color"], "fill-tunnel-structure-color": ["structure_color"] };
        function yu(t2, e2) {
          return mu[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        const gu = { "line-pattern": { source: Yo, composite: Yo }, "fill-pattern": { source: Yo, composite: Yo }, "fill-extrusion-pattern": { source: Yo, composite: Yo }, "line-dasharray": { source: Jo, composite: Jo } }, xu = { color: { source: yl, composite: el }, number: { source: $o, composite: yl } };
        function vu(t2, e2, r2) {
          const n2 = gu[t2];
          return n2 && n2[r2] || xu[e2][r2];
        }
        Qs(lu, "ConstantBinder"), Qs(uu, "PatternConstantBinder"), Qs(cu, "SourceExpressionBinder"), Qs(pu, "PatternCompositeBinder"), Qs(hu, "CompositeExpressionBinder"), Qs(du, "ProgramConfiguration", { omit: ["_buffers"] }), Qs(fu, "ProgramConfigurationSet");
        const bu = jn / Math.PI / 2, wu = 64, _u = [wu, 32, 16], Au = -bu, Mu = bu;
        function Iu(t2, e2, r2, n2 = bu) {
          return r2 = Bt(r2), [t2 * Math.sin(r2) * n2, -e2 * n2, t2 * Math.cos(r2) * n2];
        }
        function Su(t2, e2, r2) {
          return Iu(Math.cos(Bt(t2)), Math.sin(Bt(t2)), e2, r2);
        }
        const Pu = 63710088e-1, zu = 2 * Math.PI * Pu;
        class Bu {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Bu(Rt(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return Pu * Math.acos(Math.min(i2, 1));
          }
          toBounds(t2 = 0) {
            const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
            return new ku({ lng: this.lng - r2, lat: this.lat - e2 }, { lng: this.lng + r2, lat: this.lat + e2 });
          }
          toEcef(t2) {
            return Su(this.lat, this.lng, bu + t2 * bu / Pu);
          }
          static convert(t2) {
            if (t2 instanceof Bu) return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length)) return new Bu(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2) return new Bu(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class ku {
          constructor(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : Array.isArray(t2) && 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof Bu ? new Bu(t2.lng, t2.lat) : Bu.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof Bu ? new Bu(t2.lng, t2.lat) : Bu.convert(t2), this;
          }
          extend(t2) {
            const e2 = this._sw, r2 = this._ne;
            let n2, i2;
            if (t2 instanceof Bu) n2 = t2, i2 = t2;
            else {
              if (!(t2 instanceof ku)) return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(ku.convert(t2)) : this.extend(Bu.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend(Bu.convert(t2)) : this;
              if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2) return this;
            }
            return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Bu(n2.lng, n2.lat), this._ne = new Bu(i2.lng, i2.lat)), this;
          }
          getCenter() {
            return new Bu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new Bu(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new Bu(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            const { lng: e2, lat: r2 } = Bu.convert(t2);
            let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
          }
          static convert(t2) {
            if (t2) return t2 instanceof ku ? t2 : new ku(t2);
          }
        }
        function Tu(t2) {
          return zu * Math.cos(t2 * Math.PI / 180);
        }
        function Vu(t2) {
          return (180 + t2) / 360;
        }
        function Eu(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Fu(t2, e2) {
          return t2 / Tu(e2);
        }
        function Du(t2) {
          return 360 * t2 - 180;
        }
        function Cu(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        function Ru(t2, e2) {
          return t2 * Tu(Cu(e2));
        }
        const Lu = 85.051129;
        function Ou(t2) {
          return Math.cos(Bt(Dt(t2, -85.051129, Lu)));
        }
        function Uu(t2, e2) {
          const r2 = Dt(e2, 0, 25.5), n2 = Math.pow(2, r2);
          return Ou(t2) * zu / (512 * n2);
        }
        function Nu(t2) {
          return 1 / Math.cos(t2 * Math.PI / 180);
        }
        function ju(t2, e2 = 0) {
          const r2 = Math.exp(Math.PI * (1 - (t2.y + e2 / jn) / (1 << t2.z) * 2));
          return 80150034 * r2 / (r2 * r2 + 1) / jn / (1 << t2.z);
        }
        class Gu {
          constructor(t2, e2, r2 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t2, e2 = 0) {
            const r2 = Bu.convert(t2);
            return new Gu(Vu(r2.lng), Eu(r2.lat), Fu(e2, r2.lat));
          }
          toLngLat() {
            return new Bu(Du(this.x), Cu(this.y));
          }
          toAltitude() {
            return Ru(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / zu * Nu(Cu(this.y));
          }
        }
        function $u(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = (e2 + n2) / 2, c2 = (r2 + i2) / 2, h2 = new It(u2, c2);
          o2(h2), function(t3, e3, r3, n3, i3, s3) {
            const a3 = r3 - i3, o3 = n3 - s3;
            return Math.abs((n3 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
          }(h2.x, h2.y, s2.x, s2.y, a2.x, a2.y) >= l2 ? ($u(t2, e2, r2, u2, c2, s2, h2, o2, l2), $u(t2, u2, c2, n2, i2, h2, a2, o2, l2)) : t2.push(a2);
        }
        function qu(t2, e2, r2) {
          let n2 = t2[0], i2 = n2.x, s2 = n2.y;
          e2(n2);
          const a2 = [n2];
          for (let o2 = 1; o2 < t2.length; o2++) {
            const l2 = t2[o2], { x: u2, y: c2 } = l2;
            e2(l2), $u(a2, i2, s2, u2, c2, n2, l2, e2, r2), i2 = u2, s2 = c2, n2 = l2;
          }
          return a2;
        }
        function Xu(t2, e2, r2, n2) {
          if (n2(e2, r2)) {
            const i2 = e2.add(r2)._mult(0.5);
            Xu(t2, e2, i2, n2), Xu(t2, i2, r2, n2);
          } else t2.push(r2);
        }
        function Hu(t2, e2) {
          let r2 = t2[0];
          const n2 = [r2];
          for (let i2 = 1; i2 < t2.length; i2++) {
            const s2 = t2[i2];
            Xu(n2, r2, s2, e2), r2 = s2;
          }
          return n2;
        }
        const Zu = Math.pow(2, 14) - 1, Wu = -Zu - 1;
        function Yu(t2, e2) {
          const r2 = Math.round(t2.x * e2), n2 = Math.round(t2.y * e2);
          return t2.x = Dt(r2, Wu, Zu), t2.y = Dt(n2, Wu, Zu), (r2 < t2.x || r2 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && Zt("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
        }
        function Ju(t2, e2, r2) {
          const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = jn / i2;
          if (e2 && r2 && r2.projection.isReprojectedInTileSpace) {
            const s3 = 1 << e2.z, { scale: a2, x: o2, y: l2, projection: u2 } = r2, c2 = (t3) => {
              const r3 = Du((e2.x + t3.x / i2) / s3), n3 = Cu((e2.y + t3.y / i2) / s3), c3 = u2.project(r3, n3);
              t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l2) * i2;
            };
            for (let e3 = 0; e3 < n2.length; e3++) if (1 !== t2.type) n2[e3] = qu(n2[e3], c2, 1);
            else {
              const t3 = [];
              for (const r3 of n2[e3]) r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c2(r3), t3.push(r3));
              n2[e3] = t3;
            }
          }
          for (const t3 of n2) for (const e3 of t3) Yu(e3, s2);
          return n2;
        }
        function Ku(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ju(t2) : [] };
        }
        class Qu {
          constructor(t2, e2, r2, n2, i2) {
            this.properties = {}, this.extent = r2, this.type = 0, this.id = void 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(tc, this, e2);
          }
          loadGeometry() {
            const t2 = this._pbf;
            t2.pos = this._geometry;
            const e2 = t2.readVarint() + t2.pos, r2 = [];
            let n2, i2 = 1, s2 = 0, a2 = 0, o2 = 0;
            for (; t2.pos < e2; ) {
              if (s2 <= 0) {
                const e3 = t2.readVarint();
                i2 = 7 & e3, s2 = e3 >> 3;
              }
              if (s2--, 1 === i2 || 2 === i2) a2 += t2.readSVarint(), o2 += t2.readSVarint(), 1 === i2 && (n2 && r2.push(n2), n2 = []), n2 && n2.push(new It(a2, o2));
              else {
                if (7 !== i2) throw new Error(`unknown command ${i2}`);
                n2 && n2.push(n2[0].clone());
              }
            }
            return n2 && r2.push(n2), r2;
          }
          bbox() {
            const t2 = this._pbf;
            t2.pos = this._geometry;
            const e2 = t2.readVarint() + t2.pos;
            let r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0;
            for (; t2.pos < e2; ) {
              if (n2 <= 0) {
                const e3 = t2.readVarint();
                r2 = 7 & e3, n2 = e3 >> 3;
              }
              if (n2--, 1 === r2 || 2 === r2) i2 += t2.readSVarint(), s2 += t2.readSVarint(), i2 < a2 && (a2 = i2), i2 > o2 && (o2 = i2), s2 < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
              else if (7 !== r2) throw new Error(`unknown command ${r2}`);
            }
            return [a2, l2, o2, u2];
          }
          toGeoJSON(t2, e2, r2) {
            const n2 = this.extent * Math.pow(2, r2), i2 = this.extent * t2, s2 = this.extent * e2, a2 = this.loadGeometry();
            function o2(t3) {
              return [360 * (t3.x + i2) / n2 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t3.y + s2) / n2) * Math.PI)) - 90];
            }
            function l2(t3) {
              return t3.map(o2);
            }
            let u2;
            if (1 === this.type) {
              const t3 = [];
              for (const e4 of a2) t3.push(e4[0]);
              const e3 = l2(t3);
              u2 = 1 === t3.length ? { type: "Point", coordinates: e3[0] } : { type: "MultiPoint", coordinates: e3 };
            } else if (2 === this.type) {
              const t3 = a2.map(l2);
              u2 = 1 === t3.length ? { type: "LineString", coordinates: t3[0] } : { type: "MultiLineString", coordinates: t3 };
            } else {
              if (3 !== this.type) throw new Error("unknown feature type");
              {
                const t3 = function(t4) {
                  const e4 = t4.length;
                  if (e4 <= 1) return [t4];
                  const r3 = [];
                  let n3, i3;
                  for (let s3 = 0; s3 < e4; s3++) {
                    const e5 = ec(t4[s3]);
                    0 !== e5 && (void 0 === i3 && (i3 = e5 < 0), i3 === e5 < 0 ? (n3 && r3.push(n3), n3 = [t4[s3]]) : n3 && n3.push(t4[s3]));
                  }
                  return n3 && r3.push(n3), r3;
                }(a2), e3 = [];
                for (const r3 of t3) e3.push(r3.map(l2));
                u2 = 1 === e3.length ? { type: "Polygon", coordinates: e3[0] } : { type: "MultiPolygon", coordinates: e3 };
              }
            }
            const c2 = { type: "Feature", geometry: u2, properties: this.properties };
            return null != this.id && (c2.id = this.id), c2;
          }
        }
        function tc(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? function(t3, e3) {
            const r3 = t3.readVarint() + t3.pos;
            for (; t3.pos < r3; ) {
              const r4 = e3._keys[t3.readVarint()], n2 = e3._values[t3.readVarint()];
              e3.properties[r4] = n2;
            }
          }(r2, e2) : 3 === t2 ? e2.type = r2.readVarint() : 4 === t2 && (e2._geometry = r2.pos);
        }
        function ec(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        Qu.types = ["Unknown", "Point", "LineString", "Polygon"];
        class rc {
          constructor(t2, e2) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(nc, this, e2), this.length = this._features.length;
          }
          feature(t2) {
            if (t2 < 0 || t2 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            const e2 = this._pbf.readVarint() + this._pbf.pos;
            return new Qu(this._pbf, e2, this.extent, this._keys, this._values);
          }
        }
        function nc(t2, e2, r2) {
          15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
            let e3 = null;
            const r3 = t3.readVarint() + t3.pos;
            for (; t3.pos < r3; ) {
              const r4 = t3.readVarint() >> 3;
              e3 = 1 === r4 ? t3.readString() : 2 === r4 ? t3.readFloat() : 3 === r4 ? t3.readDouble() : 4 === r4 ? t3.readVarint64() : 5 === r4 ? t3.readVarint() : 6 === r4 ? t3.readSVarint() : 7 === r4 ? t3.readBoolean() : null;
            }
            if (null == e3) throw new Error("unknown feature value");
            return e3;
          }(r2));
        }
        class ic {
          constructor(t2, e2) {
            this.layers = t2.readFields(sc, {}, e2);
          }
        }
        function sc(t2, e2, r2) {
          if (3 === t2) {
            const t3 = new rc(r2, r2.readVarint() + r2.pos);
            t3.length && (e2[t3.name] = t3);
          }
        }
        const ac = "3d_elevation_id", oc = "level";
        class lc {
          constructor() {
            this._valid = false;
          }
          reset(t2) {
            return this.feature = t2, this._valid = true, this._geometry = t2.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = false), this;
          }
          geometry(t2, e2) {
            return this._valid && t2(e2(this._geometry)), this;
          }
          require(t2, e2, r2) {
            return this.get(t2, true, e2, r2);
          }
          optional(t2, e2, r2) {
            return this.get(t2, false, e2, r2);
          }
          success() {
            return this._valid;
          }
          get(t2, e2, r2, n2) {
            const i2 = this.feature.properties.hasOwnProperty(t2) ? +this.feature.properties[t2] : void 0;
            return this._valid && void 0 !== i2 && !Number.isNaN(i2) ? r2(n2 ? n2(i2) : i2) : e2 && (this._valid = false), this;
          }
        }
        class uc {
          constructor(t2, e2) {
            this.featureFunc = t2, this.vertexFunc = e2;
          }
          parseFeature(t2, e2, r2) {
            return this.featureFunc(t2, e2, r2);
          }
          parseVertex(t2, e2, r2) {
            return this.vertexFunc(t2, e2, r2);
          }
        }
        const cc = new uc((t2, e2, r2) => t2.reset(e2).require(ac, (t3) => {
          r2.id = t3;
        }).optional("fixed_height_relative", (t3) => {
          r2.constantHeight = t3;
        }, pc.decodeRelativeHeight).geometry((t3) => {
          r2.bounds = t3;
        }, bn).success(), (t2, e2, r2) => t2.reset(e2).require(ac, (t3) => {
          r2.id = t3;
        }).require("elevation_idx", (t3) => {
          r2.idx = t3;
        }).require("extent", (t3) => {
          r2.extent = t3;
        }).require("height_relative", (t3) => {
          r2.height = t3;
        }, pc.decodeRelativeHeight).geometry((t3) => {
          r2.position = t3;
        }, pc.getPoint).success()), hc = new uc((t2, e2, r2) => t2.reset(e2).require(ac, (t3) => {
          r2.id = t3;
        }).optional("fixed_height", (t3) => {
          r2.constantHeight = t3;
        }, pc.decodeMetricHeight).geometry((t3) => {
          r2.bounds = t3;
        }, bn).success(), (t2, e2, r2) => t2.reset(e2).require(ac, (t3) => {
          r2.id = t3;
        }).require("elevation_idx", (t3) => {
          r2.idx = t3;
        }).require("extent", (t3) => {
          r2.extent = t3;
        }).require("height", (t3) => {
          r2.height = t3;
        }, pc.decodeMetricHeight).geometry((t3) => {
          r2.position = t3;
        }, pc.getPoint).success());
        class pc {
          static getPoint(t2) {
            return ht(t2[0][0].x, t2[0][0].y);
          }
          static decodeRelativeHeight(t2) {
            return 1e-4 * t2 * 5;
          }
          static decodeMetricHeight(t2) {
            return 1e-4 * t2;
          }
          static getVersionSchema(t2) {
            return t2 ? "1.0.1" === t2 ? hc : void 0 : cc;
          }
          static parse(t2) {
            const e2 = [], r2 = [], n2 = t2.length, i2 = new lc();
            for (let s2 = 0; s2 < n2; s2++) {
              const n3 = t2.feature(s2), a2 = n3.properties.version, o2 = pc.getVersionSchema(a2);
              if (void 0 === o2) {
                Zt(`Unknown elevation feature version number ${a2 || "(unknown)"}`);
                continue;
              }
              const l2 = n3.properties.type;
              if (!l2) continue;
              const u2 = Qu.types[n3.type];
              if ("Point" === u2 && "curve_point" === l2) {
                const t3 = {};
                o2.parseVertex(i2, n3, t3) && e2.push(t3);
              } else if ("Polygon" === u2 && "curve_meta" === l2) {
                const t3 = {};
                o2.parseFeature(i2, n3, t3) && r2.push(t3);
              }
            }
            return { vertices: e2, features: r2 };
          }
        }
        class dc {
          constructor(t2, e2) {
            this.pos = t2, this.dir = e2;
          }
          intersectsPlane(t2, e2, r2) {
            const n2 = xt(e2, this.dir);
            if (Math.abs(n2) < 1e-6) return false;
            const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1]) / n2;
            return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, true;
          }
        }
        class fc {
          constructor(t2, e2) {
            this.pos = t2, this.dir = e2;
          }
          intersectsPlane(t2, e2, r2) {
            const n2 = O(e2, this.dir);
            if (Math.abs(n2) < 1e-6) return false;
            const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n2;
            return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, r2[2] = this.pos[2] + this.dir[2] * i2, true;
          }
          closestPointOnSphere(t2, r2, n2) {
            if (function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s3 = t3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2];
              return Math.abs(n3 - a3) <= e * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= e * Math.max(1, Math.abs(i3), Math.abs(o3)) && Math.abs(s3 - l3) <= e * Math.max(1, Math.abs(s3), Math.abs(l3));
            }(this.pos, t2) || 0 === r2) return n2[0] = n2[1] = n2[2] = 0, false;
            const [i2, s2, a2] = this.dir, o2 = this.pos[0] - t2[0], l2 = this.pos[1] - t2[1], u2 = this.pos[2] - t2[2], c2 = i2 * i2 + s2 * s2 + a2 * a2, h2 = 2 * (o2 * i2 + l2 * s2 + u2 * a2), p2 = h2 * h2 - 4 * c2 * (o2 * o2 + l2 * l2 + u2 * u2 - r2 * r2);
            if (p2 < 0) {
              const t3 = Math.max(-h2 / 2, 0), e2 = o2 + i2 * t3, c3 = l2 + s2 * t3, p3 = u2 + a2 * t3, d2 = Math.hypot(e2, c3, p3);
              return n2[0] = e2 * r2 / d2, n2[1] = c3 * r2 / d2, n2[2] = p3 * r2 / d2, false;
            }
            {
              const t3 = (-h2 - Math.sqrt(p2)) / (2 * c2);
              if (t3 < 0) {
                const t4 = Math.hypot(o2, l2, u2);
                return n2[0] = o2 * r2 / t4, n2[1] = l2 * r2 / t4, n2[2] = u2 * r2 / t4, false;
              }
              return n2[0] = o2 + i2 * t3, n2[1] = l2 + s2 * t3, n2[2] = u2 + a2 * t3, true;
            }
          }
        }
        class mc {
          constructor(t2, e2, r2, n2, i2) {
            this.TL = t2, this.TR = e2, this.BR = r2, this.BL = n2, this.horizon = i2;
          }
          static fromInvProjectionMatrix(t2, e2, r2) {
            const n2 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = j(n2, n2, t2), l2 = j(i2, i2, t2), u2 = j(s2, s2, t2), c2 = j(a2, a2, t2);
            return new mc(o2, l2, u2, c2, e2 / r2);
          }
        }
        function yc(t2, e2, r2) {
          let n2 = 1 / 0, i2 = -1 / 0;
          const s2 = [];
          for (const a2 of t2) {
            H(s2, a2, e2);
            const t3 = O(s2, r2);
            n2 = Math.min(n2, t3), i2 = Math.max(i2, t3);
          }
          return [n2, i2];
        }
        function gc(t2, e2) {
          let r2 = true;
          for (let n2 = 0; n2 < t2.planes.length; n2++) {
            const i2 = t2.planes[n2];
            let s2 = 0;
            for (let t3 = 0; t3 < e2.length; t3++) s2 += +(O(i2, e2[t3]) + i2[3] >= 0);
            if (0 === s2) return 0;
            s2 !== e2.length && (r2 = false);
          }
          return r2 ? 2 : 1;
        }
        function xc(t2, e2) {
          for (const r2 of t2.projections) {
            const n2 = yc(e2, t2.points[0], r2.axis);
            if (r2.projection[1] < n2[0] || r2.projection[0] > n2[1]) return 0;
          }
          return 1;
        }
        function vc(t2, e2) {
          let r2 = 0;
          const n2 = [0, 0, 0, 0];
          for (let i2 = 0; i2 < t2.length; i2++) n2[0] = t2[i2][0], n2[1] = t2[i2][1], n2[2] = t2[i2][2], n2[3] = 1, Q(n2, e2) >= 0 && r2++;
          return r2;
        }
        class bc {
          constructor(t2, e2) {
            this.points = t2 || new Array(8).fill([0, 0, 0]), this.planes = e2 || new Array(6).fill([0, 0, 0, 0]), this.bounds = wc.fromPoints(this.points), this.projections = [], this.frustumEdges = [H([], this.points[2], this.points[3]), H([], this.points[0], this.points[3]), H([], this.points[4], this.points[0]), H([], this.points[5], this.points[1]), H([], this.points[6], this.points[2]), H([], this.points[7], this.points[3])];
            for (const t3 of this.frustumEdges) {
              const e3 = [0, -t3[2], t3[1]], r2 = [t3[2], 0, -t3[0]];
              this.projections.push({ axis: e3, projection: yc(this.points, this.points[0], e3) }), this.projections.push({ axis: r2, projection: yc(this.points, this.points[0], r2) });
            }
          }
          static fromInvProjectionMatrix(t2, e2, r2, n2) {
            const i2 = Math.pow(2, r2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
              const s3 = tt([], r3, t2), a3 = 1 / s3[3] / e2 * i2;
              return (o3 = s3)[0] = (l2 = s3)[0] * (u2 = [a3, a3, n2 ? 1 / s3[3] : a3, a3])[0], o3[1] = l2[1] * u2[1], o3[2] = l2[2] * u2[2], o3[3] = l2[3] * u2[3], o3;
              var o3, l2, u2;
            }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
              const e3 = L([], U([], H([], s2[t3[0]], s2[t3[1]]), H([], s2[t3[2]], s2[t3[1]]))), r3 = -O(e3, s2[t3[1]]);
              return e3.concat(r3);
            }), o2 = [];
            for (let t3 = 0; t3 < s2.length; t3++) o2.push([s2[t3][0], s2[t3][1], s2[t3][2]]);
            return new bc(o2, a2);
          }
          intersectsPrecise(t2, e2, r2) {
            for (let r3 = 0; r3 < e2.length; r3++) if (!vc(t2, e2[r3])) return 0;
            for (let e3 = 0; e3 < this.planes.length; e3++) if (!vc(t2, this.planes[e3])) return 0;
            for (const e3 of r2) for (const r3 of this.frustumEdges) {
              const n2 = U([], e3, r3), i2 = M(n2);
              if (0 === i2) continue;
              V(n2, n2, 1 / i2);
              const s2 = yc(this.points, this.points[0], n2), a2 = yc(t2, this.points[0], n2);
              if (s2[0] > a2[1] || a2[0] > s2[1]) return 0;
            }
            return 1;
          }
          containsPoint(t2) {
            for (const e2 of this.planes) {
              const r2 = e2[3];
              if (O([e2[0], e2[1], e2[2]], t2) + r2 < 0) return false;
            }
            return true;
          }
        }
        class wc {
          static fromPoints(t2) {
            const e2 = [1 / 0, 1 / 0, 1 / 0], r2 = [-1 / 0, -1 / 0, -1 / 0];
            for (const n2 of t2) k(e2, e2, n2), T(r2, r2, n2);
            return new wc(e2, r2);
          }
          static fromTileIdAndHeight(t2, e2, r2) {
            const n2 = 1 << t2.canonical.z, i2 = t2.canonical.x, s2 = t2.canonical.y;
            return new wc([i2 / n2, s2 / n2, e2], [(i2 + 1) / n2, (s2 + 1) / n2, r2]);
          }
          static applyTransform(t2, e2) {
            const r2 = t2.getCorners();
            for (let t3 = 0; t3 < r2.length; ++t3) j(r2[t3], r2[t3], e2);
            return wc.fromPoints(r2);
          }
          static applyTransformFast(t2, e2) {
            const r2 = [e2[12], e2[13], e2[14]], n2 = [...r2];
            for (let i2 = 0; i2 < 3; i2++) for (let s2 = 0; s2 < 3; s2++) {
              const a2 = e2[4 * s2 + i2], o2 = a2 * t2.min[s2], l2 = a2 * t2.max[s2];
              r2[i2] += Math.min(o2, l2), n2[i2] += Math.max(o2, l2);
            }
            return new wc(r2, n2);
          }
          static projectAabbCorners(t2, e2) {
            const r2 = t2.getCorners();
            for (let t3 = 0; t3 < r2.length; ++t3) j(r2[t3], r2[t3], e2);
            return r2;
          }
          constructor(t2, e2) {
            this.min = t2, this.max = e2, this.center = V([], P([], this.min, this.max), 0.5);
          }
          quadrant(t2) {
            const e2 = [t2 % 2 == 0, t2 < 2], r2 = A(this.min), n2 = A(this.max);
            for (let t3 = 0; t3 < e2.length; t3++) r2[t3] = e2[t3] ? this.min[t3] : this.center[t3], n2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
            return n2[2] = this.max[2], new wc(r2, n2);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          distanceZ(t2) {
            return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
          }
          getCorners() {
            const t2 = this.min, e2 = this.max;
            return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
          }
          intersects(t2) {
            return this.intersectsAabb(t2.bounds) ? gc(t2, this.getCorners()) : 0;
          }
          intersectsFlat(t2) {
            return this.intersectsAabb(t2.bounds) ? gc(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsPrecise(t2, e2) {
            return e2 || this.intersects(t2) ? xc(t2, this.getCorners()) : 0;
          }
          intersectsPreciseFlat(t2, e2) {
            return e2 || this.intersectsFlat(t2) ? xc(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsAabb(t2) {
            for (let e2 = 0; e2 < 3; ++e2) if (this.min[e2] > t2.max[e2] || t2.min[e2] > this.max[e2]) return false;
            return true;
          }
          intersectsAabbXY(t2) {
            return !(this.min[0] > t2.max[0] || t2.min[0] > this.max[0] || this.min[1] > t2.max[1] || t2.min[1] > this.max[1]);
          }
          encapsulate(t2) {
            for (let e2 = 0; e2 < 3; e2++) this.min[e2] = Math.min(this.min[e2], t2.min[e2]), this.max[e2] = Math.max(this.max[e2], t2.max[e2]);
          }
          encapsulatePoint(t2) {
            for (let e2 = 0; e2 < 3; e2++) this.min[e2] = Math.min(this.min[e2], t2[e2]), this.max[e2] = Math.max(this.max[e2], t2[e2]);
          }
          closestPoint(t2) {
            return [Math.max(Math.min(this.max[0], t2[0]), this.min[0]), Math.max(Math.min(this.max[1], t2[1]), this.min[1]), Math.max(Math.min(this.max[2], t2[2]), this.min[2])];
          }
        }
        Qs(wc, "Aabb");
        class _c {
          constructor(t2, e2) {
            this.feature = t2, this.metersToTile = e2, this.index = 0;
          }
          get() {
            const t2 = this.feature.vertices[this.index], e2 = this.feature.vertexProps[this.index].dir, r2 = e2[1], n2 = -e2[0], i2 = (t2.extent + 1) * this.metersToTile;
            return [new It(Math.trunc(t2.position[0] + r2 * i2), Math.trunc(t2.position[1] + n2 * i2)), new It(Math.trunc(t2.position[0] - r2 * i2), Math.trunc(t2.position[1] - n2 * i2))];
          }
          next() {
            this.index++;
          }
          valid() {
            return this.index < this.feature.vertices.length;
          }
        }
        class Ac {
          constructor(t2, e2, r2, n2, i2, s2) {
            if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this._tmpVec2 = [ct(), ct(), ct(), ct(), ct(), ct(), ct()], this.id = t2, this.heightRange = { min: r2, max: r2 }, this.safeArea = e2, this.constantHeight = r2, null == this.constantHeight && (null != this.constantHeight || 0 !== n2.length)) {
              this.vertices = n2, this.edges = i2, this.edges = this.edges.filter((t3) => {
                return t3.a < this.vertices.length && t3.b < this.vertices.length && !((e3 = this.vertices[t3.a].position)[0] === (r3 = this.vertices[t3.b].position)[0] && e3[1] === r3[1]);
                var e3, r3;
              }), this.heightRange = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
              for (const t3 of this.vertices) this.vertexProps.push({ dir: ht(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, t3.height), this.heightRange.max = Math.max(this.heightRange.max, t3.height);
              for (const t3 of this.edges) {
                const e3 = this.vertices[t3.a].position, r3 = this.vertices[t3.b].position, n3 = ft(ct(), r3, e3), i3 = yt(n3), s3 = mt(ct(), n3, 1 / i3);
                this.edgeProps.push({ vec: n3, dir: s3, len: i3 });
                const a2 = this.vertexProps[t3.a].dir, o2 = this.vertexProps[t3.b].dir;
                dt(a2, a2, s3), dt(o2, o2, s3);
              }
              for (const t3 of this.vertexProps) 0 === t3.dir[0] && 0 === t3.dir[1] || gt(t3.dir, t3.dir);
              this.tessellate(s2);
            }
          }
          pointElevation(t2) {
            if (null != this.constantHeight) return this.constantHeight;
            const e2 = this.getClosestEdge(t2);
            if (null == e2) return 0;
            const [r2, n2] = e2;
            return dr(this.vertices[this.edges[r2].a].height, this.vertices[this.edges[r2].b].height, n2);
          }
          computeSlopeNormal(t2, e2) {
            const r2 = this.getClosestEdge(t2);
            if (!r2) return I(0, 0, 1);
            const n2 = r2[0], i2 = this.edges[n2], s2 = this.edgeProps[n2].vec, a2 = I(s2[0], s2[1], (this.vertices[i2.b].height - this.vertices[i2.a].height) * e2), o2 = I(a2[1], -a2[0], 0);
            U(o2, o2, a2);
            const l2 = M(o2);
            return l2 > 0 ? V(o2, o2, 1 / l2) : S(o2, 0, 0, 1);
          }
          getSafeArea() {
            return this.safeArea;
          }
          isTunnel() {
            return this.heightRange.max <= -5;
          }
          getClosestEdge(t2) {
            if (0 === this.edges.length) return;
            let e2 = 0, r2 = Number.POSITIVE_INFINITY, n2 = 0;
            const [i2, s2, a2, o2, l2, u2, c2] = this._tmpVec2;
            pt(c2, t2.x, t2.y);
            const h2 = new dc(c2, null);
            for (let t3 = 0; t3 < this.edges.length; t3++) {
              const p2 = this.edges[t3], d2 = this.edgeProps[t3].dir;
              h2.dir = d2;
              const f2 = this.vertices[p2.a].position, m2 = this.vertices[p2.b].position, y2 = h2.intersectsPlane(f2, this.vertexProps[p2.a].dir, i2), g2 = h2.intersectsPlane(m2, this.vertexProps[p2.b].dir, s2);
              if (!y2 || !g2) continue;
              ft(a2, s2, i2), ft(o2, c2, i2);
              const x2 = xt(a2, a2), v2 = x2 > 0 ? xt(o2, a2) / x2 : 0, b2 = Dt(v2, 0, 1), w2 = Math.abs((v2 - b2) * this.edgeProps[t3].len);
              ft(l2, c2, f2), pt(u2, d2[1], -d2[0]);
              const _2 = w2 + Math.abs(xt(l2, u2));
              _2 < r2 && (e2 = t3, r2 = _2, n2 = b2);
            }
            return [e2, n2];
          }
          tessellate(t2) {
            const e2 = _(), r2 = _(), n2 = _(), i2 = _();
            for (let s2 = this.edges.length - 1; s2 >= 0; --s2) {
              const a2 = this.edges[s2].a, o2 = this.edges[s2].b, { position: l2, height: u2, extent: c2 } = this.vertices[a2], { position: h2, height: p2, extent: d2 } = this.vertices[o2], f2 = this.vertexProps[a2].dir, m2 = this.vertexProps[o2].dir;
              if (S(e2, l2[0] / t2, l2[1] / t2, u2), S(r2, h2[0] / t2, h2[1] / t2, p2), S(n2, f2[1], -f2[0], 0), V(n2, n2, c2), S(i2, m2[1], -m2[0], 0), V(i2, i2, d2), this.distSqLines(I(e2[0] + 0.5 * n2[0], e2[1] + 0.5 * n2[1], e2[2] + 0.5 * n2[2]), I(r2[0] - 0.5 * i2[0], r2[1] - 0.5 * i2[1], r2[2] - 0.5 * i2[2]), I(e2[0] - 0.5 * n2[0], e2[1] - 0.5 * n2[1], e2[2] - 0.5 * n2[2]), I(r2[0] + 0.5 * i2[0], r2[1] + 0.5 * i2[1], r2[2] + 0.5 * i2[2])) <= 0.0025000000000000005) continue;
              const y2 = this.vertices.length, g2 = dt(ct(), l2, h2);
              this.vertices.push({ position: mt(g2, g2, 0.5), height: 0.5 * (u2 + p2), extent: 0.5 * (c2 + d2) });
              const x2 = dt(ct(), f2, m2);
              this.vertexProps.push({ dir: gt(x2, x2) }), this.edges.splice(s2, 1), this.edgeProps.splice(s2, 1), this.edges.push({ a: a2, b: y2 }), this.edges.push({ a: y2, b: o2 });
              const v2 = ft(ct(), this.vertices[y2].position, l2), b2 = yt(v2), w2 = { vec: v2, dir: mt(ct(), v2, 1 / b2), len: b2 };
              this.edgeProps.push(w2), this.edgeProps.push(w2);
            }
          }
          distSqLines(t2, e2, r2, n2) {
            const i2 = z(_(), e2, t2), s2 = z(_(), n2, r2), a2 = z(_(), t2, r2), o2 = O(i2, i2), l2 = O(i2, s2), u2 = O(i2, a2), c2 = O(s2, s2), h2 = O(s2, a2), p2 = o2 * c2 - l2 * l2;
            if (0 === p2) return D(N(i2, r2, n2, O(a2, s2) / O(s2, s2)), t2);
            const d2 = (o2 * h2 - l2 * u2) / p2;
            return D(N(i2, t2, e2, (l2 * h2 - u2 * c2) / p2), N(s2, r2, n2, d2));
          }
        }
        class Mc {
          static parseFrom(t2, e2) {
            const r2 = pc.parse(t2);
            if (!r2) return [];
            let { vertices: n2, features: i2 } = r2;
            const s2 = 1 / ju(e2);
            i2.sort((t3, e3) => t3.id - e3.id), n2.sort((t3, e3) => t3.id - e3.id || t3.idx - e3.idx), n2 = n2.filter((t3, e3, r3) => e3 === r3.findIndex((e4) => e4.id === t3.id && e4.idx === t3.idx));
            const a2 = new Array();
            let o2 = 0;
            const l2 = n2.length;
            for (const t3 of i2) {
              if (t3.constantHeight) {
                a2.push(new Ac(t3.id, t3.bounds, t3.constantHeight));
                continue;
              }
              for (; o2 !== l2 && n2[o2].id < t3.id; ) o2++;
              if (o2 === l2 || n2[o2].id !== t3.id) continue;
              const e3 = new Array(), r3 = new Array(), i3 = o2;
              for (; o2 !== l2 && n2[o2].id === t3.id; ) {
                const t4 = n2[o2];
                if (e3.push({ position: t4.position, height: t4.height, extent: t4.extent }), o2 !== i3 && n2[o2 - 1].idx === t4.idx - 1) {
                  const t5 = o2 - i3;
                  r3.push({ a: t5 - 1, b: t5 });
                }
                o2++;
              }
              a2.push(new Ac(t3.id, t3.bounds, void 0, e3, r3, s2));
            }
            return a2;
          }
          static getElevationFeature(t2, e2) {
            if (!e2) return;
            const r2 = +t2.properties[ac];
            return Number.isNaN(r2) ? void 0 : e2.find((t3) => t3.id === r2);
          }
        }
        class Ic {
          constructor(t2, e2) {
            this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t2.equals(e2) || (this.zScale = Math.pow(2, e2.z - t2.z), this.xOffset = (t2.x * this.zScale - e2.x) * jn, this.yOffset = (t2.y * this.zScale - e2.y) * jn);
          }
          constantElevation(t2, e2) {
            if (null != t2.constantHeight) return this.computeBiasedHeight(t2.constantHeight, e2);
          }
          pointElevation(t2, e2, r2) {
            const n2 = this.constantElevation(e2, r2);
            return null != n2 ? n2 : (t2.x = t2.x * this.zScale + this.xOffset, t2.y = t2.y * this.zScale + this.yOffset, this.computeBiasedHeight(e2.pointElevation(t2), r2));
          }
          computeBiasedHeight(t2, e2) {
            return e2 <= 0 ? t2 : t2 + e2 * Ct(0, e2, t2 >= 0 ? t2 : Math.abs(0.5 * t2));
          }
        }
        Qs(Ac, "ElevationFeature");
        class Sc {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new No(), this.indexArray = new ll(), this.segments = new Ol(), this.programConfigurations = new fu(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.elevationMode = this.layers[0].layout.get("circle-elevation-reference"), this.hasElevation = false, "none" !== this.elevationMode && (this.elevatedLayoutVertexArray = new $o()), this.worldview = t2.worldview, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          populate(t2, e2, r2, n2) {
            const i2 = this.layers[0], s2 = [];
            let a2 = null;
            "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
            for (const { feature: i3, id: o3, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = Ku(i3, t3);
              if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), c2, r2)) continue;
              const h2 = a2 ? a2.evaluate(c2, {}, r2) : void 0, p2 = { id: o3, properties: i3.properties, type: i3.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Ju(i3, r2, n2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            let o2 = null;
            "globe" === n2.projection.name && (this.globeExtVertexArray = new Ko(), o2 = n2.projection);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l2 = t2[s3].feature;
              this.addFeature(n3, i3, s3, e2.availableImages, r2, o2, e2.brightness, e2.elevationFeatures), e2.featureIndex.insert(l2, i3, s3, a3, this.index);
            }
            this.hasElevation || (this.elevatedLayoutVertexArray = void 0);
          }
          update(t2, e2, r2, n2, i2, s2, a2) {
            this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, this.worldview);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Cl.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Ll.members)), this.elevatedLayoutVertexArray && (this.elevatedLayoutVertexBuffer = t2.createVertexBuffer(this.elevatedLayoutVertexArray, Rl.members))), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy());
          }
          addFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            let l2;
            "none" !== this.elevationMode && (l2 = Mc.getElevationFeature(t2, o2));
            for (const r3 of e2) for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= jn || n3 < 0 || n3 >= jn) continue;
              if (s2) {
                const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3);
                this.addGlobeExtVertex(t3, e4), this.addGlobeExtVertex(t3, e4), this.addGlobeExtVertex(t3, e4), this.addGlobeExtVertex(t3, e4);
              }
              const a3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o3 = a3.vertexLength;
              if (this.addCircleVertex(r4, n3, -1, -1), this.addCircleVertex(r4, n3, 1, -1), this.addCircleVertex(r4, n3, 1, 1), this.addCircleVertex(r4, n3, -1, 1), "none" !== this.elevationMode) {
                const t3 = l2 ? l2.pointElevation(new It(r4, n3)) : 0;
                this.hasElevation = this.hasElevation || 0 !== t3;
                for (let e4 = 0; e4 < 4; e4++) this.elevatedLayoutVertexArray.emplaceBack(t3);
              }
              this.indexArray.emplaceBack(o3, o3 + 1, o3 + 2), this.indexArray.emplaceBack(o3, o3 + 2, o3 + 3), a3.vertexLength += 4, a3.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2, i2, a2, void 0, this.worldview);
          }
          addCircleVertex(t2, e2, r2, n2) {
            this.layoutVertexArray.emplaceBack(2 * t2 + (r2 + 1) / 2, 2 * e2 + (n2 + 1) / 2);
          }
          addGlobeExtVertex(t2, e2) {
            const r2 = 16384;
            this.globeExtVertexArray.emplaceBack(t2.x, t2.y, t2.z, e2[0] * r2, e2[1] * r2, e2[2] * r2);
          }
        }
        function Pc(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) if (Lc(e2, t2[r2])) return true;
          for (let r2 = 0; r2 < e2.length; r2++) if (Lc(t2, e2[r2])) return true;
          return !!Tc(t2, e2);
        }
        function zc(t2, e2, r2) {
          return !!Lc(t2, e2) || !!Dc(e2, t2, r2);
        }
        function Bc(t2, e2) {
          if (1 === t2.length) return Rc(e2, t2[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2[r2];
            for (let e3 = 0; e3 < n2.length; e3++) if (Lc(t2, n2[e3])) return true;
          }
          for (let r2 = 0; r2 < t2.length; r2++) if (Rc(e2, t2[r2])) return true;
          for (let r2 = 0; r2 < e2.length; r2++) if (Tc(t2, e2[r2])) return true;
          return false;
        }
        function kc(t2, e2, r2) {
          if (t2.length > 1) {
            if (Tc(t2, e2)) return true;
            for (let n2 = 0; n2 < e2.length; n2++) if (Dc(e2[n2], t2, r2)) return true;
          }
          for (let n2 = 0; n2 < t2.length; n2++) if (Dc(t2[n2], e2, r2)) return true;
          return false;
        }
        function Tc(t2, e2) {
          if (0 === t2.length || 0 === e2.length) return false;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const n2 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++) if (Vc(n2, i2, e2[t3], e2[t3 + 1])) return true;
          }
          return false;
        }
        function Vc(t2, e2, r2, n2) {
          return Wt(t2, r2, n2) !== Wt(e2, r2, n2) && Wt(t2, e2, r2) !== Wt(t2, e2, n2);
        }
        function Ec(t2, e2, r2) {
          return (t2.x - r2.x) * (e2.y - r2.y) - (t2.y - r2.y) * (e2.x - r2.x);
        }
        function Fc(t2, e2, r2, n2) {
          const i2 = Ec(t2, e2, n2), s2 = Ec(t2, e2, r2);
          if (Math.sign(i2) === Math.sign(s2)) return;
          const a2 = Ec(r2, n2, t2), o2 = a2 + s2 - i2;
          return Math.sign(a2) !== Math.sign(o2) ? [a2 / (a2 - o2), s2 / (s2 - i2)] : void 0;
        }
        function Dc(t2, e2, r2) {
          const n2 = r2 * r2;
          if (1 === e2.length) return t2.distSqr(e2[0]) < n2;
          for (let r3 = 1; r3 < e2.length; r3++) if (Cc(t2, e2[r3 - 1], e2[r3]) < n2) return true;
          return false;
        }
        function Cc(t2, e2, r2) {
          const n2 = e2.distSqr(r2);
          if (0 === n2) return t2.distSqr(e2);
          const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
        }
        function Rc(t2, e2) {
          let r2, n2, i2, s2 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r2 = t2[a2];
            for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++) n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
          }
          return s2;
        }
        function Lc(t2, e2) {
          let r2 = false;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            const s2 = t2[n2], a2 = t2[i2];
            s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
          }
          return r2;
        }
        function Oc(t2, e2, r2, n2, i2) {
          for (const s3 of t2) if (e2 <= s3.x && r2 <= s3.y && n2 >= s3.x && i2 >= s3.y) return true;
          const s2 = [new It(e2, r2), new It(e2, i2), new It(n2, i2), new It(n2, r2)];
          if (t2.length > 2) {
            for (const e3 of s2) if (Lc(t2, e3)) return true;
          }
          for (let e3 = 0; e3 < t2.length - 1; e3++) if (Uc(t2[e3], t2[e3 + 1], s2)) return true;
          return false;
        }
        function Uc(t2, e2, r2) {
          const n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y) return false;
          const s2 = Wt(t2, e2, r2[0]);
          return s2 !== Wt(t2, e2, r2[1]) || s2 !== Wt(t2, e2, r2[2]) || s2 !== Wt(t2, e2, r2[3]);
        }
        function Nc(t2, e2, r2, n2, i2, s2) {
          let a2 = e2.y - t2.y, o2 = t2.x - e2.x;
          if (s2 = s2 || 0) {
            const t3 = a2 * a2 + o2 * o2;
            if (0 === t3) return true;
            const e3 = Math.sqrt(t3);
            a2 /= e3, o2 /= e3;
          }
          return !((r2.x - t2.x) * a2 + (r2.y - t2.y) * o2 - s2 < 0 || (n2.x - t2.x) * a2 + (n2.y - t2.y) * o2 - s2 < 0 || (i2.x - t2.x) * a2 + (i2.y - t2.y) * o2 - s2 < 0);
        }
        function jc(t2, e2, r2, n2, i2, s2, a2) {
          return !(Nc(t2, e2, n2, i2, s2, a2) || Nc(e2, r2, n2, i2, s2, a2) || Nc(r2, t2, n2, i2, s2, a2) || Nc(n2, i2, t2, e2, r2, a2) || Nc(i2, s2, t2, e2, r2, a2) || Nc(s2, n2, t2, e2, r2, a2));
        }
        function Gc(t2, e2, r2) {
          const n2 = e2.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function $c(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function qc(t2, e2, r2, n2, i2) {
          if (!e2[0] && !e2[1]) return t2;
          const s2 = It.convert(e2)._mult(i2);
          "viewport" === r2 && s2._rotate(-n2);
          const a2 = [];
          for (let e3 = 0; e3 < t2.length; e3++) a2.push(t2[e3].sub(s2));
          return a2;
        }
        function Xc(t2, e2, r2, n2) {
          const i2 = It.convert(t2)._mult(n2);
          return "viewport" === e2 && i2._rotate(-r2), i2;
        }
        let Hc, Zc;
        function Wc(t2, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        Qs(Sc, "CircleBucket", { omit: ["layers"] });
        class Yc {
          constructor(t2, e2, r2) {
            this.z = t2, this.x = e2, this.y = r2, this.key = Qc(0, t2, t2, e2, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          isChildOf(t2) {
            const e2 = this.z - t2.z;
            return 0 === t2.z || t2.z < this.z && t2.x === this.x >> e2 && t2.y === this.y >> e2;
          }
          url(t2, e2) {
            const r2 = function(t3, e3, r3) {
              var n3 = Wc(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i2 = Wc(256 * (t3 + 1), 256 * (e3 + 1), r3);
              return n3[0] + "," + n3[1] + "," + i2[0] + "," + i2[1];
            }(this.x, this.y, this.z), n2 = function(t3, e3, r3) {
              let n3, i2 = "";
              for (let s2 = t3; s2 > 0; s2--) n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i2;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r2);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Jc {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = Qc(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class Kc {
          constructor(t2, e2, r2, n2, i2) {
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new Yc(r2, +n2, +i2), this.key = 0 === e2 && t2 === r2 ? this.canonical.key : Qc(e2, t2, r2, n2, i2);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            const e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new Kc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Kc(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t2, e2 = true) {
            if (this.overscaledZ === t2 && e2) return this.key;
            if (t2 > this.canonical.z) return Qc(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r2 = this.canonical.z - t2;
              return Qc(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
            }
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap) return false;
            const e2 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.z < this.canonical.z && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2) return [new Kc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new Kc(e2, this.wrap, e2, r2, n2), new Kc(e2, this.wrap, e2, r2 + 1, n2), new Kc(e2, this.wrap, e2, r2, n2 + 1), new Kc(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new Kc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new Kc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Jc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function Qc(t2, e2, r2, n2, i2) {
          const s2 = 1 << Math.min(r2, 22);
          let a2 = s2 * (i2 % s2) + n2 % s2;
          return t2 && r2 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e2 - r2);
        }
        const th = [(t2) => {
          let e2 = t2.canonical.x - 1, r2 = t2.wrap;
          return e2 < 0 && (e2 = (1 << t2.canonical.z) - 1, r2--), new Kc(t2.overscaledZ, r2, t2.canonical.z, e2, t2.canonical.y);
        }, (t2) => {
          let e2 = t2.canonical.x + 1, r2 = t2.wrap;
          return e2 === 1 << t2.canonical.z && (e2 = 0, r2++), new Kc(t2.overscaledZ, r2, t2.canonical.z, e2, t2.canonical.y);
        }, (t2) => new Kc(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, (0 === t2.canonical.y ? 1 << t2.canonical.z : t2.canonical.y) - 1), (t2) => new Kc(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, t2.canonical.y === (1 << t2.canonical.z) - 1 ? 0 : t2.canonical.y + 1)];
        Qs(Yc, "CanonicalTileID"), Qs(Kc, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
        const eh = Oo([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: rh } = eh, nh = Oo([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var ih = Oo([{ name: "a_pos", type: "Int16", components: 2 }]);
        function sh(t2) {
          return t2 * bu / Pu;
        }
        const ah = [new wc([Au, Au, Au], [Mu, Mu, Mu]), new wc([Au, Au, Au], [0, 0, Mu]), new wc([0, Au, Au], [Mu, 0, Mu]), new wc([Au, 0, Au], [0, Mu, Mu]), new wc([0, 0, Au], [Mu, Mu, Mu])];
        function oh(t2, e2, r2, n2 = true) {
          const i2 = V([], t2._camera.position, t2.worldSize), s2 = [e2, r2, 1, 1];
          tt(s2, s2, t2.pixelMatrixInverse), J(s2, s2, 1 / s2[3]);
          const a2 = L([], H([], s2, i2)), o2 = t2.globeMatrix, l2 = [o2[12], o2[13], o2[14]], u2 = H([], l2, i2), c2 = M(u2), h2 = L([], u2), p2 = t2.worldSize / (2 * Math.PI), d2 = O(h2, a2), f2 = Math.asin(p2 / c2);
          if (f2 < Math.acos(d2)) {
            if (!n2) return null;
            const t3 = [], e3 = [];
            V(t3, a2, c2 / d2), L(e3, H(e3, t3, u2)), L(a2, P(a2, u2, V(a2, e3, Math.tan(f2) * c2)));
          }
          const m2 = [];
          new fc(i2, a2).closestPointOnSphere(l2, p2, m2);
          const y2 = L([], ee(o2, 0)), g2 = L([], ee(o2, 1)), x2 = L([], ee(o2, 2)), v2 = O(y2, m2), b2 = O(g2, m2), w2 = O(x2, m2), _2 = kt(Math.asin(-b2 / p2));
          let A2 = kt(Math.atan2(v2, w2));
          A2 = t2.center.lng + function(t3, e3) {
            const r3 = (e3 - t3 + 180) % 360 - 180;
            return r3 < -180 ? r3 + 360 : r3;
          }(t2.center.lng, A2);
          const I2 = Vu(A2), S2 = Dt(Eu(_2), 0, 1);
          return new Gu(I2, S2);
        }
        class lh {
          constructor(t2, e2, r2) {
            this.a = H([], t2, r2), this.b = H([], e2, r2), this.center = r2;
            const n2 = L([], this.a), i2 = L([], this.b);
            this.angle = Math.acos(O(n2, i2));
          }
        }
        function uh(t2, e2) {
          if (0 === t2.angle) return null;
          let r2;
          return r2 = 0 === t2.a[e2] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n2) {
            const i2 = Math.sin(r3);
            return t3 * (Math.sin((1 - n2) * r3) / i2) + e3 * (Math.sin(n2 * r3) / i2);
          }(t2.a[e2], t2.b[e2], t2.angle, Dt(r2, 0, 1)) + t2.center[e2];
        }
        function ch(t2) {
          if (t2.z <= 1) return ah[t2.z + 2 * t2.y + t2.x];
          const e2 = mh(fh(t2));
          return wc.fromPoints(e2);
        }
        function hh(t2, e2, r2) {
          return V(t2, t2, 1 - r2), E(t2, t2, e2, r2);
        }
        function ph(t2, e2, r2) {
          for (const n2 of t2) j(n2, n2, e2), V(n2, n2, r2);
        }
        function dh(t2, e2, r2, n2) {
          const i2 = e2 / t2.worldSize, s2 = t2.globeMatrix;
          if (r2.z <= 1) {
            const t3 = ch(r2).getCorners();
            return ph(t3, s2, i2), wc.fromPoints(t3);
          }
          const a2 = fh(r2, n2), o2 = mh(a2, bu + sh(t2._tileCoverLift));
          ph(o2, s2, i2);
          const l2 = Number.MAX_VALUE, u2 = [-l2, -l2, -l2], c2 = [l2, l2, l2];
          if (a2.contains(t2.center)) {
            for (const t3 of o2) k(c2, c2, t3), T(u2, u2, t3);
            u2[2] = 0;
            const e3 = t2.point, r3 = [e3.x * i2, e3.y * i2, 0];
            return k(c2, c2, r3), T(u2, u2, r3), new wc(c2, u2);
          }
          if (t2._tileCoverLift > 0) {
            for (const t3 of o2) k(c2, c2, t3), T(u2, u2, t3);
            return new wc(c2, u2);
          }
          const h2 = [s2[12] * i2, s2[13] * i2, s2[14] * i2], p2 = a2.getCenter(), d2 = Dt(t2.center.lat, -85.051129, Lu), f2 = Dt(p2.lat, -85.051129, Lu), m2 = Vu(t2.center.lng), y2 = Eu(d2);
          let g2 = m2 - Vu(p2.lng);
          const x2 = y2 - Eu(f2);
          g2 > 0.5 ? g2 -= 1 : g2 < -0.5 && (g2 += 1);
          let v2 = 0;
          Math.abs(g2) > Math.abs(x2) ? v2 = g2 >= 0 ? 1 : 3 : (v2 = x2 >= 0 ? 0 : 2, E(h2, h2, [s2[4] * i2, s2[5] * i2, s2[6] * i2], -Math.sin(Bt(x2 >= 0 ? a2.getSouth() : a2.getNorth())) * bu));
          const b2 = o2[v2], w2 = o2[(v2 + 1) % 4], _2 = new lh(b2, w2, h2), A2 = [uh(_2, 0) || b2[0], uh(_2, 1) || b2[1], uh(_2, 2) || b2[2]], M2 = Mh(t2.zoom);
          if (M2 > 0) {
            const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, a3) {
              const o3 = 1 / (1 << r3);
              let l3 = t3 * o3, u3 = l3 + o3, c3 = e3 * o3, h3 = c3 + o3, p3 = 0;
              const d3 = (l3 + u3) / 2 - s3;
              return d3 > 0.5 ? p3 = -1 : d3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (a3 *= n4)) * i4 + a3, h3 = (h3 * n4 - a3) * i4 + a3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
            }(r2, e2, t2._pixelsPerMercatorPixel, m2, y2);
            for (let t3 = 0; t3 < o2.length; t3++) hh(o2[t3], n3[t3], M2);
            const i3 = P([], n3[v2], n3[(v2 + 1) % 4]);
            V(i3, i3, 0.5), hh(A2, i3, M2);
          }
          for (const t3 of o2) k(c2, c2, t3), T(u2, u2, t3);
          return c2[2] = Math.min(b2[2], w2[2]), k(c2, c2, A2), T(u2, u2, A2), new wc(c2, u2);
        }
        function fh({ x: t2, y: e2, z: r2 }, n2 = false) {
          const i2 = 1 / (1 << r2), s2 = new Bu(Du(t2 * i2), e2 === (1 << r2) - 1 && n2 ? -90 : Cu((e2 + 1) * i2)), a2 = new Bu(Du((t2 + 1) * i2), 0 === e2 && n2 ? 90 : Cu(e2 * i2));
          return new ku(s2, a2);
        }
        function mh(t2, e2 = bu) {
          const r2 = Bt(t2.getNorth()), n2 = Bt(t2.getSouth()), i2 = Math.cos(r2), s2 = Math.cos(n2), a2 = Math.sin(r2), o2 = Math.sin(n2), l2 = t2.getWest(), u2 = t2.getEast();
          return [Iu(s2, o2, l2, e2), Iu(s2, o2, u2, e2), Iu(i2, a2, u2, e2), Iu(i2, a2, l2, e2)];
        }
        function yh(t2, e2, r2, n2) {
          const i2 = 1 << r2.z, s2 = (t2 / jn + r2.x) / i2;
          return Su(Cu((e2 / jn + r2.y) / i2), Du(s2), n2);
        }
        function gh({ min: t2, max: e2 }) {
          return 16383 / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
        }
        const xh = new Float64Array(16);
        function vh(t2) {
          const e2 = gh(t2), r2 = g(xh, [e2, e2, e2]);
          return p(r2, r2, R([], t2.min));
        }
        function bh(t2) {
          const e2 = function(t3, e3) {
            return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = e3[0], t3[13] = e3[1], t3[14] = e3[2], t3[15] = 1, t3;
          }(xh, t2.min), r2 = 1 / gh(t2);
          return d(e2, e2, [r2, r2, r2]);
        }
        function wh(t2) {
          const e2 = jn / (2 * Math.PI);
          return t2 / (2 * Math.PI) / e2;
        }
        function _h(t2, e2) {
          return jn / (512 * Math.pow(2, t2)) * gh(ch(e2));
        }
        function Ah(t2, e2, r2, n2, i2) {
          const s2 = wh(r2), a2 = [t2, e2, -r2 / (2 * Math.PI)], o2 = u(new Float64Array(16));
          return p(o2, o2, a2), d(o2, o2, [s2, s2, s2]), f(o2, o2, Bt(-i2)), m(o2, o2, Bt(-n2)), o2;
        }
        function Mh(t2) {
          return Ct(5, 6, t2);
        }
        function Ih(t2, e2) {
          const r2 = Su(e2.lat, e2.lng), n2 = function(t3) {
            const e3 = Su(t3._center.lat, t3._center.lng);
            let r3 = U([], I(0, 1, 0), e3);
            const n3 = x([], -t3.angle, e3);
            r3 = j(r3, r3, n3), x(n3, -t3._pitch, r3);
            const i3 = L([], e3);
            return V(i3, i3, sh(t3.cameraToCenterDistance / t3.pixelsPerMeter)), j(i3, i3, n3), P([], e3, i3);
          }(t2);
          return a2 = (i2 = z([], n2, r2))[0], o2 = i2[1], l2 = i2[2], u2 = (s2 = r2)[0], c2 = s2[1], h2 = s2[2], d2 = (p2 = Math.sqrt((a2 * a2 + o2 * o2 + l2 * l2) * (u2 * u2 + c2 * c2 + h2 * h2))) && O(i2, s2) / p2, Math.acos(Math.min(Math.max(d2, -1), 1));
          var i2, s2, a2, o2, l2, u2, c2, h2, p2, d2;
        }
        function Sh(t2, e2) {
          return Ih(t2, e2) > Math.PI / 2 * 1.01;
        }
        const Ph = Bt(85), zh = Math.cos(Ph), Bh = Math.sin(Ph), kh = o(), Th = (t2) => {
          const e2 = [];
          return "map" === t2.paint.get("circle-pitch-alignment") && e2.push("PITCH_WITH_MAP"), "map" === t2.paint.get("circle-pitch-scale") && e2.push("SCALE_WITH_MAP"), e2;
        };
        function Vh(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          if (s2 && t2.queryGeometry.isAboveHorizon) return false;
          s2 && (l2 *= t2.pixelToTileUnitsFactor);
          const u2 = t2.tileID.canonical, c2 = r2.projection.upVectorScale(u2, r2.center.lat, r2.worldSize).metersToTile;
          for (const h2 of e2) for (const e3 of h2) {
            const h3 = e3.add(o2), p2 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(h3.x, h3.y, true) : 0, d2 = r2.projection.projectTilePoint(h3.x, h3.y, u2);
            if (p2 > 0) {
              const t3 = r2.projection.upVector(u2, h3.x, h3.y);
              d2.x += t3[0] * c2 * p2, d2.y += t3[1] * c2 * p2, d2.z += t3[2] * c2 * p2;
            }
            const f2 = s2 ? h3 : Eh(d2.x, d2.y, d2.z, n2), m2 = s2 ? t2.tilespaceRays.map((t3) => Ch(t3, p2)) : t2.queryGeometry.screenGeometry, y2 = tt([], [d2.x, d2.y, d2.z, 1], n2);
            if (!a2 && s2 ? l2 *= y2[3] / r2.cameraToCenterDistance : a2 && !s2 && (l2 *= r2.cameraToCenterDistance / y2[3]), s2) {
              const t3 = Cu((e3.y / jn + u2.y) / (1 << u2.z));
              l2 /= r2.projection.pixelsPerMeter(t3, 1) / Fu(1, t3);
            }
            if (zc(m2, f2, l2)) return true;
          }
          return false;
        }
        function Eh(t2, e2, r2, n2) {
          const i2 = tt([], [t2, e2, r2, 1], n2);
          return new It(i2[0] / i2[3], i2[1] / i2[3]);
        }
        const Fh = I(0, 0, 0), Dh = I(0, 0, 1);
        function Ch(t2, e2) {
          const r2 = _();
          return Fh[2] = e2, t2.intersectsPlane(Fh, Dh, r2), new It(r2[0], r2[1]);
        }
        class Rh extends Sc {
        }
        let Lh, Oh, Uh, Nh;
        function jh(t2, { width: e2, height: r2 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r2 * n2) throw new RangeError("mismatched image size");
          } else i2 = new Uint8Array(e2 * r2 * n2);
          return t2.width = e2, t2.height = r2, t2.data = i2, t2;
        }
        function Gh(t2, e2, r2) {
          const { width: n2, height: i2 } = e2;
          n2 === t2.width && i2 === t2.height || ($h(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2, null), t2.width = n2, t2.height = i2, t2.data = e2.data);
        }
        function $h(t2, e2, r2, n2, i2, s2, a2, o2) {
          if (0 === i2.width || 0 === i2.height) return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
          const l2 = t2.data, u2 = e2.data, c2 = 4 === s2 && o2;
          for (let o3 = 0; o3 < i2.height; o3++) {
            const h2 = ((r2.y + o3) * t2.width + r2.x) * s2, p2 = ((n2.y + o3) * e2.width + n2.x) * s2;
            if (c2) for (let t3 = 0; t3 < i2.width; t3++) {
              const e3 = h2 + t3 * s2 + 3, r3 = p2 + t3 * s2;
              u2[r3 + 0] = 255, u2[r3 + 1] = 255, u2[r3 + 2] = 255, u2[r3 + 3] = l2[e3];
            }
            else if (a2) for (let t3 = 0; t3 < i2.width; t3++) {
              const e3 = h2 + t3 * s2, r3 = p2 + t3 * s2, n3 = new ur(l2[e3 + 0] / 255, l2[e3 + 1] / 255, l2[e3 + 2] / 255, l2[e3 + 3]).toNonPremultipliedRenderColor(a2).toArray();
              u2[r3 + 0] = n3[0], u2[r3 + 1] = n3[1], u2[r3 + 2] = n3[2], u2[r3 + 3] = n3[3];
            }
            else for (let t3 = 0; t3 < i2.width * s2; t3++) u2[p2 + t3] = l2[h2 + t3];
          }
          return e2;
        }
        Qs(Rh, "HeatmapBucket", { omit: ["layers"] });
        class qh {
          constructor(t2, e2) {
            jh(this, t2, 1, e2);
          }
          resize(t2) {
            Gh(this, new qh(t2), 1);
          }
          clone() {
            return new qh({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            $h(t2, e2, r2, n2, i2, 1, null);
          }
        }
        class Xh {
          constructor(t2, e2) {
            jh(this, t2, 4, e2);
          }
          resize(t2) {
            Gh(this, new Xh(t2), 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Xh({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2, s2, a2) {
            $h(t2, e2, r2, n2, i2, 4, s2, a2);
          }
        }
        class Hh {
          constructor(t2, e2) {
            this.width = t2.width, this.height = t2.height, this.data = e2 instanceof Uint8Array ? new Float32Array(e2.buffer) : e2;
          }
        }
        function Zh(t2) {
          const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Xh({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
            e2[t2.evaluationKey] = s3;
            const a2 = t2.expression.evaluate(e2), o2 = a2 ? a2.toNonPremultipliedRenderColor(null) : null;
            o2 && (i2.data[r3 + n3 + 0] = Math.floor(255 * o2.r), i2.data[r3 + n3 + 1] = Math.floor(255 * o2.g), i2.data[r3 + n3 + 2] = Math.floor(255 * o2.b), i2.data[r3 + n3 + 3] = Math.floor(255 * o2.a));
          };
          if (t2.clips) for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2) for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
            const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
            s2(i3, a2, l2 * (1 - o2) + u2 * o2);
          }
          else for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4) s2(0, e3, t3 / (r2 - 1));
          return i2;
        }
        Qs(qh, "AlphaImage"), Qs(Xh, "RGBAImage");
        const Wh = Oo([{ name: "a_pos", components: 2, type: "Int16" }], 4), Yh = Oo([{ name: "a_road_z_offset", components: 1, type: "Float32" }], 4), Jh = Oo([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_height", components: 1, type: "Float32" }], 4), Kh = Oo([{ name: "a_pos_normal_3", components: 3, type: "Int16" }], 4);
        function Qh(t2, e2, r2 = 2) {
          const n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
          let s2 = tp(t2, 0, i2, r2, true);
          const a2 = [];
          if (!s2 || s2.next === s2.prev) return a2;
          let o2, l2, u2;
          if (n2 && (s2 = function(t3, e3, r3, n3) {
            const i3 = [];
            for (let r4 = 0, s3 = e3.length; r4 < s3; r4++) {
              const a3 = tp(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
              a3 === a3.next && (a3.steiner = true), i3.push(hp(a3));
            }
            i3.sort(op);
            for (let t4 = 0; t4 < i3.length; t4++) r3 = lp(i3[t4], r3);
            return r3;
          }(t2, e2, s2, r2)), t2.length > 80 * r2) {
            o2 = t2[0], l2 = t2[1];
            let e3 = o2, n3 = l2;
            for (let s3 = r2; s3 < i2; s3 += r2) {
              const r3 = t2[s3], i3 = t2[s3 + 1];
              r3 < o2 && (o2 = r3), i3 < l2 && (l2 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
            }
            u2 = Math.max(e3 - o2, n3 - l2), u2 = 0 !== u2 ? 32767 / u2 : 0;
          }
          return rp(s2, a2, r2, o2, l2, u2, 0), a2;
        }
        function tp(t2, e2, r2, n2, i2) {
          let s2;
          if (i2 === function(t3, e3, r3, n3) {
            let i3 = 0;
            for (let s3 = e3, a2 = r3 - n3; s3 < r3; s3 += n3) i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
            return i3;
          }(t2, e2, r2, n2) > 0) for (let i3 = e2; i3 < r2; i3 += n2) s2 = _p(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
          else for (let i3 = r2 - n2; i3 >= e2; i3 -= n2) s2 = _p(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
          return s2 && yp(s2, s2.next) && (Ap(s2), s2 = s2.next), s2;
        }
        function ep(t2, e2) {
          if (!t2) return t2;
          e2 || (e2 = t2);
          let r2, n2 = t2;
          do {
            if (r2 = false, n2.steiner || !yp(n2, n2.next) && 0 !== mp(n2.prev, n2, n2.next)) n2 = n2.next;
            else {
              if (Ap(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function rp(t2, e2, r2, n2, i2, s2, a2) {
          if (!t2) return;
          !a2 && s2 && function(t3, e3, r3, n3) {
            let i3 = t3;
            do {
              0 === i3.z && (i3.z = cp(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
              let e4, r4 = 1;
              do {
                let n4, i4 = t4;
                t4 = null;
                let s3 = null;
                for (e4 = 0; i4; ) {
                  e4++;
                  let a3 = i4, o3 = 0;
                  for (let t5 = 0; t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++) ;
                  let l2 = r4;
                  for (; o3 > 0 || l2 > 0 && a3; ) 0 !== o3 && (0 === l2 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                  i4 = a3;
                }
                s3.nextZ = null, r4 *= 2;
              } while (e4 > 1);
            }(i3);
          }(t2, n2, i2, s2);
          let o2 = t2;
          for (; t2.prev !== t2.next; ) {
            const l2 = t2.prev, u2 = t2.next;
            if (s2 ? ip(t2, n2, i2, s2) : np(t2)) e2.push(l2.i, t2.i, u2.i), Ap(t2), t2 = u2.next, o2 = u2.next;
            else if ((t2 = u2) === o2) {
              a2 ? 1 === a2 ? rp(t2 = sp(ep(t2), e2), e2, r2, n2, i2, s2, 2) : 2 === a2 && ap(t2, e2, r2, n2, i2, s2) : rp(ep(t2), e2, r2, n2, i2, s2, 1);
              break;
            }
          }
        }
        function np(t2) {
          const e2 = t2.prev, r2 = t2, n2 = t2.next;
          if (mp(e2, r2, n2) >= 0) return false;
          const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = Math.min(i2, s2, a2), h2 = Math.min(o2, l2, u2), p2 = Math.max(i2, s2, a2), d2 = Math.max(o2, l2, u2);
          let f2 = n2.next;
          for (; f2 !== e2; ) {
            if (f2.x >= c2 && f2.x <= p2 && f2.y >= h2 && f2.y <= d2 && dp(i2, o2, s2, l2, a2, u2, f2.x, f2.y) && mp(f2.prev, f2, f2.next) >= 0) return false;
            f2 = f2.next;
          }
          return true;
        }
        function ip(t2, e2, r2, n2) {
          const i2 = t2.prev, s2 = t2, a2 = t2.next;
          if (mp(i2, s2, a2) >= 0) return false;
          const o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, d2 = Math.min(o2, l2, u2), f2 = Math.min(c2, h2, p2), m2 = Math.max(o2, l2, u2), y2 = Math.max(c2, h2, p2), g2 = cp(d2, f2, e2, r2, n2), x2 = cp(m2, y2, e2, r2, n2);
          let v2 = t2.prevZ, b2 = t2.nextZ;
          for (; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
            if (v2.x >= d2 && v2.x <= m2 && v2.y >= f2 && v2.y <= y2 && v2 !== i2 && v2 !== a2 && dp(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && mp(v2.prev, v2, v2.next) >= 0) return false;
            if (v2 = v2.prevZ, b2.x >= d2 && b2.x <= m2 && b2.y >= f2 && b2.y <= y2 && b2 !== i2 && b2 !== a2 && dp(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && mp(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= d2 && v2.x <= m2 && v2.y >= f2 && v2.y <= y2 && v2 !== i2 && v2 !== a2 && dp(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && mp(v2.prev, v2, v2.next) >= 0) return false;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x2; ) {
            if (b2.x >= d2 && b2.x <= m2 && b2.y >= f2 && b2.y <= y2 && b2 !== i2 && b2 !== a2 && dp(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && mp(b2.prev, b2, b2.next) >= 0) return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function sp(t2, e2) {
          let r2 = t2;
          do {
            const n2 = r2.prev, i2 = r2.next.next;
            !yp(n2, i2) && gp(n2, r2, r2.next, i2) && bp(n2, i2) && bp(i2, n2) && (e2.push(n2.i, r2.i, i2.i), Ap(r2), Ap(r2.next), r2 = t2 = i2), r2 = r2.next;
          } while (r2 !== t2);
          return ep(r2);
        }
        function ap(t2, e2, r2, n2, i2, s2) {
          let a2 = t2;
          do {
            let t3 = a2.next.next;
            for (; t3 !== a2.prev; ) {
              if (a2.i !== t3.i && fp(a2, t3)) {
                let o2 = wp(a2, t3);
                return a2 = ep(a2, a2.next), o2 = ep(o2, o2.next), rp(a2, e2, r2, n2, i2, s2, 0), void rp(o2, e2, r2, n2, i2, s2, 0);
              }
              t3 = t3.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function op(t2, e2) {
          let r2 = t2.x - e2.x;
          return 0 === r2 && (r2 = t2.y - e2.y, 0 === r2) && (r2 = (t2.next.y - t2.y) / (t2.next.x - t2.x) - (e2.next.y - e2.y) / (e2.next.x - e2.x)), r2;
        }
        function lp(t2, e2) {
          const r2 = function(t3, e3) {
            let r3 = e3;
            const n3 = t3.x, i2 = t3.y;
            let s2, a2 = -1 / 0;
            if (yp(t3, r3)) return r3;
            do {
              if (yp(t3, r3.next)) return r3.next;
              if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
                const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
                if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3)) return s2;
              }
              r3 = r3.next;
            } while (r3 !== e3);
            if (!s2) return null;
            const o2 = s2, l2 = s2.x, u2 = s2.y;
            let c2 = 1 / 0;
            r3 = s2;
            do {
              if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && pp(i2 < u2 ? n3 : a2, i2, l2, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
                const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
                bp(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && up(s2, r3))) && (s2 = r3, c2 = e4);
              }
              r3 = r3.next;
            } while (r3 !== o2);
            return s2;
          }(t2, e2);
          if (!r2) return e2;
          const n2 = wp(r2, t2);
          return ep(n2, n2.next), ep(r2, r2.next);
        }
        function up(t2, e2) {
          return mp(t2.prev, t2, e2.prev) < 0 && mp(e2.next, t2, t2.next) < 0;
        }
        function cp(t2, e2, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function hp(t2) {
          let e2 = t2, r2 = t2;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r2;
        }
        function pp(t2, e2, r2, n2, i2, s2, a2, o2) {
          return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
        }
        function dp(t2, e2, r2, n2, i2, s2, a2, o2) {
          return !(t2 === a2 && e2 === o2) && pp(t2, e2, r2, n2, i2, s2, a2, o2);
        }
        function fp(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            let r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && gp(r2, r2.next, t3, e3)) return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          }(t2, e2) && (bp(t2, e2) && bp(e2, t2) && function(t3, e3) {
            let r2 = t3, n2 = false;
            const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
            do {
              r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t3);
            return n2;
          }(t2, e2) && (mp(t2.prev, t2, e2.prev) || mp(t2, e2.prev, e2)) || yp(t2, e2) && mp(t2.prev, t2, t2.next) > 0 && mp(e2.prev, e2, e2.next) > 0);
        }
        function mp(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function yp(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function gp(t2, e2, r2, n2) {
          const i2 = vp(mp(t2, e2, r2)), s2 = vp(mp(t2, e2, n2)), a2 = vp(mp(r2, n2, t2)), o2 = vp(mp(r2, n2, e2));
          return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !xp(t2, r2, e2)) || !(0 !== s2 || !xp(t2, n2, e2)) || !(0 !== a2 || !xp(r2, t2, n2)) || !(0 !== o2 || !xp(r2, e2, n2));
        }
        function xp(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function vp(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function bp(t2, e2) {
          return mp(t2.prev, t2, t2.next) < 0 ? mp(t2, e2, t2.next) >= 0 && mp(t2, t2.prev, e2) >= 0 : mp(t2, e2, t2.prev) < 0 || mp(t2, t2.next, e2) < 0;
        }
        function wp(t2, e2) {
          const r2 = Mp(t2.i, t2.x, t2.y), n2 = Mp(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
        }
        function _p(t2, e2, r2, n2) {
          const i2 = Mp(t2, e2, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function Ap(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function Mp(t2, e2, r2) {
          return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        function Ip(t2, e2) {
          const r2 = t2.length;
          if (r2 <= 1) return [t2];
          const n2 = [];
          let i2, s2;
          for (let e3 = 0; e3 < r2; e3++) {
            const r3 = Yt(t2[e3]);
            0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
          }
          if (i2 && n2.push(i2), e2 > 1) for (let t3 = 0; t3 < n2.length; t3++) n2[t3].length <= e2 || (un(n2[t3], e2, 1, n2[t3].length - 1, Sp), n2[t3] = n2[t3].slice(0, e2));
          return n2;
        }
        function Sp(t2, e2) {
          return e2.area - t2.area;
        }
        function Pp(t2, e2, r2 = 1) {
          if (!t2) return null;
          const n2 = "string" == typeof t2 ? Or.from(t2).getPrimary() : t2.getPrimary(), i2 = "string" == typeof t2 ? null : t2.getSecondary();
          for (const t3 of [n2, i2]) {
            if (!t3) continue;
            const n3 = t3.id.toString();
            e2.has(n3) || e2.set(n3, []), t3.scaleSelf(r2), e2.get(n3).push(t3);
          }
          return { primary: n2.toString(), secondary: i2 ? i2.toString() : null };
        }
        function zp(t2, e2, r2, n2) {
          const i2 = n2.patternDependencies;
          let s2 = false;
          for (const n3 of e2) {
            const e3 = n3.paint.get(`${t2}-pattern`);
            e3.isConstant() || (s2 = true), Pp(e3.constantOr(null), i2, r2) && (s2 = true);
          }
          return s2;
        }
        function Bp(t2, e2, r2, n2, i2, s2) {
          const a2 = s2.patternDependencies;
          for (const o2 of e2) {
            const e3 = o2.paint.get(`${t2}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t3 = e3.evaluate({ zoom: n2 }, r2, {}, s2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3;
              const l2 = Pp(t3, a2, i2);
              if (!l2) continue;
              const { primary: u2, secondary: c2 } = l2;
              u2 && (r2.patterns[o2.id] = [u2, c2].filter(Boolean));
            }
          }
          return r2;
        }
        class kp {
          constructor() {
            this.portals = [];
          }
          static isOnBorder(t2, e2) {
            return t2 <= 0 && e2 <= 0 || t2 >= jn && e2 >= jn;
          }
          static evaluate(t2) {
            if (0 === t2.length) return new kp();
            let e2 = [];
            for (const r3 of t2) e2.push(...r3.portals);
            if (0 === e2.length) return new kp();
            for (const t3 of e2) {
              const e3 = t3.va, r3 = t3.vb;
              (kp.isOnBorder(e3.x, r3.x) || kp.isOnBorder(e3.y, r3.y)) && (t3.type = "border");
            }
            const r2 = e2.filter((t3) => "unevaluated" !== t3.type), n2 = e2.filter((t3) => "unevaluated" === t3.type);
            if (0 === n2.length) return new kp();
            n2.sort((t3, e3) => t3.hash === e3.hash ? t3.isTunnel === e3.isTunnel ? 0 : t3.isTunnel ? -1 : 1 : t3.hash < e3.hash ? 1 : -1), e2 = r2.concat(n2);
            let i2 = r2.length, s2 = i2, a2 = i2;
            do {
              if (s2++, s2 === e2.length || e2[i2].hash !== e2[s2].hash) {
                if (s2 - i2 === 2) {
                  a2 < i2 && (e2[a2] = e2[i2], e2[i2] = null);
                  const t3 = e2[a2], r3 = e2[s2 - 1];
                  t3.type = t3.isTunnel !== r3.isTunnel ? "tunnel" : "polygon", t3.connection = { a: t3.connection.a, b: r3.connection.a }, a2++;
                }
                i2 = s2;
              }
            } while (i2 !== e2.length);
            return e2.splice(a2), e2.sort((t3, e3) => t3.hash < e3.hash ? 1 : -1), { portals: e2 };
          }
        }
        Qs(kp, "ElevationPortalGraph");
        class Tp {
          constructor(t2, e2, r2) {
            this.outPositions = t2, this.outNormals = e2, this.outIndices = r2, this.vertexLookup = /* @__PURE__ */ new Map();
          }
          addVertex(t2, e2, r2) {
            let n2 = t2[2];
            null != r2 && (n2 *= r2);
            const i2 = `${t2[0]},${t2[1]},${t2[2]},${e2[0]},${e2[1]},${e2[2]}`, s2 = this.vertexLookup.get(i2);
            if (null != s2) return s2;
            const a2 = this.outPositions.length;
            this.vertexLookup.set(i2, a2);
            const o2 = Math.trunc(16384 * e2[0]), l2 = Math.trunc(16384 * e2[1]), u2 = Math.trunc(16384 * e2[2]);
            return this.outPositions.emplaceBack(t2[0], t2[1], n2), this.outNormals.emplaceBack(o2, l2, u2), a2;
          }
          addTriangle(t2, e2, r2) {
            this.outIndices.emplaceBack(t2, e2, r2);
          }
          addTriangles(t2, e2, r2) {
            if (0 === t2.length) return;
            const n2 = 1 === r2.length, i2 = _(), s2 = _();
            for (let a2 = 0; a2 < t2.length; a2 += 3) {
              const o2 = e2[t2[a2 + 0]], l2 = e2[t2[a2 + 1]], u2 = e2[t2[a2 + 2]], c2 = n2 ? r2[0] : r2[t2[a2 + 1]], h2 = n2 ? r2[0] : r2[t2[a2 + 2]];
              S(i2, o2.x, o2.y, n2 ? r2[0] : r2[t2[a2 + 0]]);
              const p2 = this.addVertex(i2, s2);
              S(i2, l2.x, l2.y, c2);
              const d2 = this.addVertex(i2, s2);
              S(i2, u2.x, u2.y, h2);
              const f2 = this.addVertex(i2, s2);
              this.outIndices.emplaceBack(p2, d2, f2);
            }
          }
          addQuad(t2, e2, r2, n2, i2, s2) {
            const a2 = this.addVertex(t2, i2, s2), o2 = this.addVertex(e2, i2, s2), l2 = this.addVertex(r2, i2, s2), u2 = this.addVertex(n2, i2, s2);
            this.addTriangle(a2, o2, l2), this.addTriangle(l2, u2, a2);
          }
          getVertexCount() {
            return this.outPositions.length;
          }
          clearVertexLookup() {
            this.vertexLookup.clear();
          }
        }
        class Vp {
          constructor(t2, e2, r2, n2) {
            this.unevaluatedPortals = new kp(), this.bridgeFeatureSections = [], this.tunnelFeatureSections = [], this.vertexHashLookup = /* @__PURE__ */ new Map(), this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new qo(), this.vertexNormals = new Xo(), this.indexArray = new ll(), this.tileToMeters = ju(t2), this.bridgeProgramConfigurations = new fu(e2, { zoom: r2, lut: n2 }, (t3) => "fill-tunnel-structure-color" !== t3), this.tunnelProgramConfigurations = new fu(e2, { zoom: r2, lut: n2 }, (t3) => "fill-bridge-guard-rail-color" !== t3);
          }
          addVertices(t2, e2) {
            const r2 = this.unevalVertices.length;
            for (let r3 = 0; r3 < t2.length; r3++) this.unevalVertices.push(t2[r3]), this.unevalHeights.push(e2[r3]);
            return r2;
          }
          addTriangles(t2, e2, r2) {
            const n2 = r2 ? this.unevalTunnelTriangles : this.unevalTriangles;
            for (const r3 of t2) n2.push(r3 + e2);
          }
          addRenderableRing(t2, e2, r2, n2, i2, s2) {
            const a2 = [new It(i2.min.x, i2.min.y), new It(i2.max.x, i2.min.y), new It(i2.max.x, i2.max.y), new It(i2.min.x, i2.max.y)];
            for (let o2 = 0; o2 < r2 - 1; o2++) {
              const r3 = e2 + o2, l2 = r3 + 1, u2 = this.unevalVertices[r3], c2 = this.unevalVertices[l2];
              if (!(u2.x >= i2.min.x && u2.x <= i2.max.x && u2.y >= i2.min.y && u2.y <= i2.max.y || c2.x >= i2.min.x && c2.x <= i2.max.x && c2.y >= i2.min.y && c2.y <= i2.max.y || Uc(u2, c2, a2))) continue;
              if (this.isOnBorder(u2.x, c2.x) || this.isOnBorder(u2.y, c2.y)) continue;
              const h2 = Vp.computeEdgeHash(this.unevalVertices[r3], this.unevalVertices[l2]);
              let p2, d2 = this.vertexHashLookup.get(Vp.computePosHash(u2));
              null != d2 ? p2 = d2.next : (d2 = this.vertexHashLookup.get(Vp.computePosHash(c2)), p2 = null != d2 ? d2.prev : h2), this.unevalEdges.push({ polygonIdx: t2, a: r3, b: l2, hash: h2, portalHash: p2, isTunnel: n2, type: "unevaluated", featureInfo: s2 });
            }
          }
          addPortalCandidates(t2, e2, r2, n2, i2) {
            if (0 !== e2.length) {
              this.vertexHashLookup.clear();
              for (const i3 of e2) {
                if (0 === i3.length) continue;
                const e3 = i3[0];
                let s2 = Vp.computeEdgeHash(e3[e3.length - 2], e3[e3.length - 1]);
                for (let i4 = 0; i4 < e3.length - 1; i4++) {
                  const a2 = e3[i4 + 0], o2 = e3[i4 + 1], l2 = ht(o2.x - a2.x, o2.y - a2.y), u2 = yt(l2);
                  if (0 === u2) continue;
                  let c2 = "unevaluated";
                  const h2 = n2.pointElevation(a2), p2 = n2.pointElevation(o2);
                  Math.abs(h2) < 0.01 && Math.abs(p2) < 0.01 ? c2 = "entrance" : (this.isOnBorder(a2.x, o2.x) || this.isOnBorder(a2.y, o2.y)) && (c2 = "border");
                  const d2 = Vp.computeEdgeHash(a2, o2);
                  this.unevaluatedPortals.portals.push({ connection: { a: t2, b: void 0 }, va: a2, vb: o2, vab: l2, length: u2, hash: d2, isTunnel: r2, type: c2 });
                  const f2 = Vp.computePosHash(a2);
                  this.vertexHashLookup.set(f2, { prev: s2, next: d2 }), s2 = d2;
                }
              }
            }
          }
          construct(t2) {
            if (0 === this.unevalVertices.length) return;
            const e2 = () => ({ vertexOffset: 0, primitiveOffset: this.indexArray.length }), r2 = (t3) => {
              t3.primitiveLength = this.indexArray.length - t3.primitiveOffset;
            }, n2 = new Tp(this.vertexPositions, this.vertexNormals, this.indexArray);
            this.prepareEdges(t2.portals, this.unevalEdges);
            const i2 = e2(), s2 = e2(), a2 = e2(), o2 = (t3, e3) => {
              t3.sort((t4, r4) => t4.type === e3 && r4.type !== e3 ? -1 : t4.type !== e3 && r4.type === e3 ? 1 : 0);
              const r3 = t3.findIndex((t4) => t4.type !== e3);
              return r3 >= 0 ? r3 : t3.length;
            };
            let l2 = 0;
            this.unevalEdges.length > 0 && (l2 = o2(this.unevalEdges, "none"), this.constructBridgeStructures(n2, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: l2 }, this.tileToMeters)), r2(a2);
            const u2 = e2(), c2 = e2();
            if (this.unevalEdges.length > 0) {
              const t3 = this.unevalEdges.splice(l2), e3 = o2(t3, "tunnel") + l2;
              this.unevalEdges.push(...t3), this.constructTunnelStructures(n2, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: l2 }, { min: l2, max: e3 });
            }
            r2(u2), n2.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r2(c2), n2.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r2(s2), n2.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-0.1]), r2(i2), this.maskSegments = Ol.simpleSegment(0, c2.primitiveOffset, 0, c2.primitiveLength), this.depthSegments = Ol.simpleSegment(0, s2.primitiveOffset, 0, s2.primitiveLength), this.renderableBridgeSegments = Ol.simpleSegment(0, a2.primitiveOffset, 0, a2.primitiveLength), this.renderableTunnelSegments = Ol.simpleSegment(0, u2.primitiveOffset, 0, u2.primitiveLength), this.shadowCasterSegments = Ol.simpleSegment(0, i2.primitiveOffset, 0, i2.primitiveLength);
          }
          update(t2, e2, r2, n2, i2, s2, a2, o2) {
            this.bridgeProgramConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, o2), this.tunnelProgramConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, o2);
          }
          upload(t2) {
            this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t2.createVertexBuffer(this.vertexPositions, Jh.members), this.vertexBufferNormal = t2.createVertexBuffer(this.vertexNormals, Kh.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.bridgeProgramConfigurations.upload(t2), this.tunnelProgramConfigurations.upload(t2));
          }
          destroy() {
            this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableBridgeSegments.destroy(), this.renderableTunnelSegments.destroy(), this.shadowCasterSegments.destroy()), this.bridgeProgramConfigurations.destroy(), this.tunnelProgramConfigurations.destroy();
          }
          populatePaintArrays(t2, e2, r2, n2, i2) {
            const s2 = (s3, a2) => {
              for (let o2 = 0; o2 < a2.length - 1; o2++) {
                const l2 = a2[o2].featureIndex, u2 = a2[o2 + 1].vertexStart, c2 = t2.feature(l2);
                s3.populatePaintArrays(u2, c2, l2, {}, r2, e2, n2, void 0, i2);
              }
            };
            s2(this.bridgeProgramConfigurations, this.bridgeFeatureSections), s2(this.tunnelProgramConfigurations, this.tunnelFeatureSections);
          }
          computeVertexConnections(t2, e2, r2, n2, i2) {
            const s2 = /* @__PURE__ */ new Map();
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r2[a2], i3 = n3.a, o2 = n3.b, l2 = Vp.computePosHash(t2[i3]), u2 = Vp.computePosHash(t2[o2]);
              let c2 = s2.get(l2);
              c2 || (c2 = {}, s2.set(l2, c2));
              let h2 = s2.get(u2);
              h2 || (h2 = {}, s2.set(u2, h2)), e2[i3] <= 0 && e2[o2] <= 0 || (c2.to = o2, h2.from = i3);
            }
            return s2;
          }
          isTerminalVertex(t2, e2) {
            const r2 = Vp.computePosHash(this.unevalVertices[t2]), n2 = e2.get(r2);
            return !n2 || !n2.from || !n2.to;
          }
          constructBridgeStructures(t2, e2, r2, n2, i2, s2) {
            t2.clearVertexLookup();
            const a2 = this.computeVertexConnections(e2, r2, n2, i2.min, i2.max), o2 = 1 / s2, l2 = 0.5 * o2, u2 = (t3, n3) => S(t3, e2[n3].x, e2[n3].y, r2[n3] * o2), c2 = _(), h2 = _(), p2 = _(), d2 = _(), f2 = _(), m2 = (t3, r3) => {
              const n3 = a2.get(Vp.computePosHash(e2[r3])), i3 = n3.from, s3 = n3.to;
              if (!i3 || !s3) return;
              u2(c2, i3), u2(h2, r3), u2(p2, s3), q(d2), X(c2, h2) || (H(f2, h2, c2), L(d2, f2)), X(p2, h2) || (H(f2, p2, h2), P(d2, d2, L(f2, f2)));
              const o3 = W(d2);
              return o3 > 0 ? V(t3, d2, 1 / o3) : void 0;
            };
            let y2 = Number.POSITIVE_INFINITY;
            this.sortSubarray(n2, i2.min, i2.max, (t3, e3) => t3.featureInfo.featureIndex - e3.featureInfo.featureIndex);
            const g2 = _(), x2 = _(), v2 = _(), b2 = _(), w2 = _(), A2 = _(), M2 = _(), I2 = _(), z2 = _(), B2 = [_(), _(), _(), _()], k2 = [_(), _(), _(), _()], T2 = [{ coord: new It(0, 0), height: 0 }, { coord: new It(0, 0), height: 0 }], E2 = (t3, e3) => t3 > e3;
            for (let u3 = i2.min; u3 < i2.max; u3++) {
              const i3 = n2[u3];
              if (!i3.featureInfo.guardRailEnabled) continue;
              if (!this.prepareEdgePoints(T2, e2, r2, i3, E2)) continue;
              const [c3, h3] = T2;
              if (S(g2, c3.coord.x, c3.coord.y, o2 * c3.height), S(x2, h3.coord.x, h3.coord.y, o2 * h3.height), X(g2, x2)) continue;
              H(v2, x2, g2), L(v2, v2);
              const p3 = m2(I2, i3.a) || v2, d3 = m2(z2, i3.b) || v2;
              S(b2, p3[1], -p3[0], 0), L(b2, b2), S(w2, d3[1], -d3[0], 0), L(w2, w2), U(I2, b2, p3), L(A2, I2), U(I2, w2, d3), L(M2, I2), P(B2[0], g2, V(I2, H(I2, b2, A2), l2)), P(B2[1], g2, V(I2, P(I2, b2, A2), l2)), P(B2[2], g2, V(I2, A2, l2)), B2[3] = g2, P(k2[0], x2, V(I2, H(I2, w2, M2), l2)), P(k2[1], x2, V(I2, P(I2, w2, M2), l2)), P(k2[2], x2, V(I2, M2, l2)), k2[3] = x2, y2 = this.addFeatureSection(i3.featureInfo.featureIndex, y2, this.bridgeFeatureSections, t2);
              const f3 = t2.addVertex(B2[0], b2, s2), _2 = t2.addVertex(B2[1], b2, s2), F2 = t2.addVertex(k2[0], w2, s2), D2 = t2.addVertex(k2[1], w2, s2);
              t2.addTriangle(f3, _2, F2), t2.addTriangle(_2, D2, F2);
              const C2 = t2.addVertex(B2[1], A2, s2), O2 = t2.addVertex(B2[2], A2, s2), N2 = t2.addVertex(k2[1], M2, s2), j2 = t2.addVertex(k2[2], M2, s2);
              t2.addTriangle(C2, O2, N2), t2.addTriangle(O2, j2, N2), R(b2, b2), R(w2, w2);
              const G2 = t2.addVertex(B2[2], b2, s2), $2 = t2.addVertex(B2[3], b2, s2), q2 = t2.addVertex(k2[2], w2, s2), Z2 = t2.addVertex(k2[3], w2, s2);
              t2.addTriangle(G2, $2, q2), t2.addTriangle($2, Z2, q2);
              const W2 = this.isTerminalVertex(i3.a, a2), Y2 = this.isTerminalVertex(i3.b, a2);
              c3.height < 0.01 && W2 && t2.addQuad(B2[3], B2[2], B2[1], B2[0], R(p3, p3), s2), h3.height < 0.01 && Y2 && t2.addQuad(k2[0], k2[1], k2[2], k2[3], d3, s2);
            }
            this.bridgeFeatureSections.push({ featureIndex: Number.POSITIVE_INFINITY, vertexStart: t2.getVertexCount() });
          }
          constructTunnelStructures(t2, e2, r2, n2, i2, s2) {
            t2.clearVertexLookup();
            let a2 = Number.POSITIVE_INFINITY;
            const o2 = (t3, e3) => t3.featureInfo.featureIndex - e3.featureInfo.featureIndex;
            this.sortSubarray(n2, i2.min, i2.max, o2), this.sortSubarray(n2, s2.min, s2.max, o2);
            const l2 = (t3) => L(t3, t3), u2 = [{ coord: new It(0, 0), height: 0 }, { coord: new It(0, 0), height: 0 }], c2 = (t3, e3) => t3 < e3, h2 = _(), p2 = _(), d2 = _(), f2 = _(), m2 = _();
            for (let s3 = i2.min; s3 < i2.max; s3++) {
              if (!this.prepareEdgePoints(u2, e2, r2, n2[s3], c2)) continue;
              const [i3, o3] = u2, y2 = l2(S(m2, -(o3.coord.y - i3.coord.y), o3.coord.x - i3.coord.x, 0));
              a2 = this.addFeatureSection(n2[s3].featureInfo.featureIndex, a2, this.tunnelFeatureSections, t2), t2.addQuad(S(h2, i3.coord.x, i3.coord.y, i3.height), S(p2, o3.coord.x, o3.coord.y, o3.height), S(d2, o3.coord.x, o3.coord.y, n2[s3].isTunnel ? -0.1 : 0), S(f2, i3.coord.x, i3.coord.y, n2[s3].isTunnel ? -0.1 : 0), y2);
            }
            for (let i3 = s2.min; i3 < s2.max; i3++) {
              const s3 = n2[i3];
              s3.isTunnel && ([s3.a, s3.b] = [s3.b, s3.a]);
              const o3 = e2[s3.a], u3 = e2[s3.b], c3 = l2(S(m2, -(u3.y - o3.y), u3.x - o3.x, 0));
              a2 = this.addFeatureSection(s3.featureInfo.featureIndex, a2, this.tunnelFeatureSections, t2), t2.addQuad(S(h2, u3.x, u3.y, 0), S(p2, o3.x, o3.y, 0), S(d2, o3.x, o3.y, r2[s3.a] + 4), S(f2, u3.x, u3.y, r2[s3.b] + 4), c3), t2.addQuad(S(h2, o3.x, o3.y, 0), S(p2, u3.x, u3.y, 0), S(d2, u3.x, u3.y, r2[s3.b] + 4), S(f2, o3.x, o3.y, r2[s3.a] + 4), c3);
            }
            this.tunnelFeatureSections.push({ featureIndex: Number.POSITIVE_INFINITY, vertexStart: t2.getVertexCount() });
          }
          setElevatedPoint(t2, e2, r2, n2) {
            t2.coord.x = e2, t2.coord.y = r2, t2.height = n2;
          }
          prepareEdgePoints(t2, e2, r2, n2, i2) {
            let s2 = e2[n2.a].x, a2 = e2[n2.a].y, o2 = e2[n2.b].x, l2 = e2[n2.b].y, u2 = r2[n2.a], c2 = r2[n2.b];
            const h2 = i2(u2, 0), p2 = i2(c2, 0);
            if (h2 && p2) return this.setElevatedPoint(t2[0], s2, a2, u2), this.setElevatedPoint(t2[1], o2, l2, c2), true;
            if (!h2 && !p2) return false;
            if (h2) {
              if (!p2) {
                const t3 = c2 / (c2 - u2);
                o2 = dr(o2, s2, t3), l2 = dr(l2, a2, t3), c2 = dr(c2, u2, t3);
              }
            } else {
              const t3 = u2 / (u2 - c2);
              s2 = dr(s2, o2, t3), a2 = dr(a2, l2, t3), u2 = dr(u2, c2, t3);
            }
            return this.setElevatedPoint(t2[0], s2, a2, u2), this.setElevatedPoint(t2[1], o2, l2, c2), true;
          }
          prepareEdges(t2, e2) {
            if (0 === e2.length) return;
            e2.sort((t3, e3) => t3.hash === e3.hash ? e3.polygonIdx - t3.polygonIdx : e3.hash > t3.hash ? 1 : -1);
            let r2 = 0, n2 = 0, i2 = 0, s2 = e2[r2].polygonIdx;
            do {
              n2++, (n2 === e2.length || e2[r2].hash !== e2[n2].hash) && ((1 === n2 - r2 || e2[n2 - 1].polygonIdx !== s2) && (i2 < r2 && (e2[i2] = e2[r2], e2[r2] = null), e2[i2].type = "none", i2++), r2 = n2, r2 !== e2.length && (s2 = e2[r2].polygonIdx));
            } while (r2 !== e2.length);
            if (e2.splice(i2), 0 !== e2.length && 0 !== t2.length) {
              e2.sort((t3, e3) => t3.portalHash < e3.portalHash ? 1 : -1);
              let r3 = 0, n3 = 0;
              for (; r3 !== e2.length && n3 !== t2.length; ) {
                const i3 = e2[r3], s3 = t2[n3];
                i3.portalHash > s3.hash ? r3++ : s3.hash > i3.portalHash ? n3++ : (i3.type = s3.type, r3++);
              }
            }
          }
          isOnBorder(t2, e2) {
            return t2 <= 0 && e2 <= 0 || t2 >= jn && e2 >= jn;
          }
          addFeatureSection(t2, e2, r2, n2) {
            return t2 !== e2 && (e2 = t2, r2.push({ featureIndex: t2, vertexStart: n2.getVertexCount() }), n2.clearVertexLookup()), e2;
          }
          sortSubarray(t2, e2, r2, n2) {
            const i2 = t2.slice(e2, r2);
            i2.sort(n2), t2.splice(e2, i2.length, ...i2);
          }
          static computeEdgeHash(t2, e2) {
            return (t2.y === e2.y && t2.x > e2.x || t2.y > e2.y) && ([t2, e2] = [e2, t2]), BigInt(Vp.computePosHash(t2)) << 32n | BigInt(Vp.computePosHash(e2));
          }
          static computePosHash(t2) {
            return ((65535 & t2.x) << 16 | 65535 & t2.y) >>> 0;
          }
        }
        function Ep(t2, e2) {
          return t2 > e2 ? 1 : t2 < e2 ? -1 : 0;
        }
        class Fp {
          constructor(t2 = Ep, e2 = false) {
            this._compare = t2, this._root = null, this._size = 0, this._noDuplicates = !!e2;
          }
          rotateLeft(t2) {
            var e2 = t2.right;
            e2 && (t2.right = e2.left, e2.left && (e2.left.parent = t2), e2.parent = t2.parent), t2.parent ? t2 === t2.parent.left ? t2.parent.left = e2 : t2.parent.right = e2 : this._root = e2, e2 && (e2.left = t2), t2.parent = e2;
          }
          rotateRight(t2) {
            var e2 = t2.left;
            e2 && (t2.left = e2.right, e2.right && (e2.right.parent = t2), e2.parent = t2.parent), t2.parent ? t2 === t2.parent.left ? t2.parent.left = e2 : t2.parent.right = e2 : this._root = e2, e2 && (e2.right = t2), t2.parent = e2;
          }
          _splay(t2) {
            for (; t2.parent; ) {
              var e2 = t2.parent;
              e2.parent ? e2.left === t2 && e2.parent.left === e2 ? (this.rotateRight(e2.parent), this.rotateRight(e2)) : e2.right === t2 && e2.parent.right === e2 ? (this.rotateLeft(e2.parent), this.rotateLeft(e2)) : e2.left === t2 && e2.parent.right === e2 ? (this.rotateRight(e2), this.rotateLeft(e2)) : (this.rotateLeft(e2), this.rotateRight(e2)) : e2.left === t2 ? this.rotateRight(e2) : this.rotateLeft(e2);
            }
          }
          splay(t2) {
            for (var e2, r2, n2, i2, s2; t2.parent; ) (r2 = (e2 = t2.parent).parent) && r2.parent ? ((n2 = r2.parent).left === r2 ? n2.left = t2 : n2.right = t2, t2.parent = n2) : (t2.parent = null, this._root = t2), i2 = t2.left, s2 = t2.right, t2 === e2.left ? (r2 && (r2.left === e2 ? (e2.right ? (r2.left = e2.right, r2.left.parent = r2) : r2.left = null, e2.right = r2, r2.parent = e2) : (i2 ? (r2.right = i2, i2.parent = r2) : r2.right = null, t2.left = r2, r2.parent = t2)), s2 ? (e2.left = s2, s2.parent = e2) : e2.left = null, t2.right = e2, e2.parent = t2) : (r2 && (r2.right === e2 ? (e2.left ? (r2.right = e2.left, r2.right.parent = r2) : r2.right = null, e2.left = r2, r2.parent = e2) : (s2 ? (r2.left = s2, s2.parent = r2) : r2.left = null, t2.right = r2, r2.parent = t2)), i2 ? (e2.right = i2, i2.parent = e2) : e2.right = null, t2.left = e2, e2.parent = t2);
          }
          replace(t2, e2) {
            t2.parent ? t2 === t2.parent.left ? t2.parent.left = e2 : t2.parent.right = e2 : this._root = e2, e2 && (e2.parent = t2.parent);
          }
          minNode(t2 = this._root) {
            if (t2) for (; t2.left; ) t2 = t2.left;
            return t2;
          }
          maxNode(t2 = this._root) {
            if (t2) for (; t2.right; ) t2 = t2.right;
            return t2;
          }
          insert(t2, e2) {
            var r2 = this._root, n2 = null, i2 = this._compare;
            if (this._noDuplicates) for (; r2; ) {
              if (n2 = r2, 0 === i2(r2.key, t2)) return;
              r2 = i2(r2.key, t2) < 0 ? r2.right : r2.left;
            }
            else for (; r2; ) n2 = r2, r2 = i2(r2.key, t2) < 0 ? r2.right : r2.left;
            return r2 = { key: t2, data: e2, left: null, right: null, parent: n2 }, n2 ? i2(n2.key, r2.key) < 0 ? n2.right = r2 : n2.left = r2 : this._root = r2, this.splay(r2), this._size++, r2;
          }
          find(t2) {
            for (var e2 = this._root, r2 = this._compare; e2; ) {
              var n2 = r2(e2.key, t2);
              if (n2 < 0) e2 = e2.right;
              else {
                if (!(n2 > 0)) return e2;
                e2 = e2.left;
              }
            }
            return null;
          }
          contains(t2) {
            for (var e2 = this._root, r2 = this._compare; e2; ) {
              var n2 = r2(t2, e2.key);
              if (0 === n2) return true;
              e2 = n2 < 0 ? e2.left : e2.right;
            }
            return false;
          }
          remove(t2) {
            var e2 = this.find(t2);
            if (!e2) return false;
            if (this.splay(e2), e2.left) if (e2.right) {
              var r2 = this.minNode(e2.right);
              r2.parent !== e2 && (this.replace(r2, r2.right), r2.right = e2.right, r2.right.parent = r2), this.replace(e2, r2), r2.left = e2.left, r2.left.parent = r2;
            } else this.replace(e2, e2.left);
            else this.replace(e2, e2.right);
            return this._size--, true;
          }
          removeNode(t2) {
            if (!t2) return false;
            if (this.splay(t2), t2.left) if (t2.right) {
              var e2 = this.minNode(t2.right);
              e2.parent !== t2 && (this.replace(e2, e2.right), e2.right = t2.right, e2.right.parent = e2), this.replace(t2, e2), e2.left = t2.left, e2.left.parent = e2;
            } else this.replace(t2, t2.left);
            else this.replace(t2, t2.right);
            return this._size--, true;
          }
          erase(t2) {
            var e2 = this.find(t2);
            if (e2) {
              this.splay(e2);
              var r2 = e2.left, n2 = e2.right, i2 = null;
              r2 && (r2.parent = null, i2 = this.maxNode(r2), this.splay(i2), this._root = i2), n2 && (r2 ? i2.right = n2 : this._root = n2, n2.parent = i2), this._size--;
            }
          }
          pop() {
            var t2 = this._root, e2 = null;
            if (t2) {
              for (; t2.left; ) t2 = t2.left;
              e2 = { key: t2.key, data: t2.data }, this.remove(t2.key);
            }
            return e2;
          }
          next(t2) {
            var e2 = t2;
            if (e2) if (e2.right) for (e2 = e2.right; e2 && e2.left; ) e2 = e2.left;
            else for (e2 = t2.parent; e2 && e2.right === t2; ) t2 = e2, e2 = e2.parent;
            return e2;
          }
          prev(t2) {
            var e2 = t2;
            if (e2) if (e2.left) for (e2 = e2.left; e2 && e2.right; ) e2 = e2.right;
            else for (e2 = t2.parent; e2 && e2.left === t2; ) t2 = e2, e2 = e2.parent;
            return e2;
          }
          forEach(t2) {
            for (var e2 = this._root, r2 = [], n2 = false, i2 = 0; !n2; ) e2 ? (r2.push(e2), e2 = e2.left) : r2.length > 0 ? (t2(e2 = r2.pop(), i2++), e2 = e2.right) : n2 = true;
            return this;
          }
          range(t2, e2, r2, n2) {
            const i2 = [], s2 = this._compare;
            let a2, o2 = this._root;
            for (; 0 !== i2.length || o2; ) if (o2) i2.push(o2), o2 = o2.left;
            else {
              if (o2 = i2.pop(), a2 = s2(o2.key, e2), a2 > 0) break;
              if (s2(o2.key, t2) >= 0 && r2.call(n2, o2)) return this;
              o2 = o2.right;
            }
            return this;
          }
          keys() {
            for (var t2 = this._root, e2 = [], r2 = [], n2 = false; !n2; ) t2 ? (e2.push(t2), t2 = t2.left) : e2.length > 0 ? (t2 = e2.pop(), r2.push(t2.key), t2 = t2.right) : n2 = true;
            return r2;
          }
          values() {
            for (var t2 = this._root, e2 = [], r2 = [], n2 = false; !n2; ) t2 ? (e2.push(t2), t2 = t2.left) : e2.length > 0 ? (t2 = e2.pop(), r2.push(t2.data), t2 = t2.right) : n2 = true;
            return r2;
          }
          at(t2) {
            for (var e2 = this._root, r2 = [], n2 = false, i2 = 0; !n2; ) if (e2) r2.push(e2), e2 = e2.left;
            else if (r2.length > 0) {
              if (e2 = r2.pop(), i2 === t2) return e2;
              i2++, e2 = e2.right;
            } else n2 = true;
            return null;
          }
          load(t2 = [], e2 = [], r2 = false) {
            if (0 !== this._size) throw new Error("bulk-load: tree is not empty");
            const n2 = t2.length;
            return r2 && Cp(t2, e2, 0, n2 - 1, this._compare), this._root = Dp(null, t2, e2, 0, n2), this._size = n2, this;
          }
          min() {
            var t2 = this.minNode(this._root);
            return t2 ? t2.key : null;
          }
          max() {
            var t2 = this.maxNode(this._root);
            return t2 ? t2.key : null;
          }
          isEmpty() {
            return null === this._root;
          }
          get size() {
            return this._size;
          }
          static createTree(t2, e2, r2, n2, i2) {
            return new Fp(r2, i2).load(t2, e2, n2);
          }
        }
        function Dp(t2, e2, r2, n2, i2) {
          const s2 = i2 - n2;
          if (s2 > 0) {
            const a2 = n2 + Math.floor(s2 / 2), o2 = { key: e2[a2], data: r2[a2], parent: t2 };
            return o2.left = Dp(o2, e2, r2, n2, a2), o2.right = Dp(o2, e2, r2, a2 + 1, i2), o2;
          }
          return null;
        }
        function Cp(t2, e2, r2, n2, i2) {
          if (r2 >= n2) return;
          const s2 = t2[r2 + n2 >> 1];
          let a2 = r2 - 1, o2 = n2 + 1;
          for (; ; ) {
            do {
              a2++;
            } while (i2(t2[a2], s2) < 0);
            do {
              o2--;
            } while (i2(t2[o2], s2) > 0);
            if (a2 >= o2) break;
            let r3 = t2[a2];
            t2[a2] = t2[o2], t2[o2] = r3, r3 = e2[a2], e2[a2] = e2[o2], e2[o2] = r3;
          }
          Cp(t2, e2, r2, o2, i2), Cp(t2, e2, o2 + 1, n2, i2);
        }
        const Rp = 11102230246251565e-32, Lp = 134217729, Op = (3 + 8 * Rp) * Rp;
        function Up(t2, e2, r2, n2, i2) {
          let s2, a2, o2, l2, u2 = e2[0], c2 = n2[0], h2 = 0, p2 = 0;
          c2 > u2 == c2 > -u2 ? (s2 = u2, u2 = e2[++h2]) : (s2 = c2, c2 = n2[++p2]);
          let d2 = 0;
          if (h2 < t2 && p2 < r2) for (c2 > u2 == c2 > -u2 ? (a2 = u2 + s2, o2 = s2 - (a2 - u2), u2 = e2[++h2]) : (a2 = c2 + s2, o2 = s2 - (a2 - c2), c2 = n2[++p2]), s2 = a2, 0 !== o2 && (i2[d2++] = o2); h2 < t2 && p2 < r2; ) c2 > u2 == c2 > -u2 ? (a2 = s2 + u2, l2 = a2 - s2, o2 = s2 - (a2 - l2) + (u2 - l2), u2 = e2[++h2]) : (a2 = s2 + c2, l2 = a2 - s2, o2 = s2 - (a2 - l2) + (c2 - l2), c2 = n2[++p2]), s2 = a2, 0 !== o2 && (i2[d2++] = o2);
          for (; h2 < t2; ) a2 = s2 + u2, l2 = a2 - s2, o2 = s2 - (a2 - l2) + (u2 - l2), u2 = e2[++h2], s2 = a2, 0 !== o2 && (i2[d2++] = o2);
          for (; p2 < r2; ) a2 = s2 + c2, l2 = a2 - s2, o2 = s2 - (a2 - l2) + (c2 - l2), c2 = n2[++p2], s2 = a2, 0 !== o2 && (i2[d2++] = o2);
          return 0 === s2 && 0 !== d2 || (i2[d2++] = s2), d2;
        }
        function Np(t2) {
          return new Float64Array(t2);
        }
        const jp = Np(4), Gp = Np(8), $p = Np(12), qp = Np(16), Xp = Np(4);
        function Hp(t2, e2, r2) {
          null === e2 ? (t2.inOut = false, t2.otherInOut = true) : (t2.isSubject === e2.isSubject ? (t2.inOut = !e2.inOut, t2.otherInOut = e2.otherInOut) : (t2.inOut = !e2.otherInOut, t2.otherInOut = e2.isVertical() ? !e2.inOut : e2.inOut), e2 && (t2.prevInResult = !Zp(e2, r2) || e2.isVertical() ? e2.prevInResult : e2)), t2.resultTransition = Zp(t2, r2) ? function(t3, e3) {
            let r3, n2 = !t3.inOut, i2 = !t3.otherInOut;
            switch (e3) {
              case 0:
                r3 = n2 && i2;
                break;
              case 1:
                r3 = n2 || i2;
                break;
              case 3:
                r3 = n2 !== i2;
                break;
              case 2:
                r3 = t3.isSubject ? n2 && !i2 : i2 && !n2;
            }
            return r3 ? 1 : -1;
          }(t2, r2) : 0;
        }
        function Zp(t2, e2) {
          switch (t2.type) {
            case 0:
              switch (e2) {
                case 0:
                  return !t2.otherInOut;
                case 1:
                  return t2.otherInOut;
                case 2:
                  return t2.isSubject && t2.otherInOut || !t2.isSubject && !t2.otherInOut;
                case 3:
                  return true;
              }
              break;
            case 2:
              return 0 === e2 || 1 === e2;
            case 3:
              return 2 === e2;
            case 1:
              return false;
          }
          return false;
        }
        class Wp {
          constructor(t2, e2, r2, n2, i2) {
            this.left = e2, this.point = t2, this.otherEvent = r2, this.isSubject = n2 ?? false, this.type = i2 || 0, this.inOut = false, this.otherInOut = false, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = true;
          }
          isBelow(t2) {
            const e2 = this.point, r2 = this.otherEvent.point;
            return this.left ? (e2[0] - t2[0]) * (r2[1] - t2[1]) - (r2[0] - t2[0]) * (e2[1] - t2[1]) > 0 : (r2[0] - t2[0]) * (e2[1] - t2[1]) - (e2[0] - t2[0]) * (r2[1] - t2[1]) > 0;
          }
          isAbove(t2) {
            return !this.isBelow(t2);
          }
          isVertical() {
            return this.point[0] === this.otherEvent.point[0];
          }
          get inResult() {
            return 0 !== this.resultTransition;
          }
          clone() {
            const t2 = new Wp(this.point, this.left, this.otherEvent, this.isSubject, this.type);
            return t2.contourId = this.contourId, t2.resultTransition = this.resultTransition, t2.prevInResult = this.prevInResult, t2.isExteriorRing = this.isExteriorRing, t2.inOut = this.inOut, t2.otherInOut = this.otherInOut, t2;
          }
        }
        function Yp(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1];
        }
        function Jp(t2, e2, r2) {
          const n2 = function(t3, e3, r3, n3, i2, s2) {
            const a2 = (e3 - s2) * (r3 - i2), o2 = (t3 - i2) * (n3 - s2), l2 = a2 - o2;
            if (0 === a2 || 0 === o2 || a2 > 0 != o2 > 0) return l2;
            const u2 = Math.abs(a2 + o2);
            return Math.abs(l2) >= 33306690738754716e-32 * u2 ? l2 : -function(t4, e4, r4, n4, i3, s3, a3) {
              let o3, l3, u3, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2, w2, _2, A2, M2;
              const I2 = t4 - i3, S2 = r4 - i3, P2 = e4 - s3, z2 = n4 - s3;
              b2 = I2 * z2, p2 = Lp * I2, d2 = p2 - (p2 - I2), f2 = I2 - d2, p2 = Lp * z2, m2 = p2 - (p2 - z2), y2 = z2 - m2, w2 = f2 * y2 - (b2 - d2 * m2 - f2 * m2 - d2 * y2), _2 = P2 * S2, p2 = Lp * P2, d2 = p2 - (p2 - P2), f2 = P2 - d2, p2 = Lp * S2, m2 = p2 - (p2 - S2), y2 = S2 - m2, A2 = f2 * y2 - (_2 - d2 * m2 - f2 * m2 - d2 * y2), g2 = w2 - A2, h2 = w2 - g2, jp[0] = w2 - (g2 + h2) + (h2 - A2), x2 = b2 + g2, h2 = x2 - b2, v2 = b2 - (x2 - h2) + (g2 - h2), g2 = v2 - _2, h2 = v2 - g2, jp[1] = v2 - (g2 + h2) + (h2 - _2), M2 = x2 + g2, h2 = M2 - x2, jp[2] = x2 - (M2 - h2) + (g2 - h2), jp[3] = M2;
              let B2 = function(t5, e5) {
                let r5 = e5[0];
                for (let t6 = 1; t6 < 4; t6++) r5 += e5[t6];
                return r5;
              }(0, jp), k2 = 22204460492503146e-32 * a3;
              if (B2 >= k2 || -B2 >= k2) return B2;
              if (h2 = t4 - I2, o3 = t4 - (I2 + h2) + (h2 - i3), h2 = r4 - S2, u3 = r4 - (S2 + h2) + (h2 - i3), h2 = e4 - P2, l3 = e4 - (P2 + h2) + (h2 - s3), h2 = n4 - z2, c2 = n4 - (z2 + h2) + (h2 - s3), 0 === o3 && 0 === l3 && 0 === u3 && 0 === c2) return B2;
              if (k2 = 11093356479670487e-47 * a3 + Op * Math.abs(B2), B2 += I2 * c2 + z2 * o3 - (P2 * u3 + S2 * l3), B2 >= k2 || -B2 >= k2) return B2;
              b2 = o3 * z2, p2 = Lp * o3, d2 = p2 - (p2 - o3), f2 = o3 - d2, p2 = Lp * z2, m2 = p2 - (p2 - z2), y2 = z2 - m2, w2 = f2 * y2 - (b2 - d2 * m2 - f2 * m2 - d2 * y2), _2 = l3 * S2, p2 = Lp * l3, d2 = p2 - (p2 - l3), f2 = l3 - d2, p2 = Lp * S2, m2 = p2 - (p2 - S2), y2 = S2 - m2, A2 = f2 * y2 - (_2 - d2 * m2 - f2 * m2 - d2 * y2), g2 = w2 - A2, h2 = w2 - g2, Xp[0] = w2 - (g2 + h2) + (h2 - A2), x2 = b2 + g2, h2 = x2 - b2, v2 = b2 - (x2 - h2) + (g2 - h2), g2 = v2 - _2, h2 = v2 - g2, Xp[1] = v2 - (g2 + h2) + (h2 - _2), M2 = x2 + g2, h2 = M2 - x2, Xp[2] = x2 - (M2 - h2) + (g2 - h2), Xp[3] = M2;
              const T2 = Up(4, jp, 4, Xp, Gp);
              b2 = I2 * c2, p2 = Lp * I2, d2 = p2 - (p2 - I2), f2 = I2 - d2, p2 = Lp * c2, m2 = p2 - (p2 - c2), y2 = c2 - m2, w2 = f2 * y2 - (b2 - d2 * m2 - f2 * m2 - d2 * y2), _2 = P2 * u3, p2 = Lp * P2, d2 = p2 - (p2 - P2), f2 = P2 - d2, p2 = Lp * u3, m2 = p2 - (p2 - u3), y2 = u3 - m2, A2 = f2 * y2 - (_2 - d2 * m2 - f2 * m2 - d2 * y2), g2 = w2 - A2, h2 = w2 - g2, Xp[0] = w2 - (g2 + h2) + (h2 - A2), x2 = b2 + g2, h2 = x2 - b2, v2 = b2 - (x2 - h2) + (g2 - h2), g2 = v2 - _2, h2 = v2 - g2, Xp[1] = v2 - (g2 + h2) + (h2 - _2), M2 = x2 + g2, h2 = M2 - x2, Xp[2] = x2 - (M2 - h2) + (g2 - h2), Xp[3] = M2;
              const V2 = Up(T2, Gp, 4, Xp, $p);
              b2 = o3 * c2, p2 = Lp * o3, d2 = p2 - (p2 - o3), f2 = o3 - d2, p2 = Lp * c2, m2 = p2 - (p2 - c2), y2 = c2 - m2, w2 = f2 * y2 - (b2 - d2 * m2 - f2 * m2 - d2 * y2), _2 = l3 * u3, p2 = Lp * l3, d2 = p2 - (p2 - l3), f2 = l3 - d2, p2 = Lp * u3, m2 = p2 - (p2 - u3), y2 = u3 - m2, A2 = f2 * y2 - (_2 - d2 * m2 - f2 * m2 - d2 * y2), g2 = w2 - A2, h2 = w2 - g2, Xp[0] = w2 - (g2 + h2) + (h2 - A2), x2 = b2 + g2, h2 = x2 - b2, v2 = b2 - (x2 - h2) + (g2 - h2), g2 = v2 - _2, h2 = v2 - g2, Xp[1] = v2 - (g2 + h2) + (h2 - _2), M2 = x2 + g2, h2 = M2 - x2, Xp[2] = x2 - (M2 - h2) + (g2 - h2), Xp[3] = M2;
              const E2 = Up(V2, $p, 4, Xp, qp);
              return qp[E2 - 1];
            }(t3, e3, r3, n3, i2, s2, u2);
          }(t2[0], t2[1], e2[0], e2[1], r2[0], r2[1]);
          return n2 > 0 ? -1 : n2 < 0 ? 1 : 0;
        }
        function Kp(t2, e2) {
          const r2 = t2.point, n2 = e2.point;
          return r2[0] > n2[0] ? 1 : r2[0] < n2[0] ? -1 : r2[1] !== n2[1] ? r2[1] > n2[1] ? 1 : -1 : function(t3, e3, r3) {
            return t3.left !== e3.left ? t3.left ? 1 : -1 : 0 !== Jp(r3, t3.otherEvent.point, e3.otherEvent.point) ? t3.isBelow(e3.otherEvent.point) ? -1 : 1 : !t3.isSubject && e3.isSubject ? 1 : -1;
          }(t2, e2, r2);
        }
        function Qp(t2, e2, r2) {
          const n2 = new Wp(e2, false, t2, t2.isSubject), i2 = new Wp(e2, true, t2.otherEvent, t2.isSubject);
          return Yp(t2.point, t2.otherEvent.point) && console.warn("what is that, a collapsed segment?", t2), n2.contourId = i2.contourId = t2.contourId, Kp(i2, t2.otherEvent) > 0 && (t2.otherEvent.left = true, i2.left = false), t2.otherEvent.otherEvent = i2, t2.otherEvent = n2, r2.push(i2), r2.push(n2), r2;
        }
        function td(t2, e2) {
          return t2[0] * e2[1] - t2[1] * e2[0];
        }
        function ed(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1];
        }
        function rd(t2, e2, r2) {
          const n2 = function(t3, e3, r3, n3) {
            const i3 = [e3[0] - t3[0], e3[1] - t3[1]], s3 = [n3[0] - r3[0], n3[1] - r3[1]];
            function a3(t4, e4, r4) {
              return [t4[0] + e4 * r4[0], t4[1] + e4 * r4[1]];
            }
            const o3 = [r3[0] - t3[0], r3[1] - t3[1]];
            let l2 = td(i3, s3), u2 = l2 * l2;
            const c2 = ed(i3, i3);
            if (u2 > 0) {
              const e4 = td(o3, s3) / l2;
              if (e4 < 0 || e4 > 1) return null;
              const n4 = td(o3, i3) / l2;
              return n4 < 0 || n4 > 1 ? null : 0 === e4 || 1 === e4 ? [a3(t3, e4, i3)] : 0 === n4 || 1 === n4 ? [a3(r3, n4, s3)] : [a3(t3, e4, i3)];
            }
            if (l2 = td(o3, i3), u2 = l2 * l2, u2 > 0) return null;
            const h2 = ed(i3, o3) / c2, p2 = h2 + ed(i3, s3) / c2, d2 = Math.min(h2, p2), f2 = Math.max(h2, p2);
            return d2 <= 1 && f2 >= 0 ? 1 === d2 ? [a3(t3, d2 > 0 ? d2 : 0, i3)] : 0 === f2 ? [a3(t3, f2 < 1 ? f2 : 1, i3)] : [a3(t3, d2 > 0 ? d2 : 0, i3), a3(t3, f2 < 1 ? f2 : 1, i3)] : null;
          }(t2.point, t2.otherEvent.point, e2.point, e2.otherEvent.point), i2 = n2 ? n2.length : 0;
          if (0 === i2 || 1 === i2 && (Yp(t2.point, e2.point) || Yp(t2.otherEvent.point, e2.otherEvent.point)) || 2 === i2 && t2.isSubject === e2.isSubject) return 0;
          if (1 === i2) return !Yp(t2.point, n2[0]) && !Yp(t2.otherEvent.point, n2[0]) && Qp(t2, n2[0], r2), !Yp(e2.point, n2[0]) && !Yp(e2.otherEvent.point, n2[0]) && Qp(e2, n2[0], r2), 1;
          const s2 = [];
          let a2 = false, o2 = false;
          return Yp(t2.point, e2.point) ? a2 = true : 1 === Kp(t2, e2) ? s2.push(e2, t2) : s2.push(t2, e2), Yp(t2.otherEvent.point, e2.otherEvent.point) ? o2 = true : 1 === Kp(t2.otherEvent, e2.otherEvent) ? s2.push(e2.otherEvent, t2.otherEvent) : s2.push(t2.otherEvent, e2.otherEvent), a2 && o2 || a2 ? (e2.type = 1, t2.type = e2.inOut === t2.inOut ? 2 : 3, a2 && !o2 && Qp(s2[1].otherEvent, s2[0].point, r2), 2) : o2 ? (Qp(s2[0], s2[1].point, r2), 3) : s2[0] !== s2[3].otherEvent ? (Qp(s2[0], s2[1].point, r2), Qp(s2[1], s2[2].point, r2), 3) : (Qp(s2[0], s2[1].point, r2), Qp(s2[3].otherEvent, s2[2].point, r2), 3);
        }
        function nd(t2, e2) {
          if (t2 === e2) return 0;
          if (0 !== Jp(t2.point, t2.otherEvent.point, e2.point) || 0 !== Jp(t2.point, t2.otherEvent.point, e2.otherEvent.point)) return Yp(t2.point, e2.point) ? t2.isBelow(e2.otherEvent.point) ? -1 : 1 : t2.point[0] === e2.point[0] ? t2.point[1] < e2.point[1] ? -1 : 1 : 1 === Kp(t2, e2) ? e2.isAbove(t2.point) ? -1 : 1 : t2.isBelow(e2.point) ? -1 : 1;
          if (t2.isSubject !== e2.isSubject) return t2.isSubject ? -1 : 1;
          {
            let r2 = t2.point, n2 = e2.point;
            if (r2[0] === n2[0] && r2[1] === n2[1]) return r2 = t2.otherEvent.point, n2 = e2.otherEvent.point, r2[0] === n2[0] && r2[1] === n2[1] ? 0 : (t2.contourId ?? 0) > (e2.contourId ?? 0) ? 1 : -1;
          }
          return 1 === Kp(t2, e2) ? 1 : -1;
        }
        class id {
          constructor() {
            this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;
          }
          isExterior() {
            return null == this.holeOf;
          }
        }
        function sd(t2, e2, r2, n2) {
          let i2, s2 = t2 + 1, a2 = e2[t2].point;
          const o2 = e2.length;
          for (s2 < o2 && (i2 = e2[s2].point); s2 < o2 && i2[0] === a2[0] && i2[1] === a2[1]; ) {
            if (!r2[s2]) return s2;
            s2++, s2 < o2 && (i2 = e2[s2].point);
          }
          for (s2 = t2 - 1; r2[s2] && s2 > n2; ) s2--;
          return s2;
        }
        function ad(t2, e2, r2) {
          const n2 = new id();
          if (null != t2.prevInResult) {
            const i2 = t2.prevInResult, s2 = i2.outputContourId;
            if (i2.resultTransition > 0) {
              const t3 = e2[s2];
              if (null != t3.holeOf) {
                const i3 = t3.holeOf;
                e2[i3].holeIds.push(r2), n2.holeOf = i3, n2.depth = e2[s2].depth;
              } else e2[s2].holeIds.push(r2), n2.holeOf = s2, n2.depth = e2[s2].depth + 1;
            } else n2.holeOf = null, n2.depth = e2[s2].depth;
          } else n2.holeOf = null, n2.depth = 0;
          return n2;
        }
        const od = Math.max, ld = Math.min;
        let ud = 0;
        function cd(t2, e2, r2, n2, i2, s2) {
          let a2, o2, l2, u2, c2, h2;
          for (a2 = 0, o2 = t2.length - 1; a2 < o2; a2++) {
            if (l2 = t2[a2], u2 = t2[a2 + 1], c2 = new Wp(l2, false, void 0, e2), h2 = new Wp(u2, false, c2, e2), c2.otherEvent = h2, l2[0] === u2[0] && l2[1] === u2[1]) continue;
            c2.contourId = h2.contourId = r2, s2 || (c2.isExteriorRing = false, h2.isExteriorRing = false), Kp(c2, h2) > 0 ? h2.left = true : c2.left = true;
            const o3 = l2[0], p2 = l2[1];
            i2[0] = ld(i2[0], o3), i2[1] = ld(i2[1], p2), i2[2] = od(i2[2], o3), i2[3] = od(i2[3], p2), n2.push(c2), n2.push(h2);
          }
        }
        const hd = [];
        function pd(t2, e2, r2) {
          let n2 = t2, i2 = e2;
          "number" == typeof t2[0][0][0] && (n2 = [t2]), "number" == typeof e2[0][0][0] && (i2 = [e2]);
          let s2 = function(t3, e3, r3) {
            let n3 = null;
            return t3.length * e3.length === 0 && (0 === r3 ? n3 = hd : 2 === r3 ? n3 = t3 : (1 === r3 || 3 === r3) && (n3 = 0 === t3.length ? e3 : t3)), n3;
          }(n2, i2, r2);
          if (s2) return s2 === hd ? null : s2;
          const a2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l2 = function(t3, e3, r3, n3, i3) {
            const s3 = new Nn(void 0, Kp);
            let a3, o3, l3, u3, c3, h3;
            for (l3 = 0, u3 = t3.length; l3 < u3; l3++) for (a3 = t3[l3], c3 = 0, h3 = a3.length; c3 < h3; c3++) o3 = 0 === c3, o3 && ud++, cd(a3[c3], true, ud, s3, r3, o3);
            for (l3 = 0, u3 = e3.length; l3 < u3; l3++) for (a3 = e3[l3], c3 = 0, h3 = a3.length; c3 < h3; c3++) o3 = 0 === c3, 2 === i3 && (o3 = false), o3 && ud++, cd(a3[c3], false, ud, s3, n3, o3);
            return s3;
          }(n2, i2, a2, o2, r2);
          if (s2 = function(t3, e3, r3, n3, i3) {
            let s3 = null;
            return (r3[0] > n3[2] || n3[0] > r3[2] || r3[1] > n3[3] || n3[1] > r3[3]) && (0 === i3 ? s3 = hd : 2 === i3 ? s3 = t3 : (1 === i3 || 3 === i3) && (s3 = t3.concat(e3))), s3;
          }(n2, i2, a2, o2, r2), s2) return s2 === hd ? null : s2;
          const u2 = function(t3, e3, r3, n3, i3, s3) {
            const a3 = new Fp(nd), o3 = [], l3 = Math.min(n3[2], i3[2]);
            let u3, c3, h3;
            for (; 0 !== t3.length; ) {
              let e4 = t3.pop();
              if (o3.push(e4), 0 === s3 && e4.point[0] > l3 || 2 === s3 && e4.point[0] > n3[2]) break;
              if (e4.left) {
                c3 = u3 = a3.insert(e4), h3 = a3.minNode(), u3 = u3 !== h3 ? a3.prev(u3) : null, c3 = a3.next(c3);
                const r4 = u3 ? u3.key : null;
                let n4;
                if (Hp(e4, r4, s3), c3 && 2 === rd(e4, c3.key, t3) && (Hp(e4, r4, s3), Hp(c3.key, e4, s3)), u3 && 2 === rd(u3.key, e4, t3)) {
                  let t4 = u3;
                  t4 = t4 !== h3 ? a3.prev(t4) : null, n4 = t4 ? t4.key : null, Hp(r4, n4, s3), Hp(e4, r4, s3);
                }
              } else e4 = e4.otherEvent, c3 = u3 = a3.find(e4), u3 && c3 && (u3 = u3 !== h3 ? a3.prev(u3) : null, c3 = a3.next(c3), a3.remove(e4), c3 && u3 && rd(u3.key, c3.key, t3));
            }
            return o3;
          }(l2, 0, 0, a2, o2, r2), c2 = function(t3) {
            let e3, r3;
            const n3 = function(t4) {
              let e4, r4, n4, i4, s4;
              const a3 = [];
              for (r4 = 0, n4 = t4.length; r4 < n4; r4++) e4 = t4[r4], (e4.left && e4.inResult || !e4.left && e4.otherEvent.inResult) && a3.push(e4);
              let o3 = false;
              for (; !o3; ) for (o3 = true, r4 = 0, n4 = a3.length; r4 < n4; r4++) r4 + 1 < n4 && 1 === Kp(a3[r4], a3[r4 + 1]) && (i4 = a3[r4], a3[r4] = a3[r4 + 1], a3[r4 + 1] = i4, o3 = false);
              for (r4 = 0, n4 = a3.length; r4 < n4; r4++) e4 = a3[r4], e4.otherPos = r4;
              for (r4 = 0, n4 = a3.length; r4 < n4; r4++) e4 = a3[r4], e4.left || (s4 = e4.otherPos, e4.otherPos = e4.otherEvent.otherPos, e4.otherEvent.otherPos = s4);
              return a3;
            }(t3), i3 = {}, s3 = [];
            for (e3 = 0, r3 = n3.length; e3 < r3; e3++) {
              if (i3[e3]) continue;
              const t4 = s3.length, r4 = ad(n3[e3], s3, t4), a3 = (e4) => {
                i3[e4] = true, e4 < n3.length && n3[e4] && (n3[e4].outputContourId = t4);
              };
              let o3 = e3, l3 = e3;
              for (r4.points.push(n3[e3].point); a3(o3), o3 = n3[o3].otherPos, a3(o3), r4.points.push(n3[o3].point), o3 = sd(o3, n3, i3, l3), !(o3 == l3 || o3 >= n3.length) && n3[o3]; ) ;
              s3.push(r4);
            }
            return s3;
          }(u2), h2 = [];
          for (let t3 = 0; t3 < c2.length; t3++) {
            let e3 = c2[t3];
            if (e3.isExterior()) {
              let t4 = [e3.points];
              for (let r3 = 0; r3 < e3.holeIds.length; r3++) t4.push(c2[e3.holeIds[r3]].points);
              h2.push(t4);
            }
          }
          return h2;
        }
        function dd(t2, e2, r2, n2) {
          const i2 = [], s2 = 0 === n2 ? (t3, e3, r3, n3, i3, s3) => {
            t3.push(new It(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
          } : (t3, e3, r3, n3, i3, s3) => {
            t3.push(new It(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
          };
          for (const a2 of t2) {
            const t3 = [];
            for (const i3 of a2) {
              if (i3.length <= 2) continue;
              const a3 = [];
              for (let t4 = 0; t4 < i3.length - 1; t4++) {
                const o3 = i3[t4].x, l3 = i3[t4].y, u2 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h2 = 0 === n2 ? o3 : l3, p2 = 0 === n2 ? u2 : c2;
                h2 < e2 ? p2 > e2 && s2(a3, o3, l3, u2, c2, e2) : h2 > r2 ? p2 < r2 && s2(a3, o3, l3, u2, c2, r2) : a3.push(i3[t4]), p2 < e2 && h2 >= e2 && s2(a3, o3, l3, u2, c2, e2), p2 > r2 && h2 <= r2 && s2(a3, o3, l3, u2, c2, r2);
              }
              let o2 = i3[i3.length - 1];
              const l2 = 0 === n2 ? o2.x : o2.y;
              l2 >= e2 && l2 <= r2 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
            }
            t3.length && i2.push(t3);
          }
          return i2;
        }
        function fd(t2, e2) {
          const r2 = pd(yd(t2), yd([e2]), 0);
          return null == r2 ? [] : gd(r2);
        }
        function md(t2, e2) {
          const r2 = 65536;
          let n2 = yd(t2, r2);
          const i2 = [];
          for (; e2.valid(); e2.next()) {
            const [t3, n3] = e2.get(), s2 = t3.x * r2, a2 = t3.y * r2, o2 = n3.x * r2, l2 = n3.y * r2, u2 = o2 - s2, c2 = l2 - a2, h2 = Math.hypot(u2, c2);
            if (0 === h2) continue;
            const p2 = Math.trunc(c2 / h2 * 3), d2 = -Math.trunc(u2 / h2 * 3);
            i2.push([[[s2, a2], [o2, l2], [o2 + p2, l2 + d2], [s2 + p2, a2 + d2], [s2, a2]]]);
          }
          return i2.length > 0 && (n2 = pd(n2, i2, 2)), gd(n2, 1 / r2, 128);
        }
        function yd(t2, e2 = 1) {
          return [t2.map((t3) => t3.map((t4) => [t4.x * e2, t4.y * e2]))];
        }
        function gd(t2, e2 = 1, r2) {
          return t2.map((t3) => t3.map((t4, n2) => {
            const i2 = t4.map((t5) => {
              let n3 = t5[0], i3 = t5[1];
              return r2 && (n3 = Math.round(n3 / r2) * r2, i3 = Math.round(i3 / r2) * r2), new It(n3 * e2, i3 * e2)._round();
            });
            return n2 > 0 && i2.reverse(), i2;
          }));
        }
        class xd {
          constructor(t2, e2) {
            this.layoutVertexArray = new No(), this.indexArray = new ll(), this.lineIndexArray = new nl(), this.triangleSegments = new Ol(), this.lineSegments = new Ol(), this.programConfigurations = new fu(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.uploaded = false, e2 && (this.elevatedLayoutVertexArray = new $o());
          }
          update(t2, e2, r2, n2, i2, s2, a2, o2) {
            this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, o2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          needsUpload() {
            return this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Wh.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t2.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t2.createVertexBuffer(this.elevatedLayoutVertexArray, Yh.members))), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());
          }
          populatePaintArrays(t2, e2, r2, n2, i2, s2, a2) {
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, e2, r2, n2, i2, s2, void 0, a2);
          }
        }
        class vd {
          constructor(t2) {
            this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lut = t2.lut, this.bufferData = new xd(t2, false), this.elevationBufferData = new xd(t2, true), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference"), this.sourceLayerIndex = t2.sourceLayerIndex, this.worldview = t2.worldview, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          populate(t2, e2, r2, n2) {
            this.hasPattern = zp("fill", this.layers, this.pixelRatio, e2);
            const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = Ku(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), c2, r2)) continue;
              const h2 = i2 ? i2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Ju(a2, r2, n2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = Bp("fill", this.layers, n3, this.zoom, this.pixelRatio, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r2, {}, e2.availableImages, e2.brightness, e2.elevationFeatures);
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2, n2, i2, s2, a2) {
            this.bufferData.update(t2, e2, r2, n2, i2, s2, a2, this.worldview), this.elevationBufferData.update(t2, e2, r2, n2, i2, s2, a2, this.worldview), this.elevatedStructures && this.elevatedStructures.update(t2, e2, r2, n2, i2, s2, a2, this.worldview);
          }
          addFeatures(t2, e2, r2, n2, i2, s2) {
            for (const i3 of this.patternFeatures) this.addFeature(i3, i3.geometry, i3.index, e2, r2, n2, s2, t2.elevationFeatures);
          }
          isEmpty() {
            return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();
          }
          uploadPending() {
            return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();
          }
          upload(t2) {
            this.bufferData.upload(t2), this.elevationBufferData.upload(t2), this.elevatedStructures && this.elevatedStructures.upload(t2);
          }
          destroy() {
            this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();
          }
          addFeature(t2, e2, r2, n2, i2, s2 = [], a2, o2) {
            const l2 = Ip(e2, 500);
            "none" !== this.elevationMode ? this.addElevatedRoadFeature(t2, l2, n2, r2, o2) : this.addGeometry(l2, this.bufferData), this.bufferData.populatePaintArrays(t2, r2, i2, s2, n2, a2, this.worldview), this.elevationBufferData.populatePaintArrays(t2, r2, i2, s2, n2, a2, this.worldview);
          }
          getUnevaluatedPortalGraph() {
            return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;
          }
          setEvaluatedPortalGraph(t2, e2, r2, n2, i2) {
            this.elevatedStructures && (this.elevatedStructures.construct(t2), this.elevatedStructures.populatePaintArrays(e2, r2, n2, i2, this.worldview));
          }
          addElevatedRoadFeature(t2, e2, r2, n2, i2) {
            const s2 = new Array(), a2 = Mc.getElevationFeature(t2, i2);
            if (!a2) return void this.addGeometry(e2, this.bufferData);
            {
              const t3 = this.clipPolygonsToTile(e2, 1);
              t3.length > 0 && s2.push({ polygons: t3, elevationFeature: a2, elevationTileID: r2 });
            }
            const o2 = { guardRailEnabled: this.layers[0].layout.get("fill-construct-bridge-guard-rail").evaluate(t2, {}, r2), featureIndex: n2 };
            for (const e3 of s2) if (e3.elevationFeature) {
              if ("hd-road-base" === this.elevationMode) {
                this.elevatedStructures || (this.elevatedStructures = new Vp(e3.elevationTileID, this.layers, this.zoom, this.lut));
                const r3 = e3.elevationFeature.isTunnel();
                let n3 = 0;
                t2.properties.hasOwnProperty(oc) && (n3 = +t2.properties[oc]), this.elevatedStructures.addPortalCandidates(e3.elevationFeature.id, e3.polygons, r3, e3.elevationFeature, n3);
              }
              null == e3.elevationFeature.constantHeight && (e3.polygons = this.prepareElevatedPolygons(e3.polygons, e3.elevationFeature, e3.elevationTileID));
              const i3 = new Ic(r2, e3.elevationTileID);
              this.addElevatedGeometry(e3.polygons, i3, e3.elevationFeature, "hd-road-base" === this.elevationMode ? 0 : 0.05, n2, o2);
            }
          }
          addElevatedGeometry(t2, e2, r2, n2, i2, s2) {
            const a2 = { elevation: r2, elevationSampler: e2, bias: n2, index: i2, featureInfo: s2 }, [o2, l2] = this.addGeometry(t2, this.elevationBufferData, a2);
            null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = { min: o2, max: l2 } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, o2), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, l2));
          }
          addGeometry(t2, e2, r2) {
            let n2 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY, s2 = null;
            r2 && (s2 = r2.elevationSampler.constantElevation(r2.elevation, r2.bias), null != s2 && (n2 = s2, i2 = s2));
            const a2 = (t3, a3, o2) => {
              if (null != r2) if (a3.push(t3), null != s2) e2.elevatedLayoutVertexArray.emplaceBack(s2), o2.push(s2);
              else {
                const s3 = r2.elevationSampler.pointElevation(t3, r2.elevation, r2.bias);
                e2.elevatedLayoutVertexArray.emplaceBack(s3), o2.push(s3), n2 = Math.min(n2, s3), i2 = Math.max(i2, s3);
              }
            };
            for (const n3 of t2) {
              let t3 = 0;
              for (const e3 of n3) t3 += e3.length;
              const i3 = e2.triangleSegments.prepareSegment(t3, e2.layoutVertexArray, e2.indexArray), s3 = i3.vertexLength, o2 = [], l2 = [], u2 = [], c2 = [], h2 = [], p2 = e2.layoutVertexArray.length;
              for (const t4 of n3) {
                if (0 === t4.length) continue;
                t4 !== n3[0] && l2.push(o2.length / 2);
                const i4 = e2.lineSegments.prepareSegment(t4.length, e2.layoutVertexArray, e2.lineIndexArray), s4 = i4.vertexLength;
                r2 && h2.push(e2.layoutVertexArray.length - p2), a2(t4[0], u2, c2), e2.layoutVertexArray.emplaceBack(t4[0].x, t4[0].y), e2.lineIndexArray.emplaceBack(s4 + t4.length - 1, s4), o2.push(t4[0].x), o2.push(t4[0].y);
                for (let r3 = 1; r3 < t4.length; r3++) a2(t4[r3], u2, c2), e2.layoutVertexArray.emplaceBack(t4[r3].x, t4[r3].y), e2.lineIndexArray.emplaceBack(s4 + r3 - 1, s4 + r3), o2.push(t4[r3].x), o2.push(t4[r3].y);
                i4.vertexLength += t4.length, i4.primitiveLength += t4.length;
              }
              const d2 = Qh(o2, l2);
              for (let t4 = 0; t4 < d2.length; t4 += 3) e2.indexArray.emplaceBack(s3 + d2[t4], s3 + d2[t4 + 1], s3 + d2[t4 + 2]);
              if (d2.length > 0 && r2 && "hd-road-base" === this.elevationMode) {
                const t4 = r2.elevation.isTunnel(), e3 = r2.elevation.safeArea, n4 = this.elevatedStructures.addVertices(u2, c2);
                this.elevatedStructures.addTriangles(d2, n4, t4);
                const i4 = h2.length;
                if (i4 > 0) {
                  for (let s4 = 0; s4 < i4 - 1; s4++) this.elevatedStructures.addRenderableRing(r2.index, h2[s4] + n4, h2[s4 + 1] - h2[s4], t4, e3, r2.featureInfo);
                  this.elevatedStructures.addRenderableRing(r2.index, h2[i4 - 1] + n4, u2.length - h2[i4 - 1], t4, e3, r2.featureInfo);
                }
              }
              i3.vertexLength += t3, i3.primitiveLength += d2.length / 3;
            }
            return [n2, i2];
          }
          prepareElevatedPolygons(t2, e2, r2) {
            const n2 = 1 / ju(r2), i2 = [];
            for (const r3 of t2) {
              const t3 = md(r3, new _c(e2, n2));
              i2.push(...t3);
            }
            return i2;
          }
          clipPolygonsToTile(t2, e2) {
            const r2 = -e2, n2 = -e2, i2 = jn + e2, s2 = jn + e2;
            let a2 = 0;
            const o2 = [], l2 = [];
            for (; a2 < t2.length; a2++) {
              const e3 = t2[a2], u3 = bn(e3);
              (u3.min.x >= r2 && u3.max.x <= i2 && u3.min.y >= n2 && u3.max.y <= s2 ? o2 : l2).push(e3);
            }
            if (o2.length === t2.length) return t2;
            const u2 = [new It(r2, n2), new It(i2, n2), new It(i2, s2), new It(r2, s2), new It(r2, n2)], c2 = o2;
            for (const t3 of l2) c2.push(...fd(t3, u2));
            return c2;
          }
        }
        let bd, wd, _d, Ad;
        Qs(vd, "FillBucket", { omit: ["layers", "patternFeatures"] }), Qs(xd, "FillBufferData"), Qs(Vp, "ElevatedStructures");
        class Md {
          constructor(t2, e2, r2, n2) {
            if (this.triangleCount = e2.length / 3, this.min = new It(0, 0), this.max = new It(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t2.length) return;
            const [i2, s2] = [t2[0].clone(), t2[0].clone()];
            for (let e3 = 1; e3 < t2.length; ++e3) {
              const r3 = t2[e3];
              i2.x = Math.min(i2.x, r3.x), i2.y = Math.min(i2.y, r3.y), s2.x = Math.max(s2.x, r3.x), s2.y = Math.max(s2.y, r3.y);
            }
            if (n2) {
              const t3 = Math.ceil(Math.max(s2.x - i2.x, s2.y - i2.y) / n2);
              r2 = Math.max(r2, t3);
            }
            if (0 === r2) return;
            this.min = i2, this.max = s2;
            const a2 = this.max.sub(this.min);
            a2.x = Math.max(a2.x, 1), a2.y = Math.max(a2.y, 1);
            const o2 = Math.max(a2.x, a2.y) / r2;
            this.cellsX = Math.max(1, Math.ceil(a2.x / o2)), this.cellsY = Math.max(1, Math.ceil(a2.y / o2)), this.xScale = 1 / o2, this.yScale = 1 / o2;
            const l2 = [];
            for (let r3 = 0; r3 < this.triangleCount; r3++) {
              const n3 = t2[e2[3 * r3 + 0]].sub(this.min), i3 = t2[e2[3 * r3 + 1]].sub(this.min), s3 = t2[e2[3 * r3 + 2]].sub(this.min), a3 = Id(Math.floor(Math.min(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), u3 = Id(Math.floor(Math.max(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), c2 = Id(Math.floor(Math.min(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), h2 = Id(Math.floor(Math.max(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), p2 = new It(0, 0), d2 = new It(0, 0), f2 = new It(0, 0), m2 = new It(0, 0);
              for (let t3 = c2; t3 <= h2; ++t3) {
                p2.y = d2.y = t3 * o2, f2.y = m2.y = (t3 + 1) * o2;
                for (let e3 = a3; e3 <= u3; ++e3) p2.x = f2.x = e3 * o2, d2.x = m2.x = (e3 + 1) * o2, (jc(n3, i3, s3, p2, d2, m2) || jc(n3, i3, s3, p2, m2, f2)) && l2.push({ cellIdx: t3 * this.cellsX + e3, triIdx: r3 });
              }
            }
            if (0 === l2.length) return;
            l2.sort((t3, e3) => t3.cellIdx - e3.cellIdx || t3.triIdx - e3.triIdx);
            let u2 = 0;
            for (; u2 < l2.length; ) {
              const t3 = l2[u2].cellIdx, e3 = { start: this.payload.length, len: 0 };
              for (; u2 < l2.length && l2[u2].cellIdx === t3; ) ++e3.len, this.payload.push(l2[u2++].triIdx);
              this.cells[t3] = e3;
            }
          }
          _lazyInitLookup() {
            this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
          }
          queryPoint(t2, e2) {
            if (0 === this.triangleCount || 0 === this.cells.length) return;
            if (t2.x > this.max.x || this.min.x > t2.x || t2.y > this.max.y || this.min.y > t2.y) return;
            const r2 = Id(t2.x - this.min.x, this.xScale, this.cellsX), n2 = Id(t2.y - this.min.y, this.yScale, this.cellsY), i2 = this.cells[n2 * this.cellsX + r2];
            if (i2) {
              this._lazyInitLookup();
              for (let t3 = 0; t3 < i2.len; t3++) {
                const r3 = this.payload[i2.start + t3], n3 = Math.floor(r3 / 8), s2 = 1 << r3 % 8;
                if (!(this.lookup[n3] & s2) && (this.lookup[n3] |= s2, e2.push(r3), e2.length === this.triangleCount)) return;
              }
            }
          }
          query(t2, e2, r2) {
            if (0 === this.triangleCount || 0 === this.cells.length) return;
            if (t2.x > this.max.x || this.min.x > e2.x) return;
            if (t2.y > this.max.y || this.min.y > e2.y) return;
            this._lazyInitLookup();
            const n2 = Id(t2.x - this.min.x, this.xScale, this.cellsX), i2 = Id(e2.x - this.min.x, this.xScale, this.cellsX), s2 = Id(t2.y - this.min.y, this.yScale, this.cellsY), a2 = Id(e2.y - this.min.y, this.yScale, this.cellsY);
            for (let t3 = s2; t3 <= a2; t3++) for (let e3 = n2; e3 <= i2; e3++) {
              const n3 = this.cells[t3 * this.cellsX + e3];
              if (n3) for (let t4 = 0; t4 < n3.len; t4++) {
                const e4 = this.payload[n3.start + t4], i3 = Math.floor(e4 / 8), s3 = 1 << e4 % 8;
                if (!(this.lookup[i3] & s3) && (this.lookup[i3] |= s3, r2.push(e4), r2.length === this.triangleCount)) return;
              }
            }
          }
        }
        function Id(t2, e2, r2) {
          return Math.max(0, Math.min(r2 - 1, Math.floor(t2 * e2)));
        }
        Qs(Md, "TriangleGridIndex");
        class Sd {
          constructor(t2) {
            this.zoom = t2.zoom, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.footprints = [], this.worldview = t2.worldview, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
            for (const r2 of this.footprints) e2.push({ footprint: r2, id: t2 });
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          populate(t2, e2, r2, n2) {
            const i2 = [];
            for (const { feature: s2, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ku(s2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), u2, r2)) continue;
              const c2 = { id: a2, properties: s2.properties, type: s2.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Ju(s2, r2, n2), patterns: {} };
              i2.push(c2);
            }
            for (const n3 of i2) {
              const { geometry: i3, index: s2, sourceLayerIndex: a2 } = n3;
              this.addFeature(n3, i3, s2, r2, {}, e2.availableImages, e2.brightness), e2.featureIndex.insert(t2[s2].feature, i3, s2, a2, this.index);
            }
          }
          isEmpty() {
            return 0 === this.footprints.length;
          }
          uploadPending() {
            return false;
          }
          upload(t2) {
          }
          update(t2, e2, r2, n2, i2, s2, a2) {
          }
          destroy() {
          }
          addFeature(t2, e2, r2, n2, i2, s2 = [], a2) {
            for (const t3 of Ip(e2, 2)) {
              const e3 = [], r3 = [], n3 = [], i3 = new It(1 / 0, 1 / 0), s3 = new It(-1 / 0, -1 / 0);
              for (const a4 of t3) if (0 !== a4.length) {
                a4 !== t3[0] && n3.push(r3.length / 2);
                for (let t4 = 0; t4 < a4.length; t4++) r3.push(a4[t4].x), r3.push(a4[t4].y), e3.push(a4[t4]), i3.x = Math.min(i3.x, a4[t4].x), i3.y = Math.min(i3.y, a4[t4].y), s3.x = Math.max(s3.x, a4[t4].x), s3.y = Math.max(s3.y, a4[t4].y);
              }
              const a3 = Qh(r3, n3), o2 = new Md(e3, a3, 8, 256);
              this.footprints.push({ vertices: e3, indices: a3, grid: o2, min: i3, max: s3 });
            }
          }
        }
        Qs(Sd, "ClipBucket", { omit: ["layers"] });
        const Pd = Oo([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), zd = Oo([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Bd = Oo([{ name: "a_flood_light_ground_radius", components: 1, type: "Float32" }]), kd = Oo([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Td = Oo([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Vd = Oo([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Ed = Oo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Fd } = Pd, Dd = Number.MAX_SAFE_INTEGER, Cd = Dd - 1;
        function Rd(t2, e2, r2, n2) {
          return t2.order < e2 || t2.order === Dd || !(t2.clipMask & r2) || function(t3, e3) {
            return 0 !== e3.length && void 0 === e3.find((e4) => e4 === t3);
          }(n2, t2.clipScope);
        }
        function Ld(t2, e2) {
          return t2.x - e2.x || t2.y - e2.y;
        }
        function Od(t2, e2) {
          return 0 === Ld(t2.min, e2.min) && 0 === Ld(t2.max, e2.max);
        }
        function Ud(t2, e2) {
          return !(t2.min.x > e2.max.x || t2.max.x < e2.min.x || t2.min.y > e2.max.y || t2.max.y < e2.min.y);
        }
        function Nd(t2, e2) {
          if (t2.length !== e2.length) return false;
          for (let r2 = 0; r2 < t2.length; r2++) if (t2[r2].sourceId !== e2[r2].sourceId || !Od(t2[r2], e2[r2]) || t2[r2].order !== e2[r2].order || t2[r2].clipMask !== e2[r2].clipMask || !St(t2[r2].clipScope, e2[r2].clipScope)) return false;
          return true;
        }
        function jd(t2, e2, r2) {
          const n2 = 1 / jn, i2 = 1 / (1 << r2.canonical.z), s2 = (e2.x * n2 + r2.canonical.x) * i2 + r2.wrap, a2 = (e2.y * n2 + r2.canonical.y) * i2;
          return { min: new It((t2.x * n2 + r2.canonical.x) * i2 + r2.wrap, (t2.y * n2 + r2.canonical.y) * i2), max: new It(s2, a2) };
        }
        function Gd(t2, e2, r2) {
          const n2 = 1 << r2.canonical.z, i2 = ((e2.x - r2.wrap) * n2 - r2.canonical.x) * jn, s2 = (e2.y * n2 - r2.canonical.y) * jn;
          return { min: new It(((t2.x - r2.wrap) * n2 - r2.canonical.x) * jn, (t2.y * n2 - r2.canonical.y) * jn), max: new It(i2, s2) };
        }
        function $d(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = t2.indices, l2 = t2.vertices, u2 = [];
          for (let c2 = n2; c2 < n2 + i2; c2 += 3) {
            const n3 = e2[r2[c2 + 0] + s2], i3 = e2[r2[c2 + 1] + s2], h2 = e2[r2[c2 + 2] + s2], p2 = Math.min(n3.x, i3.x, h2.x), d2 = Math.max(n3.x, i3.x, h2.x), f2 = Math.min(n3.y, i3.y, h2.y), m2 = Math.max(n3.y, i3.y, h2.y);
            u2.length = 0, t2.grid.query(new It(p2, f2), new It(d2, m2), u2);
            for (let t3 = 0; t3 < u2.length; t3++) {
              const e3 = u2[t3];
              if (jc(l2[o2[3 * e3 + 0]], l2[o2[3 * e3 + 1]], l2[o2[3 * e3 + 2]], n3, i3, h2, a2)) return true;
            }
          }
          return false;
        }
        function qd(t2, e2, r2, n2) {
          if (!t2 || !r2) return false;
          let i2 = t2.vertices;
          if (!e2.canonical.equals(n2.canonical) || e2.wrap !== n2.wrap) {
            if (r2.vertices.length < t2.vertices.length) return qd(r2, n2, t2, e2);
            const s2 = e2.canonical, a2 = n2.canonical, o2 = Math.pow(2, a2.z - s2.z);
            i2 = t2.vertices.map((t3) => new It((t3.x + s2.x * jn) * o2 - a2.x * jn, (t3.y + s2.y * jn) * o2 - a2.y * jn));
          }
          return $d(r2, i2, t2.indices, 0, t2.indices.length, 0, 0);
        }
        function Xd(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z - r2.z);
          return new It((t2 + r2.x * jn) * i2 - n2.x * jn, (e2 + r2.y * jn) * i2 - n2.y * jn);
        }
        function Hd(t2, e2) {
          const r2 = [];
          e2.grid.queryPoint(t2, r2);
          const n2 = e2.indices, i2 = e2.vertices;
          for (let e3 = 0; e3 < r2.length; e3++) {
            const s2 = r2[e3];
            if (Lc([i2[n2[3 * s2 + 0]], i2[n2[3 * s2 + 1]], i2[n2[3 * s2 + 2]]], t2)) return true;
          }
          return false;
        }
        const Zd = [new It(0, 0), new It(jn, 0), new It(jn, jn), new It(0, jn)];
        function Wd(t2, e2) {
          const r2 = [];
          let n2 = [];
          if (!e2 || t2.length < 2) return [t2];
          if (2 === t2.length) return Uc(t2[0], t2[1], Zd) ? [t2] : [];
          for (let e3 = 0; e3 < t2.length + 2; e3++) {
            const i2 = t2[e3 % t2.length], s2 = t2[(e3 + 1) % t2.length], a2 = Uc(0 === e3 ? t2[t2.length - 1] : t2[(e3 - 1) % t2.length], i2, Zd), o2 = Uc(i2, s2, Zd), l2 = a2 || o2;
            l2 && n2.push(i2), l2 && o2 || n2.length > 0 && (n2.length > 1 && r2.push(n2), n2 = []);
          }
          return n2.length > 1 && r2.push(n2), r2;
        }
        const Yd = Qu.types, Jd = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], Kd = ["fill-extrusion-flood-light-ground-radius"], Qd = Math.pow(2, 13), tf = Math.pow(2, 15) - 1, ef = new It(0, 1), rf = 2147483648;
        function nf(t2, e2, r2, n2, i2, s2, a2, o2) {
          t2.emplaceBack((e2 << 1) + a2, (r2 << 1) + s2, (Math.floor(n2 * Qd) << 1) + i2, Math.round(o2));
        }
        function sf(t2, e2, r2) {
          t2.emplaceBack(e2.x * jn, e2.y * jn, r2 ? 1 : 0);
        }
        function af(t2, e2, r2, n2, i2, s2) {
          t2.emplaceBack(e2.x, e2.y, (r2.x << 1) + n2, (r2.y << 1) + i2, s2);
        }
        function of(t2, e2, r2) {
          const n2 = 16384;
          t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
        }
        class lf {
          constructor() {
            this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
          }
        }
        class uf {
          constructor() {
            this.centroidXY = new It(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new It(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new It(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0, this.buildingId = 0;
          }
          span() {
            return new It(this.max.x - this.min.x, this.max.y - this.min.y);
          }
        }
        class cf {
          constructor() {
            this.acc = new It(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
          }
          startRing(t2, e2) {
            t2.min.x === Number.MAX_VALUE && (t2.min.x = t2.max.x = e2.x, t2.min.y = t2.max.y = e2.y);
          }
          appendEdge(t2, e2, r2) {
            this.accCount++, this.acc._add(e2);
            let n2 = !!this.borders;
            e2.x < t2.min.x ? (t2.min.x = e2.x, n2 = true) : e2.x > t2.max.x && (t2.max.x = e2.x, n2 = true), e2.y < t2.min.y ? (t2.min.y = e2.y, n2 = true) : e2.y > t2.max.y && (t2.max.y = e2.y, n2 = true), ((0 === e2.x || e2.x === jn) && e2.x === r2.x) != ((0 === e2.y || e2.y === jn) && e2.y === r2.y) && this.processBorderOverlap(e2, r2), n2 && this.checkBorderIntersection(e2, r2);
          }
          checkBorderIntersection(t2, e2) {
            e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, dr(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > jn != t2.x > jn && this.addBorderIntersection(1, dr(e2.y, t2.y, (jn - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, dr(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > jn != t2.y > jn && this.addBorderIntersection(3, dr(e2.x, t2.x, (jn - e2.y) / (t2.y - e2.y)));
          }
          addBorderIntersection(t2, e2) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r2 = this.borders[t2];
            e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
          }
          processBorderOverlap(t2, e2) {
            if (t2.x === e2.x) {
              if (t2.y === e2.y) return;
              const r2 = 0 === t2.x ? 0 : 1;
              this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
            } else {
              const r2 = 0 === t2.y ? 2 : 3;
              this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
            }
          }
          centroid() {
            return 0 === this.accCount ? new It(0, 0) : new It(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
          }
          intersectsCount() {
            return this.borders ? this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0) : 0;
          }
        }
        function hf(t2, e2) {
          const r2 = t2.add(e2)._unit(), n2 = Dt(t2.x * r2.x + t2.y * r2.y, -1, 1);
          var i2, s2, a2;
          return a2 = Math.acos(n2), Math.min(4, Math.max(-4, Math.tan(a2))) / 4 * tf * ((i2 = t2).x * (s2 = e2).y - i2.y * s2.x < 0 ? -1 : 1);
        }
        const pf = [(t2) => t2.x < 0, (t2) => t2.x > jn, (t2) => t2.y < 0, (t2) => t2.y > jn];
        function df(t2, e2, r2, n2) {
          const i2 = [4];
          if (0 === n2) return i2;
          r2._mult(n2);
          const s2 = t2.sub(r2), a2 = e2.sub(r2), o2 = [t2, e2, s2, a2];
          for (let t3 = 0; t3 < 4; t3++) for (const e3 of o2) if (pf[t3](e3)) {
            i2.push(t3);
            break;
          }
          return i2;
        }
        class ff {
          constructor(t2) {
            this.groundRadiusArray = null, this.groundRadiusBuffer = null, this.vertexArray = new Ho(), this.indexArray = new ll(), this.programConfigurations = new fu(t2.layers, { zoom: t2.zoom, lut: t2.lut }, (t3) => Kd.includes(t3)), this._segments = new Ol(), this.hiddenByLandmarkVertexArray = new _l(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Ol();
          }
          getDefaultSegment() {
            return this.regionSegments[4];
          }
          hasData() {
            return 0 !== this.vertexArray.length;
          }
          addData(t2, e2, r2, n2 = false) {
            const i2 = t2.length;
            if (i2 > 2) {
              let s2 = Math.max(0, this._segments.get().length - 1);
              const a2 = this._segments._prepareSegment(4 * i2, this.vertexArray.length, 2 * this._segmentToGroundQuads[s2].length);
              let o2;
              s2 !== this._segments.get().length - 1 && (s2++, this._segmentToGroundQuads[s2] = [], this._segmentToRegionTriCounts[s2] = [0, 0, 0, 0, 0]);
              {
                const e3 = t2[0], r3 = t2[1];
                o2 = hf(e3.sub(t2[i2 - 1])._perp()._unit(), r3.sub(e3)._perp()._unit());
              }
              for (let l2 = 0; l2 < i2; l2++) {
                const u2 = l2 === i2 - 1 ? 0 : l2 + 1, c2 = t2[l2], h2 = t2[u2], p2 = t2[u2 === i2 - 1 ? 0 : u2 + 1], d2 = h2.sub(c2)._perp()._unit(), f2 = hf(d2, p2.sub(h2)._perp()._unit()), m2 = o2, y2 = f2;
                if (vf(c2, h2, e2) || n2 && bf(c2, e2) && bf(h2, e2)) {
                  o2 = f2;
                  continue;
                }
                const g2 = a2.vertexLength;
                af(this.vertexArray, c2, h2, 1, 1, m2), af(this.vertexArray, c2, h2, 1, 0, m2), af(this.vertexArray, c2, h2, 0, 1, y2), af(this.vertexArray, c2, h2, 0, 0, y2), a2.vertexLength += 4;
                const x2 = df(c2, h2, d2, r2);
                for (const t3 of x2) this._segmentToGroundQuads[s2].push({ id: g2, region: t3 }), this._segmentToRegionTriCounts[s2][t3] += 2, a2.primitiveLength += 2;
                o2 = f2;
              }
            }
          }
          prepareBorderSegments() {
            if (!this.hasData()) return;
            const t2 = this._segments.get(), e2 = t2.length;
            for (let t3 = 0; t3 < e2; t3++) this._segmentToGroundQuads[t3].sort((t4, e3) => t4.region - e3.region);
            for (let r2 = 0; r2 < e2; r2++) {
              const e3 = this._segmentToGroundQuads[r2], n2 = t2[r2], i2 = this._segmentToRegionTriCounts[r2];
              i2.reduce((t3, e4) => t3 + e4, 0);
              let s2 = 0;
              for (let t3 = 0; t3 <= 4; t3++) {
                const e4 = i2[t3];
                if (0 !== e4) {
                  let r3 = this.regionSegments[t3];
                  r3 || (r3 = this.regionSegments[t3] = new Ol());
                  const i3 = { vertexOffset: n2.vertexOffset, primitiveOffset: n2.primitiveOffset + s2, vertexLength: n2.vertexLength, primitiveLength: e4 };
                  r3.get().push(i3);
                }
                s2 += e4;
              }
              for (let t3 = 0; t3 < e3.length; t3++) {
                const r3 = e3[t3].id;
                this.indexArray.emplaceBack(r3, r3 + 1, r3 + 3), this.indexArray.emplaceBack(r3, r3 + 3, r3 + 2);
              }
            }
            this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
          }
          addPaintPropertiesData(t2, e2, r2, n2, i2, s2, a2) {
            this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t2, e2, r2, n2, i2, s2, void 0, a2);
          }
          upload(t2) {
            this.hasData() && (this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, zd.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), null != this.groundRadiusArray && (this.groundRadiusBuffer = t2.createVertexBuffer(this.groundRadiusArray, Bd.members)));
          }
          uploadPaintProperties(t2) {
            this.hasData() && this.programConfigurations.upload(t2);
          }
          update(t2, e2, r2, n2, i2, s2, a2, o2) {
            this.hasData() && this.programConfigurations.updatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2);
          }
          updateHiddenByLandmark(t2) {
            this.updateHiddenByLandmarkRange(t2.groundVertexArrayOffset, t2.groundVertexCount, !!(t2.flags & rf));
          }
          updateHiddenByLandmarkRange(t2, e2, r2) {
            if (!this.hasData()) return;
            const n2 = e2 + t2;
            if (0 !== e2) {
              for (let e3 = t2; e3 < n2; ++e3) this.hiddenByLandmarkVertexArray.emplace(e3, r2 ? 1 : 0);
              this._needsHiddenByLandmarkUpdate = true;
            }
          }
          uploadHiddenByLandmark(t2) {
            this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t2.createVertexBuffer(this.hiddenByLandmarkVertexArray, Vd.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
          }
          destroy() {
            if (this.vertexBuffer) {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this.groundRadiusBuffer && this.groundRadiusBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
              for (let t2 = 0; t2 <= 4; t2++) {
                const e2 = this.regionSegments[t2];
                e2 && e2.destroy();
              }
            }
          }
        }
        class mf {
          constructor(t2) {
            this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.pixelRatio = t2.pixelRatio, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ll(), this.footprintVertices = new No(), this.footprintSegments = [], this.layoutVertexArray = new Go(), this.centroidVertexArray = new El(), this.wallVertexArray = new Dl(), this.indexArray = new ll(), this.programConfigurations = new fu(t2.layers, { zoom: t2.zoom, lut: t2.lut }, (t3) => Jd.includes(t3)), this.segments = new Ol(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.groundEffect = new ff(t2), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [], this.worldview = t2.worldview, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          populate(t2, e2, r2, n2) {
            this.features = [], this.hasPattern = zp("fill-extrusion", this.layers, this.pixelRatio, e2), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = ju(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
            for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Ku(i2, t3);
              if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), l2, r2)) continue;
              const u2 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : Ju(i2, r2, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length, h2 = "Polygon" === Yd[u2.type];
              if (this.hasPattern) this.features.push({ featureId: i2.id, feature: Bp("fill-extrusion", this.layers, u2, this.zoom, this.pixelRatio, e2) });
              else if (this.wallMode) for (const t4 of u2.geometry) for (const s3 of Wd(t4, h2)) this.addFeature(i2.id, u2, [s3], a2, r2, {}, e2.availableImages, n2, e2.brightness);
              else this.addFeature(i2.id, u2, u2.geometry, a2, r2, {}, e2.availableImages, n2, e2.brightness);
              e2.featureIndex.insert(i2, u2.geometry, a2, o2, this.index, c2);
            }
            this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
          }
          addFeatures(t2, e2, r2, n2, i2, s2) {
            for (const { featureId: t3, feature: a2 } of this.features) {
              const o2 = "Polygon" === Yd[a2.type], { geometry: l2 } = a2;
              if (this.wallMode) for (const u2 of l2) for (const l3 of Wd(u2, o2)) this.addFeature(t3, a2, [l3], a2.index, e2, r2, n2, i2, s2);
              else this.addFeature(t3, a2, l2, a2.index, e2, r2, n2, i2, s2);
            }
            this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
          }
          update(t2, e2, r2, n2, i2, s2, a2) {
            this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, this.worldview), this.groundEffect.update(t2, e2, i2, r2, n2, s2, a2, this.worldview);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Fd), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t2.createVertexBuffer(this.wallVertexArray, Td.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Ed.members, true)), this.groundEffect.upload(t2)), this.groundEffect.uploadPaintProperties(t2), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          uploadCentroid(t2) {
            this.groundEffect.uploadHiddenByLandmark(t2), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, kd.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e2, {}) / this.tileToMeter, c2 = [new It(0, 0), new It(jn, jn)], h2 = o2.projection, p2 = "globe" === h2.name, d2 = this.wallMode || "Polygon" === Yd[e2.type], f2 = new cf();
            f2.centroidDataIndex = this.centroidData.length;
            const m2 = new uf();
            m2.buildingId = t2, e2.properties && e2.properties.hasOwnProperty("building_id") && (m2.buildingId = Number(e2.properties.building_id));
            const y2 = this.layers[0].paint.get("fill-extrusion-base").evaluate(e2, {}, i2) <= 0, g2 = this.layers[0].paint.get("fill-extrusion-height").evaluate(e2, {}, i2);
            let x2;
            if (m2.height = g2, m2.vertexArrayOffset = this.layoutVertexArray.length, m2.groundVertexArrayOffset = this.groundEffect.vertexArray.length, p2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ko()), this.wallMode) {
              if (p2) return void Zt("Non zero fill-extrusion-line-width is not yet supported on globe.");
              if (1 !== r2.length) return;
              x2 = function(t3) {
                const e3 = t3[0].x === t3[t3.length - 1].x && t3[0].y === t3[t3.length - 1].y, r3 = function(t4) {
                  let e4 = 0;
                  const r4 = t4.length;
                  for (let n4 = 0; n4 < r4; n4++) e4 += (t4[(n4 + 1) % r4].x - t4[n4].x) * (t4[(n4 + 1) % r4].y + t4[n4].y);
                  return e4 >= 0;
                }(t3);
                r3 || (t3 = t3.reverse());
                const n3 = { geometry: [], joinNormals: [], indices: [] }, i3 = [], s3 = [], a3 = [];
                let o3 = t3.length;
                for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); ) o3--;
                if (o3 < (e3 ? 3 : 2)) return n3;
                let l3, u3, c3, h3, p3, d3 = 0;
                for (; d3 < o3 - 1 && t3[d3].equals(t3[d3 + 1]); ) d3++;
                e3 && (l3 = t3[o3 - 2], p3 = t3[d3].sub(l3)._unit()._perp());
                for (let r4 = d3; r4 < o3; r4++) {
                  if (c3 = r4 === o3 - 1 ? e3 ? t3[d3 + 1] : void 0 : t3[r4 + 1], c3 && t3[r4].equals(c3)) continue;
                  p3 && (h3 = p3), l3 && (u3 = l3), l3 = t3[r4], p3 = c3 ? c3.sub(l3)._unit()._perp() : h3, h3 = h3 || p3;
                  let n4 = h3.add(p3);
                  0 === n4.x && 0 === n4.y || n4._unit();
                  const f4 = n4.x * p3.x + n4.y * p3.y, m3 = 0 !== f4 ? 1 / f4 : 1 / 0, y3 = h3.x * p3.y - h3.y * p3.x > 0;
                  let g3 = "miter";
                  const x3 = 2;
                  "miter" === g3 && m3 > x3 && (g3 = "bevel"), "bevel" === g3 && (m3 > 100 && (g3 = "flipbevel"), m3 < x3 && (g3 = "miter"));
                  const v3 = (t4, e4, r5, n5) => {
                    const o4 = new It(t4.x, t4.y), l4 = new It(t4.x, t4.y);
                    o4.x += e4.x * n5, o4.y += e4.y * n5, l4.x -= e4.x * Math.max(r5, 1), l4.y -= e4.y * Math.max(r5, 1), a3.push(e4), i3.push(o4), s3.push(l4);
                  };
                  if ("miter" === g3) n4._mult(m3), v3(l3, n4, 0, 0);
                  else if ("flipbevel" === g3) n4 = p3.mult(-1), v3(l3, n4, 0, 0), v3(l3, n4.mult(-1), 0, 0);
                  else {
                    const t4 = -Math.sqrt(m3 * m3 - 1), e4 = y3 ? t4 : 0, r5 = y3 ? 0 : t4;
                    u3 && v3(l3, h3, e4, r5), c3 && v3(l3, p3, e4, r5);
                  }
                }
                n3.geometry = [...i3, ...s3.reverse(), i3[0]], n3.joinNormals = [...a3, ...a3.reverse(), a3[a3.length - 1]];
                const f3 = n3.geometry.length - 1;
                for (let t4 = 0; t4 < f3 / 2; t4++) if (t4 + 1 < f3 / 2) {
                  let e4 = t4, r4 = t4 + 1, i4 = f3 - 1 - t4, s4 = f3 - 2 - t4;
                  e4 = 0 === e4 ? f3 - 1 : e4 - 1, r4 = 0 === r4 ? f3 - 1 : r4 - 1, i4 = 0 === i4 ? f3 - 1 : i4 - 1, s4 = 0 === s4 ? f3 - 1 : s4 - 1, n3.indices.push(i4), n3.indices.push(r4), n3.indices.push(e4), n3.indices.push(i4), n3.indices.push(s4), n3.indices.push(r4);
                }
                return n3;
              }(r2[0]), r2 = [x2.geometry];
            }
            const v2 = (t3, e3) => t3 < (e3.length - 1) / 2 || t3 === e3.length - 1, b2 = this.wallMode ? [r2] : Ip(r2, 500);
            for (let t3 = b2.length - 1; t3 >= 0; t3--) {
              const e3 = b2[t3];
              (0 === e3.length || wf(e3[0])) && b2.splice(t3, 1);
            }
            let w2;
            if (p2) w2 = If(b2, c2, i2);
            else {
              w2 = [];
              for (const t3 of b2) w2.push({ polygon: t3, bounds: c2 });
            }
            const _2 = d2 ? this.edgeRadius : 0, A2 = _2 > 0 && this.zoom < 17, M2 = (t3, e3) => {
              if (0 === t3.length) return false;
              const r3 = t3[t3.length - 1];
              return e3.x === r3.x && e3.y === r3.y;
            };
            for (const { polygon: t3, bounds: e3 } of w2) {
              let r3 = 0, n3 = 0;
              for (const e4 of t3) d2 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), n3 += d2 ? e4.length - 1 : e4.length;
              const s3 = this.segments.prepareSegment((d2 ? 5 : 4) * n3, this.layoutVertexArray, this.indexArray);
              m2.footprintSegIdx < 0 && (m2.footprintSegIdx = this.footprintSegments.length), m2.polygonSegIdx < 0 && (m2.polygonSegIdx = this.polygonSegments.length);
              const a3 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, o3 = new lf();
              if (o3.vertexOffset = this.footprintVertices.length, o3.indexOffset = 3 * this.footprintIndices.length, o3.ringIndices = [], d2) {
                const n4 = [], a4 = [];
                r3 = s3.vertexLength;
                for (let r4 = 0; r4 < t3.length; r4++) {
                  const l4 = t3[r4];
                  l4.length && 0 !== r4 && a4.push(n4.length / 2);
                  const c3 = [];
                  let d3, f3;
                  d3 = l4[1].sub(l4[0])._perp()._unit(), o3.ringIndices.push(l4.length - 1);
                  for (let t4 = 1; t4 < l4.length; t4++) {
                    const e4 = l4[t4], r5 = l4[t4 === l4.length - 1 ? 1 : t4 + 1], a5 = e4.clone();
                    if (_2) {
                      f3 = r5.sub(e4)._perp()._unit();
                      const t5 = d3.add(f3)._unit(), n5 = _2 * Math.min(4, 1 / (d3.x * t5.x + d3.y * t5.y));
                      a5.x += n5 * t5.x, a5.y += n5 * t5.y, a5.x = Math.round(a5.x), a5.y = Math.round(a5.y), d3 = f3;
                    }
                    if (!y2 || 0 !== _2 && !A2 || M2(c3, a5) || c3.push(a5), nf(this.layoutVertexArray, a5.x, a5.y, 0, 0, 1, 1, 0), this.wallMode) {
                      const e5 = v2(t4, l4);
                      sf(this.wallVertexArray, x2.joinNormals[t4], !e5);
                    }
                    s3.vertexLength++, this.footprintVertices.emplaceBack(e4.x, e4.y), n4.push(e4.x, e4.y), p2 && of(this.layoutVertexExtArray, h2.projectTilePoint(a5.x, a5.y, i2), h2.upVector(i2, a5.x, a5.y));
                  }
                  y2 && (0 === _2 || A2) && (0 !== c3.length && M2(c3, c3[0]) && c3.pop(), this.groundEffect.addData(c3, e3, u2));
                }
                const l3 = this.wallMode ? x2.indices : Qh(n4, a4);
                for (let t4 = 0; t4 < l3.length; t4 += 3) this.footprintIndices.emplaceBack(o3.vertexOffset + l3[t4 + 0], o3.vertexOffset + l3[t4 + 1], o3.vertexOffset + l3[t4 + 2]), this.indexArray.emplaceBack(r3 + l3[t4], r3 + l3[t4 + 2], r3 + l3[t4 + 1]), s3.primitiveLength++;
                o3.indexCount += l3.length, o3.vertexCount += this.footprintVertices.length - o3.vertexOffset;
              }
              for (let n4 = 0; n4 < t3.length; n4++) {
                const a4 = t3[n4];
                f2.startRing(m2, a4[0]);
                let o4 = a4.length > 4 && _f(a4[a4.length - 2], a4[0], a4[1]), l3 = _2 ? gf(a4[a4.length - 2], a4[0], a4[1], _2) : 0;
                const c3 = [];
                let g3, b3, w3;
                b3 = a4[1].sub(a4[0])._perp()._unit();
                let A3 = true;
                for (let t4 = 1, n5 = 0; t4 < a4.length; t4++) {
                  let u3 = a4[t4 - 1], d3 = a4[t4];
                  const I2 = a4[t4 === a4.length - 1 ? 1 : t4 + 1];
                  if (f2.appendEdge(m2, d3, u3), vf(d3, u3, e3)) {
                    _2 && (b3 = I2.sub(d3)._perp()._unit(), A3 = !A3);
                    continue;
                  }
                  const S2 = d3.sub(u3)._perp(), P2 = S2.x / (Math.abs(S2.x) + Math.abs(S2.y)), z2 = S2.y > 0 ? 1 : 0, B2 = u3.dist(d3);
                  if (n5 + B2 > 32768 && (n5 = 0), _2) {
                    w3 = I2.sub(d3)._perp()._unit();
                    let t5 = xf(u3, d3, I2, yf(b3, w3), _2);
                    isNaN(t5) && (t5 = 0);
                    const e4 = d3.sub(u3)._unit();
                    u3 = u3.add(e4.mult(l3))._round(), d3 = d3.add(e4.mult(-t5))._round(), l3 = t5, b3 = w3, y2 && this.zoom >= 17 && (M2(c3, u3) || c3.push(u3), M2(c3, d3) || c3.push(d3));
                  }
                  const k2 = s3.vertexLength, T2 = a4.length > 4 && _f(u3, d3, I2);
                  let V2 = Af(n5, o4, A3);
                  if (nf(this.layoutVertexArray, u3.x, u3.y, P2, z2, 0, 0, V2), nf(this.layoutVertexArray, u3.x, u3.y, P2, z2, 0, 1, V2), this.wallMode) {
                    const e4 = v2(t4 - 1, a4), r4 = x2.joinNormals[t4 - 1];
                    sf(this.wallVertexArray, r4, e4), sf(this.wallVertexArray, r4, e4);
                  }
                  if (n5 += B2, V2 = Af(n5, T2, !A3), o4 = T2, nf(this.layoutVertexArray, d3.x, d3.y, P2, z2, 0, 0, V2), nf(this.layoutVertexArray, d3.x, d3.y, P2, z2, 0, 1, V2), this.wallMode) {
                    const e4 = v2(t4, a4), r4 = x2.joinNormals[t4];
                    sf(this.wallVertexArray, r4, e4), sf(this.wallVertexArray, r4, e4);
                  }
                  if (s3.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s3.primitiveLength += 2, _2) {
                    const n6 = r3 + (1 === t4 ? a4.length - 2 : t4 - 2), i3 = 1 === t4 ? r3 : n6 + 1;
                    if (this.indexArray.emplaceBack(k2 + 1, n6, k2 + 3), this.indexArray.emplaceBack(n6, i3, k2 + 3), s3.primitiveLength += 2, void 0 === g3 && (g3 = k2), !vf(I2, a4[t4], e3)) {
                      const e4 = t4 === a4.length - 1 ? g3 : s3.vertexLength;
                      this.indexArray.emplaceBack(k2 + 2, k2 + 3, e4), this.indexArray.emplaceBack(k2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(k2 + 3, i3, e4 + 1), s3.primitiveLength += 3;
                    }
                    A3 = !A3;
                  }
                  if (p2) {
                    const t5 = this.layoutVertexExtArray, e4 = h2.projectTilePoint(u3.x, u3.y, i2), r4 = h2.projectTilePoint(d3.x, d3.y, i2), n6 = h2.upVector(i2, u3.x, u3.y), s4 = h2.upVector(i2, d3.x, d3.y);
                    of(t5, e4, n6), of(t5, e4, n6), of(t5, r4, s4), of(t5, r4, s4);
                  }
                }
                d2 && (r3 += a4.length - 1), y2 && _2 && this.zoom >= 17 && (0 !== c3.length && M2(c3, c3[0]) && c3.pop(), this.groundEffect.addData(c3, e3, u2, _2 > 0));
              }
              this.footprintSegments.push(o3), a3.triangleCount = this.indexArray.length - a3.triangleArrayOffset, this.polygonSegments.push(a3), ++m2.footprintSegLen, ++m2.polygonSegLen;
            }
            if (m2.vertexCount = this.layoutVertexArray.length - m2.vertexArrayOffset, m2.groundVertexCount = this.groundEffect.vertexArray.length - m2.groundVertexArrayOffset, 0 !== m2.vertexCount) {
              if (m2.centroidXY = f2.borders ? ef : this.encodeCentroid(f2, m2), this.centroidData.push(m2), f2.borders) {
                this.featuresOnBorder.push(f2);
                const t3 = this.featuresOnBorder.length - 1;
                for (let e3 = 0; e3 < f2.borders.length; e3++) f2.borders[e3][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e3].push(t3);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, n2, s2, a2, i2, l2, void 0, this.worldview), this.groundEffect.addPaintPropertiesData(e2, n2, s2, a2, i2, l2, this.worldview), this.maxHeight = Math.max(this.maxHeight, g2);
            }
          }
          sortBorders() {
            for (let t2 = 0; t2 < this.borderFeatureIndices.length; t2++) this.borderFeatureIndices[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
          }
          splitToSubtiles() {
            const t2 = [];
            for (let e3 = 0; e3 < this.centroidData.length; e3++) {
              const r3 = this.centroidData[e3], n3 = +(r3.min.y + r3.max.y > jn), i3 = 2 * n3 + (+(r3.min.x + r3.max.x > jn) ^ n3);
              for (let n4 = 0; n4 < r3.polygonSegLen; n4++) {
                const s3 = r3.polygonSegIdx + n4;
                t2.push({ centroidIdx: e3, subtile: i3, polygonSegmentIdx: s3, triangleSegmentIdx: this.polygonSegments[s3].triangleSegIdx });
              }
            }
            const e2 = new ll();
            t2.sort((t3, e3) => t3.triangleSegmentIdx === e3.triangleSegmentIdx ? t3.subtile - e3.subtile : t3.triangleSegmentIdx - e3.triangleSegmentIdx);
            let r2 = 0, n2 = 0, i2 = 0;
            for (const e3 of t2) {
              if (e3.triangleSegmentIdx !== r2) break;
              i2++;
            }
            const s2 = t2.length;
            for (; n2 !== t2.length; ) {
              r2 = t2[n2].triangleSegmentIdx;
              let a2 = 0, o2 = n2, l2 = n2;
              for (let e3 = o2; e3 < i2 && t2[e3].subtile === a2; e3++) l2++;
              for (; o2 !== i2; ) {
                const n3 = t2[o2];
                a2 = n3.subtile;
                const s3 = this.centroidData[n3.centroidIdx].min.clone(), u2 = this.centroidData[n3.centroidIdx].max.clone(), c2 = { vertexOffset: this.segments.segments[r2].vertexOffset, primitiveOffset: e2.length, vertexLength: this.segments.segments[r2].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                for (let r3 = o2; r3 < l2; r3++) {
                  const n4 = t2[r3], i3 = this.polygonSegments[n4.polygonSegmentIdx], a3 = this.centroidData[n4.centroidIdx].min, o3 = this.centroidData[n4.centroidIdx].max, l3 = this.indexArray.uint16;
                  for (let t3 = i3.triangleArrayOffset; t3 < i3.triangleArrayOffset + i3.triangleCount; t3++) e2.emplaceBack(l3[3 * t3], l3[3 * t3 + 1], l3[3 * t3 + 2]);
                  c2.primitiveLength += i3.triangleCount, s3.x = Math.min(s3.x, a3.x), s3.y = Math.min(s3.y, a3.y), u2.x = Math.max(u2.x, o3.x), u2.y = Math.max(u2.y, o3.y);
                }
                c2.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c2, min: s3, max: u2 }), o2 = l2;
                for (let e3 = o2; e3 < i2 && t2[e3].subtile === t2[o2].subtile; e3++) l2++;
              }
              n2 = i2;
              for (let e3 = n2; e3 < s2 && t2[e3].triangleSegmentIdx === t2[n2].triangleSegmentIdx; e3++) i2++;
            }
            e2._trim(), this.indexArray = e2;
          }
          getVisibleSegments(t2, e2, r2) {
            const n2 = new Ol();
            if (this.wallMode) {
              for (const t3 of this.triangleSubSegments) n2.segments.push(t3.segment);
              return n2;
            }
            let i2 = 0, s2 = 0;
            const a2 = 1 << t2.canonical.z;
            if (e2) {
              const r3 = e2.getMinMaxForTile(t2);
              r3 && (i2 = r3.min, s2 = r3.max);
            }
            s2 += this.maxHeight;
            const o2 = t2.toUnwrapped();
            let l2;
            const u2 = [o2.canonical.x / a2 + o2.wrap, o2.canonical.y / a2], c2 = [(o2.canonical.x + 1) / a2 + o2.wrap, (o2.canonical.y + 1) / a2], h2 = (t3, e3, r3) => [t3[0] * (1 - r3[0]) + e3[0] * r3[0], t3[1] * (1 - r3[1]) + e3[1] * r3[1]], p2 = [], d2 = [];
            for (const t3 of this.triangleSubSegments) {
              p2[0] = t3.min.x / jn, p2[1] = t3.min.y / jn, d2[0] = t3.max.x / jn, d2[1] = t3.max.y / jn;
              const e3 = h2(u2, c2, p2), a3 = h2(u2, c2, d2);
              if (0 === new wc([e3[0], e3[1], i2], [a3[0], a3[1], s2]).intersectsPrecise(r2)) {
                l2 && (n2.segments.push(l2), l2 = void 0);
                continue;
              }
              const o3 = t3.segment;
              l2 && l2.vertexOffset !== o3.vertexOffset && (n2.segments.push(l2), l2 = void 0), l2 ? (l2.vertexLength += o3.vertexLength, l2.primitiveLength += o3.primitiveLength) : l2 = { vertexOffset: o3.vertexOffset, primitiveLength: o3.primitiveLength, vertexLength: o3.vertexLength, primitiveOffset: o3.primitiveOffset, sortKey: void 0, vaos: {} };
            }
            return l2 && n2.segments.push(l2), n2;
          }
          encodeCentroid(t2, e2) {
            const r2 = t2.centroid(), n2 = e2.span(), i2 = Math.min(7, Math.round(n2.x * this.tileToMeter / 10)), s2 = Math.min(7, Math.round(n2.y * this.tileToMeter / 10));
            return new It(Dt(r2.x, 1, 8191) << 3 | i2, Dt(r2.y, 1, 8191) << 3 | s2);
          }
          encodeBorderCentroid(t2) {
            if (!t2.borders) return new It(0, 0);
            const e2 = t2.borders, r2 = Number.MAX_VALUE;
            if (e2[0][0] !== r2 || e2[1][0] !== r2) {
              const t3 = e2[0][0] !== r2 ? 0 : 1;
              return new It(6 | (e2[0][0] !== r2 ? 0 : 65528), (e2[t3][0] + e2[t3][1]) / 2 << 3 | 6);
            }
            {
              const t3 = e2[2][0] !== r2 ? 2 : 3;
              return new It((e2[t3][0] + e2[t3][1]) / 2 << 3 | 6, 6 | (e2[2][0] !== r2 ? 0 : 65528));
            }
          }
          showCentroid(t2) {
            const e2 = this.centroidData[t2.centroidDataIndex];
            e2.flags &= 2147483647, e2.centroidXY.x = 0, e2.centroidXY.y = 0, this.writeCentroidToBuffer(e2);
          }
          writeCentroidToBuffer(t2) {
            this.groundEffect.updateHiddenByLandmark(t2);
            const e2 = t2.vertexArrayOffset, r2 = t2.vertexCount + t2.vertexArrayOffset, n2 = t2.flags & rf ? ef : t2.centroidXY, i2 = this.centroidVertexArray.geta_centroid_pos0(e2);
            if (this.centroidVertexArray.geta_centroid_pos1(e2) !== n2.y || i2 !== n2.x) {
              for (let t3 = e2; t3 < r2; ++t3) this.centroidVertexArray.emplace(t3, n2.x, n2.y);
              this.needsCentroidUpdate = true;
            }
          }
          createCentroidsBuffer() {
            this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const t2 of this.centroidData) this.writeCentroidToBuffer(t2);
          }
          updateReplacement(t2, e2, r2) {
            if (e2.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = e2.updateTime;
            const n2 = e2.getReplacementRegionsForTile(t2.toUnwrapped());
            if (Nd(this.activeReplacements, n2)) return;
            if (this.activeReplacements = n2, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
            else for (const t3 of this.centroidData) t3.flags &= 2147483647;
            const i2 = [];
            for (const e3 of this.activeReplacements) {
              if (e3.order < r2) continue;
              const n3 = Math.max(1, Math.pow(2, e3.footprintTileId.canonical.z - t2.canonical.z));
              if (e3.footprint.buildingIds) for (const t3 of this.centroidData) t3.flags & rf || e3.min.x > t3.max.x || t3.min.x > e3.max.x || e3.min.y > t3.max.y || t3.min.y > e3.max.y || e3.footprint.buildingIds.has(t3.buildingId) && (t3.flags |= rf);
              else for (const r3 of this.centroidData) if (!(r3.flags & rf || e3.min.x > r3.max.x || r3.min.x > e3.max.x || e3.min.y > r3.max.y || r3.min.y > e3.max.y)) for (let s2 = 0; s2 < r3.footprintSegLen; s2++) {
                const a2 = this.footprintSegments[r3.footprintSegIdx + s2];
                if (i2.length = 0, Sf(this.footprintVertices, a2.vertexOffset, a2.vertexCount, e3.footprintTileId.canonical, t2.canonical, i2), $d(e3.footprint, i2, this.footprintIndices.uint16, a2.indexOffset, a2.indexCount, -a2.vertexOffset, -n3)) {
                  r3.flags |= rf;
                  break;
                }
              }
            }
            for (const t3 of this.centroidData) this.writeCentroidToBuffer(t3);
            this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
          }
          footprintContainsPoint(t2, e2, r2) {
            let n2 = false;
            for (let i2 = 0; i2 < r2.footprintSegLen; i2++) {
              const s2 = this.footprintSegments[r2.footprintSegIdx + i2];
              let a2 = 0;
              for (const r3 of s2.ringIndices) {
                for (let i3 = a2, o2 = r3 + a2 - 1; i3 < r3 + a2; o2 = i3++) {
                  const r4 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 0], a3 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 1], l2 = this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 1];
                  a3 > e2 != l2 > e2 && t2 < (this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 0] - r4) * (e2 - a3) / (l2 - a3) + r4 && (n2 = !n2);
                }
                a2 = r3;
              }
            }
            return n2;
          }
          getHeightAtTileCoord(t2, e2) {
            let r2 = Number.NEGATIVE_INFINITY, n2 = true;
            const i2 = 4 * (t2 + jn) * jn + (e2 + jn);
            if (this.partLookup.hasOwnProperty(i2)) {
              const t3 = this.partLookup[i2];
              return t3 ? { height: t3.height, hidden: !!(t3.flags & rf) } : void 0;
            }
            for (const s2 of this.centroidData) t2 > s2.max.x || s2.min.x > t2 || e2 > s2.max.y || s2.min.y > e2 || s2.height <= r2 || this.footprintContainsPoint(t2, e2, s2) && (r2 = s2.height, this.partLookup[i2] = s2, n2 = !!(s2.flags & rf));
            if (r2 !== Number.NEGATIVE_INFINITY) return { height: r2, hidden: n2 };
            this.partLookup[i2] = void 0;
          }
        }
        function yf(t2, e2) {
          const r2 = t2.add(e2)._unit();
          return t2.x * r2.x + t2.y * r2.y;
        }
        function gf(t2, e2, r2, n2) {
          const i2 = e2.sub(t2)._perp()._unit(), s2 = r2.sub(e2)._perp()._unit();
          return xf(t2, e2, r2, yf(i2, s2), n2);
        }
        function xf(t2, e2, r2, n2, i2) {
          const s2 = Math.sqrt(1 - n2 * n2);
          return Math.min(t2.dist(e2) / 3, e2.dist(r2) / 3, i2 * s2 / n2);
        }
        function vf(t2, e2, r2) {
          return t2.x < r2[0].x && e2.x < r2[0].x || t2.x > r2[1].x && e2.x > r2[1].x || t2.y < r2[0].y && e2.y < r2[0].y || t2.y > r2[1].y && e2.y > r2[1].y;
        }
        function bf(t2, e2) {
          return t2.x < e2[0].x || t2.x > e2[1].x || t2.y < e2[0].y || t2.y > e2[1].y;
        }
        function wf(t2) {
          return t2.every((t3) => t3.x <= 0) || t2.every((t3) => t3.x >= jn) || t2.every((t3) => t3.y <= 0) || t2.every((t3) => t3.y >= jn);
        }
        function _f(t2, e2, r2) {
          if (t2.x < 0 || t2.x >= jn || e2.x < 0 || e2.x >= jn || r2.x < 0 || r2.x >= jn) return false;
          const n2 = r2.sub(e2), i2 = n2.perp(), s2 = t2.sub(e2);
          return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
        }
        function Af(t2, e2, r2) {
          const n2 = e2 ? 2 | t2 : -3 & t2;
          return r2 ? 1 | n2 : -2 & n2;
        }
        function Mf() {
          const t2 = Math.PI / 32, e2 = Math.tan(t2), r2 = Pu;
          return r2 * Math.sqrt(1 + 2 * e2 * e2) - r2;
        }
        function If(t2, e2, r2) {
          const n2 = 1 << r2.z, i2 = Du(r2.x / n2), s2 = Du((r2.x + 1) / n2), a2 = Cu(r2.y / n2), o2 = Cu((r2.y + 1) / n2);
          return function(t3, e3, r3, n3, i3 = 0, s3) {
            const a3 = [];
            if (!t3.length || !r3 || !n3) return a3;
            const o3 = (t4, e4) => {
              for (const r4 of t4) a3.push({ polygon: r4, bounds: e4 });
            }, l2 = Math.ceil(Math.log2(r3)), u2 = Math.ceil(Math.log2(n3)), c2 = l2 - u2, h2 = [];
            for (let t4 = 0; t4 < Math.abs(c2); t4++) h2.push(c2 > 0 ? 0 : 1);
            for (let t4 = 0; t4 < Math.min(l2, u2); t4++) h2.push(0), h2.push(1);
            let p2 = t3;
            if (p2 = dd(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = dd(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length) return a3;
            const d2 = [];
            for (h2.length ? d2.push({ polygons: p2, bounds: e3, depth: 0 }) : o3(p2, e3); d2.length; ) {
              const t4 = d2.pop(), e4 = t4.depth, r4 = h2[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u3 = 0 === r4 ? a4.x : a4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = dd(t4.polygons, l3 - i3, c3 + i3, r4), f2 = dd(t4.polygons, c3 - i3, u3 + i3, r4);
              if (p3.length) {
                const t5 = [n4, new It(0 === r4 ? c3 : a4.x, 1 === r4 ? c3 : a4.y)];
                h2.length > e4 + 1 ? d2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
              }
              if (f2.length) {
                const t5 = [new It(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), a4];
                h2.length > e4 + 1 ? d2.push({ polygons: f2, bounds: t5, depth: e4 + 1 }) : o3(f2, t5);
              }
            }
            return a3;
          }(t2, e2, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
            if (0 === t3) return 0.5 * (e3 + i3);
            {
              const t4 = Cu((r2.y + e3 / jn) / n2);
              return (Eu(0.5 * (Cu((r2.y + i3 / jn) / n2) + t4)) * n2 - r2.y) * jn;
            }
          });
        }
        function Sf(t2, e2, r2, n2, i2, s2) {
          const a2 = Math.pow(2, n2.z - i2.z);
          for (let o2 = 0; o2 < r2; o2++) {
            let r3 = t2.int16[2 * (o2 + e2) + 0], l2 = t2.int16[2 * (o2 + e2) + 1];
            r3 = (r3 + i2.x * jn) * a2 - n2.x * jn, l2 = (l2 + i2.y * jn) * a2 - n2.y * jn, s2.push(new It(r3, l2));
          }
        }
        let Pf, zf;
        Qs(mf, "FillExtrusionBucket", { omit: ["layers", "features"] }), Qs(uf, "PartData"), Qs(lf, "FootprintSegment"), Qs(cf, "BorderCentroidData"), Qs(ff, "GroundEffect");
        class Bf extends It {
          constructor(t2, e2, r2) {
            super(t2, e2), this.z = r2;
          }
        }
        class kf extends Bf {
          constructor(t2, e2, r2, n2) {
            super(t2, e2, r2), this.w = n2;
          }
        }
        function Tf(t2, e2, r2, n2) {
          const i2 = "x" === r2 ? "y" : "x", s2 = (n2 - t2[r2]) / (e2[r2] - t2[r2]);
          t2[i2] = Math.round(t2[i2] + (e2[i2] - t2[i2]) * s2), t2[r2] = n2, t2.hasOwnProperty("z") && (t2.z = dr(t2.z, e2.z, s2)), t2.hasOwnProperty("w") && (t2.w = dr(t2.w, e2.w, s2));
        }
        function Vf(t2, e2, r2, n2) {
          const i2 = r2, s2 = n2;
          for (const r3 of ["x", "y"]) {
            let n3 = t2, a2 = e2;
            n3[r3] >= a2[r3] && (n3 = e2, a2 = t2), n3[r3] < i2 && a2[r3] > i2 && Tf(n3, a2, r3, i2), n3[r3] < s2 && a2[r3] > s2 && Tf(a2, n3, r3, s2);
          }
        }
        function Ef(t2, e2, r2, n2, i2, s2) {
          const a2 = [];
          for (let o2 = 0; o2 < t2.length; o2++) {
            const l2 = t2[o2];
            let u2;
            const c2 = a2.length;
            let h2 = 0;
            for (let t3 = 0; t3 < l2.length - 1; t3++) {
              let c3 = l2[t3], p2 = l2[t3 + 1], d2 = 0;
              const f2 = h2;
              let m2, y2;
              s2 && (d2 = Math.hypot(p2.x - c3.x, p2.y - c3.y), h2 += d2, m2 = c3, y2 = p2), c3.x < e2 && p2.x < e2 || (c3.x < e2 ? c3 = new It(e2, c3.y + (e2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round() : p2.x < e2 && (p2 = new It(e2, c3.y + (e2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round()), c3.y < r2 && p2.y < r2 || (c3.y < r2 ? c3 = new It(c3.x + (r2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), r2)._round() : p2.y < r2 && (p2 = new It(c3.x + (r2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), r2)._round()), c3.x >= n2 && p2.x >= n2 || (c3.x >= n2 ? c3 = new It(n2, c3.y + (n2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round() : p2.x >= n2 && (p2 = new It(n2, c3.y + (n2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round()), c3.y >= i2 && p2.y >= i2 || (c3.y >= i2 ? c3 = new It(c3.x + (i2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), i2)._round() : p2.y >= i2 && (p2 = new It(c3.x + (i2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), i2)._round()), u2 && c3.equals(u2[u2.length - 1]) || (u2 = [c3], a2.push(u2), s2 && s2.push({ progress: { min: f2 + Df(m2, y2, c3) * d2, max: 1 }, parentIndex: o2, prevPoint: m2, nextPoint: y2 })), u2.push(p2), s2 && (s2[s2.length - 1].progress.max = f2 + Df(m2, y2, p2) * d2, s2[s2.length - 1].nextPoint = y2)))));
            }
            if (s2 && h2 > 0) for (let t3 = c2; t3 < a2.length; t3++) s2[t3].progress.min /= h2, s2[t3].progress.max /= h2;
          }
          return a2;
        }
        function Ff(t2, e2, r2, n2, i2) {
          if (t2.length < 2) return void n2.push(t2);
          const s2 = [];
          for (; e2.valid(); ) {
            const [r3, n3] = e2.get();
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const i3 = t2[e3], a3 = t2[e3 + 1], o3 = Fc(i3, a3, r3, n3);
              if (o3) {
                const [t3] = o3, r4 = new It(dr(i3.x, a3.x, t3), dr(i3.y, a3.y, t3));
                s2.push({ t: e3 + t3, distance: 0, point: r4 });
              }
            }
            e2.next();
          }
          if (0 === s2.length) return void n2.push(t2);
          s2.sort((t3, e3) => t3.t - e3.t);
          let a2 = 0, o2 = 0, l2 = [];
          for (n2.push(l2); a2 !== t2.length; ) {
            if (o2 === s2.length) {
              for (; a2 !== t2.length; ) 0 !== l2.length && l2[l2.length - 1].equals(t2[a2]) || l2.push(t2[a2]), a2++;
              break;
            }
            s2[o2].t <= a2 ? (0 !== l2.length && l2[l2.length - 1].equals(s2[o2].point) || l2.push(s2[o2].point), Math.trunc(s2[o2].t), o2++) : (0 !== l2.length && l2[l2.length - 1].equals(t2[a2]) || l2.push(t2[a2]), a2++);
          }
        }
        function Df(t2, e2, r2) {
          return t2.x !== e2.x ? (r2.x - t2.x) / (e2.x - t2.x) : t2.y !== e2.y ? (r2.y - t2.y) / (e2.y - t2.y) : 0;
        }
        function Cf(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function Rf(t2, e2) {
          if (1 === t2.length) {
            let r2 = 0;
            const n2 = e2[r2++];
            let i2;
            for (; !i2 || n2.equals(i2); ) if (i2 = e2[r2++], !i2) return 1 / 0;
            for (; r2 < e2.length; r2++) {
              const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Cf(o2, o2), h2 = Cf(o2, l2), p2 = Cf(l2, l2), d2 = Cf(u2, o2), f2 = Cf(u2, l2), m2 = c2 * p2 - h2 * h2, y2 = (p2 * d2 - h2 * f2) / m2, g2 = (c2 * f2 - h2 * d2) / m2, x2 = n2.z * (1 - y2 - g2) + i2.z * y2 + s2.z * g2;
              if (isFinite(x2)) return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r2 of e2) t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        function Lf(t2, e2, r2) {
          let n2 = 1 / 0;
          Bc(r2, e2) && (n2 = Rf(r2, e2[0]));
          for (let i2 = 0; i2 < e2.length; i2++) {
            const s2 = e2[i2], a2 = t2[i2];
            for (let t3 = 0; t3 < s2.length - 1; t3++) {
              const e3 = s2[t3], i3 = [e3, s2[t3 + 1], a2[t3 + 1], a2[t3], e3];
              Pc(r2, i3) && (n2 = Math.min(n2, Rf(r2, i3)));
            }
          }
          return n2 !== 1 / 0 && n2;
        }
        function Of(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
          return "globe" === t2.projection.name ? function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) {
            const h2 = [], p2 = [], d2 = t3.projection.upVectorScale(c3, t3.center.lat, t3.worldSize).metersToTile, f2 = [0, 0, 0, 1], m2 = [0, 0, 0, 1], y2 = (t4, e4, r4, n4) => {
              t4[0] = e4, t4[1] = r4, t4[2] = n4, t4[3] = 1;
            }, g2 = Mf();
            r3 > 0 && (r3 += g2), n3 += g2;
            for (const g3 of e3) {
              const e4 = [], x2 = [];
              for (const h3 of g3) {
                const p3 = h3.x + i3.x, g4 = h3.y + i3.y, v2 = t3.projection.projectTilePoint(p3, g4, c3), b2 = t3.projection.upVector(c3, h3.x, h3.y);
                let w2 = r3, _2 = n3;
                if (a3) {
                  const t4 = Uf(p3, g4, r3, n3, a3, o3, l3, u3);
                  w2 += t4.base, _2 += t4.top;
                }
                0 !== r3 ? y2(f2, v2.x + b2[0] * d2 * w2, v2.y + b2[1] * d2 * w2, v2.z + b2[2] * d2 * w2) : y2(f2, v2.x, v2.y, v2.z), y2(m2, v2.x + b2[0] * d2 * _2, v2.y + b2[1] * d2 * _2, v2.z + b2[2] * d2 * _2), j(f2, f2, s3), j(m2, m2, s3), e4.push(new Bf(f2[0], f2[1], f2[2])), x2.push(new Bf(m2[0], m2[1], m2[2]));
              }
              h2.push(e4), p2.push(x2);
            }
            return [h2, p2];
          }(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) : a2 ? function(t3, e3, r3, n3, i3, s3, a3, o3, l3) {
            const u3 = [], c3 = [], h2 = [0, 0, 0, 1];
            for (const p2 of t3) {
              const t4 = [], d2 = [];
              for (const u4 of p2) {
                const c4 = u4.x + n3.x, p3 = u4.y + n3.y, f2 = Uf(c4, p3, e3, r3, s3, a3, o3, l3);
                h2[0] = c4, h2[1] = p3, h2[2] = f2.base, h2[3] = 1, tt(h2, h2, i3), h2[3] = Math.max(h2[3], 1e-5);
                const m2 = new Bf(h2[0] / h2[3], h2[1] / h2[3], h2[2] / h2[3]);
                h2[0] = c4, h2[1] = p3, h2[2] = f2.top, h2[3] = 1, tt(h2, h2, i3), h2[3] = Math.max(h2[3], 1e-5);
                const y2 = new Bf(h2[0] / h2[3], h2[1] / h2[3], h2[2] / h2[3]);
                t4.push(m2), d2.push(y2);
              }
              u3.push(t4), c3.push(d2);
            }
            return [u3, c3];
          }(e2, r2, n2, i2, s2, a2, o2, l2, u2) : function(t3, e3, r3, n3, i3) {
            const s3 = [], a3 = [], o3 = i3[8] * e3, l3 = i3[9] * e3, u3 = i3[10] * e3, c3 = i3[11] * e3, h2 = i3[8] * r3, p2 = i3[9] * r3, d2 = i3[10] * r3, f2 = i3[11] * r3;
            for (const e4 of t3) {
              const t4 = [], r4 = [];
              for (const s4 of e4) {
                const e5 = s4.x + n3.x, a4 = s4.y + n3.y, m2 = i3[0] * e5 + i3[4] * a4 + i3[12], y2 = i3[1] * e5 + i3[5] * a4 + i3[13], g2 = i3[2] * e5 + i3[6] * a4 + i3[14], x2 = i3[3] * e5 + i3[7] * a4 + i3[15], v2 = m2 + o3, b2 = y2 + l3, w2 = g2 + u3, _2 = Math.max(x2 + c3, 1e-5), A2 = m2 + h2, M2 = y2 + p2, I2 = g2 + d2, S2 = Math.max(x2 + f2, 1e-5);
                t4.push(new Bf(v2 / _2, b2 / _2, w2 / _2)), r4.push(new Bf(A2 / S2, M2 / S2, I2 / S2));
              }
              s3.push(t4), a3.push(r4);
            }
            return [s3, a3];
          }(e2, r2, n2, i2, s2);
        }
        function Uf(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = 0 !== s2[0], c2 = u2 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
            const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, d2 = 2 * c3 + 1, f2 = function(t4, e4, r4, n4, i4) {
              return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
            }(t3, h2.x - u3, h2.y - c3, p2, d2), m2 = Math.abs(f2[0] - f2[1]), y2 = Math.abs(f2[2] - f2[3]), g2 = Math.abs(f2[0] - f2[2]) + Math.abs(f2[1] - f2[3]), x2 = Math.min(0.25, 0.5 * l3 * (m2 + y2) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / d2);
            return o3 + Math.max(x2 * s3, v2 * a3);
          }(i2, s2, o2) : l2;
          return { base: l2 + (0 === r2 ? -1 : r2), top: u2 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
        }
        class Nf {
          constructor(t2) {
            this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class jf {
          constructor() {
            this.tasks = {}, this.taskQueue = [], jt(["process"], this), this.invoker = new Nf(this.process), this.nextId = 0;
          }
          add(t2, e2) {
            const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
              return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
            }(e2);
            if (0 === n2) {
              try {
                t2();
              } finally {
              }
              return null;
            }
            return this.tasks[r2] = { fn: t2, metadata: e2, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r2];
            } };
          }
          process() {
            try {
              if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length) return;
              const t2 = this.pick();
              if (null === t2) return;
              const e2 = this.tasks[t2];
              if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2) return;
              e2.fn();
            } finally {
            }
          }
          pick() {
            let t2 = null, e2 = 1 / 0;
            for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
              const n2 = this.tasks[this.taskQueue[r3]];
              n2.priority < e2 && (e2 = n2.priority, t2 = r3);
            }
            if (null === t2) return null;
            const r2 = this.taskQueue[t2];
            return this.taskQueue.splice(t2, 1), r2;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class Gf {
          constructor(t2, e2, r2) {
            this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.cancelCallbacks = {}, jt(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new jf();
          }
          send(t2, e2, r2, n2, i2 = false, s2) {
            const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r2 && (r2.metadata = s2, this.callbacks[a2] = r2);
            const o2 = /* @__PURE__ */ new Set();
            return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: ea(e2, o2) }, o2), { cancel: () => {
              r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
            } };
          }
          receive(t2) {
            const e2 = t2.data;
            if (!e2) return;
            const r2 = e2.id;
            if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId)) if ("<cancel>" === e2.type) {
              const t3 = this.cancelCallbacks[r2];
              delete this.cancelCallbacks[r2], t3 && t3.cancel();
            } else if (e2.mustQueue || Kt(self)) {
              const t3 = this.callbacks[r2], n2 = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
              n2 && (this.cancelCallbacks[r2] = n2);
            } else this.processTask(r2, e2);
          }
          processTask(t2, e2) {
            if (delete this.cancelCallbacks[t2], "<response>" === e2.type) {
              const r2 = this.callbacks[t2];
              delete this.callbacks[t2], r2 && (e2.error ? r2(ra(e2.error)) : r2(null, ra(e2.data)));
            } else {
              const r2 = /* @__PURE__ */ new Set(), n2 = e2.hasCallback ? (e3, n3) => {
                this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? ea(e3) : null, data: ea(n3, r2) }, r2);
              } : () => {
              }, i2 = ra(e2.data);
              if (this.parent[e2.type]) this.parent[e2.type](e2.sourceMapId, i2, n2);
              else if (this.parent.getWorkerSource) {
                const t3 = e2.type.split("."), { source: r3, scope: s2 } = i2;
                this.parent.getWorkerSource(e2.sourceMapId, t3[0], r3, s2)[t3[1]](i2, n2);
              } else n2(new Error(`Could not find function ${e2.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }
        var $f = { workerUrl: "", workerClass: null, workerParams: void 0 };
        function qf(t2) {
          return null != $f.workerClass ? new $f.workerClass() : new self.Worker($f.workerUrl, Object.assign({ name: t2 }, $f.workerParams));
        }
        const Xf = "mapboxgl_preloaded_worker_pool";
        class Hf {
          constructor(t2) {
            this.active = {}, this.name = t2;
          }
          acquire(t2, e2 = Hf.workerCount) {
            if (!this.workers) for (this.workers = []; this.workers.length < e2; ) {
              const e3 = qf(`${this.name || ""}WorkerPool: ${t2}-${this.workers.length}`);
              this.workers.push(e3);
            }
            return this.active[t2] = true, this.workers.slice();
          }
          release(t2) {
            delete this.active[t2], this.workers && 0 === this.numActive() && (this.workers.forEach((t3) => {
              t3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Xf];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        Hf.workerCount = 2;
        class Zf {
          constructor(t2, e2, r2 = "Worker", n2 = Hf.workerCount) {
            this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = Ut();
            const i2 = this.workerPool.acquire(this.id, n2);
            for (let t3 = 0; t3 < i2.length; t3++) {
              const n3 = new Zf.Actor(i2[t3], e2, this.id);
              n3.name = `${r2} ${t3}`, this.actors.push(n3);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t2, e2, r2) {
            Lt(this.actors, (r3, n2) => {
              r3.send(t2, e2, n2);
            }, r2 = r2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((t2) => {
              t2.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        let Wf, Yf;
        function Jf() {
          return Wf || (Wf = new Hf()), Wf;
        }
        Zf.Actor = Gf;
        const Kf = 4096;
        class Qf {
          constructor(t2) {
            this.module = t2, this.memoryStack = this.module.malloc(Kf), this.memoryStackNextFree = this.memoryStack;
          }
          createIntArray(t2) {
            const e2 = this.memoryStackNextFree;
            return this.memoryStackNextFree += t2.length * Int32Array.BYTES_PER_ELEMENT, this.memoryStackNextFree - this.memoryStack > Kf ? -1 : (new Int32Array(this.module.heap32.buffer, e2, t2.length).set(t2), e2);
          }
          createFloatArray(t2) {
            const e2 = this.memoryStackNextFree;
            return this.memoryStackNextFree += t2.length * Float32Array.BYTES_PER_ELEMENT, this.memoryStackNextFree - this.memoryStack > Kf ? -1 : (new Float32Array(this.module.heapF32.buffer, e2, t2.length).set(t2), e2);
          }
          readStringBuffer(t2) {
            let e2 = "";
            for (; 0 !== this.module.heapU8[t2]; ) e2 += String.fromCharCode(this.module.heapU8[t2]), ++t2;
            return e2;
          }
          setStyle(t2) {
            const e2 = t2.normalScale;
            this.module.setStyle(e2[0], e2[1], e2[2], t2.tileToMeters);
          }
          setAOOptions(t2, e2) {
            this.module.setAOOptions(t2 ? 1 : 0, e2);
          }
          setMetricOptions(t2, e2) {
            this.module.setMetricOptions(t2 ? 1 : 0, e2);
          }
          setStructuralOptions(t2) {
            this.module.setStructuralOptions(t2 ? 1 : 0);
          }
          setFacadeOptions(t2, e2) {
            this.module.setFacadeOptions(t2, e2 ? 1 : 0);
          }
          setFauxFacadeOptions(t2, e2, r2) {
            this.module.setFauxFacadeOptions(t2 ? 1 : 0, e2 ? 1 : 0, r2);
          }
          setFacadeClassifierOptions(t2) {
            this.module.setFacadeClassifierOptions(t2);
          }
          generateMesh(t2, e2) {
            this.memoryStackNextFree = this.memoryStack;
            for (const e3 of t2) {
              const t3 = this.createIntArray(e3.ringIndices), r3 = this.createFloatArray(e3.coordinates);
              if (-1 === t3 || -1 === r3) return `building_gen: Out of stack memory: ${this.memoryStackNextFree - this.memoryStack}/4096`;
              this.module.addFeature(e3.id, e3.sourceId, e3.minHeight, e3.height, e3.roofType, r3, t3, e3.ringIndices.length - 1);
            }
            for (const t3 of e2) {
              let e3;
              e3 = t3.entrances ? JSON.parse(t3.entrances) : [];
              const r3 = this.createFloatArray(e3), n3 = this.createFloatArray(t3.coordinates);
              if (-1 === r3 || -1 === n3) return `building_gen: Out of stack memory: ${this.memoryStackNextFree - this.memoryStack}/4096`;
              this.module.addFacade(t3.sourceId, t3.crossPerc, t3.distanceToRoad, r3, e3.length, n3, t3.coordinates.length);
            }
            if (!this.module.generateMesh()) {
              const t3 = this.module.getLastError();
              return this.readStringBuffer(t3);
            }
            const r2 = this.module.getMeshCount(), n2 = new Array(r2);
            for (let t3 = 0; t3 < r2; t3++) {
              const e3 = this.module.getPositionsPtr(t3), r3 = this.module.getPositionsLength(t3), i3 = new Float32Array(this.module.heapF32.buffer, e3, r3), s3 = this.module.getNormalsPtr(t3), a2 = this.module.getNormalsLength(t3), o2 = new Float32Array(this.module.heapF32.buffer, s3, a2), l2 = this.module.getAOPtr(t3), u2 = this.module.getAOLength(t3), c2 = new Float32Array(this.module.heapF32.buffer, l2, u2), h2 = this.module.getUVPtr(t3), p2 = this.module.getUVLength(t3), d2 = new Float32Array(this.module.heapF32.buffer, h2, p2), f2 = this.module.getFauxFacadePtr(t3), m2 = this.module.getFauxFacadeLength(t3), y2 = new Uint8Array(this.module.heapU8.buffer, f2, m2), g2 = this.module.getIndicesPtr(t3), x2 = this.module.getIndicesLength(t3), v2 = new Int16Array(this.module.heap16.buffer, g2, x2), b2 = this.module.getBuildingPart(t3);
              n2[t3] = { positions: i3, normals: o2, ao: c2, uv: d2, isFauxFacade: y2, indices: v2, buildingPart: b2 };
            }
            const i2 = this.module.getRingCount(), s2 = [];
            for (let t3 = 0; t3 < i2; t3++) {
              const e3 = this.module.getRingPtr(t3), r3 = this.module.getRingLength(t3), n3 = new Float32Array(this.module.heapF32.buffer, e3, r3);
              s2.push(n3);
            }
            return { meshes: n2, outerRingLength: this.module.getOuterRingLength(), modifiedPolygonRings: s2 };
          }
        }
        let tm, em, rm, nm, im, sm = null, am = null, om = null, lm = null;
        function um() {
          return Kt(self) && self.worker.dracoUrl ? self.worker.dracoUrl : em || oe.DRACO_URL;
        }
        function cm() {
          if (Kt(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
          if (nm) return nm;
          const t2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
          if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
          return nm = WebAssembly.validate(t2) ? oe.MESHOPT_SIMD_URL : oe.MESHOPT_URL, nm;
        }
        function hm() {
          return lm;
        }
        const pm = 5120, dm = 5121, fm = 5122, mm = 5123, ym = 5125, gm = 5126, xm = { [pm]: Int8Array, [dm]: Uint8Array, [fm]: Int16Array, [mm]: Uint16Array, [ym]: Uint32Array, [gm]: Float32Array }, vm = { [pm]: "DT_INT8", [dm]: "DT_UINT8", [fm]: "DT_INT16", [mm]: "DT_UINT16", [ym]: "DT_UINT32", [gm]: "DT_FLOAT32" }, bm = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
        function wm(t2, e2, r2) {
          const n2 = r2.json.bufferViews.length, i2 = r2.buffers.length;
          e2.bufferView = n2, r2.json.bufferViews[n2] = { buffer: i2, byteLength: t2.byteLength }, r2.buffers[i2] = t2;
        }
        const _m = "KHR_draco_mesh_compression";
        function Am(t2, e2) {
          const r2 = t2.extensions && t2.extensions[_m];
          if (!r2) return;
          const n2 = new rm.Decoder(), i2 = km(e2, r2.bufferView), s2 = new rm.Mesh();
          if (!n2.DecodeArrayToMesh(i2, i2.byteLength, s2)) throw new Error("Failed to decode Draco mesh");
          const a2 = e2.json.accessors[t2.indices], o2 = xm[a2.componentType], l2 = a2.count * o2.BYTES_PER_ELEMENT, u2 = rm._malloc(l2);
          o2 === Uint16Array ? n2.GetTrianglesUInt16Array(s2, l2, u2) : n2.GetTrianglesUInt32Array(s2, l2, u2), wm(rm.memory.buffer.slice(u2, u2 + l2), a2, e2), rm._free(u2);
          for (const i3 of Object.keys(r2.attributes)) {
            const a3 = n2.GetAttributeByUniqueId(s2, r2.attributes[i3]), o3 = e2.json.accessors[t2.attributes[i3]], l3 = vm[o3.componentType], u3 = o3.count * bm[o3.type] * xm[o3.componentType].BYTES_PER_ELEMENT, c2 = rm._malloc(u3);
            n2.GetAttributeDataArrayForAllPoints(s2, a3, rm[l3], u3, c2), wm(rm.memory.buffer.slice(c2, c2 + u3), o3, e2), rm._free(c2);
          }
          n2.destroy(), s2.destroy(), delete t2.extensions[_m];
        }
        const Mm = "EXT_meshopt_compression";
        function Im(t2, e2) {
          if (!t2.extensions || !t2.extensions[Mm]) return;
          const r2 = t2.extensions[Mm], n2 = new Uint8Array(e2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength || 0), i2 = new Uint8Array(r2.count * r2.byteStride);
          im.decodeGltfBuffer(i2, r2.count, r2.byteStride, n2, r2.mode, r2.filter), t2.buffer = e2.buffers.length, t2.byteOffset = 0, e2.buffers[t2.buffer] = i2.buffer, delete t2.extensions[Mm];
        }
        const Sm = 1179937895, Pm = new TextDecoder("utf8");
        function zm(t2, e2) {
          return new URL(t2, e2).href;
        }
        function Bm(t2, e2, r2, n2) {
          return fetch(zm(t2.uri, n2)).then((t3) => t3.arrayBuffer()).then((t3) => {
            e2.buffers[r2] = t3;
          });
        }
        function km(t2, e2) {
          const r2 = t2.json.bufferViews[e2];
          return new Uint8Array(t2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength);
        }
        function Tm(t2, e2, r2, n2) {
          if (t2.uri) {
            const i2 = zm(t2.uri, n2);
            return fetch(i2).then((t3) => t3.blob()).then((t3) => createImageBitmap(t3)).then((t3) => {
              e2.images[r2] = t3;
            });
          }
          if (void 0 !== t2.bufferView) {
            const n3 = km(e2, t2.bufferView), i2 = new Blob([n3], { type: t2.mimeType });
            return createImageBitmap(i2).then((t3) => {
              e2.images[r2] = t3;
            });
          }
        }
        function Vm(t2, e2 = 0, r2) {
          const n2 = { json: null, images: [], buffers: [] };
          if (new Uint32Array(t2, e2, 1)[0] === Sm) {
            const r3 = new Uint32Array(t2, e2);
            let i3 = 2;
            const s3 = (r3[i3++] >> 2) - 3, a3 = r3[i3++] >> 2;
            if (i3++, n2.json = JSON.parse(Pm.decode(r3.subarray(i3, i3 + a3))), i3 += a3, i3 < s3) {
              const s4 = r3[i3++];
              i3++;
              const a4 = e2 + (i3 << 2);
              n2.buffers[0] = t2.slice(a4, a4 + s4);
            }
          } else n2.json = JSON.parse(Pm.decode(new Uint8Array(t2, e2)));
          const { buffers: i2, images: s2, meshes: a2, extensionsUsed: o2, bufferViews: l2 } = n2.json;
          let u2 = Promise.resolve();
          if (i2) {
            const t3 = [];
            for (let e3 = 0; e3 < i2.length; e3++) {
              const s3 = i2[e3];
              s3.uri ? t3.push(Bm(s3, n2, e3, r2)) : n2.buffers[e3] || (n2.buffers[e3] = null);
            }
            u2 = Promise.all(t3);
          }
          return u2.then(() => {
            const t3 = [], e3 = o2 && o2.includes(_m), i3 = o2 && o2.includes(Mm);
            if (e3 && t3.push(function() {
              if (!rm) return null != tm ? tm : (tm = function(t4) {
                let e4, r3 = null;
                function n3() {
                  e4 = new Uint8Array(r3.buffer);
                }
                function i4() {
                  throw new Error("Unexpected Draco error.");
                }
                const s3 = { a: { a: i4, d: function(t5, r4, n4) {
                  return e4.copyWithin(t5, r4, r4 + n4);
                }, c: function(t5) {
                  const i5 = e4.length, s4 = Math.max(t5 >>> 0, Math.ceil(1.2 * i5)), a3 = Math.ceil((s4 - i5) / 65536);
                  try {
                    return r3.grow(a3), n3(), true;
                  } catch (t6) {
                    return false;
                  }
                }, b: i4 } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t4, s3) : t4.then((t5) => t5.arrayBuffer()).then((t5) => WebAssembly.instantiate(t5, s3))).then((t5) => {
                  const { Rb: i5, Qb: s4, P: a3, T: o3, X: l3, Ja: u3, La: c2, Qa: h2, Va: p2, Wa: d2, eb: f2, jb: m2, f: y2, e: g2, yb: x2, zb: v2, Ab: b2, Bb: w2, Db: _2, Gb: A2 } = t5.instance.exports;
                  r3 = g2;
                  const M2 = /* @__PURE__ */ (() => {
                    let t6 = 0, r4 = 0, n4 = 0, a4 = 0;
                    return (o4) => {
                      n4 && (i5(a4), i5(t6), r4 += n4, n4 = t6 = 0), t6 || (r4 += 128, t6 = s4(r4));
                      const l4 = o4.length + 7 & -8;
                      let u4 = t6;
                      l4 >= r4 && (n4 = l4, u4 = a4 = s4(l4));
                      for (let t7 = 0; t7 < o4.length; t7++) e4[u4 + t7] = o4[t7];
                      return u4;
                    };
                  })();
                  return n3(), y2(), { memory: g2, _free: i5, _malloc: s4, Mesh: class {
                    constructor() {
                      this.ptr = a3();
                    }
                    destroy() {
                      o3(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = u3();
                    }
                    destroy() {
                      m2(this.ptr);
                    }
                    DecodeArrayToMesh(t6, e5, r4) {
                      const n4 = M2(t6), i6 = c2(this.ptr, n4, e5, r4.ptr);
                      return !!l3(i6);
                    }
                    GetAttributeByUniqueId(t6, e5) {
                      return { ptr: h2(this.ptr, t6.ptr, e5) };
                    }
                    GetTrianglesUInt16Array(t6, e5, r4) {
                      p2(this.ptr, t6.ptr, e5, r4);
                    }
                    GetTrianglesUInt32Array(t6, e5, r4) {
                      d2(this.ptr, t6.ptr, e5, r4);
                    }
                    GetAttributeDataArrayForAllPoints(t6, e5, r4, n4, i6) {
                      f2(this.ptr, t6.ptr, e5.ptr, r4, n4, i6);
                    }
                  }, DT_INT8: x2(), DT_UINT8: v2(), DT_INT16: b2(), DT_UINT16: w2(), DT_UINT32: _2(), DT_FLOAT32: A2() };
                });
              }(fetch(um())), tm.then((t4) => {
                rm = t4, tm = void 0;
              }));
            }()), i3 && t3.push(function() {
              if (im) return;
              const t4 = function(t5) {
                let e4;
                const r3 = WebAssembly.instantiateStreaming(t5, {}).then((t6) => {
                  e4 = t6.instance, e4.exports.__wasm_call_ctors();
                }), n3 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i4 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                return { ready: r3, supported: true, decodeGltfBuffer(t6, r4, s3, a3, o3, l3) {
                  !function(t7, e5, r5, n4, i5, s4, a4) {
                    const o4 = t7.exports.sbrk, l4 = n4 + 3 & -4, u3 = o4(l4 * i5), c2 = o4(s4.length), h2 = new Uint8Array(t7.exports.memory.buffer);
                    h2.set(s4, c2);
                    const p2 = e5(u3, n4, i5, c2, s4.length);
                    if (0 === p2 && a4 && a4(u3, l4, i5), r5.set(h2.subarray(u3, u3 + n4 * i5)), o4(u3 - o4(0)), 0 !== p2) throw new Error(`Malformed buffer data: ${p2}`);
                  }(e4, e4.exports[i4[o3]], t6, r4, s3, a3, e4.exports[n3[l3]]);
                } };
              }(fetch(cm()));
              return t4.ready.then(() => {
                im = t4;
              });
            }()), s2) for (let e4 = 0; e4 < s2.length; e4++) t3.push(Tm(s2[e4], n2, e4, r2));
            return (t3.length ? Promise.all(t3) : Promise.resolve()).then(() => {
              if (e3 && a2) for (const { primitives: t4 } of a2) for (const e4 of t4) Am(e4, n2);
              if (i3 && a2 && l2) for (const t4 of l2) Im(t4, n2);
              return n2;
            });
          });
        }
        function Em(t2) {
          return fetch(t2).then((t3) => t3.arrayBuffer()).then((e2) => Vm(e2, 0, t2));
        }
        function Fm(t2) {
          switch (t2) {
            case WebGL2RenderingContext.RGBA8:
              return WebGL2RenderingContext.RGBA;
            case WebGL2RenderingContext.DEPTH_COMPONENT16:
              return WebGL2RenderingContext.DEPTH_COMPONENT;
            case WebGL2RenderingContext.DEPTH24_STENCIL8:
              return WebGL2RenderingContext.DEPTH_STENCIL;
            case WebGL2RenderingContext.R8:
            case WebGL2RenderingContext.R32F:
              return WebGL2RenderingContext.RED;
          }
        }
        function Dm(t2) {
          switch (t2) {
            case WebGL2RenderingContext.RGBA8:
              return WebGL2RenderingContext.UNSIGNED_BYTE;
            case WebGL2RenderingContext.DEPTH_COMPONENT16:
              return WebGL2RenderingContext.UNSIGNED_SHORT;
            case WebGL2RenderingContext.DEPTH24_STENCIL8:
              return WebGL2RenderingContext.UNSIGNED_INT_24_8;
            case WebGL2RenderingContext.R8:
              return WebGL2RenderingContext.UNSIGNED_BYTE;
            case WebGL2RenderingContext.R32F:
              return WebGL2RenderingContext.FLOAT;
          }
        }
        class Cm {
          constructor(t2, e2, r2, n2) {
            this.context = t2, this.format = r2, this.useMipmap = n2 && n2.useMipmap, this.texture = t2.gl.createTexture(), this.update(e2, { premultiply: n2 && n2.premultiply });
          }
          update(t2, e2) {
            const r2 = t2 && t2 instanceof HTMLVideoElement && 0 === t2.width ? t2.videoWidth : t2.width, n2 = t2 && t2 instanceof HTMLVideoElement && 0 === t2.height ? t2.videoHeight : t2.height, { context: i2 } = this, { gl: s2 } = i2, { x: a2, y: o2 } = e2 && e2.position ? e2.position : { x: 0, y: 0 }, l2 = a2 + r2, u2 = o2 + n2;
            !this.size || this.size[0] === l2 && this.size[1] === u2 || (s2.bindTexture(s2.TEXTURE_2D, null), s2.deleteTexture(this.texture), this.texture = s2.createTexture(), this.size = null), s2.bindTexture(s2.TEXTURE_2D, this.texture), i2.pixelStoreUnpackFlipY.set(false), i2.pixelStoreUnpack.set(1), i2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA8 && (!e2 || false !== e2.premultiply));
            const c2 = t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || ImageBitmap && t2 instanceof ImageBitmap;
            if (!this.size && l2 > 0 && u2 > 0) {
              const t3 = this.useMipmap ? Math.floor(Math.log2(Math.max(l2, u2))) + 1 : 1;
              s2.texStorage2D(s2.TEXTURE_2D, t3, this.format, l2, u2), this.size = [l2, u2];
            }
            this.size && (c2 ? s2.texSubImage2D(s2.TEXTURE_2D, 0, a2, o2, Fm(this.format), Dm(this.format), t2) : "data" in t2 && t2.data && s2.texSubImage2D(s2.TEXTURE_2D, 0, a2, o2, r2, n2, Fm(this.format), Dm(this.format), t2.data)), this.useMipmap && s2.generateMipmap(s2.TEXTURE_2D);
          }
          bind(t2, e2, r2 = false) {
            const { context: n2 } = this, { gl: i2 } = n2;
            i2.bindTexture(i2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, this.useMipmap && !r2 ? t2 === i2.NEAREST ? i2.NEAREST_MIPMAP_NEAREST : i2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), e2 !== this.wrapS && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
          }
          bindExtraParam(t2, e2, r2, n2, i2) {
            const { context: s2 } = this, { gl: a2 } = s2;
            a2.bindTexture(a2.TEXTURE_2D, this.texture), e2 !== this.magFilter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, e2), this.magFilter = e2), t2 !== this.minFilter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === a2.NEAREST ? a2.NEAREST_MIPMAP_NEAREST : a2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), r2 !== this.wrapS && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, r2), this.wrapS = r2), n2 !== this.wrapT && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, n2), this.wrapT = n2), i2 !== this.compareMode && (i2 ? (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_COMPARE_MODE, a2.COMPARE_REF_TO_TEXTURE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_COMPARE_FUNC, i2)) : a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_COMPARE_MODE, a2.NONE), this.compareMode = i2);
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Rm {
          constructor(t2, e2) {
            this.context = t2, this.texture = e2;
          }
          bind(t2, e2) {
            const { context: r2 } = this, { gl: n2 } = r2;
            n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e2 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
          }
        }
        const Lm = Oo([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Om = Oo([{ name: "a_color_3f", components: 3, type: "Float32" }]), Um = Oo([{ name: "a_color_4f", components: 4, type: "Float32" }]), Nm = Oo([{ name: "a_uv_2f", components: 2, type: "Float32" }]), jm = Oo([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Gm = Oo([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), $m = Oo([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]);
        function qm(t2, e2) {
          const r2 = Hm(t2.projection, t2.zoom, t2.width, t2.height), n2 = function(t3, e3, r3, n3, i3) {
            const s2 = new Bu(r3.lng - 180 * Zm, r3.lat), a2 = new Bu(r3.lng + 180 * Zm, r3.lat), o2 = t3.project(s2.lng, s2.lat), l2 = t3.project(a2.lng, a2.lat), c2 = -Math.atan2(l2.y - o2.y, l2.x - o2.x), p2 = Gu.fromLngLat(r3);
            p2.y = Dt(p2.y, -1 + Zm, 1 - Zm);
            const f2 = p2.toLngLat(), m2 = t3.project(f2.lng, f2.lat), g2 = Gu.fromLngLat(f2);
            g2.x += Zm;
            const x2 = g2.toLngLat(), v2 = t3.project(x2.lng, x2.lat), b2 = Ym(v2.x - m2.x, v2.y - m2.y, c2), w2 = Gu.fromLngLat(f2);
            w2.y += Zm;
            const _2 = w2.toLngLat(), A2 = t3.project(_2.lng, _2.lat), M2 = Ym(A2.x - m2.x, A2.y - m2.y, c2), I2 = Math.abs(b2.x) / Math.abs(M2.y), S2 = u([]);
            y(S2, S2, -c2 * (1 - (i3 ? 0 : n3)));
            const P2 = u([]);
            return d(P2, P2, [1, 1 - (1 - I2) * n3, 1]), P2[4] = -M2.x / M2.y * n3, y(P2, P2, c2), h(P2, S2, P2), P2;
          }(t2.projection, 0, t2.center, r2, e2), i2 = Xm(t2);
          return d(n2, n2, [i2, i2, 1]), n2;
        }
        function Xm(t2) {
          const e2 = t2.projection, r2 = Hm(t2.projection, t2.zoom, t2.width, t2.height), n2 = Wm(e2, t2.center), i2 = Wm(e2, Bu.convert(e2.center));
          return Math.pow(2, n2 * r2 + (1 - r2) * i2);
        }
        function Hm(t2, e2, r2, n2, i2 = 1 / 0) {
          const s2 = t2.range;
          if (!s2) return 0;
          const a2 = Math.min(i2, Math.max(r2, n2)), o2 = Math.log2(a2 / 1024);
          return Ct(s2[0] + o2, s2[1] + o2, e2);
        }
        const Zm = 1 / 4e4;
        function Wm(t2, e2) {
          const r2 = Dt(e2.lat, -85.051129, Lu), n2 = new Bu(e2.lng - 180 * Zm, r2), i2 = new Bu(e2.lng + 180 * Zm, r2), s2 = t2.project(n2.lng, r2), a2 = t2.project(i2.lng, r2), o2 = Gu.fromLngLat(n2), l2 = Gu.fromLngLat(i2), u2 = a2.x - s2.x, c2 = a2.y - s2.y, h2 = l2.x - o2.x, p2 = l2.y - o2.y, d2 = Math.sqrt((h2 * h2 + p2 * p2) / (u2 * u2 + c2 * c2));
          return Math.log2(d2);
        }
        function Ym(t2, e2, r2) {
          const n2 = Math.cos(r2), i2 = Math.sin(r2);
          return { x: t2 * n2 - e2 * i2, y: t2 * i2 + e2 * n2 };
        }
        function Jm(t2, e2, r2) {
          u(t2), y(t2, t2, Bt(e2[2])), f(t2, t2, Bt(e2[0])), m(t2, t2, Bt(e2[1])), d(t2, t2, r2), h(t2, t2, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        function Km(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = [r2[0] - e2[0], r2[1] - e2[1], 0], u2 = [n2[0] - e2[0], n2[1] - e2[1], 0];
          if (M(l2) < 1e-12 || M(u2) < 1e-12) return rt(t2);
          const c2 = U([], l2, u2);
          L(c2, c2), z(u2, n2, e2), l2[2] = (s2 - i2) * o2, u2[2] = (a2 - i2) * o2;
          const h2 = l2;
          return U(h2, l2, u2), L(h2, h2), ut(t2, c2, h2);
        }
        function Qm(t2, e2, r2 = false) {
          const n2 = Mh(e2.zoom), i2 = function(t3, e3, r3) {
            const n3 = e3.worldSize, i3 = [t3[12], t3[13], t3[14]], s2 = Cu(i3[1] / n3), a2 = Du(i3[0] / n3), o2 = u([]), l2 = Fu(1, s2) * n3, c2 = Fu(1, 0) * n3 * Uu(s2, e3.zoom), f2 = 1 / wh(n3);
            let m2 = c2 * f2;
            if (r3) {
              const t4 = Hm(e3.projection, e3.zoom, e3.width, e3.height, 1024);
              m2 = f2 * e3.projection.pixelSpaceConversion(e3.center.lat, n3, t4);
            }
            const y2 = Su(s2, a2);
            P(y2, y2, V([], L([], y2), l2 * m2 * i3[2]));
            const g2 = function(t4) {
              const e4 = [t4[0], t4[1], t4[2]];
              let r4 = [0, 1, 0];
              const n4 = U([], r4, e4);
              return U(r4, e4, n4), 0 === C(r4) && (r4 = [0, 1, 0], U(n4, e4, r4)), L(n4, n4), L(r4, r4), L(e4, e4), [n4[0], n4[1], n4[2], 0, r4[0], r4[1], r4[2], 0, e4[0], e4[1], e4[2], 0, t4[0], t4[1], t4[2], 1];
            }(y2);
            d(o2, o2, [m2, m2, m2 * l2]), p(o2, o2, [-i3[0], -i3[1], -i3[2]]);
            const x2 = h([], e3.globeMatrix, g2);
            return h(x2, x2, o2), h(x2, x2, t3), x2;
          }(t2, e2, r2);
          if (n2 > 0) {
            const r3 = function(t3, e3) {
              const r4 = e3.worldSize, n3 = Fu(1, 0) * r4 * Uu(e3.center.lat, e3.zoom) / wh(r4), i3 = Fu(1, e3.center.lat) * r4, s2 = u([]);
              m(s2, s2, Bt(e3.center.lng)), f(s2, s2, Bt(e3.center.lat)), p(s2, s2, [0, 0, bu]), d(s2, s2, [n3, n3, n3 * i3]);
              const a2 = e3.point;
              return p(s2, s2, [-a2.x, -a2.y, 0]), h(s2, s2, t3), h(s2, e3.globeMatrix, s2);
            }(t2, e2);
            return function(t3, e3, r4) {
              const n3 = (t4, e4, r5) => {
                const n4 = M(t4), i4 = M(e4), s3 = hh(t4, e4, r5);
                return V(s3, s3, 1 / M(s3) * dr(n4, i4, r5));
              }, i3 = n3([t3[0], t3[1], t3[2]], [e3[0], e3[1], e3[2]], r4), s2 = n3([t3[4], t3[5], t3[6]], [e3[4], e3[5], e3[6]], r4), a2 = n3([t3[8], t3[9], t3[10]], [e3[8], e3[9], e3[10]], r4), o2 = hh([t3[12], t3[13], t3[14]], [e3[12], e3[13], e3[14]], r4);
              return [i3[0], i3[1], i3[2], 0, s2[0], s2[1], s2[2], 0, a2[0], a2[1], a2[2], 0, o2[0], o2[1], o2[2], 1];
            }(i2, r3, n2);
          }
          return i2;
        }
        function ty(t2, e2, r2, n2) {
          const i2 = wc.projectAabbCorners(n2, r2);
          let s2 = Number.MAX_VALUE;
          for (let t3 = 0; t3 < i2.length; ++t3) {
            const r3 = i2[t3];
            r3[0] = (0.5 * r3[0] + 0.5) * e2.width, r3[1] = (0.5 - 0.5 * r3[1]) * e2.height, r3[2] < s2 && (s2 = r3[2]);
          }
          const a2 = function(t3) {
            const e3 = [];
            let r3 = 0;
            for (let e4 = 1; e4 < t3.length; e4++) (t3[e4][0] < t3[r3][0] || t3[e4][0] === t3[r3][0] && t3[e4][1] < t3[r3][1]) && (r3 = e4);
            let n3, i3 = r3;
            const s3 = new Uint8Array(t3.length);
            do {
              if (s3[i3]) break;
              e3.push(new It(t3[i3][0], t3[i3][1])), s3[i3] = 1, n3 = (i3 + 1) % t3.length;
              for (let e4 = 0; e4 < t3.length; e4++) {
                if (t3[e4][0] === t3[n3][0] && t3[e4][1] === t3[n3][1] || t3[e4][0] === t3[i3][0] && t3[e4][1] === t3[i3][1]) continue;
                const r4 = [t3[e4][0] - t3[i3][0], t3[e4][1] - t3[i3][1]], s4 = [t3[n3][0] - t3[i3][0], t3[n3][1] - t3[i3][1]], a3 = r4[0] * s4[1] - r4[1] * s4[0];
                (a3 > 0 || 0 === a3 && r4[0] * s4[0] + r4[1] * s4[1] >= 0 && r4[0] * r4[0] + r4[1] * r4[1] > s4[0] * s4[0] + s4[1] * s4[1]) && (n3 = e4);
              }
              i3 = n3;
            } while (i3 !== r3);
            return e3.length > 0 && e3.push(e3[0]), e3;
          }(i2);
          if (Pc(t2, a2)) return s2;
        }
        const ey = 64, ry = { CoordinateSpaceTile: 1, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
        function ny(t2, e2, r2, n2, i2, s2, a2, o2, l2, c2 = false) {
          const f2 = r2.zoom, m2 = r2.project(n2), y2 = Uu(n2.lat, f2), g2 = 1 / y2;
          u(t2), p(t2, t2, [m2.x + a2[0] * g2, m2.y + a2[1] * g2, a2[2]]);
          let x2 = 1, v2 = 1;
          const w2 = r2.worldSize;
          if (c2) {
            if ("mercator" === r2.projection.name) {
              let t3 = 0;
              r2.elevation && (t3 = r2.elevation.getAtPointOrZero(new Gu(m2.x / w2, m2.y / w2), 0));
              const e3 = tt([], [m2.x, m2.y, t3, 1], r2.projMatrix)[3] / r2.cameraToCenterDistance;
              x2 = e3, v2 = e3 * Uu(r2.center.lat, f2);
            } else if ("globe" === r2.projection.name) {
              const e3 = Qm(t2, r2), i3 = [0, 0, 0, 1];
              tt(i3, i3, h([], r2.projMatrix, e3));
              const s3 = i3[3] / r2.cameraToCenterDistance, a3 = Mh(f2), o3 = r2.projection.pixelsPerMeter(n2.lat, w2) * Uu(n2.lat, f2), l3 = r2.projection.pixelsPerMeter(r2.center.lat, w2) * Uu(r2.center.lat, f2);
              x2 = s3 / dr(o3, Ou(r2.center.lat), a3), v2 = s3 * y2 / o3, x2 *= l3, v2 *= l3;
            }
          } else x2 = g2;
          d(t2, t2, [x2, x2, v2]);
          const _2 = [...t2], A2 = e2.orientation, M2 = [];
          if (Jm(M2, [A2[0] + (i2 ? i2[0] : 0), A2[1] + (i2 ? i2[1] : 0), A2[2] + (i2 ? i2[2] : 0)], s2), h(t2, _2, M2), o2 && r2.elevation) {
            let i3 = 0;
            const s3 = [];
            if (l2 && r2.elevation) {
              i3 = function(t3, e3, r3, n3, i4) {
                const s4 = e3.elevation;
                if (!s4) return 0;
                const a4 = wc.projectAabbCorners(r3, n3), o3 = Fu(1, i4.lat) * e3.worldSize, l3 = function(t4, e4) {
                  const r4 = [0, 0, 1], n4 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                  for (const i5 of n4) {
                    const n5 = t4[i5.corners[0]], s5 = t4[i5.corners[1]], a5 = t4[i5.corners[2]], o4 = [s5[0] - n5[0], s5[1] - n5[1], e4 * (s5[2] - n5[2])], l4 = U(o4, o4, [a5[0] - n5[0], a5[1] - n5[1], e4 * (a5[2] - n5[2])]);
                    L(l4, l4), i5.dotProductWithUp = O(l4, r4);
                  }
                  return n4.sort((t5, e5) => t5.dotProductWithUp - e5.dotProductWithUp), n4[0].corners;
                }(a4, o3), u2 = a4[l3[0]], c3 = a4[l3[1]], h2 = a4[l3[2]], p2 = a4[l3[3]], d2 = s4.getAtPointOrZero(new Gu(u2[0] / e3.worldSize, u2[1] / e3.worldSize), 0), f3 = s4.getAtPointOrZero(new Gu(c3[0] / e3.worldSize, c3[1] / e3.worldSize), 0), m3 = s4.getAtPointOrZero(new Gu(h2[0] / e3.worldSize, h2[1] / e3.worldSize), 0), y3 = s4.getAtPointOrZero(new Gu(p2[0] / e3.worldSize, p2[1] / e3.worldSize), 0), g3 = (d2 + y3) / 2, x3 = (f3 + m3) / 2;
                return g3 > x3 ? f3 < m3 ? Km(t3, c3, p2, u2, f3, y3, d2, o3) : Km(t3, h2, u2, p2, m3, d2, y3, o3) : d2 < y3 ? Km(t3, u2, c3, h2, d2, f3, m3, o3) : Km(t3, p2, h2, c3, y3, m3, f3, o3), Math.max(g3, x3);
              }(s3, r2, e2.aabb, t2, n2);
              const a3 = h([], b([], s3), M2);
              h(t2, _2, a3);
            } else i3 = r2.elevation.getAtPointOrZero(new Gu(m2.x / w2, m2.y / w2), 0);
            0 !== i3 && (t2[14] += i3);
          }
        }
        class iy {
          constructor(t2, e2, r2, n2, i2) {
            this.materialOverrides = /* @__PURE__ */ new Map(), this.nodeOverrides = /* @__PURE__ */ new Map(), this.materialOverrideNames = [], this.nodeOverrideNames = [], this.featureProperties = {}, this.id = t2, this.uri = e2, this.position = null != r2 ? new Bu(r2[0], r2[1]) : new Bu(0, 0), this.orientation = null != n2 ? n2 : [0, 0, 0], this.nodes = i2, this.uploaded = false, this.aabb = new wc([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
          }
          _applyTransformations(t2, e2) {
            h(t2.globalMatrix, e2, t2.localMatrix);
            const r2 = this.nodeOverrides.get(t2.name);
            if (void 0 !== r2) {
              const e3 = [];
              i2 = r2.orientation, u(n2 = e3), m(n2, n2, Bt(i2[1])), y(n2, n2, Bt(i2[2])), f(n2, n2, Bt(i2[0])), h(t2.globalMatrix, t2.globalMatrix, e3);
            }
            var n2, i2;
            if (t2.meshes) for (const e3 of t2.meshes) {
              const r3 = wc.applyTransformFast(e3.aabb, t2.globalMatrix);
              this.aabb.encapsulate(r3);
            }
            if (t2.children) for (const e3 of t2.children) this._applyTransformations(e3, t2.globalMatrix);
          }
          computeBoundsAndApplyParent() {
            const t2 = u([]);
            this.aabb = new wc([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            for (const e2 of this.nodes) this._applyTransformations(e2, t2);
          }
          computeModelMatrix(t2, e2, r2, n2, i2, s2, a2 = false) {
            ny(this.matrix, this, t2.transform, this.position, e2, r2, n2, i2, s2, a2);
          }
          upload(t2) {
            if (!this.uploaded) {
              for (const e2 of this.nodes) oy(e2, t2);
              for (const t3 of this.nodes) ly(t3);
              this.uploaded = true;
            }
          }
          destroy() {
            for (const t2 of this.nodes) cy(t2);
          }
        }
        function sy(t2, e2, r2 = false) {
          t2.uploaded || (t2.gfxTexture = new Cm(e2, t2.image, r2 ? e2.gl.R8 : e2.gl.RGBA8, { useMipmap: t2.sampler.minFilter >= e2.gl.NEAREST_MIPMAP_NEAREST }), t2.uploaded = true, t2.image = null);
        }
        function ay(t2, e2, r2) {
          t2.indexBuffer = e2.createIndexBuffer(t2.indexArray, false, true), t2.vertexBuffer = e2.createVertexBuffer(t2.vertexArray, Lm.members, false, true), t2.normalArray && (t2.normalBuffer = e2.createVertexBuffer(t2.normalArray, jm.members, false, true)), t2.texcoordArray && (t2.texcoordBuffer = e2.createVertexBuffer(t2.texcoordArray, Nm.members, false, true)), t2.colorArray && (t2.colorBuffer = e2.createVertexBuffer(t2.colorArray, (12 === t2.colorArray.bytesPerElement ? Om : Um).members, false, true)), t2.featureArray && (t2.pbrBuffer = e2.createVertexBuffer(t2.featureArray, $m.members, true)), t2.segments = Ol.simpleSegment(0, 0, t2.vertexArray.length, t2.indexArray.length);
          const n2 = t2.material;
          n2.pbrMetallicRoughness.baseColorTexture && sy(n2.pbrMetallicRoughness.baseColorTexture, e2), n2.pbrMetallicRoughness.metallicRoughnessTexture && sy(n2.pbrMetallicRoughness.metallicRoughnessTexture, e2), n2.normalTexture && sy(n2.normalTexture, e2), n2.occlusionTexture && sy(n2.occlusionTexture, e2, r2), n2.emissionTexture && sy(n2.emissionTexture, e2);
        }
        function oy(t2, e2, r2) {
          if (t2.meshes) for (const n2 of t2.meshes) ay(n2, e2, r2);
          if (t2.children) for (const n2 of t2.children) oy(n2, e2, r2);
        }
        function ly(t2) {
          if (t2.meshes) for (const e2 of t2.meshes) e2.indexArray.destroy(), e2.vertexArray.destroy(), e2.colorArray && e2.colorArray.destroy(), e2.normalArray && e2.normalArray.destroy(), e2.texcoordArray && e2.texcoordArray.destroy(), e2.featureArray && e2.featureArray.destroy();
          if (t2.children) for (const e2 of t2.children) ly(e2);
        }
        function uy(t2) {
          t2.pbrMetallicRoughness.baseColorTexture && t2.pbrMetallicRoughness.baseColorTexture.gfxTexture && t2.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), t2.pbrMetallicRoughness.metallicRoughnessTexture && t2.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && t2.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), t2.normalTexture && t2.normalTexture.gfxTexture && t2.normalTexture.gfxTexture.destroy(), t2.emissionTexture && t2.emissionTexture.gfxTexture && t2.emissionTexture.gfxTexture.destroy(), t2.occlusionTexture && t2.occlusionTexture.gfxTexture && t2.occlusionTexture.gfxTexture.destroy();
        }
        function cy(t2) {
          if (t2.meshes) for (const e2 of t2.meshes) e2.vertexBuffer && (e2.vertexBuffer.destroy(), e2.indexBuffer.destroy(), e2.normalBuffer && e2.normalBuffer.destroy(), e2.texcoordBuffer && e2.texcoordBuffer.destroy(), e2.colorBuffer && e2.colorBuffer.destroy(), e2.pbrBuffer && e2.pbrBuffer.destroy(), e2.segments.destroy(), e2.material && uy(e2.material));
          if (t2.children) for (const e2 of t2.children) cy(e2);
        }
        function hy(t2, e2) {
          const r2 = t2.json.bufferViews[e2.bufferView], n2 = xm[e2.componentType];
          return new n2(t2.buffers[r2.buffer], (e2.byteOffset || 0) + (r2.byteOffset || 0), e2.count * (r2.byteStride && r2.byteStride !== bm[e2.type] * n2.BYTES_PER_ELEMENT ? r2.byteStride / n2.BYTES_PER_ELEMENT : bm[e2.type]));
        }
        function py(t2, e2, r2, n2) {
          const i2 = xm[e2.componentType], s2 = function(t3) {
            switch (t3) {
              case Int8Array:
                return 1 / 127;
              case Uint8Array:
                return 1 / 255;
              case Int16Array:
                return 1 / 32767;
              case Uint16Array:
                return 1 / 65535;
              default:
                return 1;
            }
          }(i2), a2 = t2.json.bufferViews[e2.bufferView], o2 = a2.byteStride ? a2.byteStride / i2.BYTES_PER_ELEMENT : bm[e2.type], l2 = r2.float32, u2 = l2.length / r2.capacity;
          for (let t3 = 0, r3 = 0; t3 < e2.count * o2; t3 += o2, r3 += u2) for (let e3 = 0; e3 < u2; e3++) l2[r3 + e3] = n2[t3 + e3] * s2;
          r2._trim();
        }
        function dy(t2, e2, r2) {
          const n2 = t2.indices, i2 = t2.attributes, s2 = {};
          s2.indexArray = new ll();
          const a2 = e2.json.accessors[n2], o2 = a2.count / 3;
          s2.indexArray.reserve(o2);
          const l2 = hy(e2, a2);
          for (let t3 = 0; t3 < o2; t3++) s2.indexArray.emplaceBack(l2[3 * t3], l2[3 * t3 + 1], l2[3 * t3 + 2]);
          s2.indexArray._trim(), s2.vertexArray = new Wo();
          const u2 = e2.json.accessors[i2.POSITION];
          s2.vertexArray.reserve(u2.count);
          const c2 = hy(e2, u2);
          for (let t3 = 0; t3 < u2.count; t3++) s2.vertexArray.emplaceBack(c2[3 * t3], c2[3 * t3 + 1], c2[3 * t3 + 2]);
          if (s2.vertexArray._trim(), s2.aabb = new wc(u2.min, u2.max), s2.centroid = function(t3, e3) {
            const r3 = [0, 0, 0], n3 = t3.length;
            if (n3 > 0) {
              for (let i3 = 0; i3 < n3; i3++) {
                const n4 = 3 * t3[i3];
                r3[0] += e3[n4], r3[1] += e3[n4 + 1], r3[2] += e3[n4 + 2];
              }
              r3[0] /= n3, r3[1] /= n3, r3[2] /= n3;
            }
            return r3;
          }(l2, c2), void 0 !== i2.COLOR_0) {
            const t3 = e2.json.accessors[i2.COLOR_0], r3 = bm[t3.type], n3 = hy(e2, t3);
            s2.colorArray = 3 === r3 ? new Wo() : new el(), s2.colorArray.resize(t3.count), py(e2, t3, s2.colorArray, n3);
          }
          if (void 0 !== i2.NORMAL) {
            s2.normalArray = new Wo();
            const t3 = e2.json.accessors[i2.NORMAL];
            s2.normalArray.resize(t3.count);
            const r3 = hy(e2, t3);
            py(e2, t3, s2.normalArray, r3);
          }
          if (void 0 !== i2.TEXCOORD_0 && r2.length > 0) {
            s2.texcoordArray = new yl();
            const t3 = e2.json.accessors[i2.TEXCOORD_0];
            s2.texcoordArray.resize(t3.count);
            const r3 = hy(e2, t3);
            py(e2, t3, s2.texcoordArray, r3);
          }
          if (void 0 !== i2._FEATURE_ID_RGBA4444) {
            const t3 = e2.json.accessors[i2._FEATURE_ID_RGBA4444];
            e2.json.extensionsUsed && e2.json.extensionsUsed.includes("EXT_meshopt_compression") && (s2.featureData = hy(e2, t3));
          }
          void 0 !== i2._FEATURE_RGBA4444 && (s2.featureData = new Uint32Array(hy(e2, e2.json.accessors[i2._FEATURE_RGBA4444]).buffer));
          const h2 = t2.material;
          return s2.material = function(t3, e3) {
            const { emissiveFactor: r3 = [0, 0, 0], alphaMode: n3 = "OPAQUE", alphaCutoff: i3 = 0.5, normalTexture: s3, occlusionTexture: a3, emissiveTexture: o3, doubleSided: l3, name: u3 } = t3, { baseColorFactor: c3 = [1, 1, 1, 1], metallicFactor: h3 = 1, roughnessFactor: p2 = 1, baseColorTexture: d2, metallicRoughnessTexture: f2 } = t3.pbrMetallicRoughness || {}, m2 = a3 ? e3[a3.index] : void 0;
            if (a3 && a3.extensions && a3.extensions.KHR_texture_transform && m2) {
              const t4 = a3.extensions.KHR_texture_transform;
              m2.offsetScale = [t4.offset[0], t4.offset[1], t4.scale[0], t4.scale[1]];
            }
            return { name: u3, pbrMetallicRoughness: { baseColorFactor: new ur(...c3), metallicFactor: h3, roughnessFactor: p2, baseColorTexture: d2 ? e3[d2.index] : void 0, metallicRoughnessTexture: f2 ? e3[f2.index] : void 0 }, doubleSided: l3, emissiveFactor: new ur(...r3), alphaMode: n3, alphaCutoff: i3, normalTexture: s3 ? e3[s3.index] : void 0, occlusionTexture: m2, emissionTexture: o3 ? e3[o3.index] : void 0, defined: void 0 === t3.defined };
          }(void 0 !== h2 ? e2.json.materials[h2] : { defined: false }, r2), s2;
        }
        function fy(t2, e2, r2) {
          const { matrix: n2, rotation: i2, translation: s2, scale: a2, mesh: o2, extras: u2, children: c2, name: h2 } = t2, p2 = {};
          if (p2.name = h2, p2.localMatrix = n2 || function(t3, e3, r3, n3) {
            var i3 = e3[0], s3 = e3[1], a3 = e3[2], o3 = e3[3], l2 = i3 + i3, u3 = s3 + s3, c3 = a3 + a3, h3 = i3 * l2, p3 = i3 * u3, d2 = i3 * c3, f2 = s3 * u3, m2 = s3 * c3, y2 = a3 * c3, g2 = o3 * l2, x2 = o3 * u3, v2 = o3 * c3, b2 = n3[0], w2 = n3[1], _2 = n3[2];
            return t3[0] = (1 - (f2 + y2)) * b2, t3[1] = (p3 + v2) * b2, t3[2] = (d2 - x2) * b2, t3[3] = 0, t3[4] = (p3 - v2) * w2, t3[5] = (1 - (h3 + y2)) * w2, t3[6] = (m2 + g2) * w2, t3[7] = 0, t3[8] = (d2 + x2) * _2, t3[9] = (m2 - g2) * _2, t3[10] = (1 - (h3 + f2)) * _2, t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
          }([], i2 || [0, 0, 0, 1], s2 || [0, 0, 0], a2 || [1, 1, 1]), p2.globalMatrix = l(p2.localMatrix), void 0 !== o2) {
            p2.meshes = r2[o2];
            const t3 = p2.anchor = [0, 0];
            for (const e3 of p2.meshes) {
              const { min: r3, max: n3 } = e3.aabb;
              t3[0] += r3[0] + n3[0], t3[1] += r3[1] + n3[1];
            }
            t3[0] = Math.floor(t3[0] / p2.meshes.length / 2), t3[1] = Math.floor(t3[1] / p2.meshes.length / 2);
          }
          if (u2 && (u2.id && (p2.id = u2.id), u2.lights && (p2.lights = function(t3) {
            if (!t3.length) return [];
            const e3 = function(t4) {
              const e4 = atob(t4), r4 = new Uint8Array(e4.length);
              for (let t5 = 0; t5 < e4.length; t5++) r4[t5] = e4.codePointAt(t5);
              return r4;
            }(t3), r3 = [], n3 = e3.length / 24, i3 = new Uint16Array(e3.buffer), s3 = new Float32Array(e3.buffer);
            for (let t4 = 0; t4 < n3; t4++) {
              const e4 = i3[2 * t4 * 6] / 30, n4 = i3[2 * t4 * 6 + 1] / 30, a3 = i3[2 * t4 * 6 + 10] / 100, o3 = s3[6 * t4 + 1], l2 = s3[6 * t4 + 2], u3 = s3[6 * t4 + 3], c3 = s3[6 * t4 + 4], h3 = u3 - o3, p3 = c3 - l2, d2 = Math.hypot(h3, p3);
              r3.push({ pos: [o3 + 0.5 * h3, l2 + 0.5 * p3, n4], normal: [p3 / d2, -h3 / d2, 0], width: d2, height: e4, depth: a3, points: [o3, l2, u3, c3] });
            }
            return r3;
          }(u2.lights)), u2.MAPBOX_geometry_bloom && (p2.isGeometryBloom = u2.MAPBOX_geometry_bloom)), c2) {
            const t3 = [];
            for (const n3 of c2) t3.push(fy(e2.json.nodes[n3], e2, r2));
            p2.children = t3;
          }
          return p2;
        }
        function my(t2) {
          if (0 === t2.vertices.length || 0 === t2.indices.length) return null;
          const e2 = new Md(t2.vertices, t2.indices, 8, 256), [r2, n2] = [e2.min.clone(), e2.max.clone()];
          return { vertices: t2.vertices, indices: t2.indices, grid: e2, min: r2, max: n2 };
        }
        function yy(t2) {
          if (!t2.extras || !t2.extras.ground) return null;
          const e2 = t2.extras.ground;
          if (!e2 || !Array.isArray(e2) || 0 === e2.length) return null;
          const r2 = e2[0];
          if (!r2 || !Array.isArray(r2) || 0 === r2.length) return null;
          const n2 = [];
          for (const t3 of r2) {
            if (!Array.isArray(t3) || 2 !== t3.length) continue;
            const e3 = t3[0], r3 = t3[1];
            "number" == typeof e3 && "number" == typeof r3 && n2.push(new It(e3, r3));
          }
          if (n2.length < 3) return null;
          n2.length > 1 && n2[n2.length - 1].equals(n2[0]) && n2.pop();
          let i2 = 0;
          for (let t3 = 0; t3 < n2.length; t3++) {
            const e3 = n2[t3], r3 = n2[(t3 + 1) % n2.length], s3 = n2[(t3 + 2) % n2.length];
            i2 += (e3.x - r3.x) * (s3.y - r3.y) - (s3.x - r3.x) * (e3.y - r3.y);
          }
          i2 > 0 && n2.reverse();
          const s2 = Qh(n2.flatMap((t3) => [t3.x, t3.y]), []);
          return 0 === s2.length ? null : { vertices: n2, indices: s2 };
        }
        function gy(t2, e2) {
          const r2 = [], n2 = [];
          let i2 = 0;
          const s2 = [];
          for (const a2 of t2) {
            i2 = r2.length;
            const t3 = a2.vertexArray.float32, o2 = a2.indexArray.uint16;
            for (let n3 = 0; n3 < a2.vertexArray.length; n3++) s2[0] = t3[3 * n3 + 0], s2[1] = t3[3 * n3 + 1], s2[2] = t3[3 * n3 + 2], j(s2, s2, e2), r2.push(new It(s2[0], s2[1]));
            for (let t4 = 0; t4 < 3 * a2.indexArray.length; t4++) n2.push(o2[t4] + i2);
          }
          if (n2.length % 3 != 0) return null;
          for (let t3 = 0; t3 < n2.length; t3 += 3) {
            const e3 = r2[n2[t3 + 0]], i3 = r2[n2[t3 + 1]], s3 = r2[n2[t3 + 2]];
            (e3.x - i3.x) * (s3.y - i3.y) - (s3.x - i3.x) * (e3.y - i3.y) > 0 && ([n2[t3 + 1], n2[t3 + 2]] = [n2[t3 + 2], n2[t3 + 1]]);
          }
          return { vertices: r2, indices: n2 };
        }
        function xy(t2) {
          const e2 = function(t3, e3) {
            const r3 = [], n3 = WebGL2RenderingContext;
            if (t3.json.textures) for (const i3 of t3.json.textures) {
              const s3 = { magFilter: n3.LINEAR, minFilter: n3.NEAREST, wrapS: n3.REPEAT, wrapT: n3.REPEAT };
              void 0 !== i3.sampler && Object.assign(s3, t3.json.samplers[i3.sampler]), r3.push({ image: e3[i3.source], sampler: s3, uploaded: false });
            }
            return r3;
          }(t2, t2.images), r2 = function(t3, e3) {
            const r3 = [];
            for (const n3 of t3.json.meshes) {
              const i3 = [];
              for (const r4 of n3.primitives) i3.push(dy(r4, t3, e3));
              r3.push(i3);
            }
            return r3;
          }(t2, e2), { scenes: n2, scene: i2, nodes: s2 } = t2.json, a2 = n2 ? n2[i2 || 0].nodes : [...s2.keys()], o2 = [];
          for (const e3 of a2) o2.push(fy(s2[e3], t2, r2));
          return function(t3, e3, r3) {
            const n3 = {}, i3 = /* @__PURE__ */ new Set();
            for (let s3 = 0; s3 < t3.length; s3++) {
              const t4 = r3[e3[s3]];
              if (!t4.extras) continue;
              const a3 = t4.extras["mapbox:footprint:version"], o3 = t4.extras["mapbox:footprint:id"];
              (a3 || o3) && i3.add(s3), "1.0.0" === a3 && o3 && (n3[o3] = s3);
            }
            for (let s3 = 0; s3 < t3.length; s3++) {
              if (i3.has(s3)) continue;
              const a3 = t3[s3], o3 = r3[e3[s3]];
              if (!o3.extras) continue;
              let l2 = null;
              a3.id in n3 && (l2 = gy(t3[n3[a3.id]].meshes, a3.localMatrix)), l2 || (l2 = yy(o3)), l2 && (a3.footprint = my(l2));
            }
            if (i3.size > 0) {
              const e4 = Array.from(i3.values()).sort((t4, e5) => t4 - e5);
              for (let r4 = e4.length - 1; r4 >= 0; r4--) t3.splice(e4[r4], 1);
            }
          }(o2, a2, t2.json.nodes), o2;
        }
        function vy(t2) {
          t2.heightmap = new Float32Array(4096), t2.heightmap.fill(-1);
          const e2 = t2.vertexArray.float32, r2 = t2.aabb.min[0] - 1, n2 = t2.aabb.min[1] - 1, i2 = ey / (t2.aabb.max[0] - r2 + 2), s2 = ey / (t2.aabb.max[1] - n2 + 2);
          for (let a2 = 0; a2 < e2.length; a2 += 3) {
            const o2 = e2[a2 + 2], l2 = (e2[a2 + 0] - r2) * i2 | 0, u2 = (e2[a2 + 1] - n2) * s2 | 0;
            o2 > t2.heightmap[u2 * ey + l2] && (t2.heightmap[u2 * ey + l2] = o2);
          }
        }
        function by(t2, e2, r2, n2, i2) {
          r2.reserve(r2.length + 4 * t2.length), n2.reserve(n2.length + 10 * t2.length), i2.reserve(i2.length + 10 * t2.length);
          let s2 = n2.length;
          for (const a2 of t2) {
            const t3 = Math.min(10, Math.max(4, 1.3 * a2.height)) * e2, o2 = [-a2.normal[1], a2.normal[0], 0], l2 = Math.min(0.29, 0.1 * a2.width / a2.depth), u2 = a2.width - 2 * a2.depth * e2 * (l2 + 0.01), c2 = E([], a2.pos, o2, u2 / 2), h2 = E([], a2.pos, o2, -u2 / 2), p2 = [c2[0], c2[1], c2[2] + a2.height], d2 = [h2[0], h2[1], h2[2] + a2.height], f2 = E([], a2.normal, o2, l2);
            V(f2, f2, t3);
            const m2 = E([], a2.normal, o2, -l2);
            V(m2, m2, t3), P(f2, c2, f2), P(m2, h2, m2), c2[2] += 0.1, h2[2] += 0.1, n2.emplaceBack(f2[0], f2[1], f2[2]), n2.emplaceBack(m2[0], m2[1], m2[2]), n2.emplaceBack(c2[0], c2[1], c2[2]), n2.emplaceBack(h2[0], h2[1], h2[2]), n2.emplaceBack(p2[0], p2[1], p2[2]), n2.emplaceBack(d2[0], d2[1], d2[2]), n2.emplaceBack(c2[0], c2[1], c2[2]), n2.emplaceBack(h2[0], h2[1], h2[2]), n2.emplaceBack(f2[0], f2[1], f2[2]), n2.emplaceBack(m2[0], m2[1], m2[2]);
            const y2 = u2 / t3 / 2;
            i2.emplaceBack(-y2 - l2, -1, y2, 0.8), i2.emplaceBack(y2 + l2, -1, y2, 0.8), i2.emplaceBack(-y2, 0, y2, 1.3), i2.emplaceBack(y2, 0, y2, 1.3), i2.emplaceBack(y2 + l2, -0.8, y2, 0.7), i2.emplaceBack(y2 + l2, -0.8, y2, 0.7), i2.emplaceBack(0, 0, y2, 1.3), i2.emplaceBack(0, 0, y2, 1.3), i2.emplaceBack(y2 + l2, -1.2, y2, 0.8), i2.emplaceBack(y2 + l2, -1.2, y2, 0.8), r2.emplaceBack(6 + s2, 4 + s2, 8 + s2), r2.emplaceBack(7 + s2, 9 + s2, 5 + s2), r2.emplaceBack(0 + s2, 1 + s2, 2 + s2), r2.emplaceBack(1 + s2, 3 + s2, 2 + s2), s2 += 10;
          }
        }
        function wy(t2, e2) {
          const r2 = {};
          r2.indexArray = new ll(), r2.vertexArray = new Wo(), r2.colorArray = new el(), by(t2, e2, r2.indexArray, r2.vertexArray, r2.colorArray);
          const n2 = { defined: true };
          n2.emissiveFactor = ur.black;
          const i2 = {};
          return i2.baseColorFactor = ur.white, n2.pbrMetallicRoughness = i2, r2.material = n2, r2.aabb = new wc([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r2;
        }
        const _y = Oo([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Ay = Oo([{ name: "a_normal_3", components: 3, type: "Int16" }]), My = Oo([{ name: "a_centroid_3", components: 3, type: "Int16" }]), Iy = Oo([{ name: "a_part_color_emissive", components: 2, type: "Uint16" }]), Sy = Oo([{ name: "a_faux_facade_color_emissive", components: 2, type: "Uint16" }]), Py = Oo([{ name: "a_faux_facade_data", components: 4, type: "Uint16" }]), zy = Oo([{ name: "a_faux_facade_vertical_range", components: 2, type: "Uint16" }]), By = Oo([{ name: "a_bloom_attenuation", components: 4, type: "Float32" }]), ky = Oo([{ name: "a_flood_light_wall_radius_1i16", components: 1, type: "Uint16" }]), Ty = Qu.types, Vy = 32767;
        function Ey(t2, e2) {
          const r2 = jn + e2;
          for (const n2 of t2) for (const t3 of n2) if (t3.x < -e2 || t3.x > r2 || t3.y < -e2 || t3.y > r2) return false;
          return true;
        }
        function Fy(t2) {
          switch (t2) {
            case "flat":
              return 3;
            case "hipped":
              return 1;
            case "gabled":
              return 2;
            case "parapet":
              return 0;
            case "mansard":
              return 4;
            case "skillion":
              return 5;
            case "pyramidal":
              return 6;
            default:
              throw new Error(`Unknown roof shape: ${t2}`);
          }
        }
        class Dy {
          constructor() {
            this.layoutVertexArray = new Wo(), this.layoutAttenuationArray = new el(), this.layoutColorArray = new nl(), this.indexArray = new ll(), this.indexArrayForConflation = new ll(), this.segmentsBucket = new Ol();
          }
        }
        class Cy {
          constructor(t2) {
            this.layoutFacadePaintArray = null, this.layoutFacadeDataArray = null, this.layoutFacadeVerticalRangeArray = null, this.segmentsBucket = new Ol(), this.entranceBloom = new Dy();
            const e2 = 66560;
            this.layoutVertexArray = new Wo(), this.layoutVertexArray.reserve(e2), this.layoutNormalArray = new jo(), this.layoutNormalArray.reserve(e2), this.layoutCentroidArray = new jo(), this.layoutCentroidArray.reserve(e2), this.layoutColorArray = new nl(), this.layoutColorArray.reserve(e2), this.layoutFloodLightDataArray = new xl(), this.layoutFloodLightDataArray.reserve(e2), this.layoutAOArray = new _l(), this.layoutAOArray.reserve(e2), this.indexArray = new ll(), this.indexArray.reserve(66560), this.indexArrayForConflation = new ll(), this.segmentsBucket = new Ol(), this.entranceBloom = new Dy(), t2 && (this.layoutFacadePaintArray = new nl(), this.layoutFacadeDataArray = new Jo(), this.layoutFacadeVerticalRangeArray = new nl());
          }
          reserve(t2, e2, r2) {
            this.layoutVertexArray.reserveForAdditional(t2), this.layoutCentroidArray.reserveForAdditional(t2), this.layoutFloodLightDataArray.reserveForAdditional(t2), this.layoutNormalArray.reserveForAdditional(t2), this.layoutAOArray.reserveForAdditional(t2), this.layoutColorArray.reserveForAdditional(t2), this.indexArray.reserveForAdditional(e2), r2 && (this.layoutFacadePaintArray.reserveForAdditional(t2), this.layoutFacadeDataArray.reserveForAdditional(t2), this.layoutFacadeVerticalRangeArray.reserveForAdditional(t2));
          }
        }
        class Ry {
          constructor(t2) {
            this.colorBufferUploaded = false, this.maxHeight = 0, this.replacementUpdateTime = 0, this.activeReplacements = [], this.footprints = [], this.footprintsVertices = new yl(), this.footprintsIndices = new xl(), this.footprintsMin = new It(1 / 0, 1 / 0), this.footprintsMax = new It(-1 / 0, -1 / 0), this.featuresOnBorder = [], this.buildingWithoutFacade = new Cy(false), this.buildingWithFacade = new Cy(true), this.indexArrayForConflationUploaded = false, this.featureFootprintLookup = /* @__PURE__ */ new Map(), this.buildingIds = /* @__PURE__ */ new Set(), this.footprintLookup = {}, this.zoom = t2.zoom, this.canonical = t2.canonical, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.worldview = t2.worldview, this.lut = t2.lut, this.programConfigurations = new fu(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection, this.groundEffect = new ff(t2), this.groundEffect.groundRadiusArray = new $o(), this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
            const r2 = new Md([], [], 1), n2 = { vertices: [], indices: new Uint32Array(0), grid: r2, min: this.footprintsMin, max: this.footprintsMax, buildingIds: this.buildingIds };
            e2.push({ footprint: n2, id: t2 });
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          prepare() {
            return function() {
              if (null != lm || null != om) return null;
              if (null != am) return am;
              const t2 = fetch(oe.BUILDING_GEN_URL);
              return am = function(t3) {
                let e2, r2, n2, i2, s2;
                function a2() {
                  e2 = new Uint8Array(s2.buffer), r2 = new Int16Array(s2.buffer), n2 = new Int32Array(s2.buffer), i2 = new Float32Array(s2.buffer);
                }
                function o2() {
                  throw new Error("Unexpected BuildingGen error.");
                }
                const l2 = () => {
                }, u2 = { a: { a: o2, f: function(t4) {
                  const r3 = e2.length, n3 = Math.max(t4 >>> 0, Math.ceil(1.2 * r3)), i3 = Math.ceil((n3 - r3) / 65536);
                  try {
                    return s2.grow(i3), a2(), true;
                  } catch (t5) {
                    return false;
                  }
                }, g: o2, b: l2, c: l2, d: l2, e: l2 } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t3, u2) : t3.then((t4) => t4.arrayBuffer()).then((t4) => WebAssembly.instantiate(t4, u2))).then((t4) => {
                  const o3 = t4.instance.exports;
                  return (0, o3.g)(), s2 = o3.f, a2(), new Qf({ setStyle: o3.h, setAOOptions: o3.i, setMetricOptions: o3.j, setStructuralOptions: o3.k, setFacadeOptions: o3.l, setFauxFacadeOptions: o3.m, setFacadeClassifierOptions: o3.n, addFeature: o3.o, addFacade: o3.p, generateMesh: o3.q, getLastError: o3.r, getOuterRingLength: o3.s, getMeshCount: o3.t, getPositionsPtr: o3.u, getPositionsLength: o3.v, getNormalsPtr: o3.w, getNormalsLength: o3.x, getAOPtr: o3.y, getAOLength: o3.z, getUVPtr: o3.A, getUVLength: o3.B, getFauxFacadePtr: o3.C, getFauxFacadeLength: o3.D, getIndicesPtr: o3.E, getIndicesLength: o3.F, getBuildingPart: o3.G, getRingCount: o3.H, getRingPtr: o3.I, getRingLength: o3.J, malloc: o3.K, free: o3.L, heapU8: e2, heap16: r2, heap32: n2, heapF32: i2 });
                });
              }(t2).then((t3) => (am = null, lm = t3, lm)).catch((t3) => {
                Zt("Could not load building-gen"), am = null, om = t3;
              }), am;
            }();
          }
          populate(t2, e2, r2, n2) {
            const i2 = hm();
            if (!i2) return;
            const s2 = ju(r2);
            this.tileToMeter = s2, this.brightness = e2.brightness, i2.setStyle({ normalScale: [1, -1, s2], tileToMeters: s2 }), i2.setAOOptions(false, 0.3), i2.setMetricOptions(false, 16), i2.setStructuralOptions(true), i2.setFacadeClassifierOptions(3);
            const a2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Map();
            let l2 = 0;
            for (const { feature: e3 } of t2) {
              if ("LineString" !== Ty[e3.type]) {
                a2.set(e3.id, e3.properties.source_id);
                continue;
              }
              const t3 = this.layers[0]._featureFilter.needGeometry;
              if (t3 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), e3, r2)) continue;
              const i3 = Ku(e3, t3);
              if (!t3 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), i3, r2)) continue;
              const s3 = t3 ? i3.geometry : Ju(e3, r2, n2), u3 = [];
              for (const t4 of s3) for (const e4 of t4) u3.push(e4.x), u3.push(e4.y);
              const c3 = { coordinates: u3, crossPerc: e3.properties.cross_perc, distanceToRoad: e3.properties.distance_to_road, entrances: e3.properties.entrances, sourceId: 0 }, h3 = e3.properties.source_id;
              let p3 = o2.get(h3);
              p3 || (p3 = [], o2.set(h3, p3)), p3.push(c3), ++l2;
            }
            this.maxHeight = 0;
            const u2 = new Array(), c2 = /* @__PURE__ */ new Set(), h2 = (t3) => {
              null != t3 && c2.add(t3);
            }, p2 = (t3, e3) => {
              null != t3 && u2.push({ buildingId: t3, footprintIndex: e3 });
            }, d2 = 64 * (t2.length - l2), f2 = d2 / 2;
            this.buildingWithFacade.reserve(d2, f2, true), this.buildingWithoutFacade.reserve(2 * d2, 2 * f2, false), this.footprintsIndices.reserve(16 * (t2.length - l2)), this.footprintsVertices.reserve(8 * (t2.length - l2));
            for (const { feature: l3, id: u3, index: d3, sourceLayerIndex: f3 } of t2) {
              if ("LineString" === Ty[l3.type]) continue;
              const t3 = this.layers[0]._featureFilter.needGeometry;
              if (t3 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), l3, r2)) continue;
              let m3 = null;
              if (l3.properties && l3.properties.hasOwnProperty("building_id") && (m3 = Number(l3.properties.building_id), c2.has(m3))) continue;
              const y2 = Ku(l3, t3);
              if (!t3 && !this.layers[0]._featureFilter.filter(new Ja(this.zoom), y2, r2)) continue;
              const g2 = t3 ? y2.geometry : Ju(l3, r2, n2), x2 = Ip(g2, 500);
              let v2 = false;
              for (const t4 of x2) if (1 !== t4.length) {
                v2 = true;
                break;
              }
              if (v2) {
                h2(m3);
                continue;
              }
              if (!Ey(g2, 163)) {
                h2(m3);
                continue;
              }
              const b2 = this.layers[0], w2 = Fy(b2.layout.get("building-roof-shape").evaluate(l3, {}, r2)), _2 = b2.layout.get("building-base").evaluate(l3, {}, r2), A2 = b2.layout.get("building-height").evaluate(l3, {}, r2), M2 = b2.layout.get("building-flood-light-ground-radius").evaluate(l3, {}, r2), I2 = b2.paint.get("building-ambient-occlusion-intensity"), S2 = M2 / this.tileToMeter;
              l3.properties["building-part"] = "roof";
              const P2 = b2.paint.get("building-color").evaluate(l3, {}, this.canonical).toPremultipliedRenderColor(this.lut), z2 = b2.paint.get("building-emissive-strength").evaluate(l3, {}, this.canonical);
              l3.properties["building-part"] = "wall";
              const B2 = b2.paint.get("building-color").evaluate(l3, {}, this.canonical).toPremultipliedRenderColor(this.lut), k2 = b2.paint.get("building-emissive-strength").evaluate(l3, {}, this.canonical);
              l3.properties["building-part"] = "window";
              const T2 = b2.paint.get("building-color").evaluate(l3, {}, this.canonical).toPremultipliedRenderColor(this.lut), V2 = b2.paint.get("building-emissive-strength").evaluate(l3, {}, this.canonical);
              l3.properties["building-part"] = "door";
              const E2 = b2.paint.get("building-color").evaluate(l3, {}, this.canonical).toPremultipliedRenderColor(this.lut), F2 = b2.paint.get("building-emissive-strength").evaluate(l3, {}, this.canonical);
              let D2 = b2.layout.get("building-flood-light-wall-radius").evaluate(l3, {}, r2);
              D2 = Dt(D2, 0, 2048);
              const C2 = D2 / 2048 * Vy, R2 = a2.get(u3), L2 = o2.get(R2) || [], O2 = 0 !== L2.length && b2.layout.get("building-facade").evaluate(l3, {}, r2);
              i2.setFacadeOptions(4, true), i2.setFauxFacadeOptions(O2, false, 1);
              let U2 = 0, N2 = 0, j2 = 0, G2 = 0, $2 = 0, q2 = 0, X2 = 0, H2 = 0, Z2 = 0, W2 = 0, Y2 = 0;
              if (O2) {
                let t4 = Math.round(b2.layout.get("building-facade-floors").evaluate(l3, {}, r2));
                if (0 === _2) {
                  t4 = Math.max(1, t4 - (L2.length > 0 ? 1 : 0));
                  let e4 = 4;
                  if (A2 > 100) {
                    const t5 = [10, 13, 15];
                    e4 = t5[l3.id ? l3.id % t5.length : 0];
                  } else A2 <= 10 && (e4 = 3);
                  i2.setFacadeOptions(e4, true), $2 = (A2 < 15 ? 1.3 : 1.61803) * e4 / s2;
                } else $2 = _2 / s2;
                q2 = A2 / s2, $2 = Math.min($2, q2), j2 = b2.layout.get("building-facade-unit-width").evaluate(l3, {}, r2) / s2, G2 = (q2 - $2) / t4, i2.setFauxFacadeOptions(true, true, j2);
                const e3 = b2.layout.get("building-facade-window").evaluate(l3, {}, r2);
                U2 = e3[0], N2 = e3[1], X2 = Math.floor(65535 * Math.min(1, $2 / jn)), H2 = Math.floor(65535 * Math.min(1, q2 / jn)), Z2 = Math.floor(255 * U2) << 8 | Math.floor(255 * N2), W2 = Math.floor(65535 * Math.min(1, j2 / jn)), Y2 = Math.floor(65535 * Math.min(1, G2 / jn));
              }
              const J2 = Array(x2.length), K2 = { x: 1 / 0, y: 1 / 0 }, Q2 = { x: -1 / 0, y: -1 / 0 }, tt2 = { x: 0, y: 0 };
              let et2 = 0;
              for (let t4 = 0; t4 < x2.length; t4++) {
                const e3 = x2[t4];
                if (e3.length > 0) {
                  const r3 = [], n3 = Array(e3.length + 1);
                  n3[0] = 0;
                  for (let t5 = 0; t5 < e3.length; t5++) {
                    const i3 = e3[t5];
                    for (let t6 = 0; t6 < i3.length; t6++) {
                      const e4 = i3[i3.length - t6 - 1];
                      K2.x = Math.min(K2.x, e4.x), K2.y = Math.min(K2.y, e4.y), Q2.x = Math.max(Q2.x, e4.x), Q2.y = Math.max(Q2.y, e4.y), tt2.x += e4.x, tt2.y += e4.y, et2++, r3.push(e4.x), r3.push(e4.y);
                    }
                    n3[t5 + 1] = r3.length;
                  }
                  J2[t4] = { id: l3.id ? l3.id : 0, height: A2, minHeight: _2, sourceId: 0, roofType: w2, coordinates: r3, ringIndices: n3 };
                }
              }
              tt2.x /= et2 || 1, tt2.y /= et2 || 1;
              const rt2 = i2.generateMesh(J2, L2);
              if ("string" == typeof rt2) {
                Zt(`Unable to generate building ${l3.id}: ${rt2}`), h2(m3);
                continue;
              }
              if (0 === rt2.meshes.length || 0 === rt2.modifiedPolygonRings.length) {
                h2(m3);
                continue;
              }
              const nt2 = O2 ? this.buildingWithFacade : this.buildingWithoutFacade;
              let it2 = 0;
              for (const t4 of rt2.meshes) it2 += t4.positions.length / 3;
              const st2 = nt2.segmentsBucket.prepareSegment(it2, nt2.layoutVertexArray, nt2.indexArray), at2 = [];
              let ot2 = null, lt2 = 0, ut2 = -1;
              const ct2 = nt2.layoutVertexArray.length, ht2 = ct2 + it2;
              nt2.layoutVertexArray.resize(ht2), nt2.layoutCentroidArray.resize(ht2), nt2.layoutNormalArray.resize(ht2), nt2.layoutAOArray.resize(ht2), nt2.layoutColorArray.resize(ht2), nt2.layoutFloodLightDataArray.resize(ht2), O2 && (nt2.layoutFacadePaintArray.resize(ht2), nt2.layoutFacadeDataArray.resize(ht2), nt2.layoutFacadeVerticalRangeArray.resize(ht2));
              const pt2 = nt2.indexArray.length;
              let dt2 = 0, ft2 = ct2;
              for (const t4 of rt2.meshes) {
                let e3, r3;
                if (1 === t4.buildingPart) e3 = P2, r3 = z2;
                else if (0 === t4.buildingPart) e3 = B2, r3 = k2;
                else if (2 === t4.buildingPart) e3 = T2, r3 = V2;
                else {
                  if (3 !== t4.buildingPart) continue;
                  e3 = E2, r3 = F2;
                }
                if (r3 = Dt(r3, 0, 1), 3 === t4.buildingPart) {
                  const e4 = new Array();
                  for (let r5 = 0; r5 < t4.positions.length; r5 += 12) {
                    const n5 = t4.positions[r5 + 0], i5 = t4.positions[r5 + 1], s4 = t4.positions[r5 + 3], a4 = t4.positions[r5 + 4], o4 = t4.positions[r5 + 2], l5 = t4.positions[r5 + 8] - o4, u5 = 1, c3 = s4 - n5, h3 = a4 - i5, p3 = Math.hypot(c3, h3);
                    e4.push({ pos: [n5 + 0.5 * c3, i5 + 0.5 * h3, o4], normal: [h3 / p3, -c3 / p3, 0], width: p3, height: l5, depth: u5, points: [n5, i5, s4, a4] });
                  }
                  const r4 = nt2.entranceBloom.segmentsBucket.prepareSegment(10 * e4.length, nt2.entranceBloom.layoutVertexArray, nt2.entranceBloom.indexArray), n4 = nt2.entranceBloom.layoutVertexArray.length;
                  lt2 = nt2.entranceBloom.indexArray.length, by(e4, 0.5 / this.tileToMeter, nt2.entranceBloom.indexArray, nt2.entranceBloom.layoutVertexArray, nt2.entranceBloom.layoutAttenuationArray);
                  const i4 = nt2.entranceBloom.layoutVertexArray.length - n4;
                  ut2 = nt2.entranceBloom.indexArray.length - lt2;
                  for (let t5 = 0; t5 < i4; t5++) nt2.entranceBloom.layoutColorArray.emplaceBack(255 * E2.r << 8 | 255 * E2.g, 255 * E2.b << 8 | 51 * F2);
                  r4.vertexLength += i4, r4.primitiveLength += ut2, ot2 = { part: t4.buildingPart, vertexOffset: n4, vertexLength: i4 };
                }
                nt2.layoutVertexArray.float32.set(t4.positions, 3 * ft2);
                const n3 = t4.positions.length / 3;
                for (let i4 = 0; i4 < n3; ++i4) {
                  const n4 = 3 * i4;
                  dt2 = Math.max(dt2, t4.positions[n4 + 2]);
                  const s4 = t4.normals[n4 + 1] * Vy, a4 = t4.normals[n4 + 2] * Vy, o4 = 3 * (ft2 + i4);
                  nt2.layoutNormalArray.int16[o4] = t4.normals[n4] * Vy, nt2.layoutNormalArray.int16[o4 + 1] = s4, nt2.layoutNormalArray.int16[o4 + 2] = a4;
                  const l5 = t4.ao[i4];
                  nt2.layoutAOArray.uint8[ft2 + i4] = 255 * l5;
                  const u5 = 1 + (l5 - 1) * I2, c3 = 255 * e3.b * u5 << 8 | 255 * r3;
                  nt2.layoutColorArray.uint16[2 * (ft2 + i4)] = 255 * e3.r * u5 << 8 | 255 * e3.g * u5, nt2.layoutColorArray.uint16[2 * (ft2 + i4) + 1] = c3;
                }
                const i3 = Math.floor(tt2.x), s3 = Math.floor(tt2.y), a3 = Math.floor(A2);
                for (let t5 = 0; t5 < n3; ++t5) {
                  const e4 = 3 * (ft2 + t5);
                  nt2.layoutCentroidArray.int16[e4] = i3, nt2.layoutCentroidArray.int16[e4 + 1] = s3, nt2.layoutCentroidArray.int16[e4 + 2] = a3;
                }
                if (nt2.layoutFloodLightDataArray.uint16.fill(0 === t4.buildingPart ? C2 : 0, ft2, ft2 + n3), O2) {
                  const e4 = 255 * T2.r << 8 | 255 * T2.g, r4 = 255 * T2.b << 8 | 255 * V2;
                  for (let t5 = 0; t5 < n3; ++t5) {
                    const n4 = 2 * (ft2 + t5);
                    nt2.layoutFacadePaintArray.uint16[n4] = e4, nt2.layoutFacadePaintArray.uint16[n4 + 1] = r4;
                  }
                  for (let e5 = 0; e5 < n3; ++e5) if (t4.isFauxFacade[e5]) {
                    const r5 = Math.min(65535, Math.floor(t4.uv[2 * e5] * rt2.outerRingLength));
                    nt2.layoutFacadeDataArray.emplace(ft2 + e5, 1 | r5, Z2, W2, Y2), nt2.layoutFacadeVerticalRangeArray.emplace(ft2 + e5, X2, H2);
                  } else nt2.layoutFacadeDataArray.emplace(ft2 + e5, 0, 0, 0, 0), nt2.layoutFacadeVerticalRangeArray.emplace(ft2 + e5, 0, 0);
                }
                const o3 = st2.vertexLength, l4 = t4.indices.length / 3, u4 = nt2.indexArray.length;
                nt2.indexArray.resize(u4 + l4);
                for (let e4 = 0; e4 < l4; ++e4) {
                  const r4 = 3 * e4, n4 = 3 * u4 + r4;
                  nt2.indexArray.uint16[n4] = o3 + t4.indices[r4], nt2.indexArray.uint16[n4 + 1] = o3 + t4.indices[r4 + 1], nt2.indexArray.uint16[n4 + 2] = o3 + t4.indices[r4 + 2];
                }
                1 !== t4.buildingPart && 0 !== t4.buildingPart && 2 !== t4.buildingPart && 3 !== t4.buildingPart || at2.push({ part: t4.buildingPart, vertexOffset: ft2, vertexLength: t4.positions.length / 3 }), ft2 += n3, st2.vertexLength += n3, st2.primitiveLength += t4.indices.length / 3;
              }
              this.maxHeight = Math.max(this.maxHeight, dt2);
              const mt2 = nt2.indexArray.length - pt2, yt2 = this.footprintsIndices.length, gt2 = this.footprintsVertices.length, xt2 = [], vt2 = new It(1 / 0, 1 / 0), bt2 = new It(-1 / 0, -1 / 0), wt2 = this.groundEffect.vertexArray.length;
              for (const t4 of rt2.modifiedPolygonRings) {
                const e3 = [], r3 = new It(1 / 0, 1 / 0), n3 = new It(-1 / 0, -1 / 0);
                for (let i3 = 0; i3 < t4.length; i3 += 2) {
                  const s3 = t4.length - i3 - 2;
                  r3.x = Math.min(r3.x, t4[s3]), r3.y = Math.min(r3.y, t4[s3 + 1]), n3.x = Math.max(n3.x, t4[s3]), n3.y = Math.max(n3.y, t4[s3 + 1]);
                  const a3 = new It(t4[s3], t4[s3 + 1]);
                  e3.push(a3), xt2.push(a3.x, a3.y), this.footprintsVertices.emplaceBack(a3.x, a3.y);
                }
                vt2.x = Math.min(vt2.x, r3.x), vt2.y = Math.min(vt2.y, r3.y), bt2.x = Math.max(bt2.x, n3.x), bt2.y = Math.max(bt2.y, n3.y), this.groundEffect.addData(e3, [r3, n3], S2);
              }
              const _t2 = this.groundEffect.vertexArray.length - wt2;
              this.groundEffect.groundRadiusArray.reserveForAdditional(_t2);
              for (let t4 = 0; t4 < _t2; t4++) this.groundEffect.groundRadiusArray.emplaceBack(M2);
              (K2.x < 0 || Q2.x > jn || K2.y < 0 || Q2.y > jn) && this.featuresOnBorder.push({ featureId: l3.id, footprintIndex: this.footprints.length });
              {
                const t4 = Qh(xt2, null, 2);
                this.footprintsIndices.resize(this.footprintsIndices.length + t4.length), this.footprintsIndices.uint16.set(t4, yt2), this.buildingIds.add(null != m3 ? m3 : l3.id), this.footprintsMin.x = Math.min(this.footprintsMin.x, vt2.x), this.footprintsMin.y = Math.min(this.footprintsMin.y, vt2.y), this.footprintsMax.x = Math.max(this.footprintsMax.x, bt2.x), this.footprintsMax.y = Math.max(this.footprintsMax.y, bt2.y);
                const e3 = { footprintVertexOffset: gt2, footprintVertexLength: this.footprintsVertices.length - gt2, footprintIndexOffset: yt2, footprintIndexLength: this.footprintsIndices.length - yt2, min: vt2, max: bt2, hiddenFlags: 0, indicesOffset: pt2, indicesLength: mt2, bloomIndicesOffset: lt2, bloomIndicesLength: ut2, groundEffectVertexOffset: wt2, groundEffectVertexLength: _t2, hasFauxFacade: O2, height: dt2, promoteId: u3, feature: y2, parts: at2, buildingBloom: ot2 }, r3 = this.footprints.length;
                void 0 !== l3.id && this.featureFootprintLookup.set(l3.id, r3), p2(m3, r3), this.footprints.push(e3);
              }
              this.programConfigurations.populatePaintArrays(nt2.layoutVertexArray.length, l3, d3, {}, e2.availableImages, r2, e2.brightness), this.groundEffect.addPaintPropertiesData(l3, d3, {}, e2.availableImages, r2, e2.brightness), e2.featureIndex.insert(l3, g2, d3, f3, this.index, ct2);
            }
            u2.forEach(({ buildingId: t3, footprintIndex: e3 }) => {
              c2.has(t3) && (this.footprints[e3].hiddenFlags |= 4);
            });
            const m2 = /* @__PURE__ */ new Set();
            this.buildingIds.forEach((t3, e3, r3) => {
              c2.has(t3) || m2.add(t3);
            }), this.buildingIds = m2, this.groundEffect.prepareBorderSegments();
          }
          update(t2, e2, r2, n2, i2, s2, a2) {
            this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2), this.groundEffect.update(t2, e2, i2, r2, n2, s2, a2), this.evaluate(this.layers[0], t2), this.colorBufferUploaded = false;
          }
          isEmpty() {
            return 0 === this.buildingWithoutFacade.layoutVertexArray.length && 0 === this.buildingWithFacade.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
          }
          upload(t2) {
            const e2 = (e3) => {
              e3.layoutVertexBuffer = t2.createVertexBuffer(e3.layoutVertexArray, _y.members), e3.layoutNormalBuffer = t2.createVertexBuffer(e3.layoutNormalArray, Ay.members), e3.layoutCentroidBuffer = t2.createVertexBuffer(e3.layoutCentroidArray, My.members), e3.layoutFloodLightDataBuffer = t2.createVertexBuffer(e3.layoutFloodLightDataArray, ky.members), e3.layoutFacadeDataArray && e3.layoutFacadeDataArray.length && (e3.layoutFacadeDataBuffer = t2.createVertexBuffer(e3.layoutFacadeDataArray, Py.members)), e3.layoutFacadeVerticalRangeArray && e3.layoutFacadeVerticalRangeArray.length && (e3.layoutFacadeVerticalRangeBuffer = t2.createVertexBuffer(e3.layoutFacadeVerticalRangeArray, zy.members)), e3.entranceBloom.layoutVertexArray.length && (e3.entranceBloom.layoutVertexBuffer = t2.createVertexBuffer(e3.entranceBloom.layoutVertexArray, _y.members), e3.entranceBloom.layoutAttenuationBuffer = t2.createVertexBuffer(e3.entranceBloom.layoutAttenuationArray, By.members)), this.uploadUpdatedColorBuffer(t2), this.uploadUpdatedIndexBuffer(t2);
            };
            this.uploaded || (e2(this.buildingWithoutFacade), e2(this.buildingWithFacade), this.groundEffect.upload(t2)), this.groundEffect.uploadPaintProperties(t2), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            const t2 = (t3) => {
              t3.layoutVertexBuffer && (t3.layoutVertexBuffer.destroy(), t3.layoutNormalBuffer.destroy(), t3.layoutColorBuffer.destroy(), t3.segmentsBucket.destroy(), t3.indexBuffer && t3.indexBuffer.destroy(), t3.entranceBloom.layoutVertexBuffer && (t3.entranceBloom.layoutVertexBuffer.destroy(), t3.entranceBloom.layoutColorBuffer.destroy(), t3.entranceBloom.layoutAttenuationBuffer.destroy(), t3.entranceBloom.indexBuffer.destroy(), t3.entranceBloom.segmentsBucket.destroy()));
            };
            t2(this.buildingWithoutFacade), t2(this.buildingWithFacade), this.groundEffect.destroy(), this.programConfigurations.destroy();
          }
          updateFootprintHiddenFlags(t2, e2, r2 = true) {
            let n2 = false;
            const i2 = r2 ? e2 : 0, s2 = 0 | (r2 ? -1 : ~e2);
            0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const e3 of t2) {
              const t3 = this.footprints[e3], r3 = t3.hiddenFlags & s2 | i2;
              t3.hiddenFlags !== r3 && (t3.hiddenFlags = r3, n2 = true, this.groundEffect.updateHiddenByLandmarkRange(t3.groundEffectVertexOffset, t3.groundEffectVertexLength, 0 !== t3.hiddenFlags));
            }
            return n2 && (this.indexArrayForConflationUploaded = false), n2;
          }
          uploadUpdatedIndexBuffer(t2) {
            if (this.groundEffect.uploadHiddenByLandmark(t2), this.indexArrayForConflationUploaded) return;
            const e2 = (t3) => {
              0 !== t3.indexArray.length && (t3.indexArrayForConflation.resize(t3.indexArray.length), t3.indexArrayForConflation.uint16.set(t3.indexArray.uint16), t3.entranceBloom.indexArrayForConflation.resize(t3.entranceBloom.indexArray.length), t3.entranceBloom.indexArrayForConflation.uint16.set(t3.entranceBloom.indexArray.uint16));
            };
            e2(this.buildingWithoutFacade), e2(this.buildingWithFacade);
            for (const t3 of this.footprints) {
              const e3 = t3.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade, r3 = t3.indicesOffset + t3.indicesLength;
              if (0 !== t3.hiddenFlags) {
                for (let n3 = t3.indicesOffset; n3 < r3; n3++) e3.indexArrayForConflation.uint16[3 * n3 + 0] = 0, e3.indexArrayForConflation.uint16[3 * n3 + 1] = 0, e3.indexArrayForConflation.uint16[3 * n3 + 2] = 0;
                const n2 = t3.bloomIndicesOffset + t3.bloomIndicesLength;
                for (let r4 = t3.bloomIndicesOffset; r4 < n2; r4++) e3.entranceBloom.indexArrayForConflation.uint16[3 * r4 + 0] = 0, e3.entranceBloom.indexArrayForConflation.uint16[3 * r4 + 1] = 0, e3.entranceBloom.indexArrayForConflation.uint16[3 * r4 + 2] = 0;
              }
            }
            const r2 = (e3) => {
              0 !== e3.indexArray.length && (e3.indexBuffer ? e3.indexBuffer.updateData(e3.indexArrayForConflation) : e3.indexBuffer = t2.createIndexBuffer(e3.indexArrayForConflation, true), e3.entranceBloom.indexBuffer ? e3.entranceBloom.indexBuffer.updateData(e3.entranceBloom.indexArrayForConflation) : e3.entranceBloom.indexBuffer = t2.createIndexBuffer(e3.entranceBloom.indexArrayForConflation, true));
            };
            r2(this.buildingWithoutFacade), r2(this.buildingWithFacade), this.indexArrayForConflationUploaded = true;
          }
          uploadUpdatedColorBuffer(t2) {
            const e2 = (e3) => {
              e3.layoutColorBuffer ? e3.layoutColorBuffer.updateData(e3.layoutColorArray) : e3.layoutColorBuffer = t2.createVertexBuffer(e3.layoutColorArray, Iy.members, true), e3.layoutFacadePaintArray && (e3.layoutFacadePaintBuffer ? e3.layoutFacadePaintBuffer.updateData(e3.layoutFacadePaintArray) : e3.layoutFacadePaintBuffer = t2.createVertexBuffer(e3.layoutFacadePaintArray, Sy.members, true)), e3.entranceBloom.layoutColorBuffer ? e3.entranceBloom.layoutColorBuffer.updateData(e3.entranceBloom.layoutColorArray) : e3.entranceBloom.layoutColorBuffer = t2.createVertexBuffer(e3.entranceBloom.layoutColorArray, Iy.members, true);
            };
            e2(this.buildingWithoutFacade), e2(this.buildingWithFacade), this.colorBufferUploaded = true;
          }
          evaluate(t2, e2) {
            const r2 = t2.paint.get("building-ambient-occlusion-intensity");
            for (const n2 of this.footprints) {
              if (4 & n2.hiddenFlags) continue;
              const i2 = e2[n2.promoteId], s2 = n2.feature;
              s2.properties["building-part"] = "roof";
              const a2 = t2.paint.get("building-color").evaluate(s2, i2, this.canonical).toPremultipliedRenderColor(this.lut), o2 = t2.paint.get("building-emissive-strength").evaluate(s2, i2, this.canonical);
              s2.properties["building-part"] = "wall";
              const l2 = t2.paint.get("building-color").evaluate(s2, i2, this.canonical).toPremultipliedRenderColor(this.lut), u2 = t2.paint.get("building-emissive-strength").evaluate(s2, i2, this.canonical);
              s2.properties["building-part"] = "window";
              const c2 = t2.paint.get("building-color").evaluate(s2, i2, this.canonical).toPremultipliedRenderColor(this.lut), h2 = t2.paint.get("building-emissive-strength").evaluate(s2, i2, this.canonical);
              s2.properties["building-part"] = "door";
              const p2 = t2.paint.get("building-color").evaluate(s2, i2, this.canonical).toPremultipliedRenderColor(this.lut), d2 = t2.paint.get("building-emissive-strength").evaluate(s2, i2, this.canonical), f2 = n2.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade;
              for (const t3 of n2.parts) {
                let e3, i3 = a2;
                1 === t3.part ? (i3 = a2, e3 = o2) : 0 === t3.part ? (i3 = l2, e3 = u2) : 2 === t3.part ? (i3 = c2, e3 = h2) : 3 === t3.part && (i3 = p2, e3 = d2), e3 = Dt(e3, 0, 1);
                for (let s3 = 0; s3 < t3.vertexLength; s3++) {
                  const a3 = t3.vertexOffset + s3, o3 = 1 + (f2.layoutAOArray.uint8[a3] / 255 - 1) * r2;
                  f2.layoutColorArray.emplace(a3, i3.r * o3 * 255 << 8 | i3.g * o3 * 255, i3.b * o3 * 255 << 8 | 255 * e3), n2.hasFauxFacade && f2.layoutFacadePaintArray.emplace(a3, 255 * c2.r << 8 | 255 * c2.g, 255 * c2.b << 8 | 255 * h2);
                }
              }
              const m2 = n2.buildingBloom;
              if (m2) for (let t3 = 0; t3 < m2.vertexLength; t3++) f2.entranceBloom.layoutColorArray.emplace(m2.vertexOffset + t3, 255 * p2.r << 8 | 255 * p2.g, 255 * p2.b << 8 | 51 * d2);
            }
          }
          needsEvaluation() {
            return !this.colorBufferUploaded;
          }
          updateReplacement(t2, e2, r2) {
            if (e2.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = e2.updateTime;
            const n2 = e2.getReplacementRegionsForTile(t2.toUnwrapped());
            if (Nd(this.activeReplacements, n2)) return;
            this.activeReplacements = n2;
            for (const t3 of this.footprints) t3.hiddenFlags &= -2;
            const i2 = [];
            for (const e3 of this.activeReplacements) {
              if (e3.order < r2) continue;
              const n3 = Math.max(1, Math.pow(2, e3.footprintTileId.canonical.z - t2.canonical.z));
              for (const r3 of this.footprints) r3.min.x > e3.max.x || r3.max.x < e3.min.x || r3.min.y > e3.max.y || r3.max.y < e3.min.y || (i2.length = 0, Oy(this.footprintsVertices, r3.footprintVertexOffset, r3.footprintVertexLength, e3.footprintTileId.canonical, t2.canonical, i2), $d(e3.footprint, i2, this.footprintsIndices.uint16, r3.footprintIndexOffset, r3.footprintIndexLength, 0, -n3) && (r3.hiddenFlags |= 1));
            }
            0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const t3 of this.footprints) this.groundEffect.updateHiddenByLandmarkRange(t3.groundEffectVertexOffset, t3.groundEffectVertexLength, 0 !== t3.hiddenFlags);
            this.indexArrayForConflationUploaded = false;
          }
          getFootprint(t2) {
            if (void 0 !== t2.id) {
              const e2 = this.featureFootprintLookup.get(t2.id);
              return this.footprints[e2];
            }
            return null;
          }
          getHeightAtTileCoord(t2, e2) {
            let r2 = Number.NEGATIVE_INFINITY, n2 = true;
            const i2 = 4 * (t2 + jn) * jn + (e2 + jn);
            if (this.footprintLookup.hasOwnProperty(i2)) {
              const t3 = this.footprintLookup[i2];
              return t3 ? { height: t3.height, hidden: 0 !== t3.hiddenFlags } : void 0;
            }
            const s2 = new It(t2, e2);
            for (const a2 of this.footprints) t2 > a2.max.x || a2.min.x > t2 || e2 > a2.max.y || a2.min.y > e2 || a2.height <= r2 || Ly(s2, this.footprintsVertices.float32.subarray(2 * a2.footprintVertexOffset, 2 * (a2.footprintVertexOffset + a2.footprintVertexLength)), this.footprintsIndices.uint16.subarray(a2.footprintIndexOffset, a2.footprintIndexOffset + a2.footprintIndexLength)) && (r2 = a2.height, this.footprintLookup[i2] = a2, n2 = 0 !== a2.hiddenFlags);
            if (r2 !== Number.NEGATIVE_INFINITY) return { height: r2, hidden: n2 };
            this.footprintLookup[i2] = void 0;
          }
        }
        function Ly(t2, e2, r2) {
          for (let n2 = 0; n2 < r2.length; n2 += 3) {
            const i2 = r2[n2], s2 = r2[n2 + 1], a2 = r2[n2 + 2], o2 = e2[2 * i2 + 0], l2 = e2[2 * i2 + 1], u2 = e2[2 * s2 + 0], c2 = e2[2 * s2 + 1], h2 = e2[2 * a2 + 0], p2 = e2[2 * a2 + 1], d2 = (o2 - h2) * (t2.y - p2) - (l2 - p2) * (t2.x - h2), f2 = (u2 - o2) * (t2.y - l2) - (c2 - l2) * (t2.x - o2);
            if (d2 < 0 != f2 < 0 && 0 !== d2 && 0 !== f2) continue;
            const m2 = (h2 - u2) * (t2.y - c2) - (p2 - c2) * (t2.x - u2);
            if (0 === m2 || m2 < 0 == d2 + f2 <= 0) return true;
          }
          return false;
        }
        function Oy(t2, e2, r2, n2, i2, s2) {
          const a2 = Math.pow(2, n2.z - i2.z);
          for (let o2 = 0; o2 < r2; o2++) {
            let r3 = t2.float32[2 * (o2 + e2) + 0], l2 = t2.float32[2 * (o2 + e2) + 1];
            r3 = (r3 + i2.x * jn) * a2 - n2.x * jn, l2 = (l2 + i2.y * jn) * a2 - n2.y * jn, s2.push(new It(r3, l2));
          }
        }
        let Uy, Ny;
        Qs(Ry, "BuildingBucket", { omit: ["layers"] }), Qs(Cy, "BuildingGeometry"), Qs(Dy, "BuildingBloomGeometry");
        const jy = Oo([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), Gy = Oo([{ name: "a_z_offset_width", components: 3, type: "Float32" }], 4), { members: $y } = jy, qy = Oo([{ name: "a_packed", components: 3, type: "Float32" }]), { members: Xy } = qy, Hy = Oo([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: Zy } = Hy;
        class Wy {
          constructor(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.image = new qh({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t2, e2) {
            const r2 = this.getKey(t2, e2);
            return this.positions[r2];
          }
          trim() {
            const t2 = this.width, e2 = this.height = Nt(this.nextRow);
            this.image.resize({ width: t2, height: e2 });
          }
          getKey(t2, e2) {
            return t2.join(",") + e2;
          }
          getDashRanges(t2, e2, r2) {
            const n2 = [];
            let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, a2 = true;
            n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t2[0] });
            let o2 = t2[0];
            for (let e3 = 1; e3 < t2.length; e3++) {
              a2 = !a2;
              const l2 = t2[e3];
              i2 = o2 * r2, o2 += l2, s2 = o2 * r2, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l2 });
            }
            return n2;
          }
          addRoundDash(t2, e2, r2) {
            const n2 = e2 / 2;
            for (let e3 = -r2; e3 <= r2; e3++) {
              const i2 = this.width * (this.nextRow + r2 + e3);
              let s2 = 0, a2 = t2[s2];
              for (let o2 = 0; o2 < this.width; o2++) {
                o2 / a2.right > 1 && (a2 = t2[++s2]);
                const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
                let h2;
                const p2 = e3 / r2 * (n2 + 1);
                if (a2.isDash) {
                  const t3 = n2 - Math.abs(p2);
                  h2 = Math.sqrt(c2 * c2 + t3 * t3);
                } else h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                this.image.data[i2 + o2] = Math.max(0, Math.min(255, h2 + 128));
              }
            }
          }
          addRegularDash(t2, e2) {
            for (let e3 = t2.length - 1; e3 >= 0; --e3) {
              const r3 = t2[e3], n3 = t2[e3 + 1];
              r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
            }
            const r2 = t2[0], n2 = t2[t2.length - 1];
            r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
            const i2 = this.width * this.nextRow;
            let s2 = 0, a2 = t2[s2];
            for (let r3 = 0; r3 < this.width; r3++) {
              r3 / a2.right > 1 && (a2 = t2[++s2]);
              const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l2 = Math.min(n3, o2);
              this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
            }
          }
          addDash(t2, e2) {
            const r2 = this.getKey(t2, e2);
            if (this.positions[r2]) return this.positions[r2];
            const n2 = "round" === e2, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
            if (this.nextRow + s2 > this.height) return Zt("LineAtlas out of space"), null;
            0 === t2.length && t2.push(1);
            let a2 = 0;
            for (let e3 = 0; e3 < t2.length; e3++) t2[e3] < 0 && (Zt("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
            if (0 !== a2) {
              const r3 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r3);
              n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e2 ? 0.5 * r3 : 0);
            }
            const o2 = this.nextRow + i2;
            this.nextRow += s2;
            const l2 = { tl: [o2, i2], br: [a2, 0] };
            return this.positions[r2] = l2, l2;
          }
        }
        Qs(Wy, "LineAtlas");
        const Yy = Qu.types, Jy = Math.cos(Math.PI / 180 * 37.5), Ky = Math.cos(Math.PI / 180 * 5);
        class Qy {
          constructor(t2) {
            this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.elevationType = "none", this.zoom = t2.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t2.overscaling, this.pixelRatio = t2.pixelRatio, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.hasCrossSlope = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new Zo(), this.layoutVertexArray2 = new Wo(), this.patternVertexArray = new Wo(), this.indexArray = new ll(), this.programConfigurations = new fu(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.segments = new Ol(), this.maxLineLength = 0, this.zOffsetVertexArray = new Wo(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.tessellationStep = t2.tessellationStep ? t2.tessellationStep : 128, this.worldview = t2.worldview, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          populate(t2, e2, r2, n2) {
            this.hasPattern = zp("line", this.layers, this.pixelRatio, e2);
            const i2 = this.layers[0].layout.get("line-sort-key");
            this.tileToMeter = ju(r2);
            const s2 = this.layers[0].layout.get("line-elevation-reference");
            if ("hd-road-markup" === s2) this.elevationType = "road";
            else {
              const t3 = this.layers[0].layout.get("line-z-offset"), e3 = t3.isConstant() && !t3.constantOr(0);
              this.elevationType = "sea" !== s2 && "ground" !== s2 && e3 ? "none" : "offset", "offset" === this.elevationType && "none" === s2 && Zt(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
            }
            const a2 = this.layers[0].layout.get("line-cross-slope");
            this.hasCrossSlope = "offset" === this.elevationType && void 0 !== a2;
            const o2 = [];
            for (const { feature: s3, id: a3, index: l3, sourceLayerIndex: u3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c3 = Ku(s3, t3);
              if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), c3, r2)) continue;
              const h2 = i2 ? i2.evaluate(c3, {}, r2) : void 0, p2 = { id: a3, properties: s3.properties, type: s3.type, sourceLayerIndex: u3, index: l3, geometry: t3 ? c3.geometry : Ju(s3, r2, n2), patterns: {}, sortKey: h2 };
              o2.push(p2);
            }
            i2 && o2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            const { lineAtlas: l2, featureIndex: u2 } = e2, c2 = this.addConstantDashes(l2);
            for (const n3 of o2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3;
              if (c2 && this.addFeatureDashes(n3, l2), this.hasPattern) {
                const t3 = Bp("line", this.layers, n3, this.zoom, this.pixelRatio, e2);
                this.patternFeatures.push(t3);
              } else this.addFeature(n3, i3, s3, r2, l2.positions, e2.availableImages, e2.brightness, e2.elevationFeatures);
              u2.insert(t2[s3].feature, i3, s3, a3, this.index);
            }
          }
          addConstantDashes(t2) {
            let e2 = false;
            for (const r2 of this.layers) {
              const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
              if ("constant" !== n2.kind || "constant" !== i2.kind) e2 = true;
              else {
                const e3 = i2.value, r3 = n2.value;
                if (!r3) continue;
                t2.addDash(r3, e3);
              }
            }
            return e2;
          }
          addFeatureDashes(t2, e2) {
            const r2 = this.zoom;
            for (const n2 of this.layers) {
              const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
              if ("constant" === i2.kind && "constant" === s2.kind) continue;
              let a2, o2;
              if ("constant" === i2.kind) {
                if (a2 = i2.value, !a2) continue;
              } else a2 = i2.evaluate({ zoom: r2 }, t2);
              o2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r2 }, t2), e2.addDash(a2, o2), t2.patterns[n2.id] = [e2.getKey(a2, o2)];
            }
          }
          update(t2, e2, r2, n2, i2, s2, a2, o2) {
            this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, o2);
          }
          addFeatures(t2, e2, r2, n2, i2, s2) {
            for (const i3 of this.patternFeatures) this.addFeature(i3, i3.geometry, i3.index, e2, r2, n2, s2, t2.elevationFeatures);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Xy)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t2.createVertexBuffer(this.patternVertexArray, Zy)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, Gy.members, true)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, $y), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2, e2) {
            let r2, n2;
            if (e2 && e2 > 0 ? (r2 = `mapbox_clip_start_${e2}`, n2 = `mapbox_clip_end_${e2}`) : (r2 = "mapbox_clip_start", n2 = "mapbox_clip_end"), t2.properties && t2.properties.hasOwnProperty(r2) && t2.properties.hasOwnProperty(n2)) return { start: +t2.properties[r2], end: +t2.properties[n2] };
          }
          addFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.layers[0].layout, u2 = l2.get("line-join").evaluate(t2, {}), c2 = l2.get("line-cap").evaluate(t2, {}), h2 = l2.get("line-miter-limit"), p2 = l2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2), this.lineFeature = t2;
            const d2 = !(!t2.properties || !t2.properties.hasOwnProperty("mapbox_line_metrics")) && t2.properties.mapbox_line_metrics;
            this.zOffsetValue = l2.get("line-z-offset").value;
            const f2 = this.layers[0].paint.get("line-width").value;
            if ("constant" !== f2.kind && false === f2.isLineProgressConstant && (this.variableWidthValue = f2), "road" === this.elevationType) {
              const r3 = this.layoutVertexArray.length;
              if (!this.addElevatedRoadFeature(t2, e2, n2, o2, u2, c2, h2, p2)) {
                const [i3, s3] = this.clipRuntimeLinesToTile(e2, 1);
                for (let e3 = 0; e3 < i3.length; e3++) {
                  const r4 = i3[e3], a3 = s3[e3], o3 = { progress: { min: a3.progress.min, max: a3.progress.max }, nextDir: this.computeSegNextDir(a3, r4), prevDir: this.computeSegPrevDir(a3, r4) };
                  this.addLine(r4, t2, n2, u2, c2, h2, p2, o3, d2 && a3.parentIndex > 0 ? a3.parentIndex : null);
                }
                this.fillNonElevatedRoadSegment(r3);
              }
            } else for (let r3 = 0; r3 < e2.length; r3++) this.addLine(e2[r3], t2, n2, u2, c2, h2, p2, void 0, d2 && r3 > 0 ? r3 : null);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, a2, void 0, this.worldview);
          }
          computeSegNextDir(t2, e2) {
            return t2.nextPoint.sub(e2.at(-2)).unit();
          }
          computeSegPrevDir(t2, e2) {
            return e2[1].sub(t2.prevPoint).unit();
          }
          clipLinesToTile(t2, e2) {
            return Ef(t2, -e2, -e2, jn + e2, jn + e2);
          }
          clipRuntimeLinesToTile(t2, e2) {
            const r2 = [];
            return [Ef(t2, -e2, -e2, jn + e2, jn + e2, r2), r2];
          }
          addElevatedRoadFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = [], u2 = Mc.getElevationFeature(t2, n2);
            if (u2) {
              const t3 = this.clipLinesToTile(e2, 1), n3 = this.prepareElevatedLines(t3, u2, r2);
              for (const t4 of n3) l2.push({ geometry: t4, elevation: u2, elevationTileID: r2, segment: { progress: { min: 0, max: 1 }, nextDir: void 0, prevDir: void 0 } });
            }
            if (0 === l2.length) return false;
            for (const e3 of l2) {
              const n3 = this.layoutVertexArray.length;
              this.addLine(e3.geometry, t2, r2, i2, s2, a2, o2);
              const l3 = new Ic(r2, e3.elevationTileID);
              if (e3.elevation) for (let t3 = n3; t3 < this.layoutVertexArray.length; t3++) {
                const r3 = new It(this.layoutVertexArray.int16[6 * t3] >> 1, this.layoutVertexArray.int16[6 * t3 + 1] >> 1), n4 = l3.pointElevation(r3, e3.elevation, 0.05);
                this.updateHeightRange(n4), this.zOffsetVertexArray.emplaceBack(n4, 0, 0);
              }
              else this.fillNonElevatedRoadSegment(n3);
            }
            return true;
          }
          prepareElevatedLines(t2, e2, r2) {
            if (null != e2.constantHeight) return t2;
            const n2 = [], i2 = 1 / ju(r2);
            for (const r3 of t2) Ff(r3, new _c(e2, i2), 0, n2);
            return n2;
          }
          fillNonElevatedRoadSegment(t2) {
            for (let e2 = t2; e2 < this.layoutVertexArray.length; e2++) this.zOffsetVertexArray.emplaceBack(0, 0, 0);
          }
          updateHeightRange(t2) {
            this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t2), this.heightRange.max = Math.max(this.heightRange.max, t2)) : this.heightRange = { min: t2, max: t2 };
          }
          addLine(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0, this.lineClips = l2 ? this.lineFeatureClips(e2, l2) : this.lineClips;
            const u2 = "none" === n2;
            this.patternJoinNone = this.hasPattern && u2, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
            const c2 = o2 && o2.progress.min > 0, h2 = o2 && o2.progress.max < 1;
            if (this.lineClips) {
              let r3 = { min: this.lineClips.start, max: this.lineClips.end }, n3 = 1;
              if (o2) {
                const t3 = this.lineClips.end - this.lineClips.start;
                r3 = function(t4, e3, r4) {
                  return { min: ae(t4.min, e3, r4), max: ae(t4.max, e3, r4) };
                }(o2.progress, { min: 0, max: 1 }, r3), t3 > 0 && (n3 = (r3.max - r3.min) / t3);
              }
              const i3 = +e2.properties.mapbox_clip_feature_len, s3 = +e2.properties.mapbox_clip_seg_len;
              if (Number.isNaN(i3) || Number.isNaN(s3)) {
                for (let e4 = 0; e4 < t2.length - 1; e4++) this.totalDistance += t2[e4].dist(t2[e4 + 1]);
                const e3 = this.totalDistance / (r3.max - r3.min);
                this.totalFeatureLength = Number.isFinite(e3) ? e3 : 0, this.lineClips.start = r3.min, this.lineClips.end = r3.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              } else this.totalFeatureLength = i3, this.distance = s3 * n3, this.lineClips.start = r3.min, this.lineClips.end = r3.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
              this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
            }
            const p2 = "Polygon" === Yy[e2.type];
            let d2 = t2.length;
            for (; d2 >= 2 && t2[d2 - 1].equals(t2[d2 - 2]); ) d2--;
            let f2 = 0;
            for (; f2 < d2 - 1 && t2[f2].equals(t2[f2 + 1]); ) f2++;
            if (d2 < (p2 ? 3 : 2)) return;
            "bevel" === n2 && (s2 = 1.05);
            const m2 = this.segments.prepareSegment(10 * d2, this.layoutVertexArray, this.indexArray);
            let y2, g2, x2, v2, b2, w2, _2, A2;
            o2 && o2.prevDir && (w2 = o2.prevDir.perp()), o2 && o2.nextDir && (_2 = o2.nextDir.perp()), this.e1 = this.e2 = -1, p2 && (y2 = t2[d2 - 2], b2 = t2[f2].sub(y2)._unit()._perp());
            for (let e3 = f2; e3 < d2; e3++) {
              if (x2 = e3 === d2 - 1 ? p2 ? t2[f2 + 1] : void 0 : t2[e3 + 1], x2 && t2[e3].equals(x2)) continue;
              b2 && (v2 = b2), y2 && (g2 = y2), y2 = t2[e3], A2 = this.evaluateLineProgressFeatures(g2 ? g2.dist(y2) : 0), b2 = x2 ? x2.sub(y2)._unit()._perp() : v2, v2 = v2 || b2;
              const r3 = g2 && x2;
              let o3 = r3 ? n2 : p2 || u2 ? "butt" : i2;
              const l3 = v2.x * b2.x + v2.y * b2.y;
              if (u2) {
                const t3 = function(t4) {
                  if (t4.patternJoinNone) {
                    const e4 = t4.segmentPoints.length / 2, r4 = t4.lineSoFar - t4.segmentStart;
                    for (let n3 = 0; n3 < e4; ++n3) {
                      const e5 = t4.segmentPoints[2 * n3 + 1], i3 = Math.round(t4.segmentPoints[2 * n3]) + 0.5 + 0.25 * e5;
                      t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart), t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart);
                    }
                    t4.segmentPoints.length = 0;
                  }
                  t4.e1 = t4.e2 = -1;
                };
                if (r3 && l3 < Ky) {
                  this.updateDistance(g2, y2), this.addCurrentVertex(y2, v2, 1, 1, m2, A2), t3(this), this.addCurrentVertex(y2, b2, -1, -1, m2, A2);
                  continue;
                }
                if (g2) {
                  if (!x2) {
                    this.updateDistance(g2, y2), this.addCurrentVertex(y2, v2, 1, 1, m2, A2), t3(this);
                    continue;
                  }
                  o3 = "miter";
                }
              }
              let M2 = v2.add(b2);
              0 === M2.x && 0 === M2.y || M2._unit();
              const I2 = M2.x * b2.x + M2.y * b2.y, S2 = 0 !== I2 ? 1 / I2 : 1 / 0, P2 = 2 * Math.sqrt(2 - 2 * I2), z2 = I2 < Jy && g2 && x2, B2 = v2.x * b2.y - v2.y * b2.x > 0, k2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0;
              if (r3 && "round" === o3) {
                if (S2 < a2) o3 = "miter";
                else if (S2 <= 2) {
                  const t3 = tg(y2, -10, 8202);
                  o3 = "offset" === this.elevationType && (t3 || this.hasCrossSlope) ? "miter" : "fakeround";
                }
              }
              if ("miter" === o3 && S2 > s2 && (o3 = "bevel"), "bevel" === o3 && (S2 > 2 && (o3 = "flipbevel"), S2 < s2 && (o3 = "miter")), g2 && !("miter" === o3 && z2) && this.updateDistance(g2, y2), "miter" === o3) if (z2) {
                const t3 = y2.dist(g2);
                if (t3 > 2 * k2) {
                  const e5 = y2.sub(y2.sub(g2)._mult(k2 / t3)._round());
                  this.updateDistance(g2, e5), this.addCurrentVertex(e5, v2, 0, 0, m2, A2), g2 = e5;
                }
                this.updateDistance(g2, y2), M2._mult(S2), this.addCurrentVertex(y2, M2, 0, 0, m2, A2);
                const e4 = y2.dist(x2);
                if (e4 > 2 * k2) {
                  const t4 = y2.add(x2.sub(y2)._mult(k2 / e4)._round());
                  this.updateDistance(y2, t4), this.addCurrentVertex(t4, b2, 0, 0, m2, A2), y2 = t4;
                }
              } else M2._mult(S2), this.addCurrentVertex(y2, M2, 0, 0, m2, A2);
              else if ("flipbevel" === o3) {
                if (S2 > 100) M2 = b2.mult(-1);
                else {
                  const t3 = S2 * v2.add(b2).mag() / v2.sub(b2).mag();
                  M2._perp()._mult(t3 * (B2 ? -1 : 1));
                }
                this.addCurrentVertex(y2, M2, 0, 0, m2, A2), this.addCurrentVertex(y2, M2.mult(-1), 0, 0, m2, A2);
              } else if ("bevel" === o3 || "fakeround" === o3) {
                null != A2 && g2 && this.addCurrentVertex(y2, _2 || v2, -1, -1, m2, A2);
                const t3 = y2.dist(g2) <= 2 * k2 && "bevel" !== o3, e4 = M2.mult(B2 ? 1 : -1);
                e4._mult(S2);
                const r4 = b2.mult(B2 ? -1 : 1), n3 = v2.mult(B2 ? -1 : 1), i3 = this.evaluateLineProgressFeatures(this.distance);
                if (null == A2 && (this.addHalfVertex(y2, e4.x, e4.y, false, !B2, 0, m2, i3), t3 || this.addHalfVertex(y2, e4.x + 2 * n3.x, e4.y + 2 * n3.y, false, B2, 0, m2, i3)), "fakeround" === o3) {
                  const t4 = Math.round(180 * P2 / Math.PI / 20);
                  this.addHalfVertex(y2, n3.x, n3.y, false, B2, 0, m2, i3);
                  for (let e5 = 0; e5 < t4; e5++) {
                    let s3 = e5 / t4;
                    if (0.5 !== s3) {
                      const t5 = s3 - 0.5;
                      s3 += s3 * t5 * (s3 - 1) * ((1.0904 + l3 * (l3 * (3.55645 - 1.43519 * l3) - 3.2452)) * t5 * t5 + (0.848013 + l3 * (0.215638 * l3 - 1.06021)));
                    }
                    const a3 = r4.sub(n3)._mult(s3)._add(n3)._unit();
                    this.addHalfVertex(y2, a3.x, a3.y, false, B2, 0, m2, i3);
                  }
                  this.addHalfVertex(y2, r4.x, r4.y, false, B2, 0, m2, i3);
                }
                t3 || null != A2 || this.addHalfVertex(y2, e4.x + 2 * r4.x, e4.y + 2 * r4.y, false, B2, 0, m2, i3), null != A2 && x2 && this.addCurrentVertex(y2, w2 || b2, 1, 1, m2, A2);
              } else if ("butt" === o3) this.addCurrentVertex(y2, M2, 0, 0, m2, A2);
              else if ("square" === o3) {
                if (!g2) {
                  const t3 = c2 ? 0 : -1;
                  this.addCurrentVertex(y2, M2, t3, t3, m2, A2);
                }
                if (this.addCurrentVertex(y2, M2, 0, 0, m2, A2), g2) {
                  const t3 = h2 ? 0 : 1;
                  this.addCurrentVertex(y2, M2, t3, t3, m2, A2);
                }
              } else if ("round" === o3) {
                if (g2) {
                  const t3 = !r3 && _2 ? _2 : v2;
                  this.addCurrentVertex(y2, t3, 0, 0, m2, A2), !r3 && h2 || this.addCurrentVertex(y2, t3, 1, 1, m2, A2, true);
                }
                if (x2) {
                  const t3 = !r3 && w2 ? w2 : b2;
                  !r3 && c2 || this.addCurrentVertex(y2, t3, -1, -1, m2, A2, true), this.addCurrentVertex(y2, t3, 0, 0, m2, A2);
                }
              }
            }
          }
          addVerticesTo(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = (e2.w - t2.w) / this.tessellationStep | 0;
            let h2 = 0;
            const p2 = this.scaledDistance;
            if (c2 > 1) {
              this.lineSoFar = t2.w;
              const p3 = (e2.x - t2.x) / c2, d3 = (e2.y - t2.y) / c2, f2 = (e2.z - t2.z) / c2, m2 = (e2.w - t2.w) / c2;
              for (let e3 = 1; e3 < c2; ++e3) {
                t2.x += p3, t2.y += d3, t2.z += f2, this.lineSoFar += m2, h2 += m2;
                const e4 = this.evaluateLineProgressFeatures(this.prevDistance + h2);
                this.scaledDistance = (this.prevDistance + h2) / this.totalDistance, this.addHalfVertex(t2, r2, n2, u2, false, a2, l2, e4), this.addHalfVertex(t2, i2, s2, u2, true, -o2, l2, e4);
              }
            }
            this.lineSoFar = e2.w, this.scaledDistance = p2;
            const d2 = this.evaluateLineProgressFeatures(this.distance);
            this.addHalfVertex(e2, r2, n2, u2, false, a2, l2, d2), this.addHalfVertex(e2, i2, s2, u2, true, -o2, l2, d2);
          }
          evaluateLineProgressFeatures(t2) {
            if (!this.variableWidthValue && "offset" !== this.elevationType) return null;
            this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t2) / this.totalFeatureLength) : Zt(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
            let e2 = 0;
            return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e2 = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), "offset" !== this.elevationType ? { zOffset: 0, variableWidth: e2 } : "constant" === this.zOffsetValue.kind ? { zOffset: this.zOffsetValue.value, variableWidth: e2 } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: e2 };
          }
          addCurrentVertex(t2, e2, r2, n2, i2, s2, a2 = false) {
            const o2 = e2.x + e2.y * r2, l2 = e2.y - e2.x * r2, u2 = e2.y * n2 - e2.x, c2 = -e2.y - e2.x * n2;
            if (null != s2) {
              const e3 = "offset" === this.elevationType, h2 = -10, p2 = 8202, d2 = s2.zOffset, f2 = new kf(t2.x, t2.y, d2, this.lineSoFar), m2 = !!e3 && tg(t2, h2, p2), y2 = this.lineSoFar, g2 = this.distance;
              if (this.currentVertex) if (m2) {
                const e4 = this.currentVertexIsOutside, s3 = this.currentVertex, m3 = new kf(t2.x, t2.y, d2, this.lineSoFar);
                if (Vf(s3, m3, h2, p2), !tg(m3, h2, p2)) {
                  if (e4) {
                    this.e1 = this.e2 = -1, this.distance -= s3.dist(f2), this.lineSoFar = s3.w;
                    const t3 = this.evaluateLineProgressFeatures(s3.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                    this.addHalfVertex(s3, o2, l2, a2, false, r2, i2, t3), this.addHalfVertex(s3, u2, c2, a2, true, -n2, i2, t3), this.prevDistance = this.distance;
                  }
                  this.distance = this.prevDistance + s3.dist(m3), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s3, m3, o2, l2, u2, c2, r2, n2, i2, a2), this.distance = g2, this.scaledDistance = this.distance / this.totalDistance;
                }
              } else {
                const t3 = this.currentVertex;
                if (this.currentVertexIsOutside) {
                  Vf(t3, f2, h2, p2), this.e1 = this.e2 = -1, this.distance -= t3.dist(f2), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3.w;
                  const e4 = this.evaluateLineProgressFeatures(t3.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                  this.addHalfVertex(t3, o2, l2, a2, false, r2, i2, e4), this.addHalfVertex(t3, u2, c2, a2, true, -n2, i2, e4), this.prevDistance = this.distance, this.distance = g2, this.scaledDistance = this.distance / this.totalDistance;
                }
                this.addVerticesTo(t3, f2, o2, l2, u2, c2, r2, n2, i2, a2);
              }
              else m2 || (this.addHalfVertex(t2, o2, l2, a2, false, r2, i2, s2), this.addHalfVertex(t2, u2, c2, a2, true, -n2, i2, s2));
              this.currentVertex = f2, this.currentVertexIsOutside = m2, this.lineSoFar = y2;
            } else this.addHalfVertex(t2, o2, l2, a2, false, r2, i2, s2), this.addHalfVertex(t2, u2, c2, a2, true, -n2, i2, s2);
          }
          addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2, l2) {
            if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s2 || this.segmentPoints.push(this.lineSoFar - this.segmentStart, a2)), this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
              const t3 = dr(this.lineClips.start, this.lineClips.end, this.scaledDistance);
              this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t3);
            }
            const u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2, null != l2 && this.zOffsetVertexArray.emplaceBack(l2.zOffset, l2.variableWidth, l2.variableWidth);
          }
          updateScaledDistance() {
            this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
          }
          updateDistance(t2, e2) {
            this.prevDistance = this.distance, this.distance += t2.dist(e2), this.updateScaledDistance();
          }
        }
        function tg(t2, e2, r2) {
          return t2.x < e2 || t2.x > r2 || t2.y < e2 || t2.y > r2;
        }
        let eg, rg;
        function ng(t2, e2, r2) {
          return e2 * (jn / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
        }
        Qs(Qy, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
        const ig = (t2, e2, r2) => (1 - r2) * t2 + r2 * e2;
        function sg(t2, e2) {
          return 1 / ng(t2, 1, e2.tileZoom);
        }
        function ag(t2, e2, r2, n2) {
          return t2.translatePosMatrix(n2 || e2.tileID.projMatrix, e2, r2.paint.get("line-translate"), r2.paint.get("line-translate-anchor"));
        }
        const og = (t2) => {
          const e2 = [];
          lg(t2) && e2.push("RENDER_LINE_DASH"), t2.paint.get("line-gradient") && e2.push("RENDER_LINE_GRADIENT");
          const r2 = t2.paint.get("line-trim-offset");
          0 === r2[0] && 0 === r2[1] || e2.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t2.paint.get("line-border-width").constantOr(1) && e2.push("RENDER_LINE_BORDER");
          const n2 = "none" === t2.layout.get("line-join").constantOr("miter"), i2 = !!t2.paint.get("line-pattern").constantOr(1);
          return n2 && i2 && e2.push("LINE_JOIN_NONE"), e2;
        };
        function lg(t2) {
          const e2 = t2.paint.get("line-dasharray").value;
          return "constant" !== e2.kind || e2.value;
        }
        let ug;
        const cg = () => ug || (ug = { layout: eg || (eg = new uo({ "line-cap": new oo(co.layout_line["line-cap"]), "line-join": new oo(co.layout_line["line-join"]), "line-miter-limit": new ao(co.layout_line["line-miter-limit"]), "line-round-limit": new ao(co.layout_line["line-round-limit"]), "line-sort-key": new oo(co.layout_line["line-sort-key"]), "line-z-offset": new oo(co.layout_line["line-z-offset"]), "line-elevation-reference": new ao(co.layout_line["line-elevation-reference"]), "line-cross-slope": new ao(co.layout_line["line-cross-slope"]), visibility: new ao(co.layout_line.visibility), "line-width-unit": new ao(co.layout_line["line-width-unit"]) })), paint: rg || (rg = new uo({ "line-opacity": new oo(co.paint_line["line-opacity"]), "line-color": new oo(co.paint_line["line-color"]), "line-translate": new ao(co.paint_line["line-translate"]), "line-translate-anchor": new ao(co.paint_line["line-translate-anchor"]), "line-width": new oo(co.paint_line["line-width"]), "line-gap-width": new oo(co.paint_line["line-gap-width"]), "line-offset": new oo(co.paint_line["line-offset"]), "line-blur": new oo(co.paint_line["line-blur"]), "line-dasharray": new oo(co.paint_line["line-dasharray"]), "line-pattern": new oo(co.paint_line["line-pattern"]), "line-pattern-cross-fade": new ao(co.paint_line["line-pattern-cross-fade"]), "line-gradient": new lo(co.paint_line["line-gradient"]), "line-trim-offset": new ao(co.paint_line["line-trim-offset"]), "line-trim-fade-range": new ao(co.paint_line["line-trim-fade-range"]), "line-trim-color": new ao(co.paint_line["line-trim-color"]), "line-emissive-strength": new oo(co.paint_line["line-emissive-strength"]), "line-border-width": new oo(co.paint_line["line-border-width"]), "line-border-color": new oo(co.paint_line["line-border-color"]), "line-occlusion-opacity": new ao(co.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, ug);
        class hg extends oo {
          possiblyEvaluate(t2, e2) {
            return e2 = new Ja(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition, worldview: e2.worldview }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r2, n2) {
            return e2 = Object.assign({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
          }
        }
        let pg;
        function dg(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        const fg = Oo([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), mg = Oo([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), yg = Oo([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        Oo([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const gg = Oo([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), xg = Oo([{ name: "a_x_axis", components: 3, type: "Float32" }, { name: "a_y_axis", components: 3, type: "Float32" }]), vg = Oo([{ name: "a_texb", components: 2, type: "Uint16" }]), bg = Oo([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), wg = Oo([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
        Oo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const _g = Oo([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Ag = Oo([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        Oo([{ name: "triangle", components: 3, type: "Uint16" }]), Oo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Oo([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }, { type: "Uint16", name: "elevationFeatureIndex" }]), Oo([{ type: "Float32", name: "offsetX" }]), Oo([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var Mg = 24;
        function Ig(t2, e2, r2) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e3, r3) {
              const n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Ya.applyArabicShaping && (t4 = Ya.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r2);
          }), t2;
        }
        const Sg = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        function Pg(t2) {
          return "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2;
        }
        function zg(t2) {
          return "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2;
        }
        const Bg = 4294967296, kg = 1 / Bg, Tg = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
        let Vg = class {
          constructor(t2 = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t2, e2, r2 = this.length) {
            for (; this.pos < r2; ) {
              const r3 = this.readVarint(), n2 = r3 >> 3, i2 = this.pos;
              this.type = 7 & r3, t2(n2, e2, this), this.pos === i2 && this.skip(r3);
            }
            return e2;
          }
          readMessage(t2, e2) {
            return this.readFields(t2, e2, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t2 = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t2;
          }
          readSFixed32() {
            const t2 = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t2;
          }
          readFixed64() {
            const t2 = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * Bg;
            return this.pos += 8, t2;
          }
          readSFixed64() {
            const t2 = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * Bg;
            return this.pos += 8, t2;
          }
          readFloat() {
            const t2 = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t2;
          }
          readDouble() {
            const t2 = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t2;
          }
          readVarint(t2) {
            const e2 = this.buf;
            let r2, n2;
            return n2 = e2[this.pos++], r2 = 127 & n2, n2 < 128 ? r2 : (n2 = e2[this.pos++], r2 |= (127 & n2) << 7, n2 < 128 ? r2 : (n2 = e2[this.pos++], r2 |= (127 & n2) << 14, n2 < 128 ? r2 : (n2 = e2[this.pos++], r2 |= (127 & n2) << 21, n2 < 128 ? r2 : (n2 = e2[this.pos], r2 |= (15 & n2) << 28, function(t3, e3, r3) {
              const n3 = r3.buf;
              let i2, s2;
              if (s2 = n3[r3.pos++], i2 = (112 & s2) >> 4, s2 < 128) return Eg(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 3, s2 < 128) return Eg(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 10, s2 < 128) return Eg(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 17, s2 < 128) return Eg(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 24, s2 < 128) return Eg(t3, i2, e3);
              if (s2 = n3[r3.pos++], i2 |= (1 & s2) << 31, s2 < 128) return Eg(t3, i2, e3);
              throw new Error("Expected varint not more than 10 bytes");
            }(r2, t2, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }
          readBoolean() {
            return Boolean(this.readVarint());
          }
          readString() {
            const t2 = this.readVarint() + this.pos, e2 = this.pos;
            return this.pos = t2, t2 - e2 >= 12 && Tg ? Tg.decode(this.buf.subarray(e2, t2)) : function(t3, e3, r2) {
              let n2 = "", i2 = e3;
              for (; i2 < r2; ) {
                const e4 = t3[i2];
                let s2, a2, o2, l2 = null, u2 = e4 > 239 ? 4 : e4 > 223 ? 3 : e4 > 191 ? 2 : 1;
                if (i2 + u2 > r2) break;
                1 === u2 ? e4 < 128 && (l2 = e4) : 2 === u2 ? (s2 = t3[i2 + 1], 128 == (192 & s2) && (l2 = (31 & e4) << 6 | 63 & s2, l2 <= 127 && (l2 = null))) : 3 === u2 ? (s2 = t3[i2 + 1], a2 = t3[i2 + 2], 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & e4) << 12 | (63 & s2) << 6 | 63 & a2, (l2 <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null))) : 4 === u2 && (s2 = t3[i2 + 1], a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & s2) && 128 == (192 & a2) && 128 == (192 & o2) && (l2 = (15 & e4) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2, (l2 <= 65535 || l2 >= 1114112) && (l2 = null))), null === l2 ? (l2 = 65533, u2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += u2;
              }
              return n2;
            }(this.buf, e2, t2);
          }
          readBytes() {
            const t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e2;
          }
          readPackedVarint(t2 = [], e2) {
            const r2 = this.readPackedEnd();
            for (; this.pos < r2; ) t2.push(this.readVarint(e2));
            return t2;
          }
          readPackedSVarint(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readSVarint());
            return t2;
          }
          readPackedBoolean(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readBoolean());
            return t2;
          }
          readPackedFloat(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readFloat());
            return t2;
          }
          readPackedDouble(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readDouble());
            return t2;
          }
          readPackedFixed32(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readFixed32());
            return t2;
          }
          readPackedSFixed32(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readSFixed32());
            return t2;
          }
          readPackedFixed64(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readFixed64());
            return t2;
          }
          readPackedSFixed64(t2 = []) {
            const e2 = this.readPackedEnd();
            for (; this.pos < e2; ) t2.push(this.readSFixed64());
            return t2;
          }
          readPackedEnd() {
            return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t2) {
            const e2 = 7 & t2;
            if (0 === e2) for (; this.buf[this.pos++] > 127; ) ;
            else if (2 === e2) this.pos = this.readVarint() + this.pos;
            else if (5 === e2) this.pos += 4;
            else {
              if (1 !== e2) throw new Error(`Unimplemented type: ${e2}`);
              this.pos += 8;
            }
          }
          writeTag(t2, e2) {
            this.writeVarint(t2 << 3 | e2);
          }
          realloc(t2) {
            let e2 = this.length || 16;
            for (; e2 < this.pos + t2; ) e2 *= 2;
            if (e2 !== this.length) {
              const t3 = new Uint8Array(e2);
              t3.set(this.buf), this.buf = t3, this.dataView = new DataView(t3.buffer), this.length = e2;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t2) {
            this.realloc(4), this.dataView.setInt32(this.pos, t2, true), this.pos += 4;
          }
          writeSFixed32(t2) {
            this.realloc(4), this.dataView.setInt32(this.pos, t2, true), this.pos += 4;
          }
          writeFixed64(t2) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t2, true), this.dataView.setInt32(this.pos + 4, Math.floor(t2 * kg), true), this.pos += 8;
          }
          writeSFixed64(t2) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t2, true), this.dataView.setInt32(this.pos + 4, Math.floor(t2 * kg), true), this.pos += 8;
          }
          writeVarint(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
              let r2, n2;
              if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (r2 = ~(-t3 % 4294967296), n2 = ~(-t3 / 4294967296), 4294967295 ^ r2 ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              e2.realloc(10), function(t4, e3, r3) {
                r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
              }(r2, 0, e2), function(t4, e3) {
                const r3 = (7 & t4) << 4;
                e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
              }(n2, e2);
            }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }
          writeSVarint(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }
          writeBoolean(t2) {
            this.writeVarint(+t2);
          }
          writeString(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            const e2 = this.pos;
            this.pos = function(t3, e3, r3) {
              for (let n2, i2, s2 = 0; s2 < e3.length; s2++) {
                if (n2 = e3.charCodeAt(s2), n2 > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
                n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
              }
              return r3;
            }(this.buf, t2, this.pos);
            const r2 = this.pos - e2;
            r2 >= 128 && Fg(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
          }
          writeFloat(t2) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t2, true), this.pos += 4;
          }
          writeDouble(t2) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t2, true), this.pos += 8;
          }
          writeBytes(t2) {
            const e2 = t2.length;
            this.writeVarint(e2), this.realloc(e2);
            for (let r2 = 0; r2 < e2; r2++) this.buf[this.pos++] = t2[r2];
          }
          writeRawMessage(t2, e2) {
            this.pos++;
            const r2 = this.pos;
            t2(e2, this);
            const n2 = this.pos - r2;
            n2 >= 128 && Fg(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
          }
          writeMessage(t2, e2, r2) {
            this.writeTag(t2, 2), this.writeRawMessage(e2, r2);
          }
          writePackedVarint(t2, e2) {
            e2.length && this.writeMessage(t2, Dg, e2);
          }
          writePackedSVarint(t2, e2) {
            e2.length && this.writeMessage(t2, Cg, e2);
          }
          writePackedBoolean(t2, e2) {
            e2.length && this.writeMessage(t2, Og, e2);
          }
          writePackedFloat(t2, e2) {
            e2.length && this.writeMessage(t2, Rg, e2);
          }
          writePackedDouble(t2, e2) {
            e2.length && this.writeMessage(t2, Lg, e2);
          }
          writePackedFixed32(t2, e2) {
            e2.length && this.writeMessage(t2, Ug, e2);
          }
          writePackedSFixed32(t2, e2) {
            e2.length && this.writeMessage(t2, Ng, e2);
          }
          writePackedFixed64(t2, e2) {
            e2.length && this.writeMessage(t2, jg, e2);
          }
          writePackedSFixed64(t2, e2) {
            e2.length && this.writeMessage(t2, Gg, e2);
          }
          writeBytesField(t2, e2) {
            this.writeTag(t2, 2), this.writeBytes(e2);
          }
          writeFixed32Field(t2, e2) {
            this.writeTag(t2, 5), this.writeFixed32(e2);
          }
          writeSFixed32Field(t2, e2) {
            this.writeTag(t2, 5), this.writeSFixed32(e2);
          }
          writeFixed64Field(t2, e2) {
            this.writeTag(t2, 1), this.writeFixed64(e2);
          }
          writeSFixed64Field(t2, e2) {
            this.writeTag(t2, 1), this.writeSFixed64(e2);
          }
          writeVarintField(t2, e2) {
            this.writeTag(t2, 0), this.writeVarint(e2);
          }
          writeSVarintField(t2, e2) {
            this.writeTag(t2, 0), this.writeSVarint(e2);
          }
          writeStringField(t2, e2) {
            this.writeTag(t2, 2), this.writeString(e2);
          }
          writeFloatField(t2, e2) {
            this.writeTag(t2, 5), this.writeFloat(e2);
          }
          writeDoubleField(t2, e2) {
            this.writeTag(t2, 1), this.writeDouble(e2);
          }
          writeBooleanField(t2, e2) {
            this.writeVarintField(t2, +e2);
          }
        };
        function Eg(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function Fg(t2, e2, r2) {
          const n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (let e3 = r2.pos - 1; e3 >= t2; e3--) r2.buf[e3 + n2] = r2.buf[e3];
        }
        function Dg(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeVarint(t2[r2]);
        }
        function Cg(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeSVarint(t2[r2]);
        }
        function Rg(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeFloat(t2[r2]);
        }
        function Lg(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeDouble(t2[r2]);
        }
        function Og(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeBoolean(t2[r2]);
        }
        function Ug(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeFixed32(t2[r2]);
        }
        function Ng(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeSFixed32(t2[r2]);
        }
        function jg(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeFixed64(t2[r2]);
        }
        function Gg(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++) e2.writeSFixed64(t2[r2]);
        }
        function $g(t2, e2, r2) {
          e2.glyphs = [], 1 === t2 && r2.readMessage(qg, e2);
        }
        function qg(t2, e2, r2) {
          if (3 === t2) {
            const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(Xg, {});
            e2.glyphs.push({ id: t3, bitmap: new qh({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
          } else 4 === t2 ? e2.ascender = r2.readSVarint() : 5 === t2 && (e2.descender = r2.readSVarint());
        }
        function Xg(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
        }
        const Hg = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Zg {
          constructor() {
            this.scale = 1, this.fontStack = "", this.image = null;
          }
          static forText(t2, e2) {
            const r2 = new Zg();
            return r2.scale = t2 || 1, r2.fontStack = e2, r2;
          }
          static forImage(t2) {
            const e2 = new Zg();
            return e2.image = t2, e2;
          }
        }
        class Wg {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e2, r2) {
            const n2 = new Wg();
            for (let i2 = 0; i2 < t2.sections.length; i2++) {
              const s2 = t2.sections[i2];
              s2.image ? n2.addImageSection(s2, r2) : n2.addTextSection(s2, e2);
            }
            return n2;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCodePoint(t2) {
            return this.text.codePointAt(t2);
          }
          verticalizePunctuation(t2) {
            this.text = function(t3, e2) {
              let r2 = "";
              for (let n2 = 0; n2 < t3.length; n2++) {
                const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
                r2 += !e2 && (i2 && Ca(i2) && !Sg[t3[n2 + 1]] || s2 && Ca(s2) && !Sg[t3[n2 - 1]]) || !Sg[t3[n2]] ? t3[n2] : Sg[t3[n2]];
              }
              return r2;
            }(this.text, t2);
          }
          trim() {
            let t2 = 0;
            for (let e3 = 0; e3 < this.text.length && Jg[this.text.charCodeAt(e3)]; e3++) t2++;
            let e2 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && Jg[this.text.charCodeAt(r2)]; r2--) e2--;
            this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
          }
          substring(t2, e2) {
            const r2 = new Wg();
            return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push(Zg.forText(t2.scale, t2.fontStack || e2));
            const r2 = this.sections.length - 1;
            for (let e3 = 0; e3 < t2.text.length; ++e3) this.sectionIndex.push(r2);
          }
          addImageSection(t2, e2) {
            const r2 = t2.image ? t2.image.getPrimary() : null;
            if (!r2) return void Zt("Can't add FormattedSection with an empty image.");
            r2.scaleSelf(e2);
            const n2 = this.getNextImageSectionCharCode();
            n2 ? (this.text += String.fromCodePoint(n2), this.sections.push(Zg.forImage(r2)), this.sectionIndex.push(this.sections.length - 1)) : Zt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Yg(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2 = 1) {
          const y2 = Wg.fromFeature(t2, i2, m2);
          h2 === Hg.vertical && y2.verticalizePunctuation(p2);
          let g2 = [];
          const x2 = function(t3, e3, r3, n3, i3, s3) {
            if (!t3) return [];
            const a3 = [], o3 = function(t4, e4, r4, n4, i4, s4) {
              let a4 = 0;
              for (let r5 = 0; r5 < t4.length(); r5++) {
                const o4 = t4.getSection(r5);
                a4 += Qg(t4.getCodePoint(r5), o4, n4, i4, e4, s4);
              }
              return a4 / Math.max(1, Math.ceil(a4 / r4));
            }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("") >= 0;
            let u3 = 0;
            for (let r4 = 0; r4 < t3.length(); r4++) {
              const c3 = t3.getSection(r4), h3 = t3.getCodePoint(r4);
              if (Jg[h3] || (u3 += Qg(h3, c3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
                const e4 = Ea(h3);
                (Kg[h3] || e4 || c3.image) && a3.push(rx(r4 + 1, u3, o3, a3, ex(h3, t3.getCodePoint(r4 + 1), e4 && l3), false));
              }
            }
            return nx(rx(t3.length(), u3, o3, a3, 0, true));
          }(y2, u2, s2, e2, n2, d2), { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Ya;
          if (v2 && 1 === y2.sections.length) {
            const t3 = v2(y2.toString(), x2);
            for (const e3 of t3) {
              const t4 = new Wg();
              t4.text = e3, t4.sections = y2.sections;
              for (let r3 = 0; r3 < e3.length; r3++) t4.sectionIndex.push(0);
              g2.push(t4);
            }
          } else if (b2) {
            const t3 = b2(y2.text, y2.sectionIndex, x2);
            for (const e3 of t3) {
              const t4 = new Wg();
              t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y2.sections, g2.push(t4);
            }
          } else g2 = function(t3, e3) {
            const r3 = [], n3 = t3.text;
            let i3 = 0;
            for (const n4 of e3) r3.push(t3.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
          }(y2, x2);
          const w2 = [], _2 = { positionedLines: w2, text: y2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
          if (function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
            let p3 = 0, d3 = 0, f3 = 0;
            const m3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
            let y3 = false;
            for (const t4 of i3) {
              const r4 = t4.getSections();
              for (const t5 of r4) {
                if (t5.image) continue;
                const r5 = e3[t5.fontStack];
                if (r5 && (y3 = void 0 !== r5.ascender && void 0 !== r5.descender, !y3)) break;
              }
              if (!y3) break;
            }
            let g3 = 0;
            for (const a4 of i3) {
              a4.trim();
              const i4 = a4.getMaxScale(), o4 = (i4 - 1) * Mg, x4 = { positionedGlyphs: [], lineOffset: 0 };
              t3.positionedLines[g3] = x4;
              const v4 = x4.positionedGlyphs;
              let b4 = 0;
              if (!a4.length()) {
                d3 += s3, ++g3;
                continue;
              }
              let w3 = 0, _3 = 0;
              for (let s4 = 0; s4 < a4.length(); s4++) {
                const o5 = a4.getSection(s4), f4 = a4.getSectionIndex(s4), m4 = a4.getCodePoint(s4);
                let g4 = o5.scale, x5 = null, A3 = null, M2 = null, I2 = Mg, S2 = 0, P2 = l3;
                P2 === Hg.vertical && Da(m4) && (P2 = Hg.horizontal);
                const z2 = !(P2 === Hg.horizontal || !c3 && !Fa(m4) || c3 && (Jg[m4] || Ra(m4)));
                if (o5.image) {
                  const e4 = n3.get(o5.image.toString());
                  if (!e4) continue;
                  M2 = o5.image, t3.iconsInText = t3.iconsInText || true, A3 = e4.paddedRect;
                  const r4 = e4.displaySize;
                  g4 = g4 * Mg / h3, x5 = { width: r4[0], height: r4[1], left: 0, top: -3, advance: z2 ? r4[1] : r4[0], localGlyph: false }, S2 = y3 ? -x5.height * g4 : i4 * Mg - 17 - r4[1] * g4, I2 = x5.advance;
                  const s5 = (z2 ? r4[0] : r4[1]) * g4 - Mg * i4;
                  s5 > 0 && s5 > b4 && (b4 = s5);
                } else {
                  const t4 = r3[o5.fontStack];
                  if (!t4) continue;
                  t4[m4] && (A3 = t4[m4]);
                  const n4 = e3[o5.fontStack];
                  if (!n4) continue;
                  const s5 = n4.glyphs[m4];
                  if (!s5) continue;
                  if (x5 = s5.metrics, I2 = 8203 !== m4 ? Mg : 0, y3) {
                    const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                    w3 < r4 && (w3 = r4, _3 = (t5 - e4) / 2 * g4), S2 = -t5 * g4;
                  } else S2 = (i4 - g4) * Mg - 17;
                }
                z2 ? (t3.verticalizable = true, v4.push({ glyph: m4, image: M2, x: p3, y: d3 + S2, vertical: z2, scale: g4, localGlyph: x5.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: x5, rect: A3 }), p3 += I2 * g4 + u3) : (v4.push({ glyph: m4, image: M2, x: p3, y: d3 + S2, vertical: z2, scale: g4, localGlyph: x5.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: x5, rect: A3 }), p3 += x5.advance * g4 + u3);
              }
              0 !== v4.length && (f3 = Math.max(p3 - u3, f3), y3 ? sx(v4, m3, b4, _3, s3 * i4 / 2) : sx(v4, m3, b4, 0, s3 / 2)), p3 = 0;
              const A2 = s3 * i4 + b4;
              x4.lineOffset = Math.max(b4, o4), d3 += A2, ++g3;
            }
            const x3 = d3, { horizontalAlign: v3, verticalAlign: b3 } = ix(a3);
            (function(t4, e4, r4, n4, i4, s4) {
              const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
              for (const e5 of t4) for (const t5 of e5.positionedGlyphs) t5.x += a4, t5.y += o4;
            })(t3.positionedLines, m3, v3, b3, f3, x3), t3.top += -b3 * x3, t3.bottom = t3.top + x3, t3.left += -v3 * f3, t3.right = t3.left + f3, t3.hasBaseline = y3;
          }(_2, e2, r2, n2, g2, a2, o2, l2, h2, u2, p2, f2), !function(t3) {
            for (const e3 of t3) if (0 !== e3.positionedGlyphs.length) return false;
            return true;
          }(w2)) return _2;
        }
        const Jg = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Kg = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Qg(t2, e2, r2, n2, i2, s2) {
          if (e2.image) {
            const t3 = n2.get(e2.image.toString());
            return t3 ? t3.displaySize[0] * e2.scale * Mg / s2 + i2 : 0;
          }
          {
            const n3 = r2[e2.fontStack], s3 = n3 && n3.glyphs[t2];
            return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
          }
        }
        function tx(t2, e2, r2, n2) {
          const i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function ex(t2, e2, r2) {
          let n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function rx(t2, e2, r2, n2, i2, s2) {
          let a2 = null, o2 = tx(e2, r2, i2, s2);
          for (const t3 of n2) {
            const n3 = tx(e2 - t3.x, r2, i2, s2) + t3.badness;
            n3 <= o2 && (a2 = t3, o2 = n3);
          }
          return { index: t2, x: e2, priorBreak: a2, badness: o2 };
        }
        function nx(t2) {
          return t2 ? nx(t2.priorBreak).concat(t2.index) : [];
        }
        function ix(t2) {
          let e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function sx(t2, e2, r2, n2, i2) {
          if (!(e2 || r2 || n2 || i2)) return;
          const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
          for (let e3 = 0; e3 <= s2; e3++) t2[e3].x -= o2, t2[e3].y += r2 + n2 + i2;
        }
        function ax(t2) {
          return void 0 !== t2.imagePrimary && void 0 !== t2.top && void 0 !== t2.bottom && void 0 !== t2.left && void 0 !== t2.right;
        }
        function ox(t2, e2, r2, n2) {
          const { horizontalAlign: i2, verticalAlign: s2 } = ix(n2), a2 = r2[0] - t2.displaySize[0] * i2, o2 = r2[1] - t2.displaySize[1] * s2;
          return { imagePrimary: t2, imageSecondary: e2, top: o2, bottom: o2 + t2.displaySize[1], left: a2, right: a2 + t2.displaySize[0] };
        }
        function lx(t2, e2, r2, n2, i2, s2) {
          const a2 = t2.imagePrimary;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e3 = a2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
          }
          const l2 = e2.left * s2, u2 = e2.right * s2;
          let c2, h2, p2, d2;
          "width" === r2 || "both" === r2 ? (d2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (d2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = d2 + a2.displaySize[0]);
          const f2 = e2.top * s2, m2 = e2.bottom * s2;
          return "height" === r2 || "both" === r2 ? (c2 = i2[1] + f2 - n2[0], p2 = i2[1] + m2 + n2[2]) : (c2 = i2[1] + (f2 + m2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { imagePrimary: a2, imageSecondary: void 0, top: c2, right: h2, bottom: p2, left: d2, collisionPadding: o2 };
        }
        function ux(t2) {
          return !t2.imagePrimary.stretchX;
        }
        function cx(t2) {
          return !t2.imagePrimary.stretchY;
        }
        function hx(t2) {
          return { width: t2.right - t2.left, height: t2.bottom - t2.top };
        }
        const px = 128;
        function dx(t2, e2, r2, n2) {
          const { expression: i2 } = e2;
          if ("constant" === i2.kind) return { kind: "constant", layoutSize: i2.evaluate(new Ja(t2 + 1, { worldview: r2 }), void 0, void 0, void 0, n2) };
          if ("source" === i2.kind) return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: s2 } = i2;
            let a2 = 0;
            for (; a2 < e3.length && e3[a2] <= t2; ) a2++;
            a2 = Math.max(0, a2 - 1);
            let o2 = a2;
            for (; o2 < e3.length && e3[o2] < t2 + 1; ) o2++;
            o2 = Math.min(e3.length - 1, o2);
            const l2 = e3[a2], u2 = e3[o2];
            return "composite" === i2.kind ? { kind: "composite", minZoom: l2, maxZoom: u2, interpolationType: s2 } : { kind: "camera", minZoom: l2, maxZoom: u2, minSize: i2.evaluate(new Ja(l2, { worldview: r2 }), void 0, void 0, void 0, n2), maxSize: i2.evaluate(new Ja(u2, { worldview: r2 }), void 0, void 0, void 0, n2), interpolationType: s2 };
          }
        }
        function fx(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
          return "source" === t2.kind ? n2 / px : "composite" === t2.kind ? dr(n2 / px, i2 / px, r2) : e2;
        }
        function mx(t2, e2, r2 = 1) {
          let n2 = 0, i2 = 0;
          if ("constant" === t2.kind) i2 = t2.layoutSize * r2;
          else if ("source" !== t2.kind) {
            const { interpolationType: s2, minZoom: a2, maxZoom: o2 } = t2, l2 = s2 ? Dt(Hi.interpolationFactor(s2, e2, a2, o2), 0, 1) : 0;
            "camera" === t2.kind ? i2 = dr(t2.minSize, t2.maxSize, l2) * r2 : n2 = l2 * r2;
          }
          return { uSizeT: n2, uSize: i2 };
        }
        class yx extends It {
          constructor(t2, e2, r2, n2, i2) {
            super(t2, e2), this.angle = n2, this.z = r2, void 0 !== i2 && (this.segment = i2);
          }
          clone() {
            return new yx(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function gx(t2, e2, r2, n2, i2) {
          if (void 0 === e2.segment) return true;
          let s2 = e2, a2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (a2--, a2 < 0) return false;
            o2 -= t2[a2].dist(s2), s2 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r2 / 2; ) {
            const e3 = t2[a2], r3 = t2[a2 + 1];
            if (!r3) return false;
            let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; ) u2 -= l2.shift().angleDelta;
            if (u2 > i2) return false;
            a2++, o2 += e3.dist(r3);
          }
          return true;
        }
        function xx(t2) {
          let e2 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function vx(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function bx(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function wx(t2, e2, r2, n2, i2, s2) {
          const a2 = vx(r2, i2, s2), o2 = bx(r2, n2) * s2;
          let l2 = 0;
          const u2 = xx(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
            if (l2 + s3 > u2) {
              const c2 = (u2 - l2) / s3, h2 = dr(n3.x, i3.x, c2), p2 = dr(n3.y, i3.y, c2), d2 = new yx(h2, p2, 0, i3.angleTo(n3), r3);
              return !a2 || gx(t2, d2, o2, a2, e2) ? d2 : void 0;
            }
            l2 += s3;
          }
        }
        function _x(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = vx(n2, s2, a2), c2 = bx(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), Ax(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
        }
        function Ax(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = s2 / 2, c2 = xx(t2);
          let h2 = 0, p2 = e2 - r2, d2 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const a3 = t2[e3], o3 = t2[e3 + 1], f2 = a3.dist(o3), m2 = o3.angleTo(a3);
            for (; p2 + r2 < h2 + f2; ) {
              p2 += r2;
              const y2 = (p2 - h2) / f2, g2 = dr(a3.x, o3.x, y2), x2 = dr(a3.y, o3.y, y2);
              if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r3 = new yx(g2, x2, 0, m2, e3);
                n2 && !gx(t2, r3, s2, n2, i2) || d2.push(r3);
              }
            }
            h2 += f2;
          }
          return o2 || d2.length || a2 || (d2 = Ax(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), d2;
        }
        function Mx(t2) {
          let e2 = 0, r2 = 0;
          for (const n3 of t2) e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t2.sort((t3, e3) => e3.h - t3.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
          let i2 = 0, s2 = 0;
          for (const e3 of t2) for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                e4 && t3 < n2.length && (n2[t3] = e4);
              } else e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
          return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
        }
        Qs(yx, "Anchor");
        class Ix {
          static getImagePositionScale(t2, e2, r2) {
            if (e2 && t2) {
              const { sx: e3, sy: r3 } = t2;
              return { x: e3, y: r3 };
            }
            return { x: r2, y: r2 };
          }
          constructor(t2, e2, r2, n2) {
            this.paddedRect = t2;
            const { pixelRatio: i2, version: s2, stretchX: a2, stretchY: o2, content: l2, sdf: u2, usvg: c2 } = e2;
            this.pixelRatio = i2, this.stretchX = a2, this.stretchY = o2, this.content = l2, this.version = s2, this.padding = r2, this.sdf = u2, this.usvg = c2, this.scale = Ix.getImagePositionScale(n2, c2, i2);
          }
          get tl() {
            return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];
          }
        }
        function Sx(t2, e2, r2) {
          const n2 = Lr.parse(t2), i2 = function(t3, e3, r3 = [1, 1]) {
            return { x: 0, y: 0, w: (t3.data ? t3.data.width : t3.width * r3[0]) + 2 * e3, h: (t3.data ? t3.data.height : t3.height * r3[1]) + 2 * e3 };
          }(e2, r2, [n2.sx, n2.sy]);
          return { bin: i2, imagePosition: new Ix(i2, e2, r2, n2), imageVariant: n2 };
        }
        class Px {
          constructor(t2, e2, r2) {
            const n2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map();
            this.haveRenderCallbacks = [];
            const s2 = [];
            this.addImages(t2, n2, 1, s2), this.addImages(e2, i2, 2, s2);
            const { w: a2, h: o2 } = Mx(s2), l2 = new Xh({ width: a2 || 1, height: o2 || 1 });
            for (const [e3, r3] of t2.entries()) {
              const t3 = n2.get(e3).paddedRect;
              Xh.copy(r3.data, l2, { x: 0, y: 0 }, { x: t3.x + 1, y: t3.y + 1 }, r3.data, null, r3.sdf);
            }
            for (const [t3, n3] of e2.entries()) {
              const e3 = i2.get(t3), s3 = e3.paddedRect;
              let a3 = e3.padding;
              const o3 = s3.x + a3, u2 = s3.y + a3, c2 = n3.data.width, h2 = n3.data.height;
              a3 = a3 > 1 ? a3 - 1 : a3, Xh.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3, y: u2 }, n3.data, r2), Xh.copy(n3.data, l2, { x: 0, y: h2 - a3 }, { x: o3, y: u2 - a3 }, { width: c2, height: a3 }, r2), Xh.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3, y: u2 + h2 }, { width: c2, height: a3 }, r2), Xh.copy(n3.data, l2, { x: c2 - a3, y: 0 }, { x: o3 - a3, y: u2 }, { width: a3, height: h2 }, r2), Xh.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3 + c2, y: u2 }, { width: a3, height: h2 }, r2), Xh.copy(n3.data, l2, { x: c2 - a3, y: h2 - a3 }, { x: o3 - a3, y: u2 - a3 }, { width: a3, height: a3 }, r2), Xh.copy(n3.data, l2, { x: 0, y: h2 - a3 }, { x: o3 + c2, y: u2 - a3 }, { width: a3, height: a3 }, r2), Xh.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3 + c2, y: u2 + h2 }, { width: a3, height: a3 }, r2), Xh.copy(n3.data, l2, { x: c2 - a3, y: 0 }, { x: o3 - a3, y: u2 + h2 }, { width: a3, height: a3 }, r2);
            }
            this.lut = r2, this.image = l2, this.iconPositions = n2, this.patternPositions = i2;
          }
          addImages(t2, e2, r2, n2) {
            for (const [i2, s2] of t2.entries()) {
              const { bin: t3, imagePosition: a2, imageVariant: o2 } = Sx(i2, s2, r2);
              e2.set(i2, a2), n2.push(t3), s2.hasRenderCallback && this.haveRenderCallbacks.push(o2.id);
            }
          }
          patchUpdatedImages(t2, e2, r2, n2) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3, r2)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks, r2);
            for (const i2 of t2.getUpdatedImages(r2)) {
              for (const n3 of this.iconPositions.keys()) {
                const s2 = Lr.parse(n3);
                if (sr.isEqual(s2.id, i2)) {
                  const s3 = t2.getImage(i2, r2);
                  this.patchUpdatedImage(this.iconPositions.get(n3), s3, e2, null);
                }
              }
              for (const s2 of this.patternPositions.keys()) {
                const a2 = Lr.parse(s2);
                if (sr.isEqual(a2.id, i2)) {
                  const a3 = t2.getImage(i2, r2);
                  this.patchUpdatedImage(this.patternPositions.get(s2), a3, e2, n2 || this.lut);
                }
              }
            }
          }
          patchUpdatedImage(t2, e2, r2, n2 = null) {
            if (!t2 || !e2) return;
            if (t2.version === e2.version) return;
            t2.version = e2.version;
            const [i2, s2] = t2.tl, a2 = t2.sdf;
            if (this.lut || a2) {
              const t3 = { width: e2.data.width, height: e2.data.height }, o2 = new Xh(t3);
              Xh.copy(e2.data, o2, { x: 0, y: 0 }, { x: 0, y: 0 }, t3, n2, a2), r2.update(o2, { position: { x: i2, y: s2 } });
            } else r2.update(e2.data, { position: { x: i2, y: s2 } });
          }
        }
        Qs(Ix, "ImagePosition"), Qs(Px, "ImageAtlas", { omit: ["lut"] });
        const zx = 1e20;
        function Bx(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          for (let u2 = e2; u2 < e2 + n2; u2++) kx(t2, r2 * s2 + u2, s2, i2, a2, o2, l2);
          for (let u2 = r2; u2 < r2 + i2; u2++) kx(t2, u2 * s2 + e2, 1, n2, a2, o2, l2);
        }
        function kx(t2, e2, r2, n2, i2, s2, a2) {
          s2[0] = 0, a2[0] = -zx, a2[1] = zx, i2[0] = t2[e2];
          for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
            i2[o2] = t2[e2 + o2 * r2];
            const n3 = o2 * o2;
            do {
              const t3 = s2[l2];
              u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
            } while (u2 <= a2[l2] && --l2 > -1);
            l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = zx;
          }
          for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
            for (; a2[l2 + 1] < o2; ) l2++;
            const n3 = s2[l2], u2 = o2 - n3;
            t2[e2 + o2 * r2] = i2[n3] + u2 * u2;
          }
        }
        const Tx = { none: 0, ideographs: 1, all: 2 };
        class Vx {
          constructor(t2, e2, r2) {
            this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.url = "", this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(t2, e2) {
            const r2 = [], n2 = this.url || oe.GLYPHS_URL;
            for (const e3 in t2) for (const n3 of t2[e3]) r2.push({ stack: e3, id: n3 });
            Lt(r2, ({ stack: t3, id: e3 }, r3) => {
              let i2 = this.entries[t3];
              i2 || (i2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let s2 = i2.glyphs[e3];
              if (void 0 !== s2) return void r3(null, { stack: t3, id: e3, glyph: s2 });
              if (s2 = this._tinySDF(i2, t3, e3), s2) return i2.glyphs[e3] = s2, void r3(null, { stack: t3, id: e3, glyph: s2 });
              const a2 = Math.floor(e3 / 256);
              if (256 * a2 > 65535) return Zt("glyphs > 65535 not supported"), void r3(null, { stack: t3, id: e3, glyph: s2 });
              if (i2.ranges[a2]) return void r3(null, { stack: t3, id: e3, glyph: s2 });
              let o2 = i2.requests[a2];
              o2 || (o2 = i2.requests[a2] = [], Vx.loadGlyphRange(t3, a2, n2, this.requestManager, (t4, e4) => {
                if (e4) {
                  i2.ascender = e4.ascender, i2.descender = e4.descender;
                  for (const t5 in e4.glyphs) this._doesCharSupportLocalGlyph(+t5) || (i2.glyphs[+t5] = e4.glyphs[+t5]);
                  i2.ranges[a2] = true;
                }
                for (const r4 of o2) r4(t4, e4);
                delete i2.requests[a2];
              })), o2.push((n3, i3) => {
                n3 ? r3(n3) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
              });
            }, (t3, r3) => {
              if (t3) e2(t3);
              else if (r3) {
                const t4 = {};
                for (const { stack: e3, id: n3, glyph: i2 } of r3) void 0 === t4[e3] && (t4[e3] = {}), void 0 === t4[e3].glyphs && (t4[e3].glyphs = {}), t4[e3].glyphs[n3] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
                e2(null, t4);
              }
            });
          }
          _doesCharSupportLocalGlyph(t2) {
            return this.localGlyphMode !== Tx.none && (this.localGlyphMode === Tx.all ? !!this.localFontFamily : !!this.localFontFamily && (va(t2) || _a(t2) || ca(t2) || ha(t2) || ua(t2) || xa(t2) || (e2 = t2) >= 131072 && e2 <= 173791 || ((t3) => t3 >= 66736 && t3 <= 66815)(t2)));
            var e2;
          }
          _tinySDF(t2, e2, r2) {
            const n2 = this.localFontFamily;
            if (!n2 || !this._doesCharSupportLocalGlyph(r2)) return;
            let i2 = t2.tinySDF;
            if (!i2) {
              let r3 = "400";
              /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new Vx.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 48, buffer: 6, radius: 16 }), i2.fontWeight = r3;
            }
            if (this.localGlyphs[i2.fontWeight][r2]) return this.localGlyphs[i2.fontWeight][r2];
            const s2 = String.fromCodePoint(r2), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h2, glyphTop: p2, glyphAdvance: d2 } = i2.draw(s2);
            return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new qh({ width: o2, height: l2 }, a2), metrics: { width: u2 / 2, height: c2 / 2, left: h2 / 2, top: p2 / 2 - 27, advance: d2 / 2, localGlyph: true } };
          }
        }
        function Ex(t2, e2) {
          return t2 + e2[1] - e2[0];
        }
        function Fx(t2, e2, r2, n2, i2 = 1) {
          const s2 = [], a2 = t2.imagePrimary, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2, u2 = a2.paddedRect.h - 2, c2 = (t2.right - t2.left) * i2, h2 = (t2.bottom - t2.top) * i2, p2 = a2.stretchX || [[0, l2]], d2 = a2.stretchY || [[0, u2]], f2 = p2.reduce(Ex, 0), m2 = d2.reduce(Ex, 0), y2 = l2 - f2, g2 = u2 - m2;
          let x2 = 0, v2 = f2, b2 = 0, w2 = m2, _2 = 0, A2 = y2, M2 = 0, I2 = g2;
          if (a2.content && n2) {
            const t3 = a2.content;
            x2 = Cx(p2, 0, t3[0]), b2 = Cx(d2, 0, t3[1]), v2 = Cx(p2, t3[0], t3[2]), w2 = Cx(d2, t3[1], t3[3]), _2 = t3[0] - x2, M2 = t3[1] - b2, A2 = t3[2] - t3[0] - v2, I2 = t3[3] - t3[1] - w2;
          }
          const S2 = (n3, s3, l3, u3) => {
            const p3 = Ox(n3.stretch - x2, v2, c2, t2.left * i2), d3 = Ux(n3.fixed - _2, A2, n3.stretch, f2), y3 = Ox(s3.stretch - b2, w2, h2, t2.top * i2), g3 = Ux(s3.fixed - M2, I2, s3.stretch, m2), S3 = Ox(l3.stretch - x2, v2, c2, t2.left * i2), P2 = Ux(l3.fixed - _2, A2, l3.stretch, f2), z2 = Ox(u3.stretch - b2, w2, h2, t2.top * i2), B2 = Ux(u3.fixed - M2, I2, u3.stretch, m2), k2 = new It(p3, y3), T2 = new It(S3, y3), V2 = new It(S3, z2), E2 = new It(p3, z2), F2 = new It(d3 / o2, g3 / o2), D2 = new It(P2 / o2, B2 / o2), C2 = e2 * Math.PI / 180;
            if (C2) {
              const t3 = Math.sin(C2), e3 = Math.cos(C2), r3 = [e3, -t3, t3, e3];
              k2._matMult(r3), T2._matMult(r3), E2._matMult(r3), V2._matMult(r3);
            }
            const R2 = n3.stretch + n3.fixed, L2 = l3.stretch + l3.fixed, O2 = s3.stretch + s3.fixed, U2 = u3.stretch + u3.fixed, N2 = t2.imageSecondary;
            return { tl: k2, tr: T2, bl: E2, br: V2, texPrimary: { x: a2.paddedRect.x + 1 + R2, y: a2.paddedRect.y + 1 + O2, w: L2 - R2, h: U2 - O2 }, texSecondary: N2 ? { x: N2.paddedRect.x + 1 + R2, y: N2.paddedRect.y + 1 + O2, w: L2 - R2, h: U2 - O2 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: D2, minFontScaleX: A2 / o2 / c2, minFontScaleY: I2 / o2 / h2, isSDF: r2 };
          };
          if (a2.stretchX || a2.stretchY) {
            const t3 = Rx(p2, y2, f2), e3 = Rx(d2, g2, m2);
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              const n3 = t3[r3], i3 = t3[r3 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++) s2.push(S2(n3, e3[t4], i3, e3[t4 + 1]));
            }
          } else s2.push(S2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
          return s2;
        }
        function Dx(t2, e2) {
          const r2 = t2.stretchY || [[0, t2.paddedRect.h - 2]];
          return t2.stretchX || t2.stretchY ? Lx(t2.stretchX || [[0, t2.paddedRect.w - 2]]) * Lx(r2) : 1;
        }
        function Cx(t2, e2, r2) {
          let n2 = 0;
          for (const i2 of t2) n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
          return n2;
        }
        function Rx(t2, e2, r2) {
          const n2 = [{ fixed: -1, stretch: 0 }];
          for (const [e3, r3] of t2) {
            const t3 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
          }
          return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
        }
        function Lx(t2) {
          return 2 * t2.length + 1;
        }
        function Ox(t2, e2, r2, n2) {
          return t2 / e2 * r2 + n2;
        }
        function Ux(t2, e2, r2, n2) {
          return t2 - e2 * r2 / n2;
        }
        function Nx(t2, e2, r2, n2) {
          const i2 = e2 + t2.positionedLines[n2].lineOffset;
          return 0 === n2 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
        }
        function jx(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = [];
          if (0 === e2.positionedLines.length) return u2;
          const c2 = (void 0 !== l2 ? l2 : n2.layout.get("text-rotate").evaluate(s2, {})) * Math.PI / 180, h2 = function(t3) {
            const e3 = t3[0], r3 = t3[1], n3 = e3 * r3;
            return n3 > 0 ? [e3, -r3] : n3 < 0 ? [-e3, r3] : 0 === e3 ? [r3, e3] : [r3, -e3];
          }(r2);
          let p2 = Math.abs(e2.top - e2.bottom);
          for (const t3 of e2.positionedLines) p2 -= t3.lineOffset;
          const d2 = e2.positionedLines.length, f2 = p2 / d2;
          let m2 = e2.top - r2[1];
          for (let t3 = 0; t3 < d2; ++t3) {
            const n3 = e2.positionedLines[t3];
            m2 = Nx(e2, f2, m2, t3);
            for (const t4 of n3.positionedGlyphs) {
              if (!t4.rect) continue;
              const n4 = t4.rect || {};
              let s3 = 4, l3 = true, p3 = 1, d3 = 0;
              if (t4.image) {
                const e3 = a2.get(t4.image.toString());
                if (!e3) continue;
                if (e3.sdf) {
                  Zt("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                l3 = false, p3 = e3.pixelRatio, s3 = 1 / p3;
              }
              const f3 = (i2 || o2) && t4.vertical, y2 = t4.metrics.advance * t4.scale / 2, g2 = t4.metrics, x2 = t4.rect;
              if (null === x2) continue;
              o2 && e2.verticalizable && (d3 = t4.image ? y2 - t4.metrics.width * t4.scale / 2 : 0);
              const v2 = i2 ? [t4.x + y2, t4.y] : [0, 0];
              let b2 = [0, 0], w2 = [0, 0], _2 = false;
              i2 || (f3 ? (w2 = [t4.x + y2 + h2[0], t4.y + h2[1] - d3], _2 = true) : b2 = [t4.x + y2 + r2[0], t4.y + r2[1] - d3]);
              const A2 = x2.w * t4.scale / (p3 * (t4.localGlyph ? 2 : 1)), M2 = x2.h * t4.scale / (p3 * (t4.localGlyph ? 2 : 1));
              let I2, S2, P2, z2;
              if (f3) {
                const e3 = t4.y - m2, r3 = new It(-y2, y2 - e3), n5 = -Math.PI / 2, i3 = new It(...w2);
                I2 = new It(-y2 + b2[0], b2[1]), I2._rotateAround(n5, r3)._add(i3), I2.x += -e3 + y2, I2.y -= (g2.left - s3) * t4.scale;
                const a3 = t4.image ? g2.advance * t4.scale : Mg * t4.scale, o3 = String.fromCodePoint(t4.glyph);
                Pg(o3) ? I2.x += (1 - s3) * t4.scale : zg(o3) ? I2.x += a3 - g2.height * t4.scale + (-s3 - 1) * t4.scale : I2.x += t4.image || g2.width + 2 * s3 === x2.w && g2.height + 2 * s3 === x2.h ? (a3 - M2) / 2 : (a3 - (g2.height + 2 * s3) * t4.scale) / 2, S2 = new It(I2.x, I2.y - A2), P2 = new It(I2.x + M2, I2.y), z2 = new It(I2.x + M2, I2.y - A2);
              } else {
                const e3 = (g2.left - s3) * t4.scale - y2 + b2[0], r3 = (-g2.top - s3) * t4.scale + b2[1], n5 = e3 + A2, i3 = r3 + M2;
                I2 = new It(e3, r3), S2 = new It(n5, r3), P2 = new It(e3, i3), z2 = new It(n5, i3);
              }
              if (c2) {
                let t5;
                t5 = i2 ? new It(0, 0) : _2 ? new It(h2[0], h2[1]) : new It(r2[0], r2[1]), I2._rotateAround(c2, t5), S2._rotateAround(c2, t5), P2._rotateAround(c2, t5), z2._rotateAround(c2, t5);
              }
              const B2 = new It(0, 0), k2 = new It(0, 0);
              u2.push({ tl: I2, tr: S2, bl: P2, br: z2, texPrimary: n4, texSecondary: void 0, writingMode: e2.writingMode, glyphOffset: v2, sectionIndex: t4.sectionIndex, isSDF: l3, pixelOffsetTL: B2, pixelOffsetBR: k2, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return u2;
        }
        function Gx(t2, e2 = 1, r2 = false) {
          let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          const o2 = t2[0];
          for (let t3 = 0; t3 < o2.length; t3++) {
            const e3 = o2[t3];
            (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
          }
          const l2 = Math.min(s2 - n2, a2 - i2);
          let u2 = l2 / 2;
          const c2 = new Nn([], $x);
          if (0 === l2) return new It(n2, i2);
          for (let e3 = n2; e3 < s2; e3 += l2) for (let r3 = i2; r3 < a2; r3 += l2) c2.push(new qx(e3 + u2, r3 + u2, u2, t2));
          let h2 = function(t3) {
            let e3 = 0, r3 = 0, n3 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
              const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
              r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
            }
            return new qx(r3 / e3, n3 / e3, 0, t3);
          }(t2), p2 = c2.length;
          for (; c2.length; ) {
            const n3 = c2.pop();
            (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u2 = n3.h / 2, c2.push(new qx(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new qx(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new qx(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new qx(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
          }
          return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
        }
        function $x(t2, e2) {
          return e2.max - t2.max;
        }
        Vx.loadGlyphRange = function(t2, e2, r2, n2, i2) {
          const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), Ce.Glyphs);
          Ue(o2, (t3, e3) => {
            if (t3) i2(t3);
            else if (e3) {
              const t4 = {}, r3 = function(t5) {
                return new Vg(t5).readFields($g, {});
              }(e3);
              for (const e4 of r3.glyphs) t4[e4.id] = e4;
              i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
            }
          });
        }, Vx.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal", lang: o2 = null } = {}) {
            this.buffer = e2, this.cutoff = n2, this.radius = r2, this.lang = o2;
            const l2 = this.size = t2 + 4 * e2, u2 = this._createCanvas(l2), c2 = this.ctx = u2.getContext("2d", { willReadFrequently: true });
            c2.font = `${a2} ${s2} ${t2}px ${i2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(l2 * l2), this.gridInner = new Float64Array(l2 * l2), this.f = new Float64Array(l2), this.z = new Float64Array(l2 + 1), this.v = new Uint16Array(l2);
          }
          _createCanvas(t2) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t2, e2;
          }
          draw(t2) {
            const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.ceil(r2), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, a2 + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h2 = Math.max(u2 * c2, 0), p2 = new Uint8ClampedArray(h2), d2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === o2 || 0 === l2) return d2;
            const { ctx: f2, buffer: m2, gridInner: y2, gridOuter: g2 } = this;
            this.lang && (f2.lang = this.lang), f2.clearRect(m2, m2, o2, l2), f2.fillText(t2, m2, m2 + a2);
            const x2 = f2.getImageData(m2, m2, o2, l2);
            g2.fill(zx, 0, h2), y2.fill(0, 0, h2);
            for (let t3 = 0; t3 < l2; t3++) for (let e3 = 0; e3 < o2; e3++) {
              const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
              if (0 === r3) continue;
              const n3 = (t3 + m2) * u2 + e3 + m2;
              if (1 === r3) g2[n3] = 0, y2[n3] = zx;
              else {
                const t4 = 0.5 - r3;
                g2[n3] = t4 > 0 ? t4 * t4 : 0, y2[n3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
            Bx(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), Bx(y2, m2, m2, o2, l2, u2, this.f, this.v, this.z);
            for (let t3 = 0; t3 < h2; t3++) {
              const e3 = Math.sqrt(g2[t3]) - Math.sqrt(y2[t3]);
              p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return d2;
          }
        };
        class qx {
          constructor(t2, e2, r2, n2) {
            this.p = new It(t2, e2), this.h = r2, this.d = function(t3, e3) {
              let r3 = false, n3 = 1 / 0;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const s2 = e3[i2];
                for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                  const i4 = s2[e4], o2 = s2[a2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Cc(t3, i4, o2));
                }
              }
              return (r3 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const Xx = Object.keys, Hx = Number.POSITIVE_INFINITY, Zx = Math.sqrt(2);
        function Wx(t2, e2, r2, n2, i2) {
          const s2 = ax(t2) && t2.collisionPadding ? t2.collisionPadding : [0, 0, 0, 0], a2 = { top: t2.top - s2[1], bottom: t2.bottom + s2[3], left: t2.left - s2[0], right: t2.right + s2[2], scaled: false };
          return void 0 !== n2 && function(t3, e3) {
            t3.top *= e3, t3.bottom *= e3, t3.left *= e3, t3.right *= e3, t3.scaled = true;
          }(a2, n2), r2 && function(t3, e3) {
            if (!e3) return;
            const r3 = Bt(e3), n3 = new It(t3.left, t3.top), i3 = new It(t3.right, t3.top), s3 = new It(t3.left, t3.bottom), a3 = new It(t3.right, t3.bottom), o2 = new It(0, 0);
            n3._rotateAround(r3, o2), i3._rotateAround(r3, o2), s3._rotateAround(r3, o2), a3._rotateAround(r3, o2), t3.left = Math.min(n3.x, i3.x, s3.x, a3.x), t3.right = Math.max(n3.x, i3.x, s3.x, a3.x), t3.top = Math.min(n3.y, i3.y, s3.y, a3.y), t3.bottom = Math.max(n3.y, i3.y, s3.y, a3.y);
          }(a2, r2), i2 && (a2.left += i2[0], a2.right += i2[0], a2.top += i2[1], a2.bottom += i2[1]), e2 ? { top: Math.min(e2.top, a2.top), bottom: Math.max(e2.bottom, a2.bottom), left: Math.min(e2.left, a2.left), right: Math.max(e2.right, a2.right), scaled: e2.scaled || a2.scaled } : a2;
        }
        function Yx(t2, [e2, r2]) {
          let n2 = 0, i2 = 0;
          if (r2 === Hx) {
            e2 < 0 && (e2 = 0);
            const r3 = e2 / Zx;
            switch (t2) {
              case "top-right":
              case "top-left":
                i2 = r3 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                i2 = 7 - r3;
                break;
              case "bottom":
                i2 = 7 - e2;
                break;
              case "top":
                i2 = e2 - 7;
            }
            switch (t2) {
              case "top-right":
              case "bottom-right":
                n2 = -r3;
                break;
              case "top-left":
              case "bottom-left":
                n2 = r3;
                break;
              case "left":
                n2 = e2;
                break;
              case "right":
                n2 = -e2;
            }
          } else {
            switch (e2 = Math.abs(e2), r2 = Math.abs(r2), t2) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = 7 - r2;
            }
            switch (t2) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e2;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e2;
            }
          }
          return [n2, i2];
        }
        function Jx(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2) {
          const m2 = t2.layers[0], y2 = m2.appearances;
          if (0 === y2.length) return { iconBBox: null, iconVerticalBBox: null, textBBox: null, textVerticalBBox: null };
          const g2 = { iconBBox: null, iconVerticalBBox: null }, x2 = { textBBox: null, textVerticalBBox: null }, { baseIconRotate: v2, baseTextRotate: b2, iconScaleFactor: w2 } = function(t3, e3, r3) {
            const n3 = t3.get("icon-rotate").evaluate(e3, {}, r3), i3 = t3.get("text-rotate").evaluate(e3, {}, r3), [s3, a3] = t3.get("icon-size-scale-range");
            return { baseIconRotate: n3, baseTextRotate: i3, iconScaleFactor: Dt(1, s3, a3) };
          }(n2, i2, s2);
          e2 && (g2.iconBBox = Wx(e2, g2.iconBBox, v2, a2), r2) && (g2.iconVerticalBBox = Wx(r2, g2.iconVerticalBBox, v2 + 90, a2));
          const _2 = gv(h2.horizontal);
          _2 && (x2.textBBox = Wx(_2, x2.textBBox, b2, 1, d2)), h2.vertical && (x2.textVerticalBBox = Wx(h2.vertical, x2.textVerticalBBox, b2 + 90, 1, d2));
          for (const r3 of y2) r3.hasIconProperties() && Kx(g2, t2, m2, r3, i2, s2, o2, v2, a2, l2, e2, u2, w2, c2, f2), r3.hasTextProperties() && tv(x2, m2, r3, i2, s2, d2, b2, p2, _2, h2.vertical);
          return { iconBBox: g2.iconBBox, iconVerticalBBox: g2.iconVerticalBBox, textBBox: x2.textBBox, textVerticalBBox: x2.textVerticalBBox };
        }
        function Kx(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2) {
          const { appearanceIconOffset: m2, appearanceIconRotate: y2, appearanceIconSize: g2 } = Qx(n2, r2, i2, s2, a2, o2, l2, u2.iconScaleFactor);
          let x2 = null, v2 = null, b2 = null;
          n2.hasProperty("icon-image") ? b2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
            let l3 = null;
            const u3 = e3.getAppearanceValueAndResolveTokens(r3, "icon-image", n3, i3, o3);
            if (u3) {
              const e4 = t3.getResolvedImageFromTokens(u3), c3 = r3.getUnevaluatedProperty("icon-size"), h3 = iv(e4, dx(t3.zoom, c3, t3.worldview, o3), c3, i3, t3.zoom, n3, t3.pixelRatio, a3, t3.worldview, o3);
              l3 = s3.get(h3.iconPrimary.toString());
            }
            return l3;
          }(e2, r2, n2, i2, s2, h2, p2, f2) : c2 && (b2 = c2.imagePrimary), b2 && (x2 = ox(b2, null, m2, d2), e2.allowVerticalPlacement && (v2 = ox(b2, null, m2, d2))), x2 && (t2.iconBBox = Wx(x2, t2.iconBBox, y2, g2)), v2 && (t2.iconVerticalBBox = Wx(v2, t2.iconVerticalBBox, y2 + 90, g2));
        }
        function Qx(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = t2.hasProperty("icon-offset") ? e2.getAppearanceValueAndResolveTokens(t2, "icon-offset", r2, n2, []) : null, u2 = l2 && Array.isArray(l2) ? l2 : i2, c2 = t2.hasProperty("icon-rotate") ? e2.getAppearanceValueAndResolveTokens(t2, "icon-rotate", r2, n2, []) : null, h2 = "number" == typeof c2 ? c2 : s2, p2 = t2.hasProperty("icon-size") ? e2.getAppearanceValueAndResolveTokens(t2, "icon-size", r2, n2, []) : null;
          return { appearanceIconOffset: u2, appearanceIconRotate: h2, appearanceIconSize: "number" == typeof p2 ? p2 * o2 : a2 };
        }
        function tv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          const { appearanceTextOffset: c2, appearanceTextRotate: h2, appearanceTextSize: p2 } = ev(r2, e2, n2, i2, s2, a2, o2), d2 = p2 / o2;
          l2 && (t2.textBBox = Wx(l2, t2.textBBox, h2, d2, c2)), u2 && (t2.textVerticalBBox = Wx(u2, t2.textVerticalBBox, h2 + 90, d2, c2));
        }
        function ev(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = t2.hasProperty("text-offset") ? e2.getAppearanceValueAndResolveTokens(t2, "text-offset", r2, n2, []) : null, l2 = o2 && Array.isArray(o2) ? [o2[0] * Mg, o2[1] * Mg] : i2, u2 = t2.hasProperty("text-rotate") ? e2.getAppearanceValueAndResolveTokens(t2, "text-rotate", r2, n2, []) : null, c2 = "number" == typeof u2 ? u2 : s2, h2 = t2.hasProperty("text-size") ? e2.getAppearanceValueAndResolveTokens(t2, "text-size", r2, n2, []) : null;
          return { appearanceTextOffset: l2, appearanceTextRotate: c2, appearanceTextSize: "number" == typeof h2 ? h2 : a2 };
        }
        function rv(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          if (!e2 || !e2.usvg) return;
          const u2 = hx(n2), c2 = hx(i2), h2 = "both" !== s2 && "width" !== s2 || !ux(n2) ? 1 : c2.width / u2.width, p2 = "both" !== s2 && "height" !== s2 || !cx(n2) ? 1 : c2.height / u2.height;
          r2.scaleSelf(h2, p2);
          const d2 = r2.toString();
          a2.set(d2, r2), o2.set(d2, e2);
          const { imagePosition: f2 } = Sx(d2, e2, 1);
          l2.set(d2, f2);
        }
        function nv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          if (!t2) return;
          const c2 = function(t3, e3, r3, n3, i3, s3, a3) {
            if ("camera" === t3.kind) return t3.maxSize;
            if ("composite" === t3.kind) {
              const n4 = e3.possiblyEvaluate(new Ja(t3.maxZoom, { worldview: s3 }), r3, a3).evaluate(i3, {}, r3, a3), o3 = e3.possiblyEvaluate(new Ja(t3.minZoom, { worldview: s3 }), r3, a3).evaluate(i3, {}, r3, a3);
              return Math.max(n4, o3);
            }
            return e3.possiblyEvaluate(new Ja(n3, { worldview: s3 }), r3, a3).evaluate(i3, {}, r3, a3);
          }(e2, r2, n2, i2, s2, l2, u2);
          return t2.scaleSelf(c2 * o2 * a2);
        }
        function iv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          return { iconPrimary: nv(t2.getPrimary(), e2, r2, n2, i2, s2, a2, o2, l2, u2), iconSecondary: nv(t2.getSecondary(), e2, r2, n2, i2, s2, a2, o2, l2, u2) };
        }
        function sv(t2, e2, r2) {
          if (!e2) return;
          const n2 = r2.get(t2.toString()), i2 = r2.get(e2.toString());
          n2 && i2 && (n2.paddedRect.w === i2.paddedRect.w && n2.paddedRect.h === i2.paddedRect.h || Zt(`Mismatch in icon variant sizes: ${t2.toString()} and ${e2.toString()}`), n2.usvg !== i2.usvg && Zt(`Mismatch in icon variant image types: ${t2.id} and ${e2.id}`));
        }
        function av(t2, e2, r2, n2) {
          if (!t2) return;
          const i2 = e2.get(r2.toString());
          if (t2.imagePrimary = i2, n2) {
            const r3 = e2.get(n2.toString());
            t2.imageSecondary = r3;
          }
        }
        function ov(t2, e2) {
          for (const r2 in t2.horizontal) lv(t2.horizontal[r2], e2);
          lv(t2.vertical, e2);
        }
        function lv(t2, e2) {
          if (t2) {
            for (const r2 of t2.positionedLines) for (const t3 of r2.positionedGlyphs) if (null !== t3.image) {
              const r3 = t3.image.toString();
              t3.rect = e2.get(r3).paddedRect;
            }
          }
        }
        function uv(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function cv(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = gv(s2.horizontal) || s2.vertical, c2 = r2.get("icon-text-fit-padding").evaluate(n2, {}, i2);
          let h2, p2 = e2;
          return e2 && "none" !== l2 && (t2.allowVerticalPlacement && s2.vertical && (h2 = lx(e2, s2.vertical, l2, c2, o2, a2)), u2 && (p2 = lx(e2, u2, l2, c2, o2, a2))), { defaultShapedIcon: p2, verticallyShapedIcon: h2 };
        }
        function hv(t2, e2) {
          return t2 * e2 / 24;
        }
        function pv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2, v2, b2, w2, _2, A2) {
          let M2 = a2.textMaxSize.evaluate(e2, {}, p2);
          void 0 === M2 ? M2 = o2 * a2.textScaleFactor : M2 *= a2.textScaleFactor;
          const I2 = t2.layers[0].layout, S2 = hv(o2, a2.textScaleFactor), P2 = gv(r2.horizontal) || r2.vertical, z2 = t2.hasAnyAppearanceProperty(["text-size", "text-offset", "text-rotate"]);
          if (("none" !== y2 || z2) && t2.appearanceFeatureData && t2.featureToAppearanceIndex[e2.index] < t2.appearanceFeatureData.length) {
            const r3 = t2.appearanceFeatureData[t2.featureToAppearanceIndex[e2.index]];
            r3 && (r3.textShaping = P2, r3.iconTextFitPadding = I2.get("icon-text-fit-padding").evaluate(e2, {}, p2), r3.fontScale = S2, r3.textScaleFactor = a2.textScaleFactor);
          }
          const B2 = "globe" === d2.name, k2 = t2.tilePixelRatio * M2 / 24, T2 = (R2 = t2.overscaling, t2.zoom > 18 && R2 > 2 && (R2 >>= 1), Math.max(jn / (512 * R2), 1) * I2.get("symbol-spacing")), V2 = I2.get("text-padding") * t2.tilePixelRatio, E2 = I2.get("icon-padding") * t2.tilePixelRatio, F2 = Bt(I2.get("text-max-angle")), D2 = "map" === I2.get("icon-rotation-alignment") && "point" !== v2, C2 = T2 / 2;
          var R2;
          false === t2.hasAnyIconTextFit && "none" !== y2 && (t2.hasAnyIconTextFit = true);
          const L2 = e2.properties ? +e2.properties[ac] : null, O2 = L2 && t2.elevationFeatureIdToIndex ? t2.elevationFeatureIdToIndex.get(L2) : 65535, U2 = (o3, l3, v3) => {
            if (l3.x < 0 || l3.x >= jn || l3.y < 0 || l3.y >= jn) return;
            let A3 = null;
            if (B2) {
              const { x: t3, y: e3, z: r3 } = d2.projectTilePoint(l3.x, l3.y, v3);
              A3 = { anchor: new yx(t3, e3, r3, 0, void 0), up: d2.upVector(v3, l3.x, l3.y) };
            }
            !function(t3, e3, r3, n3, i3, s3, a3, o4, l4, u3, c3, h3, p3, d3, f3, m3, y3, g3, x3, v4, b3, w3, _3, A4, M3, I3, S3, P3, z3, B3, k3, T3) {
              const V3 = t3.addToLineVertexArray(e3, n3);
              let E3, F3, D3, C3, R3, L3, O3, U3 = 0, N2 = 0, j2 = 0, G2 = 0, $2 = -1, q2 = -1;
              const X2 = {};
              let H2 = Qe("");
              const Z2 = r3 ? r3.anchor : e3, W2 = "none" !== P3;
              let Y2 = 0, J2 = 0;
              if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset")) {
                const t4 = l4.layout.get("text-offset").evaluate(b3, {}, M3);
                Y2 = t4[0] * Mg, J2 = t4[1] * Mg;
              } else Y2 = l4.layout.get("text-radial-offset").evaluate(b3, {}, M3) * Mg, J2 = Hx;
              if (t3.allowVerticalPlacement && i3.vertical) {
                const t4 = i3.vertical;
                if (f3) L3 = vv(t4), o4 && (O3 = vv(o4));
                else {
                  const r4 = l4.layout.get("text-rotate").evaluate(b3, {}, M3) + 90;
                  D3 = xv(u3, Z2, e3, c3, h3, p3, t4, d3, r4, m3, T3), o4 && (C3 = xv(u3, Z2, e3, c3, h3, p3, o4, g3, r4, null, k3));
                }
              }
              if (s3) {
                const n4 = l4.layout.get("icon-rotate").evaluate(b3, {}, M3), i4 = Fx(s3, n4, _3, W2, w3.iconScaleFactor), a4 = o4 ? Fx(o4, n4, _3, W2, w3.iconScaleFactor) : void 0;
                F3 = xv(u3, Z2, e3, c3, h3, p3, s3, g3, n4, null, B3);
                const d4 = function(t4, e4, r4, n5, i5, s4, a5, o5, l5, u4) {
                  const c4 = t4.layers[0], h4 = c4.appearances;
                  let p4 = e4.length;
                  if (r4 && (p4 = Math.max(p4, r4.length)), 0 === h4.length) return p4;
                  const [d5, f5] = n5.get("icon-size-scale-range"), m5 = Dt(1, d5, f5);
                  for (const e5 of h4) {
                    const r5 = e5.getUnevaluatedProperties();
                    if (void 0 !== r5._values["icon-image"].value) {
                      const n6 = c4.getAppearanceValueAndResolveTokens(e5, "icon-image", s4, a5, u4);
                      if (n6) {
                        const l6 = t4.getResolvedImageFromTokens(n6);
                        if (l6) {
                          const n7 = e5.hasProperty("icon-size") ? r5._values["icon-size"] : i5._values["icon-size"], c5 = iv(l6, dx(t4.zoom, n7, t4.worldview, u4), n7, a5, t4.zoom, s4, t4.pixelRatio, m5, t4.worldview, u4), h5 = o5.get(c5.iconPrimary.toString());
                          h5 && (p4 = Math.max(p4, Dx(h5)));
                        }
                      }
                    }
                  }
                  return p4;
                }(t3, i4, a4, l4.layout, l4._unevaluatedLayout, b3, M3, t3.iconAtlasPositions, 0, A4);
                U3 = 4 * d4;
                const f4 = l4.layout.get("icon-size").evaluate(b3, {}, M3, A4), m4 = w3.compositeIconSizes ? w3.compositeIconSizes[0].evaluate(b3, {}, M3, A4) : 0, y4 = w3.compositeIconSizes ? w3.compositeIconSizes[1].evaluate(b3, {}, M3, A4) : 0, P4 = yv(t3.layerIds[0], t3.iconSizeData, f4, w3.iconScaleFactor, m4, y4);
                t3.addSymbols(t3.icon, i4, P4, v4, x3, b3, void 0, r3, e3, V3.lineStartIndex, V3.lineLength, -1, A4, M3, I3, S3, t3.symbolInstances.length, d4), $2 = t3.icon.placedSymbolArray.length - 1, a4 && (N2 = 4 * d4, t3.addSymbols(t3.icon, a4, P4, v4, x3, b3, Hg.vertical, r3, e3, V3.lineStartIndex, V3.lineLength, -1, A4, M3, I3, S3, t3.symbolInstances.length, d4), q2 = t3.icon.placedSymbolArray.length - 1);
              }
              for (const n4 in i3.horizontal) {
                const s4 = n4, o5 = i3.horizontal[s4];
                E3 || (H2 = Qe(o5.text), f3 ? R3 = vv(o5) : E3 = xv(u3, Z2, e3, c3, h3, p3, o5, d3, l4.layout.get("text-rotate").evaluate(b3, {}, M3), m3, T3));
                const y4 = 1 === o5.positionedLines.length;
                if (j2 += mv(t3, r3, e3, o5, a3, l4, f3, b3, m3, V3, i3.vertical ? Hg.horizontal : Hg.horizontalOnly, y4 ? Xx(i3.horizontal) : [s4], X2, $2, w3, A4, M3, t3.symbolInstances.length, I3), y4) break;
              }
              i3.vertical && (G2 += mv(t3, r3, e3, i3.vertical, a3, l4, f3, b3, m3, V3, Hg.vertical, ["vertical"], X2, q2, w3, A4, M3, t3.symbolInstances.length, I3));
              let K2 = -1;
              const Q2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
              K2 = Q2(R3, K2), K2 = Q2(L3, K2), K2 = Q2(O3, K2);
              const tt2 = K2 > -1 ? 1 : 0;
              t3.glyphOffsetArray.length >= 65535 && Zt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b3.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, Z2.x, Z2.y, Z2.z, X2.right >= 0 ? X2.right : -1, X2.center >= 0 ? X2.center : -1, X2.left >= 0 ? X2.left : -1, X2.vertical >= 0 ? X2.vertical : -1, $2, q2, H2, void 0 !== E3 ? E3 : t3.collisionBoxArray.length, void 0 !== E3 ? E3 + 1 : t3.collisionBoxArray.length, void 0 !== D3 ? D3 : t3.collisionBoxArray.length, void 0 !== D3 ? D3 + 1 : t3.collisionBoxArray.length, void 0 !== F3 ? F3 : t3.collisionBoxArray.length, void 0 !== F3 ? F3 + 1 : t3.collisionBoxArray.length, C3 || t3.collisionBoxArray.length, C3 ? C3 + 1 : t3.collisionBoxArray.length, c3, j2, G2, U3, N2, tt2, 0, Y2, J2, K2, 0, W2 ? 1 : 0, z3);
            }(t2, l3, A3, o3, r2, n2, s2, i2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, V2, x2, u2, 0, E2, D2, g2, e2, a2, c2, h2, p2, f2, m2, y2, O2, b2, w2, _2);
          };
          if ("line" === v2) for (const i3 of Ef(e2.geometry, 0, 0, jn, jn)) {
            const e3 = _x(i3, T2, F2, r2.vertical || P2, n2, 24, k2, t2.overscaling, jn);
            for (const r3 of e3) P2 && bv(t2, P2.text, C2, r3) || U2(i3, r3, p2);
          }
          else if ("line-center" === v2) {
            for (const t3 of e2.geometry) if (t3.length > 1) {
              const e3 = wx(t3, F2, r2.vertical || P2, n2, 24, k2);
              e3 && U2(t3, e3, p2);
            }
          } else if ("Polygon" === e2.type) for (const t3 of Ip(e2.geometry, 0)) {
            const e3 = Gx(t3, 16);
            U2(t3[0], new yx(e3.x, e3.y, 0, 0, void 0), p2);
          }
          else if ("LineString" === e2.type) for (const t3 of e2.geometry) U2(t3, new yx(t3[0].x, t3[0].y, 0, 0, void 0), p2);
          else if ("Point" === e2.type) for (const t3 of e2.geometry) for (const e3 of t3) U2([e3], new yx(e3.x, e3.y, 0, 0, void 0), p2);
        }
        const dv = 255, fv = dv * px;
        function mv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2, x2) {
          const v2 = jx(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement, void 0), b2 = s2.layout.get("text-size").evaluate(o2, {}, y2), w2 = f2.compositeTextSizes ? f2.compositeTextSizes[0].evaluate(o2, {}, y2) : 0, _2 = f2.compositeTextSizes ? f2.compositeTextSizes[1].evaluate(o2, {}, y2) : 0, A2 = yv(t2.layerIds[0], t2.textSizeData, b2, f2.textScaleFactor, w2, _2);
          t2.addSymbols(t2.text, v2, A2, l2, a2, o2, c2, e2, r2, u2.lineStartIndex, u2.lineLength, d2, m2, y2, x2, false, g2, v2.length);
          for (const e3 of h2) p2[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * v2.length;
        }
        function yv(t2, e2, r2, n2, i2, s2) {
          const a2 = e2;
          let o2 = null;
          return "source" === a2.kind ? (o2 = [px * r2 * n2], o2[0] > fv && Zt(`${t2}: Value for "text-size" is >= ${dv}. Reduce your "text-size".`)) : "composite" === a2.kind && (o2 = [px * i2 * n2, px * s2 * n2], (o2[0] > fv || o2[1] > fv) && Zt(`${t2}: Value for "text-size" is >= ${dv}. Reduce your "text-size".`)), o2;
        }
        function gv(t2) {
          for (const e2 in t2) return t2[e2];
          return null;
        }
        function xv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
          let h2, p2, d2, f2;
          if (h2 = c2 ? c2.top : a2.top, p2 = c2 ? c2.bottom : a2.bottom, d2 = c2 ? c2.left : a2.left, f2 = c2 ? c2.right : a2.right, ax(a2) && a2.collisionPadding) {
            const t3 = a2.collisionPadding;
            d2 -= t3[0], h2 -= t3[1], f2 += t3[2], p2 += t3[3];
          }
          if (l2) {
            const t3 = new It(d2, h2), e3 = new It(f2, h2), r3 = new It(d2, p2), n3 = new It(f2, p2), i3 = Bt(l2);
            let s3 = new It(0, 0);
            u2 && (s3 = new It(u2[0], u2[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), d2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), h2 = Math.min(t3.y, e3.y, r3.y, n3.y), p2 = Math.max(t3.y, e3.y, r3.y, n3.y);
          }
          return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, d2, h2, f2, p2, o2, n2, i2, s2), t2.length - 1;
        }
        function vv(t2) {
          ax(t2) && t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
          const e2 = t2.bottom - t2.top;
          return e2 > 0 ? Math.max(10, e2) : null;
        }
        function bv(t2, e2, r2, n2) {
          const i2 = t2.compareText;
          if (e2 in i2) {
            const t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n2.dist(t3[e3]) < r2) return true;
          } else i2[e2] = [];
          return i2[e2].push(n2), false;
        }
        function wv(t2, e2) {
          const r2 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01));
          let a2 = Math.sin(t2._pitch) * s2 + i2;
          const o2 = i2 * (1 / t2._horizonShift);
          if (!t2.elevation || 0 === t2.elevation.exaggeration()) {
            let e3 = Math.max(t2.zoom - 17, 0);
            t2.isOrthographic && (e3 /= 10), a2 *= 1 + e3;
          }
          return Math.min(1.01 * a2, o2);
        }
        function _v(t2, e2) {
          if (!e2.isReprojectedInTileSpace) return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
          const r2 = Math.pow(2, -t2.z), n2 = t2.x * r2, i2 = (t2.x + 1) * r2, s2 = t2.y * r2, a2 = (t2.y + 1) * r2, o2 = Du(n2), l2 = Du(i2), u2 = Cu(s2), c2 = Cu(a2), h2 = e2.project(o2, u2), p2 = e2.project(l2, u2), d2 = e2.project(l2, c2), f2 = e2.project(o2, c2);
          let m2 = Math.min(h2.x, p2.x, d2.x, f2.x), y2 = Math.min(h2.y, p2.y, d2.y, f2.y), g2 = Math.max(h2.x, p2.x, d2.x, f2.x), x2 = Math.max(h2.y, p2.y, d2.y, f2.y);
          const v2 = r2 / 16;
          function b2(t3, r3, n3, i3, s3, a3) {
            const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e2.project(Du(o3), Cu(l3)), c3 = Math.max(0, m2 - u3.x, y2 - u3.y, u3.x - g2, u3.y - x2);
            m2 = Math.min(m2, u3.x), g2 = Math.max(g2, u3.x), y2 = Math.min(y2, u3.y), x2 = Math.max(x2, u3.y), c3 > v2 && (b2(t3, u3, n3, i3, o3, l3), b2(u3, r3, o3, l3, s3, a3));
          }
          b2(h2, p2, n2, s2, i2, s2), b2(p2, d2, i2, s2, i2, a2), b2(d2, f2, i2, a2, n2, a2), b2(f2, h2, n2, a2, n2, s2), m2 -= v2, y2 -= v2, g2 += v2, x2 += v2;
          const w2 = 1 / Math.max(g2 - m2, x2 - y2);
          return { scale: w2, x: m2 * w2, y: y2 * w2, x2: g2 * w2, y2: x2 * w2, projection: e2 };
        }
        function Av(t2, { x: e2, y: r2 }, n2 = 0) {
          return new It(((e2 - n2) * t2.scale - t2.x) * jn, (r2 * t2.scale - t2.y) * jn);
        }
        const Mv = u(new Float32Array(16));
        class Iv {
          constructor(t2) {
            this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(t2, e2) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(t2, e2) {
            return new Bu(0, 0);
          }
          projectTilePoint(t2, e2, r2) {
            return { x: t2, y: e2, z: 0 };
          }
          locationPoint(t2, e2, r2, n2 = true) {
            return t2._coordinatePoint(t2.locationCoordinate(e2, r2), n2);
          }
          pixelsPerMeter(t2, e2) {
            return Fu(1, t2) * e2;
          }
          pixelSpaceConversion(t2, e2, r2) {
            return 1;
          }
          farthestPixelDistance(t2) {
            return wv(t2, t2.pixelsPerMeter);
          }
          pointCoordinate(t2, e2, r2, n2) {
            const i2 = t2.horizonLineFromTop(false), s2 = new It(e2, Math.max(i2, r2));
            return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
          }
          pointCoordinate3D(t2, e2, r2) {
            const n2 = new It(e2, r2);
            if (t2.elevation) return t2.elevation.pointCoordinate(n2);
            {
              const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
              return [e3.x, e3.y, e3.z];
            }
          }
          isPointAboveHorizon(t2, e2) {
            if (t2.elevation && t2.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t2, e2.x, e2.y);
            const r2 = t2.horizonLineFromTop();
            return e2.y < r2;
          }
          createInversionMatrix(t2, e2) {
            return Mv;
          }
          createTileMatrix(t2, e2, r2) {
            let n2, i2, s2;
            const a2 = r2.canonical, o2 = u(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const l2 = _v(a2, this);
              n2 = 1, i2 = l2.x + r2.wrap * l2.scale, s2 = l2.y, d(o2, o2, [n2 / l2.scale, n2 / l2.scale, t2.pixelsPerMeter / e2]);
            } else n2 = e2 / t2.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r2.wrap) * n2, s2 = a2.y * n2;
            return p(o2, o2, [i2, s2, 0]), d(o2, o2, [n2 / jn, n2 / jn, 1]), o2;
          }
          upVector(t2, e2, r2) {
            return [0, 0, 1];
          }
          upVectorScale(t2, e2, r2) {
            return { metersToTile: 1 };
          }
        }
        class Sv extends Iv {
          constructor(t2) {
            super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
            const [e2, r2] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(Bt(e2));
            this.n = (n2 + Math.sin(Bt(r2))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(t2, e2) {
            const { n: r2, c: n2, r0: i2 } = this, s2 = Bt(t2 - this.center[0]), a2 = Bt(e2), o2 = Math.sqrt(n2 - 2 * r2 * Math.sin(a2)) / r2;
            return { x: o2 * Math.sin(s2 * r2), y: o2 * Math.cos(s2 * r2) - i2, z: 0 };
          }
          unproject(t2, e2) {
            const { n: r2, c: n2, r0: i2 } = this, s2 = i2 + e2;
            let a2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
            s2 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
            const o2 = Bt(this.center[0]) * r2;
            a2 = Rt(a2, -Math.PI - o2, Math.PI - o2);
            const l2 = Dt(kt(a2 / r2) + this.center[0], -180, 180), u2 = Math.asin(Dt((n2 - (t2 * t2 + s2 * s2) * r2 * r2) / (2 * r2), -1, 1)), c2 = Dt(kt(u2), -85.051129, Lu);
            return new Bu(l2, c2);
          }
        }
        const Pv = 1.340264, zv = -0.081106, Bv = 893e-6, kv = 3796e-6, Tv = Math.sqrt(3) / 2;
        class Vv extends Iv {
          project(t2, e2) {
            e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
            const r2 = Math.asin(Tv * Math.sin(e2)), n2 = r2 * r2, i2 = n2 * n2 * n2;
            return { x: 0.5 * (t2 * Math.cos(r2) / (Tv * (Pv + 3 * zv * n2 + i2 * (7 * Bv + 9 * kv * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (Pv + zv * n2 + i2 * (Bv + kv * n2)) / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI;
            let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = r2 * r2, i2 = n2 * n2 * n2;
            for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r2 * (Pv + zv * n2 + i2 * (Bv + kv * n2)) - e2, a3 = Pv + 3 * zv * n2 + i2 * (7 * Bv + 9 * kv * n2), t3 = s3 / a3, r2 = Dt(r2 - t3, -Math.PI / 3, Math.PI / 3), n2 = r2 * r2, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++o3) ;
            const s2 = Tv * t2 * (Pv + 3 * zv * n2 + i2 * (7 * Bv + 9 * kv * n2)) / Math.cos(r2), a2 = Math.asin(Math.sin(r2) / Tv), o2 = Dt(180 * s2 / Math.PI, -180, 180), l2 = Dt(180 * a2 / Math.PI, -85.051129, Lu);
            return new Bu(o2, l2);
          }
        }
        class Ev extends Iv {
          constructor(t2) {
            super(t2), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t2, e2) {
            return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
          }
          unproject(t2, e2) {
            const r2 = 360 * (t2 - 0.5), n2 = Dt(360 * (0.5 - e2), -85.051129, Lu);
            return new Bu(r2, n2);
          }
        }
        const Fv = Math.PI / 2;
        function Dv(t2) {
          return Math.tan((Fv + t2) / 2);
        }
        class Cv extends Iv {
          constructor(t2) {
            super(t2), this.center = t2.center || [0, 30];
            const [e2, r2] = this.parallels = t2.parallels || [30, 30];
            let n2 = Bt(e2), i2 = Bt(r2);
            this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
            const s2 = Math.cos(n2), a2 = Dv(n2);
            this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log(Dv(i2) / a2), this.f = s2 * Math.pow(Dv(n2), this.n) / this.n;
          }
          project(t2, e2) {
            e2 = Bt(e2), this.southernCenter && (e2 = -e2), t2 = Bt(t2 - this.center[0]);
            const r2 = 1e-6, { n: n2, f: i2 } = this;
            i2 > 0 ? e2 < -Fv + r2 && (e2 = -Fv + r2) : e2 > Fv - r2 && (e2 = Fv - r2);
            const s2 = i2 / Math.pow(Dv(e2), n2);
            let a2 = s2 * Math.sin(n2 * t2), o2 = i2 - s2 * Math.cos(n2 * t2);
            return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
            const { n: r2, f: n2 } = this, i2 = n2 - e2, s2 = Math.sign(i2), a2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
            let o2 = Math.atan2(t2, Math.abs(i2)) * s2;
            i2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * s2);
            const l2 = Dt(kt(o2 / r2) + this.center[0], -180, 180), u2 = Dt(kt(2 * Math.atan(Math.pow(n2 / a2, 1 / r2)) - Fv), -85.051129, Lu);
            return new Bu(l2, this.southernCenter ? -u2 : u2);
          }
        }
        class Rv extends Iv {
          constructor(t2) {
            super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
          }
          project(t2, e2) {
            return { x: Vu(t2), y: Eu(e2), z: 0 };
          }
          unproject(t2, e2) {
            const r2 = Du(t2), n2 = Cu(e2);
            return new Bu(r2, n2);
          }
        }
        const Lv = Bt(Lu);
        class Ov extends Iv {
          project(t2, e2) {
            const r2 = (e2 = Bt(e2)) * e2, n2 = r2 * r2;
            return { x: 0.5 * ((t2 = Bt(t2)) * (0.8707 - 0.131979 * r2 + n2 * (n2 * (3971e-6 * r2 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r2 * (0.015085 + n2 * (0.028874 * r2 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI;
            let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r2 * r2;
            do {
              s2 = r2 * r2;
              const t3 = s2 * s2;
              i2 = (r2 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r2 = Dt(r2 - i2, -Lv, Lv);
            } while (Math.abs(i2) > 1e-6 && --n2 > 0);
            s2 = r2 * r2;
            const a2 = Dt(kt(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = kt(r2);
            return new Bu(a2, o2);
          }
        }
        const Uv = Bt(Lu);
        class Nv extends Iv {
          project(t2, e2) {
            e2 = Bt(e2), t2 = Bt(t2);
            const r2 = Math.cos(e2), n2 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n2 + 2 * r2 * Math.sin(t2 / 2) / s2) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
            return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
            const s2 = 1e-6;
            let a2 = 0, o2 = 0;
            do {
              const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u2 = s3 * s3, c2 = i3 * i3, h2 = Math.cos(r2 / 2), p2 = Math.sin(r2 / 2), d2 = 2 * h2 * p2, f2 = p2 * p2, m2 = 1 - c2 * h2 * h2, y2 = m2 ? 1 / m2 : 0, g2 = m2 ? Math.acos(i3 * h2) * Math.sqrt(1 / m2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r2 / Math.PI) - t2, v2 = 0.5 * (g2 * s3 + n2) - e2, b2 = 0.5 * y2 * (c2 * f2 + g2 * i3 * h2 * u2) + 1 / Math.PI, w2 = y2 * (d2 * l2 / 4 - g2 * s3 * p2), _2 = 0.125 * y2 * (l2 * p2 - g2 * s3 * c2 * d2), A2 = 0.5 * y2 * (u2 * h2 + g2 * f2 * i3) + 0.5, M2 = w2 * _2 - A2 * b2;
              a2 = (v2 * w2 - x2 * A2) / M2, o2 = (x2 * _2 - v2 * b2) / M2, r2 = Dt(r2 - a2, -Math.PI, Math.PI), n2 = Dt(n2 - o2, -Uv, Uv);
            } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
            return new Bu(kt(r2), kt(n2));
          }
        }
        class jv extends Iv {
          constructor(t2) {
            super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Bt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t2, e2) {
            const { scale: r2, cosPhi: n2 } = this;
            return { x: Bt(t2) * n2 * r2 + 0.5, y: -Math.sin(Bt(e2)) / n2 * r2 + 0.5, z: 0 };
          }
          unproject(t2, e2) {
            const { scale: r2, cosPhi: n2 } = this, i2 = -(e2 - 0.5) / r2, s2 = Dt(kt((t2 - 0.5) / r2) / n2, -180, 180), a2 = Math.asin(Dt(i2 * n2, -1, 1)), o2 = Dt(kt(a2), -85.051129, Lu);
            return new Bu(s2, o2);
          }
        }
        class Gv extends Rv {
          constructor(t2) {
            super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(t2, e2, r2) {
            const n2 = yh(t2, e2, r2);
            return j(n2, n2, vh(ch(r2))), { x: n2[0], y: n2[1], z: n2[2] };
          }
          locationPoint(t2, e2, r2) {
            const n2 = Su(e2.lat, e2.lng), i2 = L([], n2), s2 = r2 ? t2._centerAltitude + r2 : t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude;
            E(n2, n2, i2, Fu(1, 0) * jn * s2);
            const a2 = u(new Float64Array(16));
            return h(a2, t2.pixelMatrix, t2.globeMatrix), j(n2, n2, a2), new It(n2[0], n2[1]);
          }
          pixelsPerMeter(t2, e2) {
            return Fu(1, 0) * e2;
          }
          pixelSpaceConversion(t2, e2, r2) {
            const n2 = Fu(1, t2) * e2, i2 = dr(Fu(1, 45) * e2, n2, r2);
            return this.pixelsPerMeter(t2, e2) / i2;
          }
          createTileMatrix(t2, e2, r2) {
            const n2 = bh(ch(r2.canonical));
            return h(new Float64Array(16), t2.globeMatrix, n2);
          }
          createInversionMatrix(t2, e2) {
            const { center: r2 } = t2, n2 = vh(ch(e2));
            return m(n2, n2, Bt(r2.lng)), f(n2, n2, Bt(r2.lat)), d(n2, n2, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n2);
          }
          pointCoordinate(t2, e2, r2, n2) {
            return oh(t2, e2, r2, true) || new Gu(0, 0);
          }
          pointCoordinate3D(t2, e2, r2) {
            const n2 = this.pointCoordinate(t2, e2, r2, 0);
            return [n2.x, n2.y, n2.z];
          }
          isPointAboveHorizon(t2, e2) {
            return !oh(t2, e2.x, e2.y, false);
          }
          farthestPixelDistance(t2) {
            const e2 = function(t3, e3) {
              const r3 = t3.cameraToCenterDistance, n2 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), a2 = P([], V([], s2, -r3), [0, 0, n2]), o2 = t3.worldSize / (2 * Math.PI), l2 = [0, 0, -o2], u2 = t3.width / t3.height, c2 = Math.tan(t3.fovAboveCenter), h2 = V([], i2.up(), c2), p2 = V([], i2.right(), c2 * u2), d2 = L([], P([], P([], s2, h2), p2)), f2 = [];
              let m2;
              if (new fc(a2, d2).closestPointOnSphere(l2, o2, f2)) {
                const e4 = P([], f2, l2), r4 = H([], e4, a2);
                m2 = Math.cos(t3.fovAboveCenter) * M(r4);
              } else {
                const t4 = H([], a2, l2), e4 = H([], l2, a2);
                L(e4, e4);
                const r4 = M(t4) - o2;
                m2 = Math.sqrt(r4 * (r4 + 2 * o2));
                const n3 = Math.acos(m2 / (o2 + r4)) - Math.acos(O(s2, e4));
                m2 *= Math.cos(n3);
              }
              return 1.01 * m2;
            }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r2 = Mh(t2.zoom);
            if (r2 > 0) {
              const n2 = wv(t2, Fu(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s2 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
              return dr(e2, n2 + i2 * (1 - Math.cos(s2)), Math.pow(r2, 10));
            }
            return e2;
          }
          upVector(t2, e2, r2) {
            return yh(e2, r2, t2, 1);
          }
          upVectorScale(t2) {
            return { metersToTile: sh(gh(ch(t2))) };
          }
        }
        function $v(t2) {
          const e2 = t2.parallels, r2 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
          switch (t2.name) {
            case "mercator":
              return new Rv(t2);
            case "equirectangular":
              return new Ev(t2);
            case "naturalEarth":
              return new Ov(t2);
            case "equalEarth":
              return new Vv(t2);
            case "winkelTripel":
              return new Nv(t2);
            case "albers":
              return r2 ? new jv(t2) : new Sv(t2);
            case "lambertConformalConic":
              return r2 ? new jv(t2) : new Cv(t2);
            case "globe":
              return new Gv(t2);
          }
          throw new Error(`Invalid projection name: ${t2.name}`);
        }
        const qv = Qu.types, Xv = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Hv(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const d2 = o2 ? Math.min(fv, Math.round(o2[0])) : 0, f2 = o2 ? Math.min(fv, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (d2 << 1) + (l2 ? 1 : 0), 0 + (f2 << 1), 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function Zv(t2, e2, r2) {
          t2.emplaceBack(e2, r2);
        }
        function Wv(t2, e2, r2, n2, i2, s2, a2) {
          t2.emplaceBack(e2, r2, n2, i2, s2, a2);
        }
        const Yv = (t2, e2, r2, n2) => {
          for (let i2 = 0; i2 < e2; i2++) t2.emplaceBack(r2[0], r2[1], r2[2], n2[0], n2[1], n2[2]);
        };
        function Jv(t2, e2, r2, n2, i2) {
          t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2);
        }
        function Kv(t2) {
          for (const e2 of t2.sections) if (Ua(e2.text)) return true;
          return false;
        }
        class Qv {
          constructor(t2) {
            this.layoutVertexArray = new Qo(), this.indexArray = new ll(), this.programConfigurations = t2, this.segments = new Ol(), this.dynamicLayoutVertexArray = new el(), this.opacityVertexArray = new rl(), this.placedSymbolArray = new Sl(), this.iconTransitioningVertexArray = new nl(), this.globeExtVertexArray = new tl(), this.zOffsetVertexArray = new $o(), this.orientationVertexArray = new hl(), this.symbolInstanceIndices = [];
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
          }
          getSymbolVertexData(t2, e2) {
            const r2 = [], n2 = this.layoutVertexArray.uint16;
            for (let i2 = 0; i2 < e2; ++i2) {
              const e3 = 12 * (t2 + i2);
              r2.push(...n2.slice(e3, e3 + 12));
            }
            return r2;
          }
          updateSymbolVertexData(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const d2 = this.layoutVertexArray.uint16, f2 = 12 * t2;
            d2[f2] = e2, d2[f2 + 1] = r2, d2[f2 + 2] = n2, d2[f2 + 3] = i2, d2[f2 + 4] = s2, d2[f2 + 5] = a2, d2[f2 + 6] = o2, d2[f2 + 7] = l2, d2[f2 + 8] = u2, d2[f2 + 9] = c2, d2[f2 + 10] = h2, d2[f2 + 11] = p2;
          }
          upload(t2, e2, r2, n2, i2, s2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, fg.members, !!s2), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, yg.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Xv, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t2.createVertexBuffer(this.iconTransitioningVertexArray, vg.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, mg.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i2) && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, gg.members, true)), !this.orientationVertexBuffer && this.orientationVertexArray && this.orientationVertexArray.length > 0 && (this.orientationVertexBuffer = t2.createVertexBuffer(this.orientationVertexArray, xg.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.orientationVertexBuffer && this.orientationVertexBuffer.destroy());
          }
        }
        Qs(Qv, "SymbolBuffers");
        class tb {
          constructor(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new Ol(), this.collisionVertexArray = new ol(), this.collisionVertexArrayExt = new el();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, bg.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, wg.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        Qs(tb, "CollisionBuffers");
        class eb {
          constructor(t2) {
            this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = u([]), this.placementViewportMatrix = u([]);
            const e2 = this.layers[0]._unevaluatedLayout._values;
            this.worldview = t2.worldview, this.localizable = t2.localizable, this.textSizeData = dx(this.zoom, e2["text-size"], this.worldview, t2.availableImages), this.iconSizeData = dx(this.zoom, e2["icon-size"], this.worldview, t2.availableImages);
            const r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
            this.lut = t2.lut, this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => Hg[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = false, this.elevationType = "none", this.elevationStateComplete = false, this.activeReplacements = [], this.replacementUpdateTime = 0, this.hasAnySecondaryIcon = false, this.hasAppearances = null, this.lastActiveApperance = null, this.featureToAppearanceIndex = {};
          }
          hasAnyAppearanceProperty(t2) {
            const e2 = this.layers[0].getAppearances();
            if (!e2 || 0 === e2.length) return false;
            const r2 = Array.isArray(t2) ? t2 : [t2];
            return e2.some((t3) => r2.some((e3) => null != t3.getProperty(e3)));
          }
          createArrays() {
            this.text = new Qv(new fu(this.layers, { zoom: this.zoom, lut: this.lut }, (t2) => t2.startsWith("text") || t2.startsWith("symbol"))), this.icon = new Qv(new fu(this.layers, { zoom: this.zoom, lut: this.lut }, (t2) => t2.startsWith("icon") || t2.startsWith("symbol"))), this.glyphOffsetArray = new Bl(), this.lineVertexArray = new kl(), this.symbolInstances = new zl();
          }
          calculateGlyphDependencies(t2, e2, r2, n2, i2) {
            for (const r3 of t2) {
              const t3 = r3.codePointAt(0);
              if (void 0 === t3) break;
              if (e2[t3] = true, n2 && i2 && t3 <= 65535) {
                const t4 = Sg[r3];
                t4 && (e2[t4.charCodeAt(0)] = true);
              }
            }
          }
          calculateEffectiveAppearanceIconSize(t2, e2, r2, n2, i2, s2, a2) {
            if (!t2.hasProperty("icon-size")) return a2 * s2;
            let o2 = 1;
            const l2 = t2.getUnevaluatedProperties()._values["icon-size"], u2 = dx(this.zoom, l2, this.worldview, i2), c2 = mx(u2, e2);
            if ("constant" !== u2.kind && "camera" !== u2.kind || (o2 = c2.uSize), "composite" === u2.kind) {
              const { minZoom: t3, maxZoom: e3 } = u2, s3 = l2.possiblyEvaluate(new Ja(t3, { worldview: this.worldview }), n2), a3 = l2.possiblyEvaluate(new Ja(e3, { worldview: this.worldview }), n2), h2 = s3.evaluate(r2, {}, n2, i2);
              o2 = h2 + (a3.evaluate(r2, {}, n2, i2) - h2) * c2.uSizeT;
            }
            return "source" === u2.kind && (o2 = l2.possiblyEvaluate(new Ja(this.zoom, { worldview: this.worldview }), n2).evaluate(r2, {}, n2, i2)), o2 * s2;
          }
          updateFootprints(t2, e2) {
          }
          updateReplacement(t2, e2) {
            if (e2.updateTime === this.replacementUpdateTime) return false;
            this.replacementUpdateTime = e2.updateTime;
            const r2 = e2.getReplacementRegionsForTile(t2.toUnwrapped(), true);
            return !Nd(this.activeReplacements, r2) && (this.activeReplacements = r2, true);
          }
          getResolvedImageFromTokens(t2) {
            return "string" == typeof t2 ? Or.build(t2) : t2;
          }
          populate(t2, e2, r2, n2) {
            const i2 = this.layers[0], s2 = i2.layout, a2 = "globe" === this.projection.name, o2 = s2.get("text-font"), l2 = s2.get("text-field"), u2 = s2.get("icon-image"), [c2, h2] = s2.get("icon-size-scale-range"), p2 = Dt(e2.scaleFactor || 1, c2, h2), d2 = ("constant" !== l2.value.kind || l2.value.value instanceof Rr && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), f2 = "constant" !== u2.value.kind || !!u2.value.value || Object.keys(u2.parameters).length > 0, m2 = this.hasAnyAppearanceProperty("icon-image"), y2 = s2.get("symbol-sort-key");
            if (this.features = [], this.appearanceFeatureData = [], !d2 && !f2 && !m2) return;
            const g2 = e2.iconDependencies, x2 = e2.glyphDependencies, v2 = e2.availableImages, b2 = new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), w2 = (t3) => {
              const e3 = t3.id.toString();
              g2.has(e3) ? g2.get(e3).push(t3) : g2.set(e3, [t3]);
            };
            for (const e3 of t2) {
              const { feature: t3, id: l3, index: u3, sourceLayerIndex: c3 } = e3, h3 = i2._featureFilter.needGeometry, _2 = Ku(t3, h3);
              if (!i2._featureFilter.filter(b2, _2, r2)) continue;
              if (h3 || (_2.geometry = Ju(t3, r2, n2)), a2 && 1 !== t3.type && r2.z <= 5) {
                const t4 = _2.geometry, e4 = 0.98078528056, n3 = (t5, n4) => O(yh(t5.x, t5.y, r2, 1), yh(n4.x, n4.y, r2, 1)) < e4;
                for (let e5 = 0; e5 < t4.length; e5++) t4[e5] = Hu(t4[e5], n3);
              }
              let A2, M2;
              if (d2) {
                const t4 = i2.getValueAndResolveTokens("text-field", _2, r2, v2), e4 = Rr.factory(t4);
                Kv(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Za() || this.hasRTLText && Ya.isParsed()) && (A2 = Ig(e4, i2, _2));
              }
              if (f2) {
                const t4 = i2.getValueAndResolveTokens("icon-image", _2, r2, v2);
                M2 = this.getResolvedImageFromTokens(t4);
              }
              const I2 = this.layers[0];
              let S2 = false;
              if (!M2 && m2) {
                const t4 = I2.getAppearances();
                for (const e4 of t4) if (e4.getProperty("icon-image")) {
                  const t5 = I2.getAppearanceValueAndResolveTokens(e4, "icon-image", _2, r2, v2);
                  if (t5) {
                    M2 = this.getResolvedImageFromTokens(t5), S2 = true;
                    break;
                  }
                }
              }
              if (!A2 && !M2) continue;
              const P2 = this.sortFeaturesByKey ? y2.evaluate(_2, {}, r2) : void 0, z2 = { id: l3, text: A2, icon: M2, index: u3, sourceLayerIndex: c3, geometry: _2.geometry, properties: t3.properties, type: qv[t3.type], sortKey: P2 };
              if (this.features.push(z2), this.featureToAppearanceIndex[u3] = this.appearanceFeatureData.length, this.appearanceFeatureData.push({ id: l3, properties: t3.properties, usesAppearanceIconAsPlaceholder: S2, isUsingAppearanceIconVertexData: false, isUsingAppearanceTextVertexData: false, layoutBasedIconVertexData: [], layoutBasedTextVertexData: [], activeAppearance: null }), M2) {
                const t4 = I2._unevaluatedLayout._values, { iconPrimary: e4, iconSecondary: n3 } = iv(M2, this.iconSizeData, t4["icon-size"], r2, this.zoom, z2, this.pixelRatio, p2, this.worldview, v2);
                w2(e4), n3 && (this.hasAnySecondaryIcon = true, w2(n3));
              }
              const B2 = I2.getAppearances();
              if (0 !== B2.length && B2.forEach((t4) => {
                if (!t4.getProperty("icon-image")) return;
                const e4 = this.getCombinedIconPrimary(t4, I2, _2, r2, v2, z2, p2);
                e4 && w2(e4);
              }), A2) {
                const t4 = o2.evaluate(_2, {}, r2).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Hg.vertical) >= 0;
                for (const r3 of A2.sections) if (r3.image) {
                  const t5 = r3.image.getPrimary().scaleSelf(this.pixelRatio), e5 = t5.id.toString(), n3 = g2.get(e5) || [];
                  n3.push(t5), g2.set(e5, n3);
                } else {
                  const n3 = ka(A2.toString()), i3 = r3.fontStack || t4, s3 = x2[i3] = x2[i3] || {};
                  this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                }
              }
            }
            if ("line" === s2.get("symbol-placement") && (this.features = function(t3) {
              const e3 = {}, r3 = {}, n3 = [];
              let i3 = 0;
              function s3(e4) {
                n3.push(t3[e4]), i3++;
              }
              function a3(t4, e4, i4) {
                const s4 = r3[t4];
                return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
              }
              function o3(t4, r4, i4) {
                const s4 = e3[r4];
                return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
              }
              function l3(t4, e4, r4) {
                const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t4}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t3.length; u3++) {
                const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s3(u3);
                  continue;
                }
                const d3 = l3(p3, h3), f3 = l3(p3, h3, true);
                if (d3 in r3 && f3 in e3 && r3[d3] !== e3[f3]) {
                  const t4 = o3(d3, f3, h3), i4 = a3(d3, f3, n3[t4].geometry);
                  delete e3[d3], delete r3[f3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
                } else d3 in r3 ? a3(d3, f3, h3) : f3 in e3 ? o3(d3, f3, h3) : (s3(u3), e3[d3] = i3 - 1, r3[f3] = i3 - 1);
              }
              return n3.filter((t4) => t4.geometry);
            }(this.features)), "hd-road-markup" === s2.get("symbol-elevation-reference")) {
              if (this.elevationType = "road", e2.elevationFeatures) {
                !this.elevationFeatures && e2.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = /* @__PURE__ */ new Map());
                for (const t3 of e2.elevationFeatures) this.elevationFeatureIdToIndex.set(t3.id, this.elevationFeatures.length), this.elevationFeatures.push(t3);
              }
            } else s2.get("symbol-z-elevate") && (this.elevationType = "offset");
            "none" !== this.elevationType && (this.zOffsetBuffersNeedUpload = true), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
          }
          getCombinedIconPrimary(t2, e2, r2, n2, i2, s2, a2) {
            let o2, l2;
            const u2 = t2.getUnevaluatedProperties();
            if (void 0 !== u2._values["icon-image"].value) {
              const s3 = e2.getAppearanceValueAndResolveTokens(t2, "icon-image", r2, n2, i2);
              o2 = this.getResolvedImageFromTokens(s3);
            } else {
              const t3 = e2.getValueAndResolveTokens("icon-image", r2, n2, i2);
              o2 = this.getResolvedImageFromTokens(t3);
            }
            if (o2) {
              const r3 = t2.hasProperty("icon-size") ? u2._values["icon-size"] : e2._unevaluatedLayout._values["icon-size"];
              l2 = iv(o2, dx(this.zoom, r3, this.worldview, i2), r3, n2, this.zoom, s2, this.pixelRatio, a2, this.worldview, i2).iconPrimary;
            }
            return l2;
          }
          updateSymbolInstanceIconVertices(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2) {
            if (t2.placedIconSymbolIndex < 0) return { vertexOffsetDelta: 0, hasChanges: false };
            if (e2.activeAppearance === r2) return { vertexOffsetDelta: t2.numIconVertices, hasChanges: false };
            if (r2) {
              const f2 = this.getCombinedIconPrimary(r2, l2, n2, s2, a2, { sortKey: void 0, text: void 0, icon: null, index: t2.featureIndex, sourceLayerIndex: t2.featureIndex, geometry: [], properties: e2.properties, type: "Point", id: e2.id }, u2);
              if (!f2) return { vertexOffsetDelta: 0, hasChanges: false };
              const m2 = f2.toString(), y2 = this.iconAtlasPositions && this.iconAtlasPositions.get(m2);
              if (y2) {
                const { appearanceIconOffset: f3, appearanceIconRotate: m3 } = Qx(r2, l2, n2, s2, h2, d2, p2, u2);
                let g2 = ox(y2, void 0, f3, l2.layout.get("icon-anchor").evaluate(n2, c2, s2));
                const x2 = y2.sdf, v2 = l2.layout.get("icon-text-fit").constantOr("none");
                "none" !== v2 && e2.textShaping && e2.iconTextFitPadding && e2.fontScale && (g2 = lx(g2, e2.textShaping, v2, e2.iconTextFitPadding, f3, e2.fontScale));
                const b2 = this.calculateEffectiveAppearanceIconSize(r2, o2.zoom, n2, s2, a2, u2, p2), w2 = 0, _2 = 1 + (Math.min(fv, Math.round(b2 * px)) << 1), A2 = Fx(g2, m3, x2, "none" !== v2, u2);
                e2.isUsingAppearanceIconVertexData || (e2.isUsingAppearanceIconVertexData = true, e2.layoutBasedIconVertexData = this.icon.getSymbolVertexData(i2, t2.numIconVertices));
                let M2 = i2;
                for (let r3 = 0; r3 < A2.length; ++r3) {
                  const n3 = A2[r3], i3 = e2.layoutBasedIconVertexData[0] || t2.tileAnchorX, s3 = e2.layoutBasedIconVertexData[1] || t2.tileAnchorY, a3 = 16 * n3.pixelOffsetTL.x, o3 = 16 * n3.pixelOffsetTL.y, l3 = 16 * n3.pixelOffsetBR.x, u3 = 16 * n3.pixelOffsetBR.y, c3 = 16 * n3.minFontScaleX, h3 = 16 * n3.minFontScaleY;
                  this.icon.updateSymbolVertexData(M2, i3, s3, Math.round(32 * n3.tl.x), Math.round(32 * n3.tl.y), n3.texPrimary.x, n3.texPrimary.y, w2, _2, a3, o3, c3, h3), this.icon.updateSymbolVertexData(M2 + 1, i3, s3, Math.round(32 * n3.tr.x), Math.round(32 * n3.tr.y), n3.texPrimary.x + n3.texPrimary.w, n3.texPrimary.y, w2, _2, l3, o3, c3, h3), this.icon.updateSymbolVertexData(M2 + 2, i3, s3, Math.round(32 * n3.bl.x), Math.round(32 * n3.bl.y), n3.texPrimary.x, n3.texPrimary.y + n3.texPrimary.h, w2, _2, a3, u3, c3, h3), this.icon.updateSymbolVertexData(M2 + 3, i3, s3, Math.round(32 * n3.br.x), Math.round(32 * n3.br.y), n3.texPrimary.x + n3.texPrimary.w, n3.texPrimary.y + n3.texPrimary.h, w2, _2, l3, u3, c3, h3), M2 += 4;
                }
                const I2 = t2.numIconVertices - 4 * A2.length;
                for (let t3 = 0; t3 < I2; ++t3) this.icon.updateSymbolVertexData(M2 + t3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                return { vertexOffsetDelta: t2.numIconVertices, hasChanges: true };
              }
            } else if (e2.usesAppearanceIconAsPlaceholder) {
              if (this.layers[0].appearances && this.layers[0].appearances.length > 0) return this.icon.updateSymbolVertexData(i2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateSymbolVertexData(i2 + 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateSymbolVertexData(i2 + 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this.icon.updateSymbolVertexData(i2 + 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), { vertexOffsetDelta: t2.numIconVertices, hasChanges: true };
            } else if (e2.isUsingAppearanceIconVertexData) {
              const t3 = 12, r3 = e2.layoutBasedIconVertexData.length / t3;
              for (let n3 = 0; n3 < r3; ++n3) {
                const r4 = n3 * t3;
                this.icon.updateSymbolVertexData(i2 + n3, e2.layoutBasedIconVertexData[r4 + 0], e2.layoutBasedIconVertexData[r4 + 1], e2.layoutBasedIconVertexData[r4 + 2], e2.layoutBasedIconVertexData[r4 + 3], e2.layoutBasedIconVertexData[r4 + 4], e2.layoutBasedIconVertexData[r4 + 5], e2.layoutBasedIconVertexData[r4 + 6], e2.layoutBasedIconVertexData[r4 + 7], e2.layoutBasedIconVertexData[r4 + 8], e2.layoutBasedIconVertexData[r4 + 9], e2.layoutBasedIconVertexData[r4 + 10], e2.layoutBasedIconVertexData[r4 + 11]);
              }
              return e2.isUsingAppearanceIconVertexData = false, { vertexOffsetDelta: r3, hasChanges: true };
            }
            return { vertexOffsetDelta: t2.numIconVertices, hasChanges: false };
          }
          updateSymbolInstanceTextVertices(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2) {
            const x2 = t2.numHorizontalGlyphVertices > 0 || t2.numVerticalGlyphVertices > 0;
            if (!x2) return { vertexOffsetDelta: x2 ? t2.numHorizontalGlyphVertices + t2.numVerticalGlyphVertices : 0, hasChanges: false };
            if (e2.activeAppearance === r2) return { vertexOffsetDelta: t2.numHorizontalGlyphVertices + t2.numVerticalGlyphVertices, hasChanges: false };
            if (r2 && e2.textShaping) {
              const { appearanceTextOffset: x3, appearanceTextRotate: v2, appearanceTextSize: b2 } = ev(r2, a2, n2, s2, c2, p2, h2);
              e2.fontScale = hv(b2, e2.textScaleFactor);
              const w2 = r2.getUnevaluatedProperty("text-size");
              let _2 = this.textSizeData, A2 = m2, M2 = y2;
              r2.hasProperty("text-size") && (_2 = dx(this.zoom, w2, this.worldview, g2), A2 = "composite" === this.textSizeData.kind ? this.textSizeData.minZoom : 0, M2 = "composite" === this.textSizeData.kind ? this.textSizeData.maxZoom : 0);
              const I2 = e2.textShaping.bottom - c2[1], S2 = e2.textShaping.left - c2[0], P2 = e2.textShaping.right - c2[0];
              e2.textShaping.top = x3[1] + (e2.textShaping.top - c2[1]), e2.textShaping.bottom = x3[1] + I2, e2.textShaping.left = x3[0] + S2, e2.textShaping.right = x3[0] + P2;
              const z2 = jx(0, e2.textShaping, x3, a2, false, n2, l2, this.allowVerticalPlacement, v2), B2 = b2 && "composite" === _2.kind ? w2.possiblyEvaluate(new Ja(A2, {}), s2).evaluate(n2, u2, s2) : d2, k2 = b2 && "composite" === _2.kind ? w2.possiblyEvaluate(new Ja(M2, {}), s2).evaluate(n2, u2, s2) : f2, T2 = yv(r2.name, _2, b2, o2, B2, k2), V2 = Array.isArray(T2) ? T2[1] : b2, E2 = 0, F2 = 1 + (Math.min(fv, Math.round(V2 * px)) << 1);
              e2.isUsingAppearanceTextVertexData || (e2.isUsingAppearanceTextVertexData = true, e2.layoutBasedTextVertexData = this.text.getSymbolVertexData(i2, t2.numHorizontalGlyphVertices + t2.numVerticalGlyphVertices));
              for (let e3 = 0; e3 < z2.length && e3 < (t2.numHorizontalGlyphVertices + t2.numVerticalGlyphVertices) / 4; ++e3) {
                const r3 = z2[e3], n3 = r3.glyphOffset[1], s3 = t2.tileAnchorX, a3 = t2.tileAnchorY, o3 = i2 + 4 * e3;
                this.text.updateSymbolVertexData(o3, s3, a3, Math.round(32 * r3.tl.x), Math.round(32 * (n3 + r3.tl.y)), r3.texPrimary.x, r3.texPrimary.y, E2, F2, r3.pixelOffsetTL.x, r3.pixelOffsetTL.y, r3.minFontScaleX, r3.minFontScaleY), this.text.updateSymbolVertexData(o3 + 1, s3, a3, Math.round(32 * r3.tr.x), Math.round(32 * (n3 + r3.tr.y)), r3.texPrimary.x + r3.texPrimary.w, r3.texPrimary.y, E2, F2, r3.pixelOffsetBR.x, r3.pixelOffsetTL.y, r3.minFontScaleX, r3.minFontScaleY), this.text.updateSymbolVertexData(o3 + 2, s3, a3, Math.round(32 * r3.bl.x), Math.round(32 * (n3 + r3.bl.y)), r3.texPrimary.x, r3.texPrimary.y + r3.texPrimary.h, E2, F2, r3.pixelOffsetTL.x, r3.pixelOffsetBR.y, r3.minFontScaleX, r3.minFontScaleY), this.text.updateSymbolVertexData(o3 + 3, s3, a3, Math.round(32 * r3.br.x), Math.round(32 * (n3 + r3.br.y)), r3.texPrimary.x + r3.texPrimary.w, r3.texPrimary.y + r3.texPrimary.h, E2, F2, r3.pixelOffsetBR.x, r3.pixelOffsetBR.y, r3.minFontScaleX, r3.minFontScaleY);
              }
              return { vertexOffsetDelta: t2.numHorizontalGlyphVertices + t2.numVerticalGlyphVertices, hasChanges: true };
            }
            if (e2.isUsingAppearanceTextVertexData) {
              const t3 = 12, r3 = e2.layoutBasedTextVertexData.length / t3;
              for (let n3 = 0; n3 < r3; ++n3) {
                const r4 = n3 * t3;
                this.text.updateSymbolVertexData(i2 + n3, e2.layoutBasedTextVertexData[r4 + 0], e2.layoutBasedTextVertexData[r4 + 1], e2.layoutBasedTextVertexData[r4 + 2], e2.layoutBasedTextVertexData[r4 + 3], e2.layoutBasedTextVertexData[r4 + 4], e2.layoutBasedTextVertexData[r4 + 5], e2.layoutBasedTextVertexData[r4 + 6], e2.layoutBasedTextVertexData[r4 + 7], e2.layoutBasedTextVertexData[r4 + 8], e2.layoutBasedTextVertexData[r4 + 9], e2.layoutBasedTextVertexData[r4 + 10], e2.layoutBasedTextVertexData[r4 + 11]);
              }
              return e2.isUsingAppearanceTextVertexData = false, { vertexOffsetDelta: r3, hasChanges: true };
            }
            return { vertexOffsetDelta: t2.numHorizontalGlyphVertices + t2.numVerticalGlyphVertices, hasChanges: false };
          }
          update(t2, e2, r2, n2, i2, s2, a2) {
            this.text.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, this.worldview), this.icon.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, a2, this.worldview);
          }
          updateRoadElevation(t2) {
            if ("road" !== this.elevationType || !this.elevationFeatures) return;
            if (this.elevationStateComplete) return;
            this.elevationStateComplete = true, this.hasAnyZOffset = false;
            let e2 = false;
            const r2 = ju(t2), n2 = 1 / r2;
            let i2 = false, s2 = false;
            for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
              const a2 = this.symbolInstances.get(t3), o2 = I(1, 0, 0), l2 = I(0, 1, 0), { numHorizontalGlyphVertices: u2, numVerticalGlyphVertices: c2, numIconVertices: h2, numVerticalIconVertices: p2 } = a2, d2 = u2 > 0 || c2 > 0, f2 = h2 > 0, m2 = this.elevationFeatures[a2.elevationFeatureIndex];
              if (m2) {
                const t4 = new It(a2.tileAnchorX, a2.tileAnchorY), u3 = 0.075 + m2.pointElevation(t4);
                a2.zOffset !== u3 && (e2 = true, a2.zOffset = u3), 0 !== u3 && (this.hasAnyZOffset = true);
                const c3 = m2.computeSlopeNormal(t4, n2), h3 = ut(et(), I(0, 0, 1), c3);
                $(o2, o2, h3), $(l2, l2, h3), o2[2] *= r2, l2[2] *= r2, 1 === o2[0] && 0 === o2[1] && 0 === o2[2] && 0 === l2[0] && 1 === l2[1] && 0 === l2[2] || (i2 = i2 || d2, s2 = s2 || f2);
              }
              if (d2 && (Yv(this.text.orientationVertexArray, u2, o2, l2), Yv(this.text.orientationVertexArray, c2, o2, l2)), f2) {
                const { placedIconSymbolIndex: t4, verticalPlacedIconSymbolIndex: e3 } = a2;
                t4 >= 0 && Yv(this.icon.orientationVertexArray, h2, o2, l2), e3 >= 0 && Yv(this.icon.orientationVertexArray, p2, o2, l2);
              }
            }
            i2 || (this.text.orientationVertexArray = void 0), s2 || (this.icon.orientationVertexArray = void 0), e2 && (this.zOffsetBuffersNeedUpload = true, this.zOffsetSortDirty = true);
          }
          updateZOffset() {
            const t2 = (t3, e3, n3) => {
              r2 += e3, r2 > t3.length && t3.resize(r2);
              for (let i2 = -e3; i2 < 0; i2++) t3.emplace(i2 + r2, n3);
            }, e2 = (t3, e3, r3) => {
              n2 += e3, n2 > t3.length && t3.resize(n2);
              for (let i2 = -e3; i2 < 0; i2++) t3.emplace(i2 + n2, r3);
            };
            if (!this.zOffsetBuffersNeedUpload) return;
            this.zOffsetBuffersNeedUpload = false;
            let r2 = 0, n2 = 0;
            for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
              const n3 = this.symbolInstances.get(r3), { numHorizontalGlyphVertices: i2, numVerticalGlyphVertices: s2, numIconVertices: a2 } = n3, o2 = n3.zOffset, l2 = a2 > 0;
              if ((i2 > 0 || s2 > 0) && (t2(this.text.zOffsetVertexArray, i2, o2), t2(this.text.zOffsetVertexArray, s2, o2)), l2) {
                const { placedIconSymbolIndex: t3, verticalPlacedIconSymbolIndex: r4 } = n3;
                t3 >= 0 && e2(this.icon.zOffsetVertexArray, a2, o2), r4 >= 0 && e2(this.icon.zOffsetVertexArray, n3.numVerticalIconVertices, o2);
              }
            }
            this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2, e2, r2, n2, i2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload, this.hasAppearances), null === this.hasAppearances && (this.hasAppearances = this.layers.some((t3) => t3.appearances && t3.appearances.length > 0)), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload, this.hasAppearances), this.uploaded = true;
          }
          updateAppearances(t2, e2, r2, n2, i2) {
            if (!(t2 && e2 && r2 && this.appearanceFeatureData)) return false;
            const s2 = this.icon.layoutVertexArray && this.icon.layoutVertexArray.length > 0 && this.icon.layoutVertexArray.arrayBuffer, a2 = this.text.layoutVertexArray && this.text.layoutVertexArray.length > 0 && this.text.layoutVertexArray.arrayBuffer;
            if (!s2 && !a2) return false;
            const o2 = this.layers[0], l2 = o2.layout;
            let u2 = 1, c2 = 0, h2 = false;
            if (s2) {
              const [t3, e3] = l2.get("icon-size-scale-range");
              u2 = Dt(1, t3, e3);
            }
            let p2 = 1, d2 = 0, f2 = false;
            if (a2) {
              const [t3, e3] = l2.get("text-size-scale-range");
              p2 = Dt(1, t3, e3);
            }
            const m2 = /* @__PURE__ */ new Map();
            if (i2 && r2) for (const t3 of r2) {
              const e3 = i2.getImage(t3, o2.scope);
              if (e3) {
                const r3 = new Lr(t3.toString());
                m2.set(r3.toString(), e3);
              }
            }
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const y2 = this.symbolInstances.get(i3), g2 = this.featureToAppearanceIndex[y2.featureIndex], x2 = void 0 !== g2 ? this.appearanceFeatureData[g2] : void 0;
              if (!x2) continue;
              const v2 = x2.id, b2 = e2 && void 0 !== v2 ? e2[String(v2)] : void 0, w2 = { type: "Point", id: x2.id, properties: x2.properties, geometry: [] }, _2 = o2.appearances && o2.appearances.find((e3) => e3.isActive({ globals: n2, feature: w2, canonical: t2, featureState: b2 }));
              if (a2) {
                const e3 = l2.get("text-size"), n3 = l2.get("text-offset").evaluate(w2, b2, t2), i4 = e3.evaluate(w2, b2, t2), s3 = l2.get("text-rotate").evaluate(w2, b2, t2), a3 = "composite" === this.textSizeData.kind ? this.textSizeData.minZoom : 0, u3 = "composite" === this.textSizeData.kind ? this.textSizeData.maxZoom : 0, c3 = e3.evaluate(w2, { zoom: a3 }, t2), h3 = e3.evaluate(w2, { zoom: u3 }, t2), g3 = this.updateSymbolInstanceTextVertices(y2, x2, _2, w2, d2, t2, o2, p2, m2, b2, n3, i4, s3, c3, h3, a3, u3, r2);
                d2 += g3.vertexOffsetDelta, f2 = f2 || g3.hasChanges;
              }
              if (s2) {
                const e3 = l2.get("icon-offset").evaluate(w2, b2, t2), i4 = l2.get("icon-size").evaluate(w2, b2, t2, r2), s3 = l2.get("icon-rotate").evaluate(w2, b2, t2), a3 = this.updateSymbolInstanceIconVertices(y2, x2, _2, w2, c2, t2, r2, n2, o2, u2, b2, e3, i4, s3);
                c2 += a3.vertexOffsetDelta, h2 = h2 || a3.hasChanges;
              }
              x2.activeAppearance = _2;
            }
            return h2 && this.icon.layoutVertexBuffer && null !== this.icon.layoutVertexArray.arrayBuffer && this.icon.layoutVertexArray.length === this.icon.layoutVertexBuffer.length && this.icon.layoutVertexBuffer.updateData(this.icon.layoutVertexArray), f2 && this.text.layoutVertexBuffer && null !== this.text.layoutVertexArray.arrayBuffer && this.text.layoutVertexArray.length === this.text.layoutVertexBuffer.length && this.text.layoutVertexBuffer.updateData(this.text.layoutVertexArray), h2 || f2;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = $v(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) for (const { x: t3, y: r3 } of e2) this.lineVertexArray.emplaceBack(t3, r3);
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2, g2) {
            const x2 = t2.indexArray, v2 = t2.layoutVertexArray, b2 = t2.globeExtVertexArray, w2 = t2.segments.prepareSegment(4 * g2, v2, x2, this.canOverlap ? s2.sortKey : void 0), _2 = this.glyphOffsetArray.length, A2 = w2.vertexLength, M2 = this.allowVerticalPlacement && a2 === Hg.vertical ? Math.PI / 2 : 0, I2 = s2.text && s2.text.sections;
            for (let n3 = 0; n3 < e2.length; n3++) {
              const { tl: i3, tr: a3, bl: u3, br: c3, texPrimary: h3, texSecondary: y3, pixelOffsetTL: g3, pixelOffsetBR: _3, minFontScaleX: A3, minFontScaleY: S3, glyphOffset: P3, isSDF: z2, sectionIndex: B2 } = e2[n3], k2 = w2.vertexLength, T2 = P3[1];
              if (Hv(v2, l2.x, l2.y, i3.x, T2 + i3.y, h3.x, h3.y, r2, z2, g3.x, g3.y, A3, S3), Hv(v2, l2.x, l2.y, a3.x, T2 + a3.y, h3.x + h3.w, h3.y, r2, z2, _3.x, g3.y, A3, S3), Hv(v2, l2.x, l2.y, u3.x, T2 + u3.y, h3.x, h3.y + h3.h, r2, z2, g3.x, _3.y, A3, S3), Hv(v2, l2.x, l2.y, c3.x, T2 + c3.y, h3.x + h3.w, h3.y + h3.h, r2, z2, _3.x, _3.y, A3, S3), o2) {
                const { x: e3, y: r3, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
                Wv(b2, e3, r3, n4, i4, s3, a4), Wv(b2, e3, r3, n4, i4, s3, a4), Wv(b2, e3, r3, n4, i4, s3, a4), Wv(b2, e3, r3, n4, i4, s3, a4), Jv(t2.dynamicLayoutVertexArray, e3, r3, n4, M2);
              } else Jv(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, M2);
              if (m2) {
                const e3 = y3 || h3;
                Zv(t2.iconTransitioningVertexArray, e3.x, e3.y), Zv(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y), Zv(t2.iconTransitioningVertexArray, e3.x, e3.y + e3.h), Zv(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y + e3.h);
              }
              x2.emplaceBack(k2, k2 + 1, k2 + 2), x2.emplaceBack(k2 + 1, k2 + 2, k2 + 3), w2.vertexLength += 4, w2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P3[0]), n3 !== e2.length - 1 && B2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(v2.length, s2, s2.index, {}, p2, d2, f2, I2 && I2[B2], this.worldview);
            }
            const S2 = g2 - e2.length;
            0 !== S2 && this._addNullVertices(S2, v2, r2, o2, b2, t2, m2, w2, x2);
            const P2 = o2 ? o2.anchor : l2;
            t2.placedSymbolArray.emplaceBack(P2.x, P2.y, P2.z, l2.x, l2.y, _2, this.glyphOffsetArray.length - _2, A2, u2, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], a2, 0, 0, 0, h2, 0), t2.symbolInstanceIndices.push(y2);
          }
          _addNullVertices(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            for (let u2 = 0; u2 < t2; u2++) {
              for (let t4 = 0; t4 < 4; t4++) Hv(e2, 0, 0, 0, 0, 0, 0, r2, false, 0, 0, 0, 0), n2 ? (Wv(i2, 0, 0, 0, 0, 0, 0), Jv(s2.dynamicLayoutVertexArray, 0, 0, 0, 0)) : Jv(s2.dynamicLayoutVertexArray, 0, 0, 0, 0), a2 && Zv(s2.iconTransitioningVertexArray, 0, 0);
              const t3 = o2.vertexLength;
              l2.emplaceBack(t3, t3 + 1, t3 + 2), l2.emplaceBack(t3 + 1, t3 + 2, t3 + 3), o2.vertexLength += 4, o2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(0);
            }
          }
          _commitLayoutVertex(t2, e2, r2, n2, i2, s2, a2) {
            t2.emplaceBack(e2, r2, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
          }
          _addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l2 = o2.vertexLength, u2 = a2.tileAnchorX, c2 = a2.tileAnchorY;
            for (let t3 = 0; t3 < 4; t3++) r2.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
            this._commitDebugCollisionVertexUpdate(r2.collisionVertexArrayExt, e2, t2.padding, a2.zOffset), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new It(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new It(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new It(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new It(t2.x1, t2.y2)), o2.vertexLength += 4;
            const h2 = r2.indexArray;
            h2.emplaceBack(l2, l2 + 1), h2.emplaceBack(l2 + 1, l2 + 2), h2.emplaceBack(l2 + 2, l2 + 3), h2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
              this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
            }
          }
          _addIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
            for (let a2 = n2; a2 < i2; a2++) {
              const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
              this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
            }
          }
          generateCollisionDebugBuffers(t2, e2, r2) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new tb(sl, _g.members, nl), this.iconCollisionBox = new tb(sl, _g.members, nl);
            const n2 = mx(this.iconSizeData, t2), i2 = mx(this.textSizeData, t2, r2);
            for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
              const s2 = this.symbolInstances.get(r3);
              this._addTextDebugCollisionBoxes(i2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(i2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(n2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(n2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
            }
          }
          getSymbolInstanceTextSize(t2, e2, r2, n2) {
            const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = fx(this.textSizeData, t2, i2) / Mg;
            return this.tilePixelRatio * s2;
          }
          getSymbolInstanceIconSize(t2, e2, r2) {
            const n2 = this.icon.placedSymbolArray.get(r2), i2 = fx(this.iconSizeData, t2, n2);
            return this.tilePixelRatio * i2;
          }
          _commitDebugCollisionVertexUpdate(t2, e2, r2, n2) {
            t2.emplaceBack(e2, -r2, -r2, n2), t2.emplaceBack(e2, r2, -r2, n2), t2.emplaceBack(e2, r2, r2, n2), t2.emplaceBack(e2, -r2, r2, n2);
          }
          _updateTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2, a2) {
            for (let a3 = n2; a3 < i2; a3++) {
              const n3 = r2.get(a3), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a3);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
            }
          }
          _updateIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2, a2) {
            for (let a3 = n2; a3 < i2; a3++) {
              const n3 = r2.get(a3), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
            }
          }
          updateCollisionDebugBuffers(t2, e2, r2, n2) {
            if (!this.hasDebugData()) return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const i2 = mx(this.iconSizeData, t2, n2), s2 = mx(this.textSizeData, t2, r2);
            for (let a2 = 0; a2 < this.symbolInstances.length; a2++) {
              const o2 = this.symbolInstances.get(a2);
              this._updateTextDebugCollisionBoxes(s2, t2, e2, o2.textBoxStartIndex, o2.textBoxEndIndex, o2, r2), this._updateTextDebugCollisionBoxes(s2, t2, e2, o2.verticalTextBoxStartIndex, o2.verticalTextBoxEndIndex, o2, r2), this._updateIconDebugCollisionBoxes(i2, t2, e2, o2.iconBoxStartIndex, o2.iconBoxEndIndex, o2, n2), this._updateIconDebugCollisionBoxes(i2, t2, e2, o2.verticalIconBoxStartIndex, o2.verticalIconBoxEndIndex, o2, n2);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = {};
            if (e2 < r2) {
              const { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = t2.get(e2);
              u2.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.textFeatureIndex = d2;
            }
            if (n2 < i2) {
              const { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = t2.get(n2);
              u2.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalTextFeatureIndex = d2;
            }
            if (s2 < a2) {
              const { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = t2.get(s2);
              u2.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.iconFeatureIndex = d2;
            }
            if (o2 < l2) {
              const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: d2 } = t2.get(o2);
              u2.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalIconFeatureIndex = d2;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          hasIconTextFit() {
            return this.hasAnyIconTextFit;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4) t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s2.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e2 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
            }
            return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
          }
          getSortedIndexesByZOffset() {
            if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
            if (!this.symbolInstanceIndexesSortedZOffset) {
              this.symbolInstanceIndexesSortedZOffset = [];
              for (let t2 = 0; t2 < this.symbolInstances.length; ++t2) this.symbolInstanceIndexesSortedZOffset.push(t2);
            }
            return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t2, e2) => this.symbolInstances.get(e2).zOffset - this.symbolInstances.get(t2).zOffset);
          }
          addToSortKeyRanges(t2, e2) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex);
                const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e2;
                r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
          getElevationFeatureForText(t2) {
            const e2 = this.symbolInstances.get(this.text.symbolInstanceIndices[t2]).elevationFeatureIndex;
            let r2;
            return this.elevationFeatures && e2 < this.elevationFeatures.length && (r2 = this.elevationFeatures[e2]), r2;
          }
        }
        function rb(t2, e2) {
          return e2.replace(/{([^{}]+)}/g, (e3, r2) => r2 in t2 ? String(t2[r2]) : "");
        }
        let nb, ib, sb;
        Qs(eb, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "compareText", "features"] }), eb.addDynamicAttributes = Jv;
        class ab {
          constructor(t2) {
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : xr, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection)) return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Qs(ab, "FormatSectionOverride", { omit: ["defaultValue"] });
        const ob = () => sb || (sb = { layout: nb || (nb = new uo({ "symbol-placement": new ao(co.layout_symbol["symbol-placement"]), "symbol-spacing": new ao(co.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ao(co.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new oo(co.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ao(co.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new ao(co.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new ao(co.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new ao(co.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new ao(co.layout_symbol["icon-ignore-placement"]), "icon-optional": new ao(co.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ao(co.layout_symbol["icon-rotation-alignment"]), "icon-size": new oo(co.layout_symbol["icon-size"]), "icon-size-scale-range": new ao(co.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new oo(co.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new oo(co.layout_symbol["icon-text-fit-padding"]), "icon-image": new oo(co.layout_symbol["icon-image"]), "icon-image-use-theme": new ao({ type: "string", default: "default", "property-type": "data-constant" }), "icon-rotate": new oo(co.layout_symbol["icon-rotate"]), "icon-padding": new ao(co.layout_symbol["icon-padding"]), "icon-keep-upright": new ao(co.layout_symbol["icon-keep-upright"]), "icon-offset": new oo(co.layout_symbol["icon-offset"]), "icon-anchor": new oo(co.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ao(co.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ao(co.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ao(co.layout_symbol["text-rotation-alignment"]), "text-field": new oo(co.layout_symbol["text-field"]), "text-font": new oo(co.layout_symbol["text-font"]), "text-size": new oo(co.layout_symbol["text-size"]), "text-size-scale-range": new ao(co.layout_symbol["text-size-scale-range"]), "text-max-width": new oo(co.layout_symbol["text-max-width"]), "text-line-height": new oo(co.layout_symbol["text-line-height"]), "text-letter-spacing": new oo(co.layout_symbol["text-letter-spacing"]), "text-justify": new oo(co.layout_symbol["text-justify"]), "text-radial-offset": new oo(co.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ao(co.layout_symbol["text-variable-anchor"]), "text-anchor": new oo(co.layout_symbol["text-anchor"]), "text-max-angle": new ao(co.layout_symbol["text-max-angle"]), "text-writing-mode": new ao(co.layout_symbol["text-writing-mode"]), "text-rotate": new oo(co.layout_symbol["text-rotate"]), "text-padding": new ao(co.layout_symbol["text-padding"]), "text-keep-upright": new ao(co.layout_symbol["text-keep-upright"]), "text-transform": new oo(co.layout_symbol["text-transform"]), "text-offset": new oo(co.layout_symbol["text-offset"]), "text-allow-overlap": new ao(co.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new ao(co.layout_symbol["text-ignore-placement"]), "text-optional": new ao(co.layout_symbol["text-optional"]), visibility: new ao(co.layout_symbol.visibility) })), paint: ib || (ib = new uo({ "icon-opacity": new oo(co.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new oo(co.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new oo(co.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new oo(co.paint_symbol["text-emissive-strength"]), "icon-color": new oo(co.paint_symbol["icon-color"]), "icon-halo-color": new oo(co.paint_symbol["icon-halo-color"]), "icon-halo-width": new oo(co.paint_symbol["icon-halo-width"]), "icon-halo-blur": new oo(co.paint_symbol["icon-halo-blur"]), "icon-translate": new ao(co.paint_symbol["icon-translate"]), "icon-translate-anchor": new ao(co.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new ao(co.paint_symbol["icon-image-cross-fade"]), "text-opacity": new oo(co.paint_symbol["text-opacity"]), "text-occlusion-opacity": new oo(co.paint_symbol["text-occlusion-opacity"]), "text-color": new oo(co.paint_symbol["text-color"], { runtimeType: _r, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new oo(co.paint_symbol["text-halo-color"]), "text-halo-width": new oo(co.paint_symbol["text-halo-width"]), "text-halo-blur": new oo(co.paint_symbol["text-halo-blur"]), "text-translate": new ao(co.paint_symbol["text-translate"]), "text-translate-anchor": new ao(co.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new ao(co.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new ao(co.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new ao(co.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new ao(co.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new oo(co.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, sb);
        class lb extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, ob(), e2, r2, n2, t2.layout ? t2.layout["icon-image-use-theme"] : null), this._colorAdjustmentMatrix = u([]), this.hasOcclusionOpacityProperties = void 0 !== t2.paint && ("icon-occlusion-opacity" in t2.paint || "text-occlusion-opacity" in t2.paint);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "icon-occlusion-opacity" !== t2 && "text-occlusion-opacity" !== t2 || (this.hasOcclusionOpacityProperties = true);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.appearances && this.appearances.forEach((r3) => {
              r3.recalculate(t2, e2, this.iconImageUseTheme);
            }), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r2 = this.layout.get("text-writing-mode");
            if (r2) {
              const t3 = [];
              for (const e3 of r2) t3.indexOf(e3) < 0 && t3.push(e3);
              this.layout._values["text-writing-mode"] = t3;
            } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getColorAdjustmentMatrix(t2, e2, r2, n2) {
            return this._saturation === t2 && this._contrast === e2 && this._brightnessMin === r2 && this._brightnessMax === n2 || (this._colorAdjustmentMatrix = function(t3, e3, r3, n3) {
              t3 = se(t3), e3 = ie(e3);
              const i2 = o(), s2 = t3 / 3, a2 = 1 - 2 * s2, l2 = [a2, s2, s2, 0, s2, a2, s2, 0, s2, s2, a2, 0, 0, 0, 0, 1], u2 = 0.5 - 0.5 * e3, c2 = n3 - r3;
              return h(i2, [c2, 0, 0, 0, 0, c2, 0, 0, 0, 0, c2, 0, r3, r3, r3, 1], [e3, 0, 0, 0, 0, e3, 0, 0, 0, 0, e3, 0, u2, u2, u2, 1]), h(i2, i2, l2), i2;
            }(t2, e2, r2, n2), this._saturation = t2, this._contrast = e2, this._brightnessMin = r2, this._brightnessMax = n2), this._colorAdjustmentMatrix;
          }
          getValueAndResolveTokens(t2, e2, r2, n2) {
            const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
            return s2.isDataDriven() || Ns(s2.value) || !i2 ? i2 : rb(e2.properties, i2);
          }
          getAppearanceValueAndResolveTokens(t2, e2, r2, n2, i2) {
            const s2 = t2.getProperty(e2);
            if (!s2) return;
            const a2 = s2.evaluate(r2, {}, n2, i2), o2 = t2.getUnevaluatedProperties()._values[e2];
            return o2.isDataDriven() || Ns(o2.value) || !a2 || "string" != typeof a2 ? a2 : rb(r2.properties, a2);
          }
          createBucket(t2) {
            return new eb(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t2 of ob().paint.overridableProperties) {
              if (!lb.hasPaintOverride(this.layout, t2)) continue;
              const e2 = this.paint.get(t2), r2 = new ab(e2), n2 = new Us(r2, e2.property.specification, this.scope, this.options, this.layout.get("icon-image-use-theme"));
              let i2 = null;
              i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Gs("source", n2) : new $s("composite", n2, e2.value.zoomStops, e2.value.interpolationType), this.paint._values[t2] = new io(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && lb.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            const r2 = t2.get("text-field"), n2 = ob().paint.properties[e2];
            let i2 = false;
            const s2 = (t3) => {
              for (const e3 of t3) if (n2.overrides && n2.overrides.hasOverride(e3)) return void (i2 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof Rr) s2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              const t3 = (e4) => {
                i2 || (e4 instanceof $r && jr(e4.value) === Sr ? s2(e4.value.sections) : e4 instanceof Zr ? s2(e4.sections) : e4.eachChild(t3));
              }, e3 = r2.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
          getProgramIds() {
            return ["symbol"];
          }
          getDefaultProgramParams(t2, e2, r2) {
            return { config: new du(this, { zoom: e2, lut: r2 }), overrideFog: false };
          }
          hasElevation() {
            return this.layout && "hd-road-markup" === this.layout.get("symbol-elevation-reference");
          }
        }
        let ub, cb, hb, pb;
        var db = Oo([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        function fb(t2, e2, r2, n2, i2, o2, l2, u2) {
          const c2 = [t2, e2, 1, r2, n2, 1, i2, o2, 1], h2 = [l2, u2, 1], p2 = s([], c2), [d2, f2, m2] = G(h2, h2, p2);
          return a(c2, c2, [d2, 0, 0, 0, f2, 0, 0, 0, m2]);
        }
        function mb(t2, e2, r2, n2, i2, o2, l2, u2) {
          const c2 = function(t3, e3, r3, n3, i3, o3, l3, u3) {
            const c3 = fb(0, 0, 1, 0, 1, 1, 0, 1), h2 = fb(t3, e3, r3, n3, i3, o3, l3, u3);
            return a(h2, h2, s([], c3));
          }(t2, e2, r2, n2, i2, o2, l2, u2);
          return [c2[2] / c2[8] / jn, c2[5] / c2[8] / jn];
        }
        function yb(t2) {
          return [t2[0], Math.min(Math.max(t2[1], -85.051129), Lu)];
        }
        class gb extends ir {
          constructor(t2, e2, r2, n2) {
            super(), this.id = t2, this.dispatcher = r2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n2), this.options = e2, this._dirty = false;
          }
          load(t2, e2) {
            if (this._loaded = e2 || false, this.fire(new tr("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return t2 && (this.coordinates = t2), this._loaded = true, void this._finishLoading();
            this._imageRequest = qe(this.map._requestManager.transformRequest(this.url, Ce.Image), (e3, r2) => {
              this._imageRequest = null, this._loaded = true, e3 ? this.fire(new er(e3)) : r2 && (this.image = r2 instanceof HTMLImageElement ? ge.getImageData(r2) : r2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t2) {
            return t2.url ? (this._imageRequest && t2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t2.url, this.load(t2.coordinates, this._loaded), this) : this;
          }
          setTexture(t2) {
            if (!(t2.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
            return this.texture = new Rm(this.map.painter.context, t2.handle), this.width = t2.dimensions[0], this.height = t2.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new tr("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove(t2) {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Rm || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
          }
          setCoordinates(t2) {
            if (this.coordinates = t2, this._boundsArray = void 0, this._unsupportedCoords = false, !t2.length) return this;
            this.onNorthPole = false, this.onSouthPole = false;
            let e2 = t2[0][1], r2 = t2[0][1];
            for (const n3 of t2) n3[1] > r2 && (r2 = n3[1]), n3[1] < e2 && (e2 = n3[1]);
            const n2 = (r2 + e2) / 2;
            if (n2 > Lu ? this.onNorthPole = true : n2 < -85.051129 && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
              const e3 = t2.map(Gu.fromLngLat);
              this.tileID = function(t3) {
                let e4 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i2 = -1 / 0;
                for (const s3 of t3) e4 = Math.min(e4, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i2 = Math.max(i2, s3.y);
                const s2 = Math.max(n3 - e4, i2 - r3), a2 = Math.max(0, Math.floor(-Math.log2(s2))), o2 = Math.pow(2, a2);
                let l2 = Math.floor((e4 + n3) / 2 * o2);
                return l2 > 1 && (l2 -= 1), new Yc(a2, l2, Math.floor((r3 + i2) / 2 * o2));
              }(e3), this.minzoom = this.maxzoom = this.tileID.z;
            }
            return this.fire(new tr("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            !this.texture || this.texture instanceof Rm || (this.texture.destroy(), this._dirty = true), this.texture = null, this._boundsArray = void 0, this._unsupportedCoords = false;
          }
          _prepareData(t2) {
            for (const t3 in this.tiles) {
              const e3 = this.tiles[t3];
              "loaded" !== e3.state && (e3.state = "loaded", e3.texture = this.texture);
            }
            if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
            const e2 = _v(new Yc(0, 0, 0), this.map.transform.projection), r2 = [e2.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e2.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e2.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e2.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
            if (!function(t3) {
              const e3 = t3[1].x - t3[0].x, r3 = t3[1].y - t3[0].y, n3 = t3[2].x - t3[1].x, i3 = t3[2].y - t3[1].y, s2 = t3[3].x - t3[2].x, a2 = t3[3].y - t3[2].y, o3 = t3[0].x - t3[3].x, l3 = t3[0].y - t3[3].y, u3 = e3 * i3 - n3 * r3, c3 = n3 * a2 - s2 * i3, h3 = s2 * l3 - o3 * a2, p3 = o3 * r3 - e3 * l3;
              return u3 > 0 && c3 > 0 && h3 > 0 && p3 > 0 || u3 < 0 && c3 < 0 && h3 < 0 && p3 < 0;
            }(r2)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
            const n2 = _v(this.tileID, this.map.transform.projection), [i2, o2, l2, u2] = this.coordinates.map((t3) => {
              const e3 = n2.projection.project(t3[0], t3[1]);
              return Av(n2, e3)._round();
            });
            this.perspectiveTransform = mb(i2.x, i2.y, o2.x, o2.y, l2.x, l2.y, u2.x, u2.y);
            const c2 = this._boundsArray = new Go();
            c2.emplaceBack(i2.x, i2.y, 0, 0), c2.emplaceBack(o2.x, o2.y, jn, 0), c2.emplaceBack(u2.x, u2.y, 0, jn), c2.emplaceBack(l2.x, l2.y, jn, jn), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t2.createVertexBuffer(c2, db.members), this.boundsSegments = Ol.simpleSegment(0, 0, 4, 2);
            const h2 = [], p2 = [yb((d2 = this.coordinates)[0]), yb(d2[1]), yb(d2[2]), yb(d2[3])];
            var d2;
            const [f2, m2, y2, g2] = function(t3) {
              let e3 = t3[0][0], r3 = e3, n3 = t3[0][1], i3 = n3;
              for (let s2 = 1; s2 < t3.length; s2++) t3[s2][0] < e3 ? e3 = t3[s2][0] : t3[s2][0] > r3 && (r3 = t3[s2][0]), t3[s2][1] < n3 ? n3 = t3[s2][1] : t3[s2][1] > i3 && (i3 = t3[s2][1]);
              return [e3, n3, r3 - e3, i3 - n3];
            }(p2);
            {
              const n3 = new Go(), [i3, o3, l3, u3] = function(t3) {
                let e3 = t3[0].x, r3 = e3, n4 = t3[0].y, i4 = n4;
                for (let s2 = 1; s2 < t3.length; s2++) t3[s2].x < e3 ? e3 = t3[s2].x : t3[s2].x > r3 && (r3 = t3[s2].x), t3[s2].y < n4 ? n4 = t3[s2].y : t3[s2].y > i4 && (i4 = t3[s2].y);
                return [e3, n4, r3 - e3, i4 - n4];
              }(r2), c3 = (t3) => [(t3.x - i3) / l3, (t3.y - o3) / u3], [p3, d3, x2, v2] = r2.map(c3), b2 = function(t3, e3, r3, n4, i4, o4, l4, u4) {
                const c4 = fb(0, 0, 1, 0, 1, 1, 0, 1);
                return a(c4, c4, s([], fb(t3, e3, r3, n4, i4, o4, l4, u4)));
              }(p3[0], p3[1], d3[0], d3[1], x2[0], x2[1], v2[0], v2[1]);
              this.elevatedGlobePerspectiveTransform = mb(p3[0], p3[1], d3[0], d3[1], x2[0], x2[1], v2[0], v2[1]);
              const w2 = (t3, e3) => {
                h2.push(t3.lng);
                const r3 = Math.round((t3.lng - f2) / y2 * jn), i4 = Math.round((t3.lat - m2) / g2 * jn), s2 = c3(e3), a2 = G([], [s2[0], s2[1], 1], b2), o4 = Math.round(a2[0] / a2[2] * jn), l4 = Math.round(a2[1] / a2[2] * jn);
                n3.emplaceBack(r3, i4, o4, l4);
              }, _2 = r2[3].x - r2[0].x, A2 = r2[3].y - r2[0].y, M2 = r2[2].x - r2[1].x, I2 = r2[2].y - r2[1].y;
              for (let t3 = 0; t3 < 65; t3++) {
                const n4 = t3 / 64, i4 = [r2[0].x + n4 * _2, r2[0].y + n4 * A2], s2 = [r2[1].x + n4 * M2, r2[1].y + n4 * I2], a2 = s2[0] - i4[0], o4 = s2[1] - i4[1];
                for (let t4 = 0; t4 < 65; t4++) {
                  const r3 = t4 / 64, n5 = { x: i4[0] + a2 * r3, y: i4[1] + o4 * r3 };
                  w2(e2.projection.unproject(n5.x, n5.y), n5);
                }
              }
              this.elevatedGlobeVertexBuffer = t2.createVertexBuffer(n3, db.members);
            }
            {
              this.maxLongitudeTriangleSize = 0;
              let e3 = [], r3 = new ll();
              const n3 = (t3, n4, i3) => {
                r3.emplaceBack(t3, n4, i3);
                const s2 = h2[t3], a2 = h2[n4], o3 = h2[i3], l3 = Math.min(Math.min(s2, a2), o3), u3 = Math.max(Math.max(s2, a2), o3) - l3;
                u3 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u3), e3.push(l3 + u3 / 2);
              };
              for (let t3 = 0; t3 < 64; t3++) for (let e4 = 0; e4 < 64; e4++) {
                const r4 = 65 * t3 + e4, i3 = r4 + 1, s2 = r4 + 65, a2 = s2 + 1;
                n3(r4, s2, i3), n3(i3, s2, a2);
              }
              [e3, r3] = function(t3, e4) {
                const r4 = Array.from({ length: t3.length }, (t4, e5) => e5);
                r4.sort((e5, r5) => t3[e5] - t3[r5]);
                const n4 = [], i3 = new ll();
                for (let s2 = 0; s2 < r4.length; s2++) {
                  const a2 = r4[s2];
                  n4.push(t3[a2]);
                  const o3 = 3 * a2, l3 = o3 + 1;
                  i3.emplaceBack(e4.uint16[o3], e4.uint16[l3], e4.uint16[l3 + 1]);
                }
                return [n4, i3];
              }(e3, r3), this.elevatedGlobeTrianglesCenterLongitudes = e3, this.elevatedGlobeIndexBuffer = t2.createIndexBuffer(r3);
            }
            this.elevatedGlobeSegments = Ol.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, y2 / jn, 0, g2 / jn, 0, 0, m2, f2, 0]);
          }
          prepare() {
            const t2 = 0 !== Object.keys(this.tiles).length;
            if (this.tileID && !t2) return;
            const e2 = this.map.painter.context, r2 = e2.gl;
            !this._dirty || this.texture instanceof Rm || (this.texture ? this.texture.update(this.image) : (this.texture = new Cm(e2, this.image, r2.RGBA8), this.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE)), this._dirty = false), t2 && this._prepareData(e2);
          }
          loadTile(t2, e2) {
            this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e2(null)) : (t2.state = "errored", e2(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          getSegmentsForLongitude(t2) {
            const e2 = this.elevatedGlobeSegments;
            if (!this.elevatedGlobeTrianglesCenterLongitudes || !e2) return null;
            const r2 = this.elevatedGlobeTrianglesCenterLongitudes;
            let n2 = (i2 = t2 + 180) + 360 * Math.round((r2[0] - i2) / 360);
            var i2;
            const s2 = new Ol(), a2 = (t3, r3) => {
              s2.segments.push({ vertexOffset: 0, primitiveOffset: t3, vertexLength: e2.segments[0].vertexLength, primitiveLength: r3, sortKey: void 0, vaos: {} });
            }, o2 = 0.51 * this.maxLongitudeTriangleSize;
            if (Math.abs(r2[0] - n2) <= o2) {
              const t3 = ne(r2, 0, r2.length, n2 + o2);
              return t3 === r2.length || a2(t3, re(r2, t3 + 1, r2.length, n2 + 360 - o2) - t3), s2;
            }
            n2 < r2[0] && (n2 += 360);
            const l2 = re(r2, 0, r2.length, n2 - o2);
            if (l2 === r2.length) return a2(0, r2.length), s2;
            a2(0, l2 - 0);
            const u2 = ne(r2, l2 + 1, r2.length, n2 + o2);
            return u2 !== r2.length && a2(u2, r2.length - u2), s2;
          }
        }
        const xb = 1024, vb = (Math.pow(xb, 2) - 1) / 268170240;
        class bb extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: hb || (hb = new uo({ visibility: new ao(co.layout_raster.visibility) })), paint: pb || (pb = new uo({ "raster-opacity": new ao(co.paint_raster["raster-opacity"]), "raster-color": new lo(co.paint_raster["raster-color"]), "raster-color-mix": new ao(co.paint_raster["raster-color-mix"]), "raster-color-range": new ao(co.paint_raster["raster-color-range"]), "raster-hue-rotate": new ao(co.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ao(co.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ao(co.paint_raster["raster-brightness-max"]), "raster-saturation": new ao(co.paint_raster["raster-saturation"]), "raster-contrast": new ao(co.paint_raster["raster-contrast"]), "raster-resampling": new ao(co.paint_raster["raster-resampling"]), "raster-fade-duration": new ao(co.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new ao(co.paint_raster["raster-emissive-strength"]), "raster-array-band": new ao(co.paint_raster["raster-array-band"]), "raster-elevation": new ao(co.paint_raster["raster-elevation"]), "raster-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
          }
          getProgramIds() {
            return ["raster"];
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-color"].value.value;
          }
          tileCoverLift() {
            return this.paint.get("raster-elevation");
          }
          isDraped(t2) {
            return !(t2 && t2._source instanceof gb && (t2._source.onNorthPole || t2._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "raster-color" !== t2 && "raster-color-range" !== t2 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
          }
          _clear() {
            this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          updateColorRamp(t2) {
            if (!this.hasColorMap()) return;
            if (!this._curRampRange) return;
            const e2 = this._transitionablePaint._values["raster-color"].value.expression, [r2, n2] = t2 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
            isNaN(r2) && isNaN(n2) || r2 === this._curRampRange[0] && n2 === this._curRampRange[1] || (this.colorRamp = Zh({ expression: e2, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r2, end: n2 }], resolution: xb }), this.colorRampTexture = null, this._curRampRange = [r2, n2]);
          }
          is3D(t2) {
            return this.paint.get("raster-elevation") > 0;
          }
        }
        let wb, _b, Ab, Mb, Ib;
        class Sb extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: wb || (wb = new uo({ visibility: new ao(co["layout_raster-particle"].visibility) })), paint: _b || (_b = new uo({ "raster-particle-array-band": new ao(co["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new ao(co["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new lo(co["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new ao(co["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new ao(co["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new ao(co["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new ao(co["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new ao(co["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._updateColorRamp(), this.lastInvalidatedAt = ge.now();
          }
          _clear() {
            this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this.tileFramebuffer && (this.tileFramebuffer.destroy(), this.tileFramebuffer = null), this.particleFramebuffer && (this.particleFramebuffer.destroy(), this.particleFramebuffer = null);
          }
          onRemove(t2) {
            this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-particle-color"].value.value;
          }
          getProgramIds() {
            return ["rasterParticle"];
          }
          hasOffscreenPass() {
            return "none" !== this.visibility;
          }
          isDraped(t2) {
            return false;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "raster-particle-color" !== t2 && "raster-particle-max-speed" !== t2 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t2 && this._invalidateAnimationState();
          }
          _updateColorRamp() {
            if (!this.hasColorMap()) return;
            const t2 = this._transitionablePaint._values["raster-particle-color"].value.expression, e2 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
            this.colorRamp = Zh({ expression: t2, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e2 }], resolution: 256 }), this.colorRampTexture = null;
          }
          _invalidateAnimationState() {
            this.lastInvalidatedAt = ge.now();
          }
          tileCoverLift() {
            return this.paint.get("raster-particle-elevation");
          }
        }
        class Pb extends Fo {
          constructor(t2, e2) {
            super(t2, {}, e2, null), this.implementation = t2, t2.slot && (this.slot = t2.slot);
          }
          is3D(t2) {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          isDraped(t2) {
            return void 0 !== this.implementation.renderToTile;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
          onAdd(t2) {
            this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
          }
          onRemove(t2) {
            this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
          }
        }
        function zb(t2, e2, r2) {
          const n2 = [0, 0, 1], i2 = rt([]);
          return it(i2, i2, r2 ? -Bt(t2) + Math.PI : Bt(t2)), nt(i2, i2, -Bt(e2)), $(n2, n2, i2), L(n2, n2);
        }
        const Bb = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4 };
        class kb {
          constructor(t2, e2, r2, n2) {
            this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function Tb(t2, e2) {
          const r2 = -1 === t2.indexOf("://");
          try {
            return new URL(t2, r2 && e2 ? "http://example.com" : void 0), true;
          } catch (t3) {
            return false;
          }
        }
        class Vb {
          constructor(t2, e2) {
            this.feature = t2, this.instancedDataOffset = e2, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
          }
        }
        class Eb {
          constructor() {
            this.maxScale = 1, this.maxXYTranslationDistance = 0, this.instancedDataArray = new vl(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
          }
          colorForInstance(t2) {
            const e2 = 16 * t2, r2 = this.instancedDataArray.float32;
            let n2 = Math.floor(r2[e2 + 2]);
            const i2 = 1.05 * (r2[e2 + 2] - n2);
            return n2 /= 100, [r2[e2] % 1 * 1.05, r2[e2 + 1] % 1 * 1.05, i2, n2];
          }
          tileCoordinatesForInstance(t2) {
            const e2 = 16 * t2, r2 = this.instancedDataArray.float32;
            let n2 = r2[e2 + 0];
            return n2 = n2 > jn ? n2 - jn : n2, new It(Math.trunc(n2), Math.trunc(r2[e2 + 1]));
          }
          translationForInstance(t2) {
            const e2 = 16 * t2, r2 = this.instancedDataArray.float32;
            return [r2[e2 + 4], r2[e2 + 5], r2[e2 + 6]];
          }
          rotationScaleForInstance(t2) {
            const e2 = 16 * t2, r2 = this.instancedDataArray.float32;
            return [r2[e2 + 7], r2[e2 + 8], r2[e2 + 9], r2[e2 + 10], r2[e2 + 11], r2[e2 + 12], r2[e2 + 13], r2[e2 + 14], r2[e2 + 15]];
          }
          transformForInstance(t2) {
            const e2 = 16 * t2, r2 = this.instancedDataArray.float32;
            return [r2[e2 + 7], r2[e2 + 8], r2[e2 + 9], r2[e2 + 4], r2[e2 + 10], r2[e2 + 11], r2[e2 + 12], r2[e2 + 5], r2[e2 + 13], r2[e2 + 14], r2[e2 + 15], r2[e2 + 6], 0, 0, 0, 1];
          }
        }
        class Fb {
          constructor(t2) {
            this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaledZ = this.canonical.z + Math.log2(t2.overscaling), this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.projection = t2.projection, this.index = t2.index, this.worldview = t2.worldview, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z + 1 ? 0 : this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t2.styleDefinedModelURLs, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          populate(t2, e2, r2, n2) {
            this.tileToMeter = ju(r2);
            const i2 = this.layers[0]._featureFilter.needGeometry;
            this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
            const s2 = "hd-road-markup" === this.layers[0].paint.get("model-elevation-reference") ? e2.elevationFeatures : void 0;
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = null != o2 ? o2 : a2.properties && a2.properties.hasOwnProperty("id") ? a2.properties.id : void 0, c2 = Ku(a2, i2);
              if (!this.layers[0]._featureFilter.filter(new Ja(this.zoom, { worldview: this.worldview, activeFloors: e2.activeFloors }), c2, r2)) continue;
              const h2 = { id: t3, sourceLayerIndex: u2, index: l2, geometry: i2 ? c2.geometry : Ju(a2, r2, n2), properties: a2.properties, type: a2.type, patterns: {} }, p2 = this.addFeature(h2, h2.geometry, c2, s2, r2);
              p2 && e2.featureIndex.insert(a2, h2.geometry, l2, u2, this.index, this.instancesPerModel[p2].instancedDataArray.length, 256);
            }
            this.lookup = null;
          }
          evaluateQueryRenderedFeaturePadding() {
            const t2 = this.layers[0].modelManager, e2 = this.layers[0].scope;
            let r2 = 0;
            for (const n2 of this.modelUris) {
              const i2 = t2.getModel(n2, e2);
              if (!i2) continue;
              const s2 = this.instancesPerModel[n2];
              if (s2) {
                const t3 = 0.5 * F(i2.aabb.max, i2.aabb.min) * s2.maxScale + s2.maxXYTranslationDistance, e3 = Math.min(jn, Math.max(t3 / this.tileToMeter, 256));
                r2 = Math.max(e3, r2);
              }
            }
            return r2;
          }
          update(t2, e2, r2, n2) {
            for (const e3 in this.instancesPerModel) {
              const r3 = this.instancesPerModel[e3];
              for (const e4 in t2) r3.idToFeaturesIndex.hasOwnProperty(e4) && (this.evaluate(r3.features[r3.idToFeaturesIndex[e4]], t2[e4], r3, true), this.uploaded = false);
            }
            this.maxHeight = 0;
          }
          updateZoomBasedPaintProperties() {
            if (!this.hasZoomDependentProperties) return false;
            let t2 = false;
            for (const e2 in this.instancesPerModel) {
              const r2 = this.instancesPerModel[e2];
              for (const e3 of r2.features) {
                const n2 = this.layers[0], i2 = e3.feature, s2 = this.canonical, a2 = n2.paint.get("model-rotation").evaluate(i2, {}, s2), o2 = n2.paint.get("model-scale").evaluate(i2, {}, s2), l2 = n2.paint.get("model-translation").evaluate(i2, {}, s2);
                X(e3.rotation, a2) && X(e3.scale, o2) && X(e3.translation, l2) || (this.evaluate(e3, e3.featureStates, r2, true), t2 = true);
              }
            }
            return t2;
          }
          updateReplacement(t2, e2, r2, n2) {
            if (e2.updateTime === this.replacementUpdateTime) return false;
            this.replacementUpdateTime = e2.updateTime;
            const i2 = e2.getReplacementRegionsForTile(t2.toUnwrapped(), true);
            if (Nd(this.activeReplacements, i2)) return false;
            this.activeReplacements = i2;
            let s2 = false;
            for (const e3 in this.instancesPerModel) {
              const i3 = this.instancesPerModel[e3], a2 = i3.instancedDataArray;
              for (const e4 of i3.features) {
                const i4 = e4.instancedDataOffset, o2 = e4.instancedDataCount;
                for (let e5 = 0; e5 < o2; e5++) {
                  const o3 = 16 * (e5 + i4);
                  let l2 = a2.float32[o3 + 0];
                  const u2 = l2 > jn;
                  l2 = u2 ? l2 - jn : l2;
                  const c2 = Math.floor(l2), h2 = Math.floor(a2.float32[o3 + 1]);
                  let p2 = false;
                  for (const e6 of this.activeReplacements) if (!Rd(e6, r2, Bb.Model, n2) && !(e6.min.x > c2 || c2 > e6.max.x || e6.min.y > h2 || h2 > e6.max.y) && (p2 = Hd(Xd(c2, h2, t2.canonical, e6.footprintTileId.canonical), e6.footprint), p2)) break;
                  a2.float32[o3] = p2 ? l2 + jn : l2, s2 = s2 || p2 !== u2;
                }
              }
            }
            return s2;
          }
          isEmpty() {
            for (const t2 in this.instancesPerModel) if (0 !== this.instancesPerModel[t2].instancedDataArray.length) return false;
            return true;
          }
          uploadPending() {
            return !this.uploaded;
          }
          upload(t2) {
            if (!this.uploaded) for (const e2 in this.instancesPerModel) {
              const r2 = this.instancesPerModel[e2];
              r2.instancedDataArray.length < 0 || 0 === r2.instancedDataArray.length || (r2.instancedDataBuffer ? r2.instancedDataBuffer.updateData(r2.instancedDataArray) : r2.instancedDataBuffer = t2.createVertexBuffer(r2.instancedDataArray, Gm.members, true, void 0, this.instanceCount));
            }
            this.uploaded = true;
          }
          destroy(t2) {
            for (const t3 in this.instancesPerModel) {
              const e3 = this.instancesPerModel[t3];
              0 !== e3.instancedDataArray.length && e3.instancedDataBuffer && e3.instancedDataBuffer.destroy();
            }
            const e2 = this.layers[0].modelManager;
            if (t2 && e2 && this.modelUris && this.modelsRequested) for (const t3 of this.modelUris) e2.removeModel(t3, "", true);
          }
          addFeature(t2, e2, r2, n2, i2) {
            const s2 = this.layers[0], a2 = s2.layout.get("model-id"), o2 = s2.layout.get("model-allow-density-reduction"), l2 = a2.evaluate(r2, {}, this.canonical);
            if (!l2) return Zt(`modelId is not evaluated for layer ${s2.id} and it is not going to get rendered.`), l2;
            (Tb(l2, false) || void 0 !== this.styleDefinedModelURLs[l2]) && (this.modelUris.includes(l2) || this.modelUris.push(l2)), this.instancesPerModel[l2] || (this.instancesPerModel[l2] = new Eb());
            const u2 = this.instancesPerModel[l2], c2 = u2.instancedDataArray, h2 = new Vb(r2, c2.length);
            let p2;
            n2 && (p2 = Mc.getElevationFeature(t2, n2));
            for (const t3 of e2) for (const e3 of t3) {
              if (e3.x < 0 || e3.x >= jn || e3.y < 0 || e3.y >= jn) continue;
              if (0 !== this.lookupDim && o2) {
                const t5 = (this.lookupDim - 1) / jn, r3 = this.lookupDim * (e3.y * t5 | 0) + e3.x * t5 | 0;
                if (this.lookup) {
                  if (0 !== this.lookup[r3]) continue;
                  this.lookup[r3] = 1;
                }
              }
              this.instanceCount++;
              const t4 = c2.length;
              if (c2.resize(t4 + 1), n2) {
                u2.instancesRoadElevation || (u2.instancesRoadElevation = []);
                const t5 = p2 ? p2.pointElevation(new It(e3.x, e3.y)) : 0;
                u2.instancesRoadElevation.push(t5);
              }
              u2.instancesEvaluatedElevation.push(0), c2.float32[16 * t4] = e3.x, c2.float32[16 * t4 + 1] = e3.y;
            }
            return h2.instancedDataCount = u2.instancedDataArray.length - h2.instancedDataOffset, h2.instancedDataCount > 0 && (t2.id && (u2.idToFeaturesIndex[t2.id] = u2.features.length), u2.features.push(h2), this.evaluate(h2, {}, u2, false)), l2;
          }
          getModelUris() {
            return this.modelUris;
          }
          evaluate(t2, e2, r2, n2) {
            const i2 = this.layers[0], s2 = t2.feature, a2 = this.canonical, o2 = t2.rotation = i2.paint.get("model-rotation").evaluate(s2, e2, a2), l2 = t2.scale = i2.paint.get("model-scale").evaluate(s2, e2, a2), u2 = t2.translation = i2.paint.get("model-translation").evaluate(s2, e2, a2), c2 = Object.assign({}, i2.paint.get("model-color").evaluate(s2, e2, a2));
            c2.a = i2.paint.get("model-color-mix-intensity").evaluate(s2, e2, a2);
            const h2 = [];
            this.maxVerticalOffset < u2[2] && (this.maxVerticalOffset = u2[2]);
            const p2 = u2[0] * u2[0] + u2[1] * u2[1], d2 = p2 > 0 ? Math.sqrt(p2) : 0;
            r2.maxScale = Math.max(Math.max(r2.maxScale, l2[0]), Math.max(l2[1], l2[2])), r2.maxXYTranslationDistance = Math.max(r2.maxXYTranslationDistance, d2), this.maxScale = Math.max(Math.max(this.maxScale, l2[0]), Math.max(l2[1], l2[2])), Jm(h2, o2, l2);
            const f2 = Math.round(100 * c2.a) + c2.b / 1.05;
            for (let e3 = 0; e3 < t2.instancedDataCount; ++e3) {
              const i3 = t2.instancedDataOffset + e3, s3 = 16 * i3, o3 = r2.instancedDataArray.float32;
              let l3 = 0;
              n2 && (l3 = o3[s3 + 6] - r2.instancesEvaluatedElevation[i3]);
              const p3 = 0 | o3[s3 + 1];
              o3[s3] = (0 | o3[s3]) + c2.r / 1.05, o3[s3 + 1] = p3 + c2.g / 1.05, o3[s3 + 2] = f2, o3[s3 + 3] = 1 / (a2.z > 10 ? this.tileToMeter : ju(a2, p3)), o3[s3 + 4] = u2[0], o3[s3 + 5] = u2[1], o3[s3 + 6] = u2[2] + (r2.instancesRoadElevation ? r2.instancesRoadElevation[i3] : 0) + l3, o3[s3 + 7] = h2[0], o3[s3 + 8] = h2[1], o3[s3 + 9] = h2[2], o3[s3 + 10] = h2[4], o3[s3 + 11] = h2[5], o3[s3 + 12] = h2[6], o3[s3 + 13] = h2[8], o3[s3 + 14] = h2[9], o3[s3 + 15] = h2[10], r2.instancesEvaluatedElevation[i3] = u2[2];
            }
          }
        }
        let Db, Cb;
        Qs(Fb, "ModelBucket", { omit: ["layers"] }), Qs(Eb, "PerModelAttributes"), Qs(Vb, "ModelFeature");
        class Rb {
          constructor(t2, e2, r2) {
            this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
          }
          static create(t2, e2, r2) {
            const n2 = r2 || t2.findDEMTileFor(e2);
            if (!n2 || !n2.dem) return;
            const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
            return new Rb(n2, i2.dim / jn / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
          }
          tileCoordToPixel(t2, e2) {
            const r2 = e2 * this._scale + this._offset[1];
            return new It(Math.floor(t2 * this._scale + this._offset[0]), Math.floor(r2));
          }
          getElevationAt(t2, e2, r2, n2) {
            const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
            return n2 = !!n2, r2 ? dr(dr(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), dr(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
          }
          getElevationAtPixel(t2, e2, r2) {
            return this._dem.get(t2, e2, !!r2);
          }
          getMeterToDEM(t2) {
            return (1 << this._demTile.tileID.canonical.z) * Fu(1, t2) * this._dem.stride;
          }
        }
        const Lb = new Float32Array(262144), Ob = new Uint8Array(262144);
        function Ub(t2) {
          let e2 = 0;
          if (t2.meshes) for (const r2 of t2.meshes) e2 = Math.max(e2, r2.aabb.max[2]);
          if (t2.children) for (const r2 of t2.children) e2 = Math.max(e2, Ub(r2));
          return e2;
        }
        function Nb(t2, e2, r2) {
          if (t2.meshes) for (const n2 of t2.meshes) {
            if (n2.aabb.min[0] === 1 / 0) continue;
            const i2 = wc.applyTransform(n2.aabb, t2.globalMatrix);
            r2.insert(e2, i2.min[0], i2.min[1], i2.max[0], i2.max[1]);
          }
          if (t2.children) for (const n2 of t2.children) Nb(n2, e2, r2);
        }
        const jb = ["", "wall", "door", "roof", "window", "lamp", "logo"];
        class Gb {
          constructor(t2) {
            this.node = t2, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedTranslation = [0, 0, 0], this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: t2.id, geometry: [], properties: { height: Ub(t2) } }, this.aabb = this._getLocalBounds(), this.state = null;
          }
          _getLocalBounds() {
            if (!this.node.meshes) return new wc([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            if (!this.aabb) {
              let t2 = 0;
              const e2 = new wc([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              for (const r2 of this.node.meshes) this.node.lightMeshIndex !== t2 && (r2.transformedAabb = wc.applyTransformFast(r2.aabb, this.node.globalMatrix), e2.encapsulate(r2.transformedAabb)), t2++;
              this.aabb = e2;
            }
            return this.aabb;
          }
        }
        class $b {
          constructor(t2, e2, r2, n2, i2, s2, a2, o2) {
            this.id = r2, this.layers = t2, this.layerIds = this.layers.map((t3) => t3.fqid), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.modelTraits |= ry.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, n2 && (this.modelTraits |= ry.HasMapboxMeshFeatures), i2 && (this.modelTraits |= ry.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s2, this.worldview = o2, this.dirty = true, this.needsUpload = false, this.filter = null, this.nodesInfo = [];
            for (const t3 of e2) this.nodesInfo.push(new Gb(t3)), Nb(t3, a2.featureIndexArray.length, a2.grid), a2.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, a2.bucketLayerIDs.length - 1, 0);
            this.states = {}, this.hasAppearances = null;
          }
          updateFootprints(t2, e2) {
            for (const r2 of this.getNodesInfo()) {
              const n2 = r2.node;
              n2.footprint && e2.push({ footprint: n2.footprint, id: t2 });
            }
          }
          updateAppearances(t2, e2, r2, n2) {
          }
          update(t2) {
            const e2 = 0 !== Object.keys(t2).length;
            if (e2 && !this.stateDependentLayers.length) return;
            const r2 = e2 ? this.stateDependentLayers : this.layers;
            if (!St(t2, this.states)) for (const e3 of r2) this.evaluate(e3, t2);
            this.states = structuredClone(t2);
          }
          populate() {
            console.log("populate 3D model bucket");
          }
          uploadPending() {
            return !this.uploaded || this.needsUpload;
          }
          upload(t2) {
            if (!this.needsUpload) return;
            const e2 = this.getNodesInfo();
            for (const r2 of e2) {
              const e3 = r2.node;
              this.uploaded ? this.updatePbrBuffer(e3) : oy(e3, t2, true);
            }
            for (const t3 of e2) ly(t3.node);
            this.uploaded = true, this.needsUpload = false;
          }
          updatePbrBuffer(t2) {
            let e2 = false;
            if (!t2.meshes) return e2;
            for (const r2 of t2.meshes) r2.pbrBuffer && (r2.pbrBuffer.updateData(r2.featureArray), e2 = true);
            return e2;
          }
          needsReEvaluation(t2, e2, r2) {
            const n2 = t2.transform.projectionOptions, i2 = t2.style.getBrightness(), s2 = this.brightness !== i2;
            if (!this.uploaded || this.dirty || n2.name !== this.projection.name || qb(r2.paint.get("model-color").value, s2) || qb(r2.paint.get("model-color-mix-intensity").value, s2) || qb(r2.paint.get("model-roughness").value, s2) || qb(r2.paint.get("model-emissive-strength").value, s2) || qb(r2.paint.get("model-height-based-emissive-strength-multiplier").value, s2)) {
              this.projection = n2, this.brightness = i2;
              const t3 = this.getNodesInfo();
              for (const e3 of t3) e3.state = null;
              return true;
            }
            return false;
          }
          evaluateTransform(t2, e2) {
            if (t2.transform.zoom === this.zoom) return;
            this.zoom = t2.transform.zoom;
            const r2 = this.getNodesInfo(), n2 = this.id.canonical;
            for (const t3 of r2) {
              const r3 = t3.feature;
              t3.evaluatedTranslation = e2.paint.get("model-translation").evaluate(r3, {}, n2), t3.evaluatedScale = e2.paint.get("model-scale").evaluate(r3, {}, n2);
            }
          }
          evaluate(t2, e2) {
            const r2 = this.getNodesInfo();
            for (const n2 of r2) {
              if (!n2.node.meshes) continue;
              const r3 = n2.feature, i2 = e2 && e2[r3.id];
              if (St(i2, n2.state)) continue;
              n2.state = structuredClone(i2);
              const s2 = n2.node.meshes && n2.node.meshes[0].featureData, a2 = n2.evaluatedColor[2], o2 = n2.evaluatedRMEA[2], l2 = this.id.canonical;
              if (n2.hasTranslucentParts = false, s2) {
                for (let e3 = 0; e3 < jb.length; e3++) {
                  const s3 = jb[e3];
                  s3.length && (r3.properties.part = s3);
                  const a3 = t2.paint.get("model-color").evaluate(r3, i2, l2).toPremultipliedRenderColor(null), o3 = t2.paint.get("model-color-mix-intensity").evaluate(r3, i2, l2);
                  n2.evaluatedColor[e3] = [a3.r, a3.g, a3.b, o3], n2.evaluatedRMEA[e3][0] = t2.paint.get("model-roughness").evaluate(r3, i2, l2), n2.evaluatedRMEA[e3][2] = t2.paint.get("model-emissive-strength").evaluate(r3, i2, l2), n2.evaluatedRMEA[e3][3] = a3.a, n2.emissionHeightBasedParams[e3] = t2.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r3, i2, l2), !n2.hasTranslucentParts && a3.a < 1 && (n2.hasTranslucentParts = true);
                }
                delete r3.properties.part, Hb(n2, a2 !== n2.evaluatedColor[2] || o2 !== n2.evaluatedRMEA[2], this.modelTraits);
              } else n2.evaluatedRMEA[0][2] = t2.paint.get("model-emissive-strength").evaluate(r3, i2, l2);
              n2.evaluatedTranslation = t2.paint.get("model-translation").evaluate(r3, i2, l2), n2.evaluatedScale = t2.paint.get("model-scale").evaluate(r3, i2, l2), this.updatePbrBuffer(n2.node) || (this.needsUpload = true);
            }
            this.dirty = false;
          }
          elevationUpdate(t2, e2, r2, n2) {
            const i2 = t2.findDEMTileFor(r2);
            if (i2 && (i2.tileID.canonical !== this.terrainTile || e2 !== this.terrainExaggeration)) {
              if (i2.dem && i2.tileID.overscaledZ !== this.elevationReadFromZ) {
                this.elevationReadFromZ = i2.tileID.overscaledZ;
                const e3 = Rb.create(t2, r2, i2);
                if (!e3) return;
                this.modelTraits & ry.HasMapboxMeshFeatures && this.updateDEM(t2, e3, r2, n2);
                for (const t3 of this.getNodesInfo()) {
                  const r3 = t3.node;
                  if (!r3.footprint || !r3.footprint.vertices || !r3.footprint.vertices.length) continue;
                  const n3 = r3.footprint.vertices;
                  let i3 = e3.getElevationAt(n3[0].x, n3[0].y, true, true);
                  for (let t4 = 1; t4 < n3.length; t4++) i3 = Math.min(i3, e3.getElevationAt(n3[t4].x, n3[t4].y, true, true));
                  r3.elevation = i3;
                }
              }
              this.terrainTile = i2.tileID.canonical, this.terrainExaggeration = e2;
            }
          }
          updateDEM(t2, e2, r2, n2) {
            let i2 = e2._dem._modifiedForSources[n2];
            if (void 0 === i2 && (e2._dem._modifiedForSources[n2] = [], i2 = e2._dem._modifiedForSources[n2]), i2.includes(r2.canonical)) return;
            const s2 = e2._dem.dim;
            i2.push(r2.canonical);
            let a2 = false;
            for (const t3 of this.getNodesInfo()) {
              const r3 = t3.node;
              if (!r3.footprint || !r3.footprint.grid) continue;
              const n3 = r3.footprint.grid, i3 = e2.tileCoordToPixel(n3.min.x, n3.min.y), o2 = e2.tileCoordToPixel(n3.max.x, n3.max.y), l2 = Math.min(Math.min(s2 - o2.y, i3.x), Math.min(i3.y, s2 - o2.x));
              if (l2 < 0) continue;
              const u2 = Dt(l2, 2, 5);
              let c2 = Math.max(0, i3.x - u2), h2 = Math.max(0, i3.y - u2), p2 = Math.min(o2.x + u2, s2 - 1), d2 = Math.min(o2.y + u2, s2 - 1);
              for (let t4 = h2; t4 <= d2; ++t4) for (let e3 = c2; e3 <= p2; ++e3) Ob[t4 * s2 + e3] = 255;
              let f2 = 0, m2 = 0;
              for (let t4 = 0; t4 < n3.cellsY; ++t4) for (let r4 = 0; r4 < n3.cellsX; ++r4) {
                if (!n3.cells[t4 * n3.cellsX + r4]) continue;
                const i4 = e2.tileCoordToPixel(n3.min.x + r4 / n3.xScale, n3.min.y + t4 / n3.yScale), a3 = e2.tileCoordToPixel(n3.min.x + (r4 + 1) / n3.xScale, n3.min.y + (t4 + 1) / n3.yScale);
                for (let t5 = i4.y; t5 <= Math.min(a3.y + 1, s2 - 1); ++t5) for (let r5 = i4.x; r5 <= Math.min(a3.x + 1, s2 - 1); ++r5) 255 === Ob[t5 * s2 + r5] && (Ob[t5 * s2 + r5] = 0, f2 += e2.getElevationAtPixel(r5, t5), m2++);
              }
              const y2 = f2 / m2;
              c2 = Math.max(1, i3.x - u2), h2 = Math.max(1, i3.y - u2), p2 = Math.min(o2.x + u2, s2 - 2), d2 = Math.min(o2.y + u2, s2 - 2), a2 = true;
              for (let t4 = h2; t4 <= d2; ++t4) for (let r4 = c2; r4 <= p2; ++r4) 0 === Ob[t4 * s2 + r4] && (Lb[t4 * s2 + r4] = e2._dem.set(r4, t4, y2));
              for (let t4 = 1; t4 < u2; ++t4) {
                c2 = Math.max(1, i3.x - t4), h2 = Math.max(1, i3.y - t4), p2 = Math.min(o2.x + t4, s2 - 2), d2 = Math.min(o2.y + t4, s2 - 2);
                for (let r4 = h2; r4 <= d2; ++r4) for (let n4 = c2; n4 <= p2; ++n4) {
                  const i4 = r4 * s2 + n4;
                  if (255 === Ob[i4]) {
                    let a3 = 0, o3 = 0, l3 = -1, c3 = -1;
                    for (let e3 = -1; e3 <= 1; ++e3) for (let i5 = -1; i5 <= 1; ++i5) {
                      const u3 = (r4 + e3) * s2 + n4 + i5;
                      if (Ob[u3] >= t4) continue;
                      const h3 = Lb[u3], p3 = Math.abs(h3);
                      p3 > o3 && (a3 = h3, o3 = p3, l3 = i5, c3 = e3);
                    }
                    if (o3 > 0.1) {
                      const s3 = 1 - (t4 + 0.5 * Math.abs(l3 * c3)) / u2;
                      let o4 = e2._dem.get(n4, r4) + a3 * s3;
                      const h3 = e2._dem.get(n4 + l3, r4 + c3), p3 = e2._dem.get(n4 - l3, r4 - c3, true);
                      (o4 - h3) * (o4 - p3) > 0 && (o4 = (h3 + p3) / 2), Lb[i4] = e2._dem.set(n4, r4, o4), Ob[i4] = t4;
                    }
                  }
                }
              }
            }
            a2 && (e2._demTile.needsDEMTextureUpload = true, e2._dem._timestamp = ge.now());
          }
          setFilter(t2) {
            this.filter = t2 ? mo(t2) : null;
          }
          getNodesInfo() {
            return this.filter ? this.nodesInfo.filter((t2) => this.filter.filter(new Ja(this.id.overscaledZ, { worldview: this.worldview }), t2.feature, this.id.canonical)) : this.nodesInfo;
          }
          destroy() {
            const t2 = this.getNodesInfo();
            for (const e2 of t2) ly(e2.node), cy(e2.node);
          }
          isEmpty() {
            return !this.nodesInfo.length;
          }
          updateReplacement(t2, e2) {
            if (e2.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = e2.updateTime;
            const r2 = e2.getReplacementRegionsForTile(t2.toUnwrapped());
            for (const t3 of this.getNodesInfo()) {
              const e3 = t3.node.footprint;
              t3.hiddenByReplacement = !!e3 && !r2.find((t4) => t4.footprint === e3);
            }
          }
          getHeightAtTileCoord(t2, e2) {
            const r2 = [], n2 = [0, 0, 0], i2 = u([]);
            for (const s2 of this.getNodesInfo()) {
              const a2 = s2.node.meshes[0], o2 = a2.transformedAabb;
              if (t2 < o2.min[0] || e2 < o2.min[1] || t2 > o2.max[0] || e2 > o2.max[1]) continue;
              if (true === s2.node.hidden) return { height: 1 / 0, maxHeight: s2.feature.properties.height, hidden: false, verticalScale: s2.evaluatedScale[2] };
              c(i2, s2.node.globalMatrix), n2[0] = t2, n2[1] = e2, j(n2, n2, i2);
              const l2 = (n2[0] - a2.aabb.min[0]) / (a2.aabb.max[0] - a2.aabb.min[0]) * ey | 0, u2 = Math.min(63, (n2[1] - a2.aabb.min[1]) / (a2.aabb.max[1] - a2.aabb.min[1]) * ey | 0) * ey + Math.min(63, l2), h2 = a2.heightmap[u2];
              if (!(h2 < 0 && s2.node.footprint)) {
                if (s2.hiddenByReplacement) return;
                return { height: h2, maxHeight: s2.feature.properties.height, hidden: false, verticalScale: s2.evaluatedScale[2] };
              }
              if (s2.node.footprint.grid.query(new It(t2, e2), new It(t2, e2), r2), r2.length > 0) return { height: void 0, maxHeight: s2.feature.properties.height, hidden: s2.hiddenByReplacement, verticalScale: s2.evaluatedScale[2] };
            }
          }
        }
        function qb(t2, e2) {
          return t2 instanceof Gs && !t2.isLightConstant && e2;
        }
        function Xb(t2, e2, r2, n2, i2, s2, a2, o2) {
          let l2 = (61440 & e2 | (61440 & e2) >> 4) >> 8, u2 = (3840 & e2 | (3840 & e2) >> 4) >> 4, c2 = 240 & e2 | (240 & e2) >> 4;
          r2[3] > 0 && (l2 = dr(l2, 255 * r2[0], r2[3]), u2 = dr(u2, 255 * r2[1], r2[3]), c2 = dr(c2, 255 * r2[2], r2[3]));
          const h2 = l2 << 8 | u2, p2 = c2 << 8 | Math.floor(255 * n2[3]), d2 = function(t3) {
            const e3 = Dt(t3, 0, 2);
            return Math.min(Math.round(0.5 * e3 * 255), 255);
          }(n2[2]) << 8 | 15 * n2[0] << 4 | 15 * n2[1], f2 = Dt(i2[0], 0, 1), m2 = Dt(i2[1], 0, 1), y2 = Dt(i2[2], 0, 1), g2 = Dt(i2[3], 0, 1);
          let x2, v2, b2, w2;
          if (f2 !== m2 && a2 !== s2 && m2 !== f2) {
            const t3 = a2 - s2;
            v2 = 1 / (t3 * (m2 - f2)), b2 = -(s2 + t3 * f2) / (t3 * (m2 - f2));
            const e3 = Dt(i2[4], -1, 1);
            w2 = Math.pow(10, e3), x2 = 255 * y2 << 8 | 255 * g2;
          } else x2 = 65535, v2 = 0, b2 = 1, w2 = 1;
          if (t2.emplaceBack(h2, p2, d2, x2, v2, b2, w2), o2) {
            const t3 = o2.length;
            o2.clear();
            for (let e3 = 0; e3 < t3; e3++) o2.emplaceBack(h2, p2, d2, x2, v2, b2, w2);
          }
        }
        function Hb(t2, e2, r2) {
          const n2 = t2.node;
          let i2 = 0;
          const s2 = r2 & ry.HasMeshoptCompression;
          for (const r3 of n2.meshes) {
            if (n2.lights && n2.lightMeshIndex === i2) continue;
            if (!r3.featureData) continue;
            r3.featureArray = new bl(), r3.featureArray.reserve(r3.featureData.length);
            let a2 = e2;
            for (const e3 of r3.featureData) {
              const i3 = s2 ? 65535 & e3 : e3 >> 16 & 65535, o2 = s2 ? e3 >> 16 & 65535 : 65535 & e3, l2 = (15 & o2) < 8 ? 15 & o2 : 0, u2 = t2.evaluatedRMEA[l2], c2 = t2.evaluatedColor[l2], h2 = t2.emissionHeightBasedParams[l2];
              let p2;
              if (a2 && 2 === l2 && n2.lights && (p2 = new bl(), p2.resize(10 * n2.lights.length)), Xb(r3.featureArray, i3, c2, u2, h2, r3.aabb.min[2], r3.aabb.max[2], p2), p2 && a2) {
                a2 = false;
                const t3 = n2.meshes[n2.lightMeshIndex];
                t3.featureArray = p2, t3.featureArray._trim();
              }
            }
            r3.featureArray._trim(), i2++;
          }
        }
        Qs($b, "Tiled3dModelBucket", { omit: ["layers"] }), Qs(Gb, "Tiled3dModelFeature");
        const Zb = ["id", "tile", "layer", "source", "sourceLayer", "state"];
        class Wb {
          constructor(t2, e2, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r2, this._y = n2, this.properties = t2 ? t2.properties : {}, this.id = i2;
          }
          clone() {
            const t2 = new Wb(this._vectorTileFeature, this._z, this._x, this._y, this.id);
            return this.state && (t2.state = Object.assign({}, this.state)), this.layer && (t2.layer = Object.assign({}, this.layer)), this.source && (t2.source = this.source), this.sourceLayer && (t2.sourceLayer = this.sourceLayer), t2;
          }
          get geometry() {
            return void 0 === this._geometry && this._vectorTileFeature && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            for (const e2 of Zb) void 0 !== this[e2] && (t2[e2] = this[e2]);
            return t2;
          }
        }
        class Yb extends ir {
          constructor(t2, e2, r2, n2) {
            super(), this.id = t2, this.type = "model", this.models = [], this._options = e2, this._modelsInfo = /* @__PURE__ */ new Map();
          }
          loadGLTFFromURI(t2) {
            return Em(this.map._requestManager.transformRequest(t2, Ce.Model).url);
          }
          load() {
            for (const t2 in this._options.models) {
              const e2 = this._options.models[t2], r2 = this._modelsInfo.get(t2);
              if (r2) {
                r2.modelSpec = e2;
                const t3 = r2.model;
                t3 && (t3.position = null != e2.position ? new Bu(e2.position[0], e2.position[1]) : new Bu(0, 0), t3.orientation = null != e2.orientation ? e2.orientation : [0, 0, 0], Yb.applyModelSpecification(t3, e2), t3.computeBoundsAndApplyParent(), this.models.push(t3));
              } else this._modelsInfo.set(t2, { modelSpec: e2, model: null }), this.loadGLTFFromURI(e2.uri).then((e3) => {
                if (!e3) return;
                const r3 = this._modelsInfo.get(t2);
                if (!r3) return;
                const n2 = xy(e3), i2 = r3.modelSpec, s2 = new iy(t2, i2.uri, i2.position, i2.orientation, n2);
                Yb.applyModelSpecification(s2, i2), s2.computeBoundsAndApplyParent(), this.models.push(s2), r3.model = s2, this.loaded() && this.fire(new tr("data", { dataType: "source", sourceDataType: "metadata" }));
              }).catch((r3) => {
                this.fire(new er(new Error(`Could not load model ${t2} from ${e2.uri}: ${r3.message}`)));
              });
            }
            this.loaded() && this.fire(new tr("data", { dataType: "source", sourceDataType: "metadata" }));
          }
          static applyModelSpecification(t2, e2) {
            e2.nodeOverrides && Yb.convertNodeOverrides(t2, e2.nodeOverrides), e2.materialOverrides && Yb.convertMaterialOverrides(t2, e2.materialOverrides), e2.nodeOverrideNames && (t2.nodeOverrideNames = [...e2.nodeOverrideNames]), e2.materialOverrideNames && (t2.materialOverrideNames = [...e2.materialOverrideNames]), e2.featureProperties && (t2.featureProperties = e2.featureProperties);
          }
          static convertNodeOverrides(t2, e2) {
            if (Array.isArray(e2) && e2.every((t3) => "string" == typeof t3)) {
              t2.nodeOverrideNames = [];
              for (const r2 of e2) t2.nodeOverrideNames.push(r2);
            } else Object.entries(e2).forEach(([e3, r2]) => {
              const n2 = { orientation: [0, 0, 0] };
              if (r2.hasOwnProperty("orientation")) {
                const t3 = r2.orientation;
                t3 && (n2.orientation = t3);
              }
              t2.nodeOverrides.set(e3, n2);
            });
          }
          static convertMaterialOverrides(t2, e2) {
            if (Array.isArray(e2) && e2.every((t3) => "string" == typeof t3)) {
              t2.materialOverrideNames = [];
              for (const r2 of e2) t2.materialOverrideNames.push(r2);
            } else Object.entries(e2).forEach(([e3, r2]) => {
              const n2 = { color: new ur(1, 1, 1), colorMix: 0, emissionStrength: 0, opacity: 1 }, i2 = r2["model-color"];
              void 0 !== i2 && (n2.color.r = i2[0], n2.color.g = i2[1], n2.color.b = i2[2]);
              const s2 = r2["model-color-mix-intensity"];
              void 0 !== s2 && (n2.colorMix = s2);
              const a2 = r2["model-emissive-strength"];
              void 0 !== a2 && (n2.emissionStrength = a2);
              const o2 = r2["model-opacity"];
              void 0 !== o2 && (n2.opacity = o2), t2.materialOverrides.set(e3, n2);
            });
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          hasTransition() {
            return false;
          }
          loaded() {
            if (0 === this._modelsInfo.size) return true;
            for (const t2 of this._modelsInfo.values()) if (null == t2.model) return false;
            return true;
          }
          getModels() {
            return this.models;
          }
          loadTile(t2, e2) {
          }
          serialize() {
            return this._options;
          }
          setProperty(t2, e2) {
            return false;
          }
          reload() {
            const t2 = zo(this.id, this.scope);
            this.map.style.clearSource(t2), this.models = [], this._modelsInfo.clear(), this.load();
          }
          setModels(t2) {
            this.models = [];
            const e2 = /* @__PURE__ */ new Map();
            for (const r2 in t2) {
              const n2 = t2[r2];
              if (this._modelsInfo.has(r2)) {
                const t3 = this._modelsInfo.get(r2);
                t3 && t3.modelSpec.uri === n2.uri && e2.set(r2, t3);
              }
            }
            this._modelsInfo = e2, this._options.models = t2, this.load();
          }
        }
        function Jb(t2, e2, r2, n2) {
          const i2 = 1 << t2.z;
          e2.lat = Cu((n2 / jn + t2.y) / i2), e2.lng = Du((r2 / jn + t2.x) / i2);
        }
        function Kb(t2, e2, r2, n2) {
          const i2 = t2.getNodesInfo()[e2];
          if (!i2 || i2.hiddenByReplacement || !i2.node.meshes) return;
          let s2 = Number.MAX_VALUE;
          const a2 = i2.node, o2 = r2.tile, l2 = n2.calculatePosMatrix(o2.tileID.toUnwrapped(), n2.worldSize), u2 = i2.evaluatedScale;
          let c2 = 0;
          n2.elevation && a2.elevation && (c2 = a2.elevation * n2.elevation.exaggeration()), p(l2, l2, [(a2.anchor ? a2.anchor[0] : 0) * (u2[0] - 1), (a2.anchor ? a2.anchor[1] : 0) * (u2[1] - 1), c2]), d(l2, l2, u2);
          const f2 = r2.queryGeometry, m2 = f2.isPointQuery() ? f2.screenBounds : f2.screenGeometry, y2 = function(t3) {
            const e3 = h([], l2, t3.globalMatrix);
            h(e3, n2.expandedFarZProjMatrix, e3);
            for (let r3 = 0; r3 < t3.meshes.length; ++r3) {
              const i3 = t3.meshes[r3];
              if (r3 === t3.lightMeshIndex) continue;
              const a3 = ty(m2, n2, e3, i3.aabb);
              null != a3 && (s2 = Math.min(a3, s2));
            }
            if (t3.children) for (const e4 of t3.children) y2(e4);
          };
          if (y2(a2), s2 === Number.MAX_VALUE) return;
          const g2 = new Bu(0, 0);
          return Jb(o2.tileID.canonical, g2, i2.node.anchor[0], i2.node.anchor[1]), { intersectionZ: s2, position: g2, feature: i2.feature };
        }
        const Qb = { circle: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Hc || (Hc = new uo({ "circle-sort-key": new oo(co.layout_circle["circle-sort-key"]), "circle-elevation-reference": new ao(co.layout_circle["circle-elevation-reference"]), visibility: new ao(co.layout_circle.visibility) })), paint: Zc || (Zc = new uo({ "circle-radius": new oo(co.paint_circle["circle-radius"]), "circle-color": new oo(co.paint_circle["circle-color"]), "circle-blur": new oo(co.paint_circle["circle-blur"]), "circle-opacity": new oo(co.paint_circle["circle-opacity"]), "circle-translate": new ao(co.paint_circle["circle-translate"]), "circle-translate-anchor": new ao(co.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ao(co.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ao(co.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new oo(co.paint_circle["circle-stroke-width"]), "circle-stroke-color": new oo(co.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new oo(co.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new ao(co.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
          }
          createBucket(t2) {
            return new Sc(t2);
          }
          queryRadius(t2) {
            const e2 = t2;
            return Gc("circle-radius", this, e2) + Gc("circle-stroke-width", this, e2) + $c(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = Xc(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
            return Vh(t2, n2, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u2);
          }
          getProgramIds() {
            return ["circle"];
          }
          getDefaultProgramParams(t2, e2, r2) {
            const n2 = Th(this);
            return { config: new du(this, { zoom: e2, lut: r2 }), defines: n2, overrideFog: false };
          }
          is3D(t2) {
            return !t2 && !!this.layout && "none" !== this.layout.get("circle-elevation-reference");
          }
          hasElevation() {
            return this.layout && "none" !== this.layout.get("circle-elevation-reference");
          }
        }, heatmap: class extends Fo {
          createBucket(t2) {
            return new Rh(t2);
          }
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Lh || (Lh = new uo({ visibility: new ao(co.layout_heatmap.visibility) })), paint: Oh || (Oh = new uo({ "heatmap-radius": new oo(co.paint_heatmap["heatmap-radius"]), "heatmap-weight": new oo(co.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ao(co.paint_heatmap["heatmap-intensity"]), "heatmap-color": new lo(co.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ao(co.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Zh({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          _clear() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          queryRadius(t2) {
            return Gc("heatmap-radius", this, t2);
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.paint.get("heatmap-radius").evaluate(e2, r2);
            return Vh(t2, n2, s2, a2, o2, true, true, new It(0, 0), l2);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getDefaultProgramParams(t2, e2, r2) {
            return "heatmap" === t2 ? { config: new du(this, { zoom: e2, lut: r2 }), overrideFog: false } : {};
          }
        }, hillshade: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Uh || (Uh = new uo({ visibility: new ao(co.layout_hillshade.visibility) })), paint: Nh || (Nh = new uo({ "hillshade-illumination-direction": new ao(co.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ao(co.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ao(co.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ao(co.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ao(co.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ao(co.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new ao(co.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
          }
          shouldRedrape() {
            return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
          getDefaultProgramParams(t2, e2, r2) {
            return { overrideFog: false };
          }
        }, fill: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: bd || (bd = new uo({ "fill-sort-key": new oo(co.layout_fill["fill-sort-key"]), visibility: new ao(co.layout_fill.visibility), "fill-elevation-reference": new ao(co.layout_fill["fill-elevation-reference"]), "fill-construct-bridge-guard-rail": new oo(co.layout_fill["fill-construct-bridge-guard-rail"]) })), paint: wd || (wd = new uo({ "fill-antialias": new ao(co.paint_fill["fill-antialias"]), "fill-opacity": new oo(co.paint_fill["fill-opacity"]), "fill-color": new oo(co.paint_fill["fill-color"]), "fill-outline-color": new oo(co.paint_fill["fill-outline-color"]), "fill-translate": new ao(co.paint_fill["fill-translate"]), "fill-translate-anchor": new ao(co.paint_fill["fill-translate-anchor"]), "fill-pattern": new oo(co.paint_fill["fill-pattern"]), "fill-pattern-cross-fade": new ao(co.paint_fill["fill-pattern-cross-fade"]), "fill-emissive-strength": new ao(co.paint_fill["fill-emissive-strength"]), "fill-z-offset": new oo(co.paint_fill["fill-z-offset"]), "fill-bridge-guard-rail-color": new oo(co.paint_fill["fill-bridge-guard-rail-color"]), "fill-tunnel-structure-color": new oo(co.paint_fill["fill-tunnel-structure-color"]), "fill-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "fill-bridge-guard-rail-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "fill-tunnel-structure-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
          }
          getProgramIds() {
            const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
          }
          getDefaultProgramParams(t2, e2, r2) {
            return { config: new du(this, { zoom: e2, lut: r2 }), overrideFog: false };
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new vd(t2);
          }
          queryRadius() {
            return $c(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
            return !t2.queryGeometry.isAboveHorizon && Bc(qc(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
          }
          isTileClipped() {
            return 0 === this.paint.get("fill-z-offset").constantOr(1);
          }
          is3D(t2) {
            if (0 !== this.paint.get("fill-z-offset").constantOr(1)) return true;
            const e2 = this.layout && "none" !== this.layout.get("fill-elevation-reference");
            return null != t2 ? e2 && !t2 : e2;
          }
          hasElevation() {
            return this.layout && "none" !== this.layout.get("fill-elevation-reference");
          }
          hasShadowPass() {
            return this.layout && "none" !== this.layout.get("fill-elevation-reference");
          }
        }, "fill-extrusion": class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Pf || (Pf = new uo({ visibility: new ao(co["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new ao(co["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: zf || (zf = new uo({ "fill-extrusion-opacity": new ao(co["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new oo(co["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ao(co["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ao(co["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new oo(co["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-pattern-cross-fade": new ao(co["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]), "fill-extrusion-height": new oo(co["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new oo(co["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new ao(co["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new ao(co["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new ao(co["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new ao(co["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new ao(co["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new ao(co["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new oo(co["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new oo(co["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new ao(co["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new ao(co["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new ao(co["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new ao(co["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new oo(co["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new oo(co["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new ao(co["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t2) {
            return new mf(t2);
          }
          queryRadius() {
            return $c(this.paint.get("fill-extrusion-translate"));
          }
          is3D(t2) {
            return true;
          }
          hasShadowPass() {
            return this.paint.get("fill-extrusion-cast-shadows");
          }
          cutoffRange() {
            return this.paint.get("fill-extrusion-cutoff-fade-range");
          }
          canCastShadows() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = Xc(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = [0, 0], d2 = o2 && s2.elevation, f2 = s2.elevation ? s2.elevation.exaggeration() : 1, m2 = t2.tile.getBucket(this);
            if (d2 && m2 instanceof mf) {
              const t3 = m2.centroidVertexArray, e3 = l2 + 1;
              e3 < t3.length && (p2[0] = t3.geta_centroid_pos0(e3), p2[1] = t3.geta_centroid_pos1(e3));
            }
            if (0 === p2[0] && 1 === p2[1]) return false;
            "globe" === s2.projection.name && (n2 = If([n2], [new It(0, 0), new It(jn, jn)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
            const y2 = d2 ? o2 : null, [g2, x2] = Of(s2, n2, h2, c2, u2, a2, y2, p2, f2, s2.center.lat, t2.tileID.canonical), v2 = t2.queryGeometry;
            return Lf(g2, x2, v2.isPointQuery() ? v2.screenBounds : v2.screenGeometry);
          }
        }, building: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Uy || (Uy = new uo({ visibility: new ao(co.layout_building.visibility), "building-facade": new oo(co.layout_building["building-facade"]), "building-facade-floors": new oo(co.layout_building["building-facade-floors"]), "building-facade-unit-width": new oo(co.layout_building["building-facade-unit-width"]), "building-facade-window": new oo(co.layout_building["building-facade-window"]), "building-roof-shape": new oo(co.layout_building["building-roof-shape"]), "building-height": new oo(co.layout_building["building-height"]), "building-base": new oo(co.layout_building["building-base"]), "building-flood-light-wall-radius": new oo(co.layout_building["building-flood-light-wall-radius"]), "building-flood-light-ground-radius": new oo(co.layout_building["building-flood-light-ground-radius"]), "building-flip-roof-orientation": new oo(co.layout_building["building-flip-roof-orientation"]) })), paint: Ny || (Ny = new uo({ "building-opacity": new ao(co.paint_building["building-opacity"]), "building-ambient-occlusion-intensity": new ao(co.paint_building["building-ambient-occlusion-intensity"]), "building-ambient-occlusion-ground-intensity": new ao(co.paint_building["building-ambient-occlusion-ground-intensity"]), "building-ambient-occlusion-ground-radius": new ao(co.paint_building["building-ambient-occlusion-ground-radius"]), "building-ambient-occlusion-ground-attenuation": new ao(co.paint_building["building-ambient-occlusion-ground-attenuation"]), "building-vertical-scale": new ao(co.paint_building["building-vertical-scale"]), "building-cast-shadows": new ao(co.paint_building["building-cast-shadows"]), "building-color": new oo(co.paint_building["building-color"]), "building-emissive-strength": new oo(co.paint_building["building-emissive-strength"]), "building-facade-emissive-chance": new ao(co.paint_building["building-facade-emissive-chance"]), "building-cutoff-fade-range": new ao(co.paint_building["building-cutoff-fade-range"]), "building-flood-light-color": new ao(co.paint_building["building-flood-light-color"]), "building-flood-light-intensity": new ao(co.paint_building["building-flood-light-intensity"]), "building-flood-light-ground-attenuation": new ao(co.paint_building["building-flood-light-ground-attenuation"]), "building-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "building-flood-light-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t2) {
            return new Ry(t2);
          }
          cutoffRange() {
            return this.paint.get("building-cutoff-fade-range");
          }
          hasShadowPass() {
            return this.paint.get("building-cast-shadows");
          }
          hasLightBeamPass() {
            return true;
          }
          canCastShadows() {
            return true;
          }
          is3D(t2) {
            return true;
          }
          queryRadius(t2) {
            return 0;
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            let c2 = this.layout.get("building-height").evaluate(e2, r2);
            const h2 = this.layout.get("building-base").evaluate(e2, r2), p2 = t2.tile.getBucket(this).getFootprint(e2);
            if (p2) {
              if (0 !== p2.hiddenFlags) return false;
              c2 = p2.height;
            }
            const [d2, f2] = Of(s2, n2, h2, c2, new It(0, 0), a2, null, [0, 0], 1, s2.center.lat, t2.tileID.canonical), m2 = t2.queryGeometry;
            return Lf(d2, f2, m2.isPointQuery() ? m2.screenBounds : m2.screenGeometry);
          }
        }, line: class extends Fo {
          constructor(t2, e2, r2, n2) {
            const i2 = cg();
            super(t2, i2, e2, r2, n2), i2.layout && (this.layout = new so(i2.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = false, this.hasNonElevatedBuckets = false;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            if ("line-gradient" === t2) {
              const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof zi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          emissiveStrengthExpression() {
            return this._transitionablePaint._values["line-emissive-strength"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = (() => {
              if (pg) return pg;
              const t3 = cg();
              return pg = new hg(t3.paint.properties["line-width"].specification), pg.useIntegerZoom = true, pg;
            })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new Qy(t2);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getDefaultProgramParams(t2, e2, r2) {
            const n2 = og(this);
            return { config: new du(this, { zoom: e2, lut: r2 }), defines: n2, overrideFog: false };
          }
          queryRadius(t2) {
            const e2 = t2, r2 = dg(Gc("line-width", this, e2), Gc("line-gap-width", this, e2)), n2 = Gc("line-offset", this, e2);
            return r2 / 2 + Math.abs(n2) + $c(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
            if (t2.queryGeometry.isAboveHorizon) return false;
            const a2 = qc(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * dg(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), l2 = this.paint.get("line-offset").evaluate(e2, r2);
            return l2 && (n2 = function(t3, e3) {
              const r3 = [], n3 = new It(0, 0);
              for (let i3 = 0; i3 < t3.length; i3++) {
                const s3 = t3[i3], a3 = [];
                for (let t4 = 0; t4 < s3.length; t4++) {
                  const r4 = s3[t4], i4 = s3[t4 + 1], o3 = 0 === t4 ? n3 : r4.sub(s3[t4 - 1])._unit()._perp(), l3 = t4 === s3.length - 1 ? n3 : i4.sub(r4)._unit()._perp(), u2 = o3._add(l3)._unit();
                  u2._mult(1 / (u2.x * l3.x + u2.y * l3.y)), a3.push(u2._mult(e3)._add(r4));
                }
                r3.push(a3);
              }
              return r3;
            }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const i3 = e3[n3];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++) if (Lc(t3, i3[e4])) return true;
                }
                if (kc(t3, i3, r3)) return true;
              }
              return false;
            }(a2, n2, o2);
          }
          isTileClipped() {
            return this.hasNonElevatedBuckets;
          }
          isDraped(t2) {
            return !this.hasElevatedBuckets || this.layout && "hd-road-markup" === this.layout.get("line-elevation-reference");
          }
          hasElevation() {
            return this.layout && "none" !== this.layout.get("line-elevation-reference");
          }
        }, symbol: lb, background: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: ub || (ub = new uo({ visibility: new ao(co.layout_background.visibility) })), paint: cb || (cb = new uo({ "background-pitch-alignment": new ao(co.paint_background["background-pitch-alignment"]), "background-color": new ao(co.paint_background["background-color"]), "background-pattern": new ao(co.paint_background["background-pattern"]), "background-opacity": new ao(co.paint_background["background-opacity"]), "background-emissive-strength": new ao(co.paint_background["background-emissive-strength"]), "background-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
          getDefaultProgramParams(t2, e2, r2) {
            return { overrideFog: false };
          }
          is3D(t2) {
            return "viewport" === this.paint.get("background-pitch-alignment");
          }
        }, raster: bb, "raster-particle": Sb, sky: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Ab || (Ab = new uo({ visibility: new ao(co.layout_sky.visibility) })), paint: Mb || (Mb = new uo({ "sky-type": new ao(co.paint_sky["sky-type"]), "sky-atmosphere-sun": new ao(co.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new ao(co.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new ao(co.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new ao(co.paint_sky["sky-gradient-radius"]), "sky-gradient": new lo(co.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new ao(co.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new ao(co.paint_sky["sky-atmosphere-color"]), "sky-opacity": new ao(co.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._updateColorRamp();
          }
          _clear() {
            this.skyboxFbo && (this.skyboxFbo.destroy(), this.skyboxFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this._skyboxInvalidated = true;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = Zh({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t2) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e2 = t2.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
            }
            return false;
          }
          getCenter(t2, e2) {
            if ("atmosphere" === this.paint.get("sky-type")) {
              const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
              return n2 && "viewport" === i2.properties.get("anchor") && Zt("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? zb(s2.azimuthal, 90 - s2.polar, e2) : zb(r3[0], 90 - r3[1], e2);
            }
            const r2 = this.paint.get("sky-gradient-center");
            return zb(r2[0], 90 - r2[1], e2);
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t2) {
            this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t2 = this.paint.get("sky-type");
            return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
          }
        }, slot: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { paint: Ib || (Ib = new uo({})) }, e2, null);
          }
        }, model: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: Db || (Db = new uo({ visibility: new ao(co.layout_model.visibility), "model-id": new oo(co.layout_model["model-id"]), "model-allow-density-reduction": new ao(co.layout_model["model-allow-density-reduction"]) })), paint: Cb || (Cb = new uo({ "model-opacity": new oo(co.paint_model["model-opacity"]), "model-rotation": new oo(co.paint_model["model-rotation"]), "model-scale": new oo(co.paint_model["model-scale"]), "model-translation": new oo(co.paint_model["model-translation"]), "model-color": new oo(co.paint_model["model-color"]), "model-color-mix-intensity": new oo(co.paint_model["model-color-mix-intensity"]), "model-type": new ao(co.paint_model["model-type"]), "model-cast-shadows": new ao(co.paint_model["model-cast-shadows"]), "model-receive-shadows": new ao(co.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new ao(co.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new oo(co.paint_model["model-emissive-strength"]), "model-roughness": new oo(co.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new oo(co.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new ao(co.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new ao(co.paint_model["model-front-cutoff"]), "model-elevation-reference": new ao(co.paint_model["model-elevation-reference"]), "model-color-use-theme": new oo({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this.layer = t2, this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t2) {
            return new Fb(t2);
          }
          getProgramIds() {
            return ["model"];
          }
          is3D(t2) {
            return true;
          }
          hasShadowPass() {
            return true;
          }
          canCastShadows() {
            return true;
          }
          hasLightBeamPass() {
            return true;
          }
          cutoffRange() {
            return this.paint.get("model-cutoff-fade-range");
          }
          queryRadius(t2) {
            return t2 instanceof $b ? 8191 : 0;
          }
          queryRenderedFeatures(t2, e2, r2) {
            const n2 = e2.getSource();
            if (!(n2 && n2 instanceof Yb)) return {};
            const i2 = n2, s2 = {};
            s2[this.id] = [];
            const a2 = s2[this.id];
            let o2 = 0;
            for (const n3 of i2.models) {
              const i3 = e2.getFeatureState(this.sourceLayer, n3.id), s3 = { type: "Unknown", id: n3.id, properties: n3.featureProperties }, l2 = this.paint.get("model-rotation").evaluate(s3, i3), u2 = this.paint.get("model-scale").evaluate(s3, i3), c2 = this.paint.get("model-translation").evaluate(s3, i3), p2 = this.paint.get("model-elevation-reference");
              let d2 = [];
              ny(d2, n3, r2, n3.position, l2, u2, c2, "ground" === p2, "ground" === p2, false), "globe" === r2.projection.name && (d2 = Qm(d2, r2));
              const f2 = h([], r2.projMatrix, d2), m2 = ty(t2.isPointQuery() ? t2.screenBounds : t2.screenGeometry, r2, f2, n3.aabb);
              if (null != m2) {
                const t3 = new Wb(void 0, 0, 0, 0, n3.id);
                t3.layer = this.layer, t3.properties = structuredClone(n3.featureProperties), t3.properties.layer = this.id, t3.properties.uri = n3.uri, t3.properties.orientation = n3.orientation, t3.sourceLayer = this.sourceLayer, t3.geometry = { type: "Point", coordinates: [n3.position.lng, n3.position.lat] }, t3.state = i3, t3.source = this.source, a2.push({ featureIndex: o2, feature: t3, intersectionZ: m2 });
              }
              ++o2;
            }
            return s2;
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            if (!this.modelManager) return false;
            const c2 = this.modelManager, p2 = t2.tile.getBucket(this);
            if (!(p2 && p2 instanceof Fb)) return false;
            for (const r3 in p2.instancesPerModel) {
              const n3 = p2.instancesPerModel[r3], i3 = void 0 !== e2.id ? e2.id : e2.properties && e2.properties.hasOwnProperty("id") ? e2.properties.id : void 0;
              if (n3.idToFeaturesIndex.hasOwnProperty(i3)) {
                const e3 = n3.features[n3.idToFeaturesIndex[i3]], a3 = c2.getModel(r3, u2 || this.scope);
                if (!a3) return false;
                let o3 = [];
                const l3 = new Bu(0, 0), d2 = p2.canonical;
                let f2 = Number.MAX_VALUE;
                for (let r4 = 0; r4 < e3.instancedDataCount; ++r4) {
                  const i4 = 16 * (e3.instancedDataOffset + r4), u3 = n3.instancedDataArray.float32, c3 = [u3[i4 + 4], u3[i4 + 5], u3[i4 + 6]];
                  Jb(d2, l3, Math.floor(u3[i4]), Math.floor(u3[i4 + 1])), ny(o3, a3, s2, l3, e3.rotation, e3.scale, c3, false, false, false), "globe" === s2.projection.name && (o3 = Qm(o3, s2));
                  const p3 = h([], s2.projMatrix, o3), m2 = t2.queryGeometry, y2 = ty(m2.isPointQuery() ? m2.screenBounds : m2.screenGeometry, s2, p3, a3.aabb);
                  null != y2 && (f2 = Math.min(y2, f2));
                }
                return f2 !== Number.MAX_VALUE && f2;
              }
            }
            return false;
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven() || "model-color" !== t2 && "model-color-mix-intensity" !== t2 && "model-rotation" !== t2 && "model-scale" !== t2 && "model-translation" !== t2 && "model-emissive-strength" !== t2);
          }
          _isPropertyZoomDependent(t2) {
            const e2 = this._transitionablePaint._values[t2];
            return null != e2 && null != e2.value && null != e2.value.expression && e2.value.expression instanceof $s;
          }
          isZoomDependent() {
            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
          }
        }, clip: class extends Fo {
          constructor(t2, e2, r2, n2) {
            super(t2, { layout: _d || (_d = new uo({ "clip-layer-types": new ao(co.layout_clip["clip-layer-types"]), "clip-layer-scope": new ao(co.layout_clip["clip-layer-scope"]), visibility: new ao(co.layout_clip.visibility) })), paint: Ad || (Ad = new uo({})) }, e2, r2, n2);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
          }
          createBucket(t2) {
            return new Sd(t2);
          }
          is3D(t2) {
            return true;
          }
        } }, tw = new ur(0, 0, 0);
        function ew(t2, e2, r2) {
          1 === t2 && e2.icons.push(function(t3, e3) {
            return function(t4) {
              if (t4.usvg_tree.height || (t4.usvg_tree.height = t4.usvg_tree.width), !t4.metadata) return t4;
              const { metadata: e4 } = t4;
              if (e4.content_area) {
                const { content_area: r3 } = e4;
                null == r3.left && (r3.left = 0), null == r3.top && (r3.top = r3.left), null == r3.width && (r3.width = t4.usvg_tree.width), null == r3.height && (r3.height = r3.width);
              }
              if (e4.text_placeholder) {
                const { text_placeholder: t5 } = e4;
                null == t5.top && (t5.top = t5.left), null == t5.height && (t5.height = t5.width);
              }
              return e4.stretch_x && e4.stretch_x.length && rw(e4, "x"), e4.stretch_y && e4.stretch_y.length && rw(e4, "y"), t4;
            }(t3.readFields(nw, { name: void 0 }, e3));
          }(r2, r2.readVarint() + r2.pos));
        }
        function rw(t2, e2) {
          const r2 = [], n2 = t2[`stretch_${e2}`];
          let i2 = null;
          for (let t3 = 0; t3 < n2.length; t3++) null === i2 ? i2 = 0 === r2.length ? n2[0] : r2[r2.length - 1][1] + n2[t3] : (r2.push([i2, i2 + n2[t3]]), i2 = null);
          t2[`stretch_${e2}_areas`] = r2;
        }
        function nw(t2, e2, r2) {
          1 === t2 ? e2.name = r2.readString() : 2 === t2 ? e2.metadata = function(t3, e3) {
            return t3.readFields(iw, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, e3);
          }(r2, r2.readVarint() + r2.pos) : 3 === t2 && (e2.usvg_tree = function(t3, e3) {
            return t3.readFields(lw, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, e3);
          }(r2, r2.readVarint() + r2.pos), e2.data = "usvg_tree");
        }
        function iw(t2, e2, r2) {
          1 === t2 ? e2.stretch_x = r2.readPackedVarint() : 2 === t2 ? e2.stretch_y = r2.readPackedVarint() : 3 === t2 ? e2.content_area = sw(r2, r2.readVarint() + r2.pos) : 4 === t2 ? e2.variables.push(function(t3, e3) {
            return t3.readFields(ow, { name: void 0 }, e3);
          }(r2, r2.readVarint() + r2.pos)) : 5 === t2 && (e2.text_placeholder = sw(r2, r2.readVarint() + r2.pos));
        }
        function sw(t2, e2) {
          return t2.readFields(aw, {}, e2);
        }
        function aw(t2, e2, r2) {
          1 === t2 ? e2.left = r2.readVarint() : 2 === t2 ? e2.width = r2.readVarint() : 3 === t2 ? e2.top = r2.readVarint() : 4 === t2 && (e2.height = r2.readVarint());
        }
        function ow(t2, e2, r2) {
          1 === t2 ? e2.name = r2.readString() : 2 === t2 && (e2.rgb_color = yw(r2.readVarint()), e2.value = "rgb_color");
        }
        function lw(t2, e2, r2) {
          1 === t2 ? e2.width = e2.height = r2.readVarint() : 2 === t2 ? e2.height = r2.readVarint() : 3 === t2 ? e2.children.push(uw(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.linear_gradients.push(function(t3, e3) {
            return t3.readFields(xw, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, e3);
          }(r2, r2.readVarint() + r2.pos)) : 5 === t2 ? e2.radial_gradients.push(function(t3, e3) {
            return t3.readFields(ww, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, e3);
          }(r2, r2.readVarint() + r2.pos)) : 7 === t2 ? e2.clip_paths.push(function(t3, e3) {
            return t3.readFields(_w, { children: [] }, e3);
          }(r2, r2.readVarint() + r2.pos)) : 8 === t2 && e2.masks.push(function(t3, e3) {
            const r3 = t3.readFields(Aw, { left: 0, width: 20, mask_type: 1, children: [] }, e3);
            return null == r3.height && (r3.height = r3.width), null == r3.top && (r3.top = r3.left), r3;
          }(r2, r2.readVarint() + r2.pos));
        }
        function uw(t2, e2) {
          return t2.readFields(cw, {}, e2);
        }
        function cw(t2, e2, r2) {
          1 === t2 ? (e2.group = function(t3, e3) {
            return t3.readFields(hw, { opacity: 255, children: [] }, e3);
          }(r2, r2.readVarint() + r2.pos), e2.node = "group") : 2 === t2 && (e2.path = function(t3, e3) {
            return t3.readFields(fw, { paint_order: 1, commands: [], step: 1, diffs: [], rule: 1 }, e3);
          }(r2, r2.readVarint() + r2.pos), e2.node = "path");
        }
        function hw(t2, e2, r2) {
          1 === t2 ? e2.transform = pw(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.opacity = r2.readVarint() : 5 === t2 ? e2.clip_path_idx = r2.readVarint() : 6 === t2 ? e2.mask_idx = r2.readVarint() : 7 === t2 && e2.children.push(uw(r2, r2.readVarint() + r2.pos));
        }
        function pw(t2, e2) {
          return t2.readFields(dw, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e2);
        }
        function dw(t2, e2, r2) {
          1 === t2 ? e2.sx = r2.readFloat() : 2 === t2 ? e2.ky = r2.readFloat() : 3 === t2 ? e2.kx = r2.readFloat() : 4 === t2 ? e2.sy = r2.readFloat() : 5 === t2 ? e2.tx = r2.readFloat() : 6 === t2 && (e2.ty = r2.readFloat());
        }
        function fw(t2, e2, r2) {
          1 === t2 ? e2.fill = function(t3, e3) {
            return t3.readFields(mw, { rgb_color: tw, paint: "rgb_color", opacity: 255 }, e3);
          }(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.stroke = function(t3, e3) {
            return t3.readFields(gw, { rgb_color: tw, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, e3);
          }(r2, r2.readVarint() + r2.pos) : 3 === t2 ? e2.paint_order = r2.readVarint() : 5 === t2 ? r2.readPackedVarint(e2.commands) : 6 === t2 ? e2.step = r2.readFloat() : 7 === t2 ? r2.readPackedSVarint(e2.diffs) : 8 === t2 && (e2.rule = r2.readVarint());
        }
        function mw(t2, e2, r2) {
          1 === t2 ? (e2.rgb_color = yw(r2.readVarint()), e2.paint = "rgb_color") : 2 === t2 ? (e2.linear_gradient_idx = r2.readVarint(), e2.paint = "linear_gradient_idx") : 3 === t2 ? (e2.radial_gradient_idx = r2.readVarint(), e2.paint = "radial_gradient_idx") : 5 === t2 && (e2.opacity = r2.readVarint());
        }
        function yw(t2) {
          return new ur((t2 >> 16 & 255) / 255, (t2 >> 8 & 255) / 255, (255 & t2) / 255, 1);
        }
        function gw(t2, e2, r2) {
          1 === t2 ? (e2.rgb_color = yw(r2.readVarint()), e2.paint = "rgb_color") : 2 === t2 ? (e2.linear_gradient_idx = r2.readVarint(), e2.paint = "linear_gradient_idx") : 3 === t2 ? (e2.radial_gradient_idx = r2.readVarint(), e2.paint = "radial_gradient_idx") : 5 === t2 ? r2.readPackedFloat(e2.dasharray) : 6 === t2 ? e2.dashoffset = r2.readFloat() : 7 === t2 ? e2.miterlimit = r2.readFloat() : 8 === t2 ? e2.opacity = r2.readVarint() : 9 === t2 ? e2.width = r2.readFloat() : 10 === t2 ? e2.linecap = r2.readVarint() : 11 === t2 && (e2.linejoin = r2.readVarint());
        }
        function xw(t2, e2, r2) {
          1 === t2 ? e2.transform = pw(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.spread_method = r2.readVarint() : 3 === t2 ? e2.stops.push(vw(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.x1 = r2.readFloat() : 5 === t2 ? e2.y1 = r2.readFloat() : 6 === t2 ? e2.x2 = r2.readFloat() : 7 === t2 && (e2.y2 = r2.readFloat());
        }
        function vw(t2, e2) {
          return t2.readFields(bw, { offset: 0, opacity: 255, rgb_color: tw }, e2);
        }
        function bw(t2, e2, r2) {
          1 === t2 ? e2.offset = r2.readFloat() : 2 === t2 ? e2.opacity = r2.readVarint() : 3 === t2 && (e2.rgb_color = yw(r2.readVarint()));
        }
        function ww(t2, e2, r2) {
          1 === t2 ? e2.transform = pw(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.spread_method = r2.readVarint() : 3 === t2 ? e2.stops.push(vw(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.cx = r2.readFloat() : 5 === t2 ? e2.cy = r2.readFloat() : 6 === t2 ? e2.r = r2.readFloat() : 7 === t2 ? e2.fx = r2.readFloat() : 8 === t2 ? e2.fy = r2.readFloat() : 9 === t2 && (e2.fr = r2.readFloat());
        }
        function _w(t2, e2, r2) {
          1 === t2 ? e2.transform = pw(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.clip_path_idx = r2.readVarint() : 3 === t2 && e2.children.push(uw(r2, r2.readVarint() + r2.pos));
        }
        function Aw(t2, e2, r2) {
          1 === t2 ? e2.left = e2.top = r2.readFloat() : 2 === t2 ? e2.width = e2.height = r2.readFloat() : 3 === t2 ? e2.top = r2.readFloat() : 4 === t2 ? e2.height = r2.readFloat() : 5 === t2 ? e2.mask_type = r2.readVarint() : 6 === t2 ? e2.mask_idx = r2.readVarint() : 7 === t2 && e2.children.push(uw(r2, r2.readVarint() + r2.pos));
        }
        class Mw {
          static calculate(t2 = {}, e2 = []) {
            const r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map();
            if (0 === Object.keys(t2).length) return r2;
            e2.forEach((t3) => {
              n2.set(t3.name, t3.rgb_color || new ur(0, 0, 0));
            });
            for (const [e3, i2] of Object.entries(t2)) n2.has(e3) ? r2.set(n2.get(e3).toString(), i2) : console.warn(`Ignoring unknown image variable "${e3}"`);
            return r2;
          }
        }
        function Iw(t2, e2 = 255, r2) {
          const n2 = e2 / 255, i2 = t2.toString(), s2 = r2.has(i2) ? r2.get(i2).clone() : t2.clone();
          return s2.a *= n2, s2.toString();
        }
        function Sw(t2, e2) {
          if (!ye()) {
            const r2 = document.createElement("canvas");
            return r2.width = t2, r2.height = e2, r2;
          }
          return new OffscreenCanvas(t2, e2);
        }
        let Pw, zw = null;
        function Bw(t2, e2, r2, n2, i2) {
          for (const s2 of n2.children) kw(t2, e2, r2, s2, i2);
        }
        function kw(t2, e2, r2, n2, i2) {
          n2.group ? (t2.save(), function(t3, e3, r3, n3, i3) {
            const s2 = null != n3.mask_idx ? r3.masks[n3.mask_idx] : null, a2 = null != n3.clip_path_idx ? r3.clip_paths[n3.clip_path_idx] : null;
            if (n3.transform && (e3 = Ow(n3.transform).preMultiplySelf(e3)), !function(t4, e4, r4) {
              return 255 !== t4.opacity || e4 || r4;
            }(n3, null != a2, null != s2)) return void Bw(t3, e3, r3, n3, i3);
            const o2 = Sw(t3.canvas.width, t3.canvas.height), l2 = o2.getContext("2d");
            Bw(l2, e3, r3, n3, i3), a2 && Rw(l2, e3, r3, a2), s2 && Lw(l2, e3, r3, s2, i3), t3.globalAlpha = n3.opacity / 255, t3.drawImage(o2, 0, 0);
          }(t2, e2, r2, n2.group, i2), t2.restore()) : n2.path && (t2.save(), function(t3, e3, r3, n3, i3) {
            t3.setTransform(e3), 1 === n3.paint_order ? (Tw(t3, r3, n3, i3), Ew(t3, r3, n3, i3)) : (Ew(t3, r3, n3, i3), Tw(t3, r3, n3, i3));
          }(t2, e2, r2, n2.path, i2), t2.restore());
        }
        function Tw(t2, e2, r2, n2) {
          const i2 = r2.fill;
          if (!i2) return;
          const s2 = i2.opacity / 255;
          switch (t2.save(), t2.beginPath(), Uw(r2, t2), i2.paint) {
            case "rgb_color":
              t2.fillStyle = Iw(i2.rgb_color, i2.opacity, n2);
              break;
            case "linear_gradient_idx": {
              const r3 = e2.linear_gradients[i2.linear_gradient_idx];
              r3.transform && t2.setTransform(Ow(r3.transform).preMultiplySelf(t2.getTransform())), t2.fillStyle = Fw(t2, r3, s2, n2);
              break;
            }
            case "radial_gradient_idx": {
              const r3 = e2.radial_gradients[i2.radial_gradient_idx];
              r3.transform && t2.setTransform(Ow(r3.transform).preMultiplySelf(t2.getTransform())), t2.fillStyle = Dw(t2, r3, s2, n2);
            }
          }
          t2.fill(Vw(r2)), t2.restore();
        }
        function Vw(t2) {
          return 1 === t2.rule ? "nonzero" : 2 === t2.rule ? "evenodd" : void 0;
        }
        function Ew(t2, e2, r2, n2) {
          const i2 = r2.stroke;
          if (!i2) return;
          const s2 = Nw(r2);
          t2.lineWidth = i2.width, t2.miterLimit = i2.miterlimit, t2.setLineDash(i2.dasharray), t2.lineDashOffset = i2.dashoffset;
          const a2 = i2.opacity / 255;
          switch (i2.paint) {
            case "rgb_color":
              t2.strokeStyle = Iw(i2.rgb_color, i2.opacity, n2);
              break;
            case "linear_gradient_idx":
              t2.strokeStyle = Fw(t2, e2.linear_gradients[i2.linear_gradient_idx], a2, n2, true);
              break;
            case "radial_gradient_idx":
              t2.strokeStyle = Dw(t2, e2.radial_gradients[i2.radial_gradient_idx], a2, n2, true);
          }
          switch (i2.linejoin) {
            case 2:
            case 1:
              t2.lineJoin = "miter";
              break;
            case 3:
              t2.lineJoin = "round";
              break;
            case 4:
              t2.lineJoin = "bevel";
          }
          switch (i2.linecap) {
            case 1:
              t2.lineCap = "butt";
              break;
            case 2:
              t2.lineCap = "round";
              break;
            case 3:
              t2.lineCap = "square";
          }
          t2.stroke(s2);
        }
        function Fw(t2, e2, r2, n2, i2 = false) {
          if (1 === e2.stops.length) {
            const t3 = e2.stops[0];
            return Iw(t3.rgb_color, t3.opacity * r2, n2);
          }
          const { x1: s2, y1: a2, x2: o2, y2: l2 } = e2;
          let u2 = new DOMPoint(s2, a2), c2 = new DOMPoint(o2, l2);
          if (i2) {
            const t3 = Ow(e2.transform);
            u2 = t3.transformPoint(u2), c2 = t3.transformPoint(c2);
          }
          const h2 = t2.createLinearGradient(u2.x, u2.y, c2.x, c2.y);
          for (const t3 of e2.stops) h2.addColorStop(t3.offset, Iw(t3.rgb_color, t3.opacity * r2, n2));
          return h2;
        }
        function Dw(t2, e2, r2, n2, i2 = false) {
          if (1 === e2.stops.length) {
            const t3 = e2.stops[0];
            return Iw(t3.rgb_color, t3.opacity * r2, n2);
          }
          const s2 = Ow(e2.transform), { fx: a2, fy: o2, fr: l2, cx: u2, cy: c2, r: h2 } = e2;
          let p2 = new DOMPoint(a2, o2), d2 = new DOMPoint(u2, c2), f2 = l2, m2 = h2;
          if (i2) {
            p2 = s2.transformPoint(p2), d2 = s2.transformPoint(d2);
            const t3 = (s2.a + s2.d) / 2;
            f2 = l2 * t3, m2 = e2.r * t3;
          }
          const y2 = t2.createRadialGradient(p2.x, p2.y, f2, d2.x, d2.y, m2);
          for (const t3 of e2.stops) y2.addColorStop(t3.offset, Iw(t3.rgb_color, t3.opacity * r2, n2));
          return y2;
        }
        function Cw(t2, e2, r2, n2) {
          const i2 = n2.transform ? Ow(n2.transform).preMultiplySelf(e2) : e2, s2 = Sw(t2.canvas.width, t2.canvas.height), a2 = s2.getContext("2d");
          for (const t3 of n2.children) if (t3.group) Cw(a2, i2, r2, t3.group);
          else if (t3.path) {
            const e3 = t3.path, r3 = new Path2D();
            r3.addPath(Nw(e3), i2), a2.fill(r3, Vw(e3));
          }
          const o2 = null != n2.clip_path_idx ? r2.clip_paths[n2.clip_path_idx] : null;
          o2 && Rw(a2, i2, r2, o2), t2.globalCompositeOperation = "source-over", t2.drawImage(s2, 0, 0);
        }
        function Rw(t2, e2, r2, n2) {
          const i2 = Sw(t2.canvas.width, t2.canvas.height);
          Cw(i2.getContext("2d"), e2, r2, n2), t2.globalCompositeOperation = "destination-in", t2.drawImage(i2, 0, 0);
        }
        function Lw(t2, e2, r2, n2, i2) {
          if (0 === n2.children.length) return;
          const s2 = null != n2.mask_idx ? r2.masks[n2.mask_idx] : null;
          s2 && Lw(t2, e2, r2, s2, i2);
          const a2 = t2.canvas.width, o2 = t2.canvas.height, l2 = Sw(a2, o2), u2 = l2.getContext("2d"), c2 = n2.width, h2 = n2.height, p2 = n2.left, d2 = n2.top, f2 = new Path2D(), m2 = new Path2D();
          m2.rect(p2, d2, c2, h2), f2.addPath(m2, e2), u2.clip(f2);
          for (const t3 of n2.children) kw(u2, e2, r2, t3, i2);
          const y2 = u2.getImageData(0, 0, a2, o2), g2 = y2.data;
          if (1 === n2.mask_type) for (let t3 = 0; t3 < g2.length; t3 += 4) g2[t3 + 3] = g2[t3 + 3] / 255 * (0.2126 * g2[t3] + 0.7152 * g2[t3 + 1] + 0.0722 * g2[t3 + 2]);
          u2.putImageData(y2, 0, 0), t2.globalCompositeOperation = "destination-in", t2.drawImage(l2, 0, 0);
        }
        function Ow(t2) {
          return t2 ? new DOMMatrix([t2.sx, t2.ky, t2.kx, t2.sy, t2.tx, t2.ty]) : new DOMMatrix();
        }
        function Uw(t2, e2) {
          const r2 = t2.step;
          let n2 = t2.diffs[0] * r2, i2 = t2.diffs[1] * r2;
          e2.moveTo(n2, i2);
          for (let s2 = 0, a2 = 2; s2 < t2.commands.length; s2++) switch (t2.commands[s2]) {
            case 1:
              n2 += t2.diffs[a2++] * r2, i2 += t2.diffs[a2++] * r2, e2.moveTo(n2, i2);
              break;
            case 2:
              n2 += t2.diffs[a2++] * r2, i2 += t2.diffs[a2++] * r2, e2.lineTo(n2, i2);
              break;
            case 3: {
              const s3 = n2 + t2.diffs[a2++] * r2, o2 = i2 + t2.diffs[a2++] * r2;
              n2 = s3 + t2.diffs[a2++] * r2, i2 = o2 + t2.diffs[a2++] * r2, e2.quadraticCurveTo(s3, o2, n2, i2);
              break;
            }
            case 4: {
              const s3 = n2 + t2.diffs[a2++] * r2, o2 = i2 + t2.diffs[a2++] * r2, l2 = s3 + t2.diffs[a2++] * r2, u2 = o2 + t2.diffs[a2++] * r2;
              n2 = l2 + t2.diffs[a2++] * r2, i2 = u2 + t2.diffs[a2++] * r2, e2.bezierCurveTo(s3, o2, l2, u2, n2, i2);
              break;
            }
            case 5:
              e2.closePath();
              break;
            default:
              jw();
          }
          return e2;
        }
        function Nw(t2) {
          return Uw(t2, new Path2D());
        }
        function jw(t2, e2) {
        }
        class Gw {
          constructor(t2) {
            this.capacity = t2, this.cache = /* @__PURE__ */ new Map();
          }
          get(t2) {
            if (!this.cache.has(t2)) return;
            const e2 = this.cache.get(t2);
            return this.cache.delete(t2), this.cache.set(t2, e2), e2;
          }
          put(t2, e2) {
            this.cache.has(t2) ? this.cache.delete(t2) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t2, e2);
          }
          delete(t2) {
            this.cache.delete(t2);
          }
        }
        Qs(Gw, "LRUCache");
        class $w {
          constructor() {
            this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
          }
          static _getImage(t2) {
            return new Xh(t2, t2.data);
          }
          getFromCache(t2, e2, r2) {
            return this.cacheMap.has(r2) || this.cacheMap.set(r2, new Gw(150)), this.cacheMap.get(r2).get(zo(t2.toString(), e2));
          }
          setInCache(t2, e2, r2, n2) {
            this.cacheDependenciesMap.has(n2) || this.cacheDependenciesMap.set(n2, /* @__PURE__ */ new Map()), this.cacheMap.has(n2) || this.cacheMap.set(n2, new Gw(150));
            const i2 = this.cacheDependenciesMap.get(n2), s2 = zo(t2.id.toString(), r2);
            i2.get(s2) || i2.set(s2, /* @__PURE__ */ new Set());
            const a2 = this.cacheMap.get(n2), o2 = t2.toString();
            i2.get(s2).add(o2), a2.put(zo(t2.toString(), r2), e2);
          }
          removeImagesFromCacheByIds(t2, e2, r2 = 0) {
            if (!this.cacheMap.has(r2) || !this.cacheDependenciesMap.has(r2)) return;
            const n2 = this.cacheMap.get(r2), i2 = this.cacheDependenciesMap.get(r2);
            for (const r3 of t2) {
              const t3 = zo(r3.toString(), e2);
              if (i2.has(t3)) {
                for (const e3 of i2.get(t3)) n2.delete(e3);
                i2.delete(t3);
              }
            }
          }
          rasterize(t2, e2, r2, n2) {
            const i2 = this.getFromCache(t2, r2, n2);
            if (i2) return i2.clone();
            const s2 = function(t3, e3) {
              const r3 = Mw.calculate(e3.params, t3.metadata ? t3.metadata.variables : []), n3 = t3.usvg_tree, i3 = n3.width, s3 = n3.height, a3 = Math.max(1, Math.round(i3 * e3.sx)), o2 = Math.max(1, Math.round(s3 * e3.sy)), l2 = new DOMMatrix([a3 / i3, 0, 0, o2 / s3, 0, 0]);
              return null === zw && (zw = Sw(10, 10), Pw = zw.getContext("2d", { willReadFrequently: true })), zw.width = a3, zw.height = o2, Bw(Pw, l2, n3, n3, r3), Pw.getImageData(0, 0, a3, o2);
            }(e2.icon, t2), a2 = $w._getImage(s2);
            return this.setInCache(t2, a2, r2, n2), a2.clone();
          }
        }
        class qw {
          constructor(t2) {
            this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t2, e2) {
            const r2 = this.toIdx(t2, e2);
            return { min: this.minimums[r2], max: this.maximums[r2] };
          }
          isLeaf(t2, e2) {
            return this.leaves[this.toIdx(t2, e2)];
          }
          toIdx(t2, e2) {
            return e2 * this.size + t2;
          }
        }
        function Xw(t2, e2, r2, n2) {
          let i2 = 0, s2 = Number.MAX_VALUE;
          for (let a2 = 0; a2 < 3; a2++) if (Math.abs(n2[a2]) < 1e-15) {
            if (r2[a2] < t2[a2] || r2[a2] > e2[a2]) return null;
          } else {
            const o2 = 1 / n2[a2];
            let l2 = (t2[a2] - r2[a2]) * o2, u2 = (e2[a2] - r2[a2]) * o2;
            if (l2 > u2) {
              const t3 = l2;
              l2 = u2, u2 = t3;
            }
            if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2) return null;
          }
          return i2;
        }
        function Hw(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
          const h2 = n2 - t2, p2 = i2 - e2, d2 = s2 - r2, f2 = a2 - t2, m2 = o2 - e2, y2 = l2 - r2, g2 = c2[1] * y2 - c2[2] * m2, x2 = c2[2] * f2 - c2[0] * y2, v2 = c2[0] * m2 - c2[1] * f2, b2 = h2 * g2 + p2 * x2 + d2 * v2;
          if (Math.abs(b2) < 1e-15) return null;
          const w2 = 1 / b2, _2 = u2[0] - t2, A2 = u2[1] - e2, M2 = u2[2] - r2, I2 = (_2 * g2 + A2 * x2 + M2 * v2) * w2;
          if (I2 < 0 || I2 > 1) return null;
          const S2 = A2 * d2 - M2 * p2, P2 = M2 * h2 - _2 * d2, z2 = _2 * p2 - A2 * h2, B2 = (c2[0] * S2 + c2[1] * P2 + c2[2] * z2) * w2;
          return B2 < 0 || I2 + B2 > 1 ? null : (f2 * S2 + m2 * P2 + y2 * z2) * w2;
        }
        function Zw(t2, e2, r2) {
          return (t2 - e2) / (r2 - e2);
        }
        function Ww(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = 1 << r2, c2 = s2 - n2, h2 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, d2 = (e2 + 0) / u2 * h2 + i2, f2 = (e2 + 1) / u2 * h2 + i2;
          o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = d2, l2[0] = p2, l2[1] = f2;
        }
        class Yw {
          constructor(t2) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
            const e2 = function(t3) {
              const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
              let n3 = Math.ceil(Math.pow(2, e3));
              const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
                const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
                i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l2;
              };
              let a2 = new qw(n3);
              const o2 = [];
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
                const r4 = Kw(o2[0], o2[1], t3), l2 = Kw(o2[2], o2[1], t3), u2 = Kw(o2[2], o2[3], t3), c2 = Kw(o2[0], o2[3], t3);
                a2.minimums.push(Math.min(r4, l2, u2, c2)), a2.maximums.push(Math.max(r4, l2, u2, c2)), a2.leaves.push(1);
              }
              for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
                const t4 = r3[r3.length - 1];
                a2 = new qw(n3);
                for (let e4 = 0; e4 < n3 * n3; e4++) {
                  s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                  const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h2 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), d2 = t4.isLeaf(o2[0], o2[3]), f2 = Math.min(r4.min, i3.min, l2.min, u2.min), m2 = Math.max(r4.max, i3.max, l2.max, u2.max), y2 = c2 && h2 && p2 && d2;
                  a2.maximums.push(m2), a2.minimums.push(f2), a2.leaves.push(m2 - f2 <= 5 && y2 ? 1 : 0);
                }
                r3.push(a2);
              }
              return r3;
            }(this.dem), r2 = e2.length - 1, n2 = e2[r2];
            this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r2, 0);
          }
          raycastRoot(t2, e2, r2, n2, i2, s2, a2 = 1) {
            return Xw([t2, e2, -100], [r2, n2, this.maximums[0] * a2], i2, s2);
          }
          raycast(t2, e2, r2, n2, i2, s2, a2 = 1) {
            if (!this.nodeCount) return null;
            const o2 = this.raycastRoot(t2, e2, r2, n2, i2, s2, a2);
            if (null == o2) return null;
            const l2 = [], u2 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
            for (; p2.length > 0; ) {
              const { idx: o3, t: d2, nodex: f2, nodey: m2, depth: y2 } = p2.pop();
              if (this.leaves[o3]) {
                Ww(f2, m2, y2, t2, e2, r2, n2, c2, h2);
                const o4 = 1 << y2, l3 = (f2 + 0) / o4, u3 = (f2 + 1) / o4, p3 = (m2 + 0) / o4, g3 = (m2 + 1) / o4, x2 = Kw(l3, p3, this.dem) * a2, v2 = Kw(u3, p3, this.dem) * a2, b2 = Kw(u3, g3, this.dem) * a2, w2 = Kw(l3, g3, this.dem) * a2, _2 = Hw(c2[0], c2[1], x2, h2[0], c2[1], v2, h2[0], h2[1], b2, i2, s2), A2 = Hw(h2[0], h2[1], b2, c2[0], h2[1], w2, c2[0], c2[1], x2, i2, s2), M2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                if (M2 !== Number.MAX_VALUE) return M2;
                {
                  const t3 = E([], i2, s2, d2);
                  if (Jw(x2, v2, w2, b2, Zw(t3[0], c2[0], h2[0]), Zw(t3[1], c2[1], h2[1])) >= t3[2]) return d2;
                }
                continue;
              }
              let g2 = 0;
              for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                Ww((f2 << 1) + this._siblingOffset[p3][0], (m2 << 1) + this._siblingOffset[p3][1], y2 + 1, t2, e2, r2, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
                const d3 = Xw(c2, h2, i2, s2);
                if (null != d3) {
                  const t3 = d3;
                  l2[p3] = t3;
                  let e3 = false;
                  for (let r3 = 0; r3 < g2 && !e3; r3++) t3 >= l2[u2[r3]] && (u2.splice(r3, 0, p3), e3 = true);
                  e3 || (u2[g2] = p3), g2++;
                }
              }
              for (let t3 = 0; t3 < g2; t3++) {
                const e3 = u2[t3];
                p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (f2 << 1) + this._siblingOffset[e3][0], nodey: (m2 << 1) + this._siblingOffset[e3][1], depth: y2 + 1 });
              }
            }
            return null;
          }
          _addNode(t2, e2, r2) {
            return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t2, e2, r2, n2, i2) {
            if (1 === t2[n2].isLeaf(e2, r2)) return;
            this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
            const s2 = n2 - 1, a2 = t2[s2];
            let o2 = 0, l2 = 0;
            for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
              const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
              u2 && (o2 |= 1 << t3), l2 || (l2 = c2);
            }
            for (let n3 = 0; n3 < this._siblingOffset.length; n3++) o2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, l2 + n3);
          }
        }
        function Jw(t2, e2, r2, n2, i2, s2) {
          return dr(dr(t2, r2, s2), dr(e2, n2, s2), i2);
        }
        function Kw(t2, e2, r2) {
          const n2 = r2.dim, i2 = Dt(t2 * n2 - 0.5, 0, n2 - 1), s2 = Dt(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
          return Jw(r2.get(a2, o2), r2.get(l2, o2), r2.get(a2, u2), r2.get(l2, u2), i2 - a2, s2 - o2);
        }
        const Qw = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function t_(t2, e2, r2) {
          return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
        }
        function e_(t2, e2, r2) {
          return 256 * t2 + e2 + r2 / 256 - 32768;
        }
        class r_ {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t2, e2, r2, n2 = false) {
            if (this.uid = t2, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
            if (r2 && "mapbox" !== r2 && "terrarium" !== r2) return void Zt(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e2.height;
            const i2 = this.dim = e2.height - 2, s2 = new Uint32Array(e2.data.buffer);
            if (this.pixels = new Uint8Array(e2.data.buffer), this.floatView = new Float32Array(e2.data.buffer), this.borderReady = n2, this._modifiedForSources = {}, !n2) {
              for (let t3 = 0; t3 < i2; t3++) s2[this._idx(-1, t3)] = s2[this._idx(0, t3)], s2[this._idx(i2, t3)] = s2[this._idx(i2 - 1, t3)], s2[this._idx(t3, -1)] = s2[this._idx(t3, 0)], s2[this._idx(t3, i2)] = s2[this._idx(t3, i2 - 1)];
              s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(i2, -1)] = s2[this._idx(i2 - 1, 0)], s2[this._idx(-1, i2)] = s2[this._idx(0, i2 - 1)], s2[this._idx(i2, i2)] = s2[this._idx(i2 - 1, i2 - 1)];
            }
            const a2 = "terrarium" === r2 ? e_ : t_;
            for (let t3 = 0; t3 < s2.length; ++t3) {
              const e3 = 4 * t3;
              this.floatView[t3] = a2(this.pixels[e3], this.pixels[e3 + 1], this.pixels[e3 + 2]);
            }
            this._timestamp = ge.now();
          }
          _buildQuadTree() {
            this._tree = new Yw(this);
          }
          get(t2, e2, r2 = false) {
            r2 && (t2 = Dt(t2, -1, this.dim), e2 = Dt(e2, -1, this.dim));
            const n2 = this._idx(t2, e2);
            return this.floatView[n2];
          }
          set(t2, e2, r2) {
            const n2 = this._idx(t2, e2), i2 = this.floatView[n2];
            return this.floatView[n2] = r2, r2 - i2;
          }
          static getUnpackVector(t2) {
            return Qw[t2];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          static pack(t2, e2) {
            const r2 = [0, 0, 0, 0], n2 = r_.getUnpackVector(e2);
            let i2 = Math.floor((t2 + n2[3]) / n2[2]);
            return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
          }
          getPixels() {
            return new Hh({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(t2, e2, r2) {
            if (this.dim !== t2.dim) throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                s2 = a2 - 1;
                break;
              case 1:
                a2 = s2 + 1;
            }
            const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
            for (let e3 = s2; e3 < a2; e3++) for (let r3 = n2; r3 < i2; r3++) {
              const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l2);
              this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
            }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        function n_(t2, e2, r2) {
          1 === t2 ? e2.headerLength = r2.readFixed32() : 2 === t2 ? e2.x = r2.readVarint() : 3 === t2 ? e2.y = r2.readVarint() : 4 === t2 ? e2.z = r2.readVarint() : 5 === t2 && e2.layers.push(function(t3, e3) {
            return t3.readFields(l_, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, e3);
          }(r2, r2.readVarint() + r2.pos));
        }
        function i_(t2, e2, r2) {
          1 === t2 ? (e2.delta_filter = function(t3, e3) {
            return t3.readFields(s_, { blockSize: 0 }, e3);
          }(r2, r2.readVarint() + r2.pos), e2.filter = "delta_filter") : 2 === t2 ? (r2.readVarint(), e2.filter = "zigzag_filter") : 3 === t2 ? (r2.readVarint(), e2.filter = "bitshuffle_filter") : 4 === t2 && (r2.readVarint(), e2.filter = "byteshuffle_filter");
        }
        function s_(t2, e2, r2) {
          1 === t2 && (e2.blockSize = r2.readVarint());
        }
        function a_(t2, e2, r2) {
          1 === t2 ? (r2.readVarint(), e2.codec = "gzip_data") : 2 === t2 ? (r2.readVarint(), e2.codec = "jpeg_image") : 3 === t2 ? (r2.readVarint(), e2.codec = "webp_image") : 4 === t2 && (r2.readVarint(), e2.codec = "png_image");
        }
        function o_(t2, e2, r2) {
          let n2 = 0, i2 = 0;
          1 === t2 ? e2.firstByte = r2.readFixed64() : 2 === t2 ? e2.lastByte = r2.readFixed64() : 3 === t2 ? e2.filters.push(function(t3, e3) {
            return t3.readFields(i_, {}, e3);
          }(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.codec = function(t3, e3) {
            return t3.readFields(a_, {}, e3);
          }(r2, r2.readVarint() + r2.pos) : 5 === t2 ? i2 = r2.readFloat() : 6 === t2 ? n2 = r2.readFloat() : 7 === t2 ? e2.bands.push(r2.readString()) : 8 === t2 ? e2.offset = r2.readDouble() : 9 === t2 && (e2.scale = r2.readDouble()), 0 === e2.offset && (e2.offset = i2), 0 === e2.scale && (e2.scale = n2);
        }
        function l_(t2, e2, r2) {
          1 === t2 ? e2.version = r2.readVarint() : 2 === t2 ? e2.name = r2.readString() : 3 === t2 ? e2.units = r2.readString() : 4 === t2 ? e2.tileSize = r2.readVarint() : 5 === t2 ? e2.buffer = r2.readVarint() : 6 === t2 ? e2.pixelFormat = r2.readVarint() : 7 === t2 && e2.dataIndex.push(function(t3, e3) {
            return t3.readFields(o_, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, e3);
          }(r2, r2.readVarint() + r2.pos));
        }
        function u_(t2, e2, r2) {
          if (2 === t2) !function(t3, e3, r3) {
            t3.readFields(c_, r3, e3);
          }(r2, r2.readVarint() + r2.pos, e2);
          else if (3 === t2) throw new Error("Not implemented");
        }
        function c_(t2, e2, r2) {
          if (1 === t2) {
            let t3 = 0;
            const n2 = r2.readVarint() + r2.pos;
            for (; r2.pos < n2; ) e2[t3++] = r2.readVarint();
          }
        }
        function h_(t2, e2) {
          if (4 !== e2.length) throw new Error(`Expected data of dimension 4 but got ${e2.length}.`);
          let r2 = e2[3];
          for (let n2 = 2; n2 >= 1; n2--) {
            const i2 = 1 === n2 ? 1 : 0, s2 = 2 === n2 ? 1 : 0;
            for (let n3 = 0; n3 < e2[0]; n3++) {
              const a2 = e2[1] * n3;
              for (let n4 = i2; n4 < e2[1]; n4++) {
                const i3 = e2[2] * (n4 + a2);
                for (let n5 = s2; n5 < e2[2]; n5++) {
                  const s3 = e2[3] * (n5 + i3);
                  for (let n6 = 0; n6 < e2[3]; n6++) {
                    const e3 = s3 + n6;
                    t2[e3] += t2[e3 - r2];
                  }
                }
              }
            }
            r2 *= e2[n2];
          }
          return t2;
        }
        function p_(t2) {
          for (let e2 = 0, r2 = t2.length; e2 < r2; e2++) t2[e2] = t2[e2] >>> 1 ^ -(1 & t2[e2]);
          return t2;
        }
        function d_(t2, e2) {
          switch (e2) {
            case "uint32":
              return t2;
            case "uint16":
              for (let e3 = 0; e3 < t2.length; e3 += 2) {
                const r2 = t2[e3], n2 = t2[e3 + 1];
                t2[e3] = (240 & r2) >> 4 | (61440 & r2) >> 8 | (240 & n2) << 4 | 61440 & n2, t2[e3 + 1] = 15 & r2 | (3840 & r2) >> 4 | (15 & n2) << 8 | (3840 & n2) << 4;
              }
              return t2;
            case "uint8":
              for (let e3 = 0; e3 < t2.length; e3 += 4) {
                const r2 = t2[e3], n2 = t2[e3 + 1], i2 = t2[e3 + 2], s2 = t2[e3 + 3];
                t2[e3 + 0] = (192 & r2) >> 6 | (192 & n2) >> 4 | (192 & i2) >> 2 | 192 & s2, t2[e3 + 1] = (48 & r2) >> 4 | (48 & n2) >> 2 | 48 & i2 | (48 & s2) << 2, t2[e3 + 2] = (12 & r2) >> 2 | 12 & n2 | (12 & i2) << 2 | (12 & s2) << 4, t2[e3 + 3] = 3 & r2 | (3 & n2) << 2 | (3 & i2) << 4 | (3 & s2) << 6;
              }
              return t2;
            default:
              throw new Error(`Invalid pixel format, "${e2}"`);
          }
        }
        Qs(r_, "DEMData"), Qs(Yw, "DemMinMaxQuadTree", { omit: ["dem"] });
        var f_ = Uint8Array, m_ = Uint16Array, y_ = Int32Array, g_ = new f_([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), x_ = new f_([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), v_ = new f_([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), b_ = function(t2, e2) {
          for (var r2 = new m_(31), n2 = 0; n2 < 31; ++n2) r2[n2] = e2 += 1 << t2[n2 - 1];
          var i2 = new y_(r2[30]);
          for (n2 = 1; n2 < 30; ++n2) for (var s2 = r2[n2]; s2 < r2[n2 + 1]; ++s2) i2[s2] = s2 - r2[n2] << 5 | n2;
          return { b: r2, r: i2 };
        }, w_ = b_(g_, 2), __ = w_.b, A_ = w_.r;
        __[28] = 258, A_[258] = 28;
        for (var M_ = b_(x_, 0).b, I_ = new m_(32768), S_ = 0; S_ < 32768; ++S_) {
          var P_ = (43690 & S_) >> 1 | (21845 & S_) << 1;
          I_[S_] = ((65280 & (P_ = (61680 & (P_ = (52428 & P_) >> 2 | (13107 & P_) << 2)) >> 4 | (3855 & P_) << 4)) >> 8 | (255 & P_) << 8) >> 1;
        }
        var z_ = function(t2, e2, r2) {
          for (var n2 = t2.length, i2 = 0, s2 = new m_(e2); i2 < n2; ++i2) t2[i2] && ++s2[t2[i2] - 1];
          var a2, o2 = new m_(e2);
          for (i2 = 1; i2 < e2; ++i2) o2[i2] = o2[i2 - 1] + s2[i2 - 1] << 1;
          a2 = new m_(1 << e2);
          var l2 = 15 - e2;
          for (i2 = 0; i2 < n2; ++i2) if (t2[i2]) for (var u2 = i2 << 4 | t2[i2], c2 = e2 - t2[i2], h2 = o2[t2[i2] - 1]++ << c2, p2 = h2 | (1 << c2) - 1; h2 <= p2; ++h2) a2[I_[h2] >> l2] = u2;
          return a2;
        }, B_ = new f_(288);
        for (S_ = 0; S_ < 144; ++S_) B_[S_] = 8;
        for (S_ = 144; S_ < 256; ++S_) B_[S_] = 9;
        for (S_ = 256; S_ < 280; ++S_) B_[S_] = 7;
        for (S_ = 280; S_ < 288; ++S_) B_[S_] = 8;
        var k_ = new f_(32);
        for (S_ = 0; S_ < 32; ++S_) k_[S_] = 5;
        var T_ = z_(B_, 9), V_ = z_(k_, 5), E_ = function(t2) {
          for (var e2 = t2[0], r2 = 1; r2 < t2.length; ++r2) t2[r2] > e2 && (e2 = t2[r2]);
          return e2;
        }, F_ = function(t2, e2, r2) {
          var n2 = e2 / 8 | 0;
          return (t2[n2] | t2[n2 + 1] << 8) >> (7 & e2) & r2;
        }, D_ = function(t2, e2) {
          var r2 = e2 / 8 | 0;
          return (t2[r2] | t2[r2 + 1] << 8 | t2[r2 + 2] << 16) >> (7 & e2);
        }, C_ = function(t2) {
          return (t2 + 7) / 8 | 0;
        }, R_ = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], L_ = function(t2, e2, r2) {
          var n2 = new Error(e2 || R_[t2]);
          if (n2.code = t2, Error.captureStackTrace && Error.captureStackTrace(n2, L_), !r2) throw n2;
          return n2;
        }, O_ = new f_(0);
        var U_ = "undefined" != typeof TextDecoder && new TextDecoder();
        try {
          U_.decode(O_, { stream: true });
        } catch (t2) {
        }
        const N_ = { gzip_data: "gzip" };
        class j_ extends Error {
          constructor(t2) {
            super(t2), this.name = "MRTError";
          }
        }
        const G_ = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, $_ = { uint32: 1, uint16: 2, uint8: 4 }, q_ = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
        let X_;
        class H_ {
          constructor(t2 = 5) {
            this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t2;
          }
          getLayer(t2) {
            const e2 = this.layers[t2];
            if (!e2) throw new j_(`Layer '${t2}' not found`);
            return e2;
          }
          getHeaderLength(t2) {
            const e2 = new Uint8Array(t2), r2 = new DataView(t2);
            if (13 !== e2[0]) throw new j_("File is not a valid MRT.");
            return r2.getUint32(1, true);
          }
          parseHeader(t2) {
            const e2 = new Uint8Array(t2), r2 = this.getHeaderLength(t2);
            if (e2.length < r2) throw new j_(`Expected header with length >= ${r2} but got buffer of length ${e2.length}`);
            const n2 = new X_(e2.subarray(0, r2)).readFields(n_, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
            if (!isNaN(this.x) && (this.x !== n2.x || this.y !== n2.y || this.z !== n2.z)) throw new j_(`Invalid attempt to parse header ${n2.z}/${n2.x}/${n2.y} for tile ${this.z}/${this.x}/${this.y}`);
            this.x = n2.x, this.y = n2.y, this.z = n2.z;
            for (const t3 of n2.layers) this.layers[t3.name] = new Z_(t3, { cacheSize: this._cacheSize });
            return this;
          }
          createDecodingTask(t2) {
            const e2 = [], r2 = this.getLayer(t2.layerName);
            for (let n2 of t2.blockIndices) {
              const i2 = r2.dataIndex[n2], s2 = i2.firstByte - t2.firstByte, a2 = i2.lastByte - t2.firstByte;
              if (r2._blocksInProgress.has(n2)) continue;
              const o2 = { layerName: r2.name, firstByte: s2, lastByte: a2, pixelFormat: r2.pixelFormat, blockIndex: n2, blockShape: [i2.bands.length].concat(r2.bandShape), buffer: r2.buffer, codec: i2.codec.codec, filters: i2.filters.map((t3) => t3.filter) };
              r2._blocksInProgress.add(n2), e2.push(o2);
            }
            return new W_(e2, () => {
              e2.forEach((t3) => r2._blocksInProgress.delete(t3.blockIndex));
            }, (t3, n2) => {
              if (e2.forEach((t4) => r2._blocksInProgress.delete(t4.blockIndex)), t3) throw t3;
              n2.forEach((t4) => {
                this.getLayer(t4.layerName).processDecodedData(t4);
              });
            });
          }
        }
        class Z_ {
          constructor({ version: t2, name: e2, units: r2, tileSize: n2, pixelFormat: i2, buffer: s2, dataIndex: a2 }, o2) {
            if (this.version = t2, 1 !== this.version) throw new j_(`Cannot parse raster layer encoded with MRT version ${t2}`);
            this.name = e2, this.units = r2, this.tileSize = n2, this.buffer = s2, this.pixelFormat = G_[i2], this.dataIndex = a2, this.bandShape = [n2 + 2 * s2, n2 + 2 * s2, $_[this.pixelFormat]], this._decodedBlocks = new Gw(o2 ? o2.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
          }
          get dimension() {
            return $_[this.pixelFormat];
          }
          get cacheSize() {
            return this._decodedBlocks.capacity;
          }
          getBandList() {
            return this.dataIndex.map(({ bands: t2 }) => t2).flat();
          }
          processDecodedData(t2) {
            const e2 = t2.blockIndex.toString();
            this._decodedBlocks.get(e2) || this._decodedBlocks.put(e2, t2.data);
          }
          getBlockForBand(t2) {
            let e2 = 0;
            switch (typeof t2) {
              case "string":
                for (const [r2, n2] of this.dataIndex.entries()) {
                  for (const [i2, s2] of n2.bands.entries()) if (s2 === t2) return { bandIndex: e2 + i2, blockIndex: r2, blockBandIndex: i2 };
                  e2 += n2.bands.length;
                }
                break;
              case "number":
                for (const [r2, n2] of this.dataIndex.entries()) {
                  if (t2 >= e2 && t2 < e2 + n2.bands.length) return { bandIndex: t2, blockIndex: r2, blockBandIndex: t2 - e2 };
                  e2 += n2.bands.length;
                }
                break;
              default:
                throw new j_(`Invalid band \`${JSON.stringify(t2)}\`. Expected string or integer.`);
            }
            return { blockIndex: -1, blockBandIndex: -1 };
          }
          getDataRange(t2) {
            let e2 = 1 / 0, r2 = -1 / 0;
            const n2 = [], i2 = /* @__PURE__ */ new Set();
            for (const s2 of t2) {
              const { blockIndex: t3 } = this.getBlockForBand(s2);
              if (t3 < 0) throw new j_(`Invalid band: ${JSON.stringify(s2)}`);
              const a2 = this.dataIndex[t3];
              n2.includes(t3) || n2.push(t3), i2.add(t3), e2 = Math.min(e2, a2.firstByte), r2 = Math.max(r2, a2.lastByte);
            }
            if (i2.size > this.cacheSize) throw new j_(`Number of blocks to decode (${i2.size}) exceeds cache size (${this.cacheSize}).`);
            return { layerName: this.name, firstByte: e2, lastByte: r2, blockIndices: n2 };
          }
          hasBand(t2) {
            const { blockIndex: e2 } = this.getBlockForBand(t2);
            return e2 >= 0;
          }
          hasDataForBand(t2) {
            const { blockIndex: e2 } = this.getBlockForBand(t2);
            return e2 >= 0 && !!this._decodedBlocks.get(e2.toString());
          }
          getBandView(t2) {
            const { blockIndex: e2, blockBandIndex: r2 } = this.getBlockForBand(t2);
            if (e2 < 0) throw new j_(`Band not found: ${JSON.stringify(t2)}`);
            const n2 = this._decodedBlocks.get(e2.toString());
            if (!n2) throw new j_(`Data for band ${JSON.stringify(t2)} of layer "${this.name}" not decoded.`);
            const i2 = this.dataIndex[e2], s2 = this.bandShape.reduce((t3, e3) => t3 * e3, 1), a2 = r2 * s2, o2 = n2.subarray(a2, a2 + s2);
            return { data: o2, bytes: new Uint8Array(o2.buffer).subarray(o2.byteOffset, o2.byteOffset + o2.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: i2.offset, scale: i2.scale };
          }
        }
        H_.setPbf = function(t2) {
          X_ = t2;
        };
        class W_ {
          constructor(t2, e2, r2) {
            this.tasks = t2, this._onCancel = e2, this._onComplete = r2, this._finalized = false;
          }
          cancel() {
            this._finalized || (this._onCancel(), this._finalized = true);
          }
          complete(t2, e2) {
            this._finalized || (this._onComplete(t2, e2), this._finalized = true);
          }
        }
        H_.performDecoding = function(t2, e2) {
          const r2 = new Uint8Array(t2);
          return Promise.all(e2.tasks.map((t3) => {
            const { layerName: e3, firstByte: n2, lastByte: i2, pixelFormat: s2, blockShape: a2, blockIndex: o2, filters: l2, codec: u2 } = t3, c2 = r2.subarray(n2, i2 + 1), h2 = new Uint32Array(a2[0] * a2[1] * a2[2]);
            let p2;
            if ("gzip_data" !== u2) throw new j_(`Unhandled codec: ${u2}`);
            return p2 = function(t4, e4) {
              if (!globalThis.DecompressionStream && "gzip_data" === e4) return Promise.resolve((a3 = function(t5) {
                31 == t5[0] && 139 == t5[1] && 8 == t5[2] || L_(6, "invalid gzip data");
                var e5 = t5[3], r4 = 10;
                4 & e5 && (r4 += 2 + (t5[10] | t5[11] << 8));
                for (var n4 = (e5 >> 3 & 1) + (e5 >> 4 & 1); n4 > 0; n4 -= !t5[r4++]) ;
                return r4 + (2 & e5);
              }(r3 = t4), a3 + 8 > r3.length && L_(6, "invalid gzip data"), function(t5, e5, r4, n4) {
                var i4 = t5.length;
                if (!i4 || e5.f && !e5.l) return r4 || new f_(0);
                var s4 = !r4, a4 = s4 || 2 != e5.i, o4 = e5.i;
                s4 && (r4 = new f_(3 * i4));
                var l4 = function(t6) {
                  var e6 = r4.length;
                  if (t6 > e6) {
                    var n5 = new f_(Math.max(2 * e6, t6));
                    n5.set(r4), r4 = n5;
                  }
                }, u3 = e5.f || 0, c3 = e5.p || 0, h3 = e5.b || 0, p3 = e5.l, d2 = e5.d, f2 = e5.m, m2 = e5.n, y2 = 8 * i4;
                do {
                  if (!p3) {
                    u3 = F_(t5, c3, 1);
                    var g2 = F_(t5, c3 + 1, 3);
                    if (c3 += 3, !g2) {
                      var x2 = t5[(B2 = C_(c3) + 4) - 4] | t5[B2 - 3] << 8, v2 = B2 + x2;
                      if (v2 > i4) {
                        o4 && L_(0);
                        break;
                      }
                      a4 && l4(h3 + x2), r4.set(t5.subarray(B2, v2), h3), e5.b = h3 += x2, e5.p = c3 = 8 * v2, e5.f = u3;
                      continue;
                    }
                    if (1 == g2) p3 = T_, d2 = V_, f2 = 9, m2 = 5;
                    else if (2 == g2) {
                      var b2 = F_(t5, c3, 31) + 257, w2 = F_(t5, c3 + 10, 15) + 4, _2 = b2 + F_(t5, c3 + 5, 31) + 1;
                      c3 += 14;
                      for (var A2 = new f_(_2), M2 = new f_(19), I2 = 0; I2 < w2; ++I2) M2[v_[I2]] = F_(t5, c3 + 3 * I2, 7);
                      c3 += 3 * w2;
                      var S2 = E_(M2), P2 = (1 << S2) - 1, z2 = z_(M2, S2);
                      for (I2 = 0; I2 < _2; ) {
                        var B2, k2 = z2[F_(t5, c3, P2)];
                        if (c3 += 15 & k2, (B2 = k2 >> 4) < 16) A2[I2++] = B2;
                        else {
                          var T2 = 0, V2 = 0;
                          for (16 == B2 ? (V2 = 3 + F_(t5, c3, 3), c3 += 2, T2 = A2[I2 - 1]) : 17 == B2 ? (V2 = 3 + F_(t5, c3, 7), c3 += 3) : 18 == B2 && (V2 = 11 + F_(t5, c3, 127), c3 += 7); V2--; ) A2[I2++] = T2;
                        }
                      }
                      var E2 = A2.subarray(0, b2), F2 = A2.subarray(b2);
                      f2 = E_(E2), m2 = E_(F2), p3 = z_(E2, f2), d2 = z_(F2, m2);
                    } else L_(1);
                    if (c3 > y2) {
                      o4 && L_(0);
                      break;
                    }
                  }
                  a4 && l4(h3 + 131072);
                  for (var D2 = (1 << f2) - 1, C2 = (1 << m2) - 1, R2 = c3; ; R2 = c3) {
                    var L2 = (T2 = p3[D_(t5, c3) & D2]) >> 4;
                    if ((c3 += 15 & T2) > y2) {
                      o4 && L_(0);
                      break;
                    }
                    if (T2 || L_(2), L2 < 256) r4[h3++] = L2;
                    else {
                      if (256 == L2) {
                        R2 = c3, p3 = null;
                        break;
                      }
                      var O2 = L2 - 254;
                      L2 > 264 && (O2 = F_(t5, c3, (1 << (j2 = g_[I2 = L2 - 257])) - 1) + __[I2], c3 += j2);
                      var U2 = d2[D_(t5, c3) & C2], N2 = U2 >> 4;
                      if (U2 || L_(3), c3 += 15 & U2, F2 = M_[N2], N2 > 3) {
                        var j2 = x_[N2];
                        F2 += D_(t5, c3) & (1 << j2) - 1, c3 += j2;
                      }
                      if (c3 > y2) {
                        o4 && L_(0);
                        break;
                      }
                      a4 && l4(h3 + 131072);
                      var G2 = h3 + O2;
                      if (h3 < F2) {
                        var $2 = 0 - F2, q2 = Math.min(F2, G2);
                        for ($2 + h3 < 0 && L_(3); h3 < q2; ++h3) r4[h3] = n4[$2 + h3];
                      }
                      for (; h3 < G2; ++h3) r4[h3] = r4[h3 - F2];
                    }
                  }
                  e5.l = p3, e5.p = R2, e5.b = h3, e5.f = u3, p3 && (u3 = 1, e5.m = f2, e5.d = d2, e5.n = m2);
                } while (!u3);
                return h3 != r4.length && s4 ? function(t6, e6, r5) {
                  return (null == r5 || r5 > t6.length) && (r5 = t6.length), new f_(t6.subarray(0, r5));
                }(r4, 0, h3) : r4.subarray(0, h3);
              }(r3.subarray(a3, -8), { i: 2 }, new f_(((i3 = r3)[(s3 = i3.length) - 4] | i3[s3 - 3] << 8 | i3[s3 - 2] << 16 | i3[s3 - 1] << 24) >>> 0), n3)));
              var r3, n3, i3, s3, a3;
              const o3 = N_[e4];
              if (!o3) throw new Error(`Unhandled codec: ${e4}`);
              const l3 = new globalThis.DecompressionStream(o3);
              return new Response(new Blob([t4]).stream().pipeThrough(l3)).arrayBuffer().then((t5) => new Uint8Array(t5));
            }(c2, u2).then((t4) => (function(t5, e4) {
              t5.readFields(u_, e4);
            }(new X_(t4), h2), new (0, q_[s2])(h2.buffer))), p2.then((t4) => {
              for (let e4 = l2.length - 1; e4 >= 0; e4--) switch (l2[e4]) {
                case "delta_filter":
                  h_(t4, a2);
                  break;
                case "zigzag_filter":
                  p_(t4);
                  break;
                case "bitshuffle_filter":
                  d_(t4, s2);
                  break;
                default:
                  throw new j_(`Unhandled filter "${l2[e4]}"`);
              }
              return { layerName: e3, blockIndex: o2, data: t4 };
            }).catch((t4) => {
              throw t4;
            });
          }));
        }, Qs(W_, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] }), Qs(H_, "MapboxRasterTile"), Qs(Z_, "MapboxRasterLayer", { omit: ["_blocksInProgress"] });
        class Y_ {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            return this._numberToString[t2];
          }
        }
        class J_ {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Js(jn, 16, 0), this.featureIndexArray = new Vl(), this.promoteId = e2, this.is3DTile = false, this.serializedLayersCache = /* @__PURE__ */ new Map();
          }
          insert(t2, e2, r2, n2, i2, s2 = 0, a2 = 0) {
            const o2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
            const l2 = this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                const e3 = r3[t4];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              0 !== a2 && (n3[0] -= a2, n3[1] -= a2, n3[2] += a2, n3[3] += a2), n3[0] < jn && n3[1] < jn && n3[2] >= 0 && n3[3] >= 0 && l2.insert(o2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new ic(new Vg(this.rawTileData)).layers, this.sourceLayerCoder = new Y_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t2 in this.vtLayers) this.vtFeatures[t2] = [];
            }
            return this.vtLayers;
          }
          query(t2, e2) {
            const { tilespaceGeometry: r2, transform: n2, tileTransform: i2, pixelPosMatrix: s2, availableImages: a2, worldview: o2 } = e2;
            this.loadVTLayers(), this.serializedLayersCache.clear();
            const l2 = e2.queryRadius ? e2.queryRadius : 0, u2 = r2.bufferedTilespaceBounds, c2 = this.grid.query(u2.min.x, u2.min.y, u2.max.x, u2.max.y, (t3, e3, n3, i3) => Oc(r2.bufferedTilespaceGeometry, t3 - l2, e3 - l2, n3 + l2, i3 + l2));
            c2.sort(Q_);
            let h2 = null;
            n2.elevation && c2.length > 0 && (h2 = Rb.create(n2.elevation, this.tileID));
            const p2 = {};
            let d2;
            for (let l3 = 0; l3 < c2.length; l3++) {
              const u3 = c2[l3];
              if (u3 === d2) continue;
              d2 = u3;
              const f2 = this.featureIndexArray.get(u3);
              let m2 = null;
              this.is3DTile ? this.loadMatchingModelFeature(p2, f2, t2, r2, n2, o2) : this.loadMatchingFeature(p2, f2, t2, a2, o2, (t3, a3, o3, l4 = 0) => (m2 || (m2 = Ju(t3, this.tileID.canonical, i2)), a3.queryIntersectsFeature(r2, t3, o3, m2, this.z, n2, s2, h2, l4, e2.scope)));
            }
            return p2;
          }
          loadMatchingFeature(t2, e2, r2, n2, i2, s2) {
            const { featureIndex: a2, bucketIndex: o2, sourceLayerIndex: l2, layoutVertexArrayOffset: u2 } = e2, c2 = this.bucketLayerIDs[o2], h2 = r2.layers, p2 = Object.keys(h2);
            if (p2.length && !Xt(p2, c2)) return;
            const d2 = r2.sourceCache, f2 = this.sourceLayerCoder.decode(l2), m2 = this.vtLayers[f2].feature(a2), y2 = this.getId(m2, f2);
            for (let e3 = 0; e3 < c2.length; e3++) {
              const r3 = c2[e3];
              if (!h2[r3]) continue;
              const { styleLayer: o3, targets: l3 } = h2[r3];
              let p3 = {};
              void 0 !== y2 && (p3 = d2.getFeatureState(o3.sourceLayer, y2));
              const f3 = !s2 || s2(m2, o3, p3, u2);
              if (!f3) continue;
              const g2 = new Wb(m2, this.z, this.x, this.y, y2);
              g2.tile = this.tileID.canonical, g2.state = p3;
              let x2 = this.serializedLayersCache.get(r3);
              x2 || (x2 = o3.serialize(), x2.id = r3, this.serializedLayersCache.set(r3, x2)), g2.source = x2.source, g2.sourceLayer = x2["source-layer"], g2.layer = Object.assign({}, x2), g2.layer.paint = K_(x2.paint, o3.paint, m2, p3, n2), g2.layer.layout = K_(x2.layout, o3.layout, m2, p3, n2);
              let v2 = false;
              for (const t3 of l3) {
                this.updateFeatureProperties(g2, t3);
                const { filter: e4 } = t3;
                if (e4) {
                  if (m2.properties = g2.properties, e4.needGeometry) {
                    const t4 = Ku(m2, true);
                    if (!e4.filter(new Ja(this.tileID.overscaledZ, { worldview: i2 }), t4, this.tileID.canonical)) continue;
                  } else if (!e4.filter(new Ja(this.tileID.overscaledZ, { worldview: i2 }), m2)) continue;
                }
                v2 = true, t3.targetId && this.addFeatureVariant(g2, t3);
              }
              v2 && this.appendToResult(t2, r3, a2, g2, f3);
            }
          }
          loadMatchingModelFeature(t2, e2, r2, n2, i2, s2) {
            const { featureIndex: a2, bucketIndex: o2 } = e2, l2 = this.bucketLayerIDs[o2], u2 = r2.layers, c2 = Object.keys(u2);
            if (!c2.length || Xt(c2, l2)) for (let e3 = 0; e3 < l2.length; e3++) {
              const o3 = l2[e3], { styleLayer: c3, targets: h2 } = u2[o3];
              if ("model" !== c3.type) continue;
              const p2 = n2.tile, d2 = p2.getBucket(c3);
              if (!(d2 && d2 instanceof $b)) continue;
              const f2 = Kb(d2, a2, n2, i2);
              if (!f2) continue;
              const { z: m2, x: y2, y: g2 } = p2.tileID.canonical, { feature: x2, intersectionZ: v2, position: b2 } = f2;
              let w2 = {};
              void 0 !== x2.id && (w2 = r2.sourceCache.getFeatureState(c3.sourceLayer, x2.id));
              const _2 = new Wb({}, m2, y2, g2, x2.id);
              _2.tile = this.tileID.canonical, _2.state = w2, _2.properties = x2.properties, _2.geometry = { type: "Point", coordinates: [b2.lng, b2.lat] };
              let A2 = this.serializedLayersCache.get(o3);
              A2 || (A2 = c3.serialize(), A2.id = o3, this.serializedLayersCache.set(o3, A2)), _2.source = A2.source, _2.sourceLayer = A2["source-layer"], _2.layer = Object.assign({}, A2);
              let M2 = false;
              for (const t3 of h2) {
                this.updateFeatureProperties(_2, t3);
                const { filter: e4 } = t3;
                if (e4) {
                  if (x2.properties = _2.properties, e4.needGeometry) {
                    if (!e4.filter(new Ja(this.tileID.overscaledZ, { worldview: s2 }), x2, this.tileID.canonical)) continue;
                  } else if (!e4.filter(new Ja(this.tileID.overscaledZ, { worldview: s2 }), x2)) continue;
                }
                M2 = true, t3.targetId && this.addFeatureVariant(_2, t3);
              }
              M2 && this.appendToResult(t2, o3, a2, _2, v2);
            }
          }
          updateFeatureProperties(t2, e2, r2) {
            if (e2.properties) {
              const n2 = {};
              for (const i2 in e2.properties) {
                const s2 = e2.properties[i2].evaluate({ zoom: this.z }, t2._vectorTileFeature, t2.state, t2.tile, r2);
                null != s2 && (n2[i2] = s2);
              }
              t2.properties = n2;
            }
          }
          addFeatureVariant(t2, e2, r2) {
            const n2 = { target: e2.target, namespace: e2.namespace, uniqueFeatureID: e2.uniqueFeatureID };
            e2.properties && (n2.properties = t2.properties), t2.variants = t2.variants || {}, t2.variants[e2.targetId] = t2.variants[e2.targetId] || [], t2.variants[e2.targetId].push(n2);
          }
          appendToResult(t2, e2, r2, n2, i2) {
            let s2 = t2[e2];
            void 0 === s2 && (s2 = t2[e2] = []), s2.push({ featureIndex: r2, feature: n2, intersectionZ: i2 });
          }
          lookupSymbolFeatures(t2, e2, r2, n2, i2, s2) {
            const a2 = {};
            this.loadVTLayers();
            for (const o2 of t2) this.loadMatchingFeature(a2, { bucketIndex: e2, sourceLayerIndex: r2, featureIndex: o2, layoutVertexArrayOffset: 0 }, n2, i2, s2);
            return a2;
          }
          loadFeature(t2) {
            const { featureIndex: e2, sourceLayerIndex: r2 } = t2;
            this.loadVTLayers();
            const n2 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n2];
            if (i2[e2]) return i2[e2];
            const s2 = this.vtLayers[n2].feature(e2);
            return i2[e2] = s2, s2;
          }
          hasLayer(t2) {
            for (const e2 of this.bucketLayerIDs) for (const r2 of e2) if (t2 === r2) return true;
            return false;
          }
          getId(t2, e2) {
            let r2 = t2.id;
            if (this.promoteId) {
              const n2 = Array.isArray(this.promoteId) || "object" != typeof this.promoteId ? this.promoteId : this.promoteId[e2];
              if (null != n2) if (Array.isArray(n2)) {
                if (!this.promoteIdExpression) {
                  const t3 = js(n2);
                  if ("success" !== t3.result) {
                    const e3 = t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", ");
                    return void Zt(`Failed to create expression for promoteId: ${e3}`);
                  }
                  this.promoteIdExpression = t3.value;
                }
                r2 = this.promoteIdExpression.evaluate({ zoom: 0 }, t2);
              } else r2 = t2.properties[n2];
              "boolean" == typeof r2 && (r2 = Number(r2));
            }
            return r2;
          }
        }
        function K_(t2, e2, r2, n2, i2) {
          return Gt(t2, (t3, s2) => {
            const a2 = e2 instanceof so ? e2.get(s2) : null;
            return a2 && a2.evaluate ? a2.evaluate(r2, n2, void 0, i2) : a2;
          });
        }
        function Q_(t2, e2) {
          return e2 - t2;
        }
        Qs(J_, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        const tA = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class eA {
          static from(t2) {
            if (!(t2 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r2] = new Uint8Array(t2, 0, 2);
            if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
            const n2 = r2 >> 4;
            if (1 !== n2) throw new Error(`Got v${n2} data when expected v1.`);
            const i2 = tA[15 & r2];
            if (!i2) throw new Error("Unrecognized array type.");
            const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
            return new eA(a2, s2, i2, t2);
          }
          constructor(t2, e2 = 64, r2 = Float64Array, n2) {
            if (isNaN(t2) || t2 < 0) throw new Error(`Unpexpected numItems value: ${t2}.`);
            this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
            const i2 = tA.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
            if (i2 < 0) throw new Error(`Unexpected typed array class: ${r2}.`);
            n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
          }
          add(t2, e2) {
            const r2 = this._pos >> 1;
            return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
          }
          finish() {
            const t2 = this._pos >> 1;
            if (t2 !== this.numItems) throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
            return rA(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t2, e2, r2, n2) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
            for (; o2.length; ) {
              const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
              if (c2 - h2 <= a2) {
                for (let a3 = h2; a3 <= c2; a3++) {
                  const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                  o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i2[a3]);
                }
                continue;
              }
              const p2 = h2 + c2 >> 1, d2 = s2[2 * p2], f2 = s2[2 * p2 + 1];
              d2 >= t2 && d2 <= r2 && f2 >= e2 && f2 <= n2 && l2.push(i2[p2]), (0 === u2 ? t2 <= d2 : e2 <= f2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= d2 : n2 >= f2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
            }
            return l2;
          }
          within(t2, e2, r2) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
            for (; a2.length; ) {
              const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
              if (c2 - h2 <= s2) {
                for (let r3 = h2; r3 <= c2; r3++) aA(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
                continue;
              }
              const p2 = h2 + c2 >> 1, d2 = i2[2 * p2], f2 = i2[2 * p2 + 1];
              aA(d2, f2, t2, e2) <= l2 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= d2 : e2 - r2 <= f2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= d2 : e2 + r2 >= f2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
            }
            return o2;
          }
        }
        function rA(t2, e2, r2, n2, i2, s2) {
          if (i2 - n2 <= r2) return;
          const a2 = n2 + i2 >> 1;
          nA(t2, e2, a2, n2, i2, s2), rA(t2, e2, r2, n2, a2 - 1, 1 - s2), rA(t2, e2, r2, a2 + 1, i2, 1 - s2);
        }
        function nA(t2, e2, r2, n2, i2, s2) {
          for (; i2 > n2; ) {
            if (i2 - n2 > 600) {
              const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
              nA(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
            }
            const a2 = e2[2 * r2 + s2];
            let o2 = n2, l2 = i2;
            for (iA(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && iA(t2, e2, n2, i2); o2 < l2; ) {
              for (iA(t2, e2, o2, l2), o2++, l2--; e2[2 * o2 + s2] < a2; ) o2++;
              for (; e2[2 * l2 + s2] > a2; ) l2--;
            }
            e2[2 * n2 + s2] === a2 ? iA(t2, e2, n2, l2) : (l2++, iA(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
          }
        }
        function iA(t2, e2, r2, n2) {
          sA(t2, r2, n2), sA(e2, 2 * r2, 2 * n2), sA(e2, 2 * r2 + 1, 2 * n2 + 1);
        }
        function sA(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function aA(t2, e2, r2, n2) {
          const i2 = t2 - r2, s2 = e2 - n2;
          return i2 * i2 + s2 * s2;
        }
        t.$ = tn, t.A = Lr, t.B = zo, t.C = 2, t.D = Zf, t.E = ir, t.F = Ix, t.G = Mx, t.H = Jr, t.I = sr, t.J = ho, t.K = Yr, t.L = Qr, t.M = Ts, t.N = zs, t.O = ks, t.P = It, t.Q = Ns, t.R = Ce, t.S = po, t.T = Cm, t.U = js, t.V = kb, t.W = qs, t.X = vi, t.Y = gi, t.Z = xi, t._ = an, t.a = function(t2) {
          return oe.API_CDN_URL_REGEX.test(t2);
        }, t.a$ = Cu, t.a0 = Kr, t.a1 = lr, t.a2 = fo, t.a3 = class extends kb {
        }, t.a4 = Vs, t.a5 = Bs, t.a6 = co, t.a7 = function(t2) {
          const e2 = t2.value;
          return e2 ? Kr(e2) ? Tb(e2, true) ? [] : [new kb(t2.key, e2, `invalid url "${e2}"`)] : [new kb(t2.key, e2, `string expected, "${Yr(e2)}" found`)] : [];
        }, t.a8 = to, t.a9 = uo, t.aA = Dt, t.aB = h, t.aC = tt, t.aD = bu, t.aE = Lc, t.aF = Vu, t.aG = qu, t.aH = function(t2, e2) {
          const r2 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.aI = ku, t.aJ = Eu, t.aK = class {
          constructor(t2) {
            this.entries = {}, this.scheduler = t2;
          }
          request(t2, e2, r2, n2) {
            const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
            if (i2.result) {
              const [t3, r3] = i2.result;
              return this.scheduler ? this.scheduler.add(() => {
                n2(t3, r3);
              }, e2) : n2(t3, r3), () => {
              };
            }
            return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
              i2.result = [r3, n3];
              for (const t3 of i2.callbacks) this.scheduler ? this.scheduler.add(() => {
                t3(r3, n3);
              }, e2) : t3(r3, n3);
              setTimeout(() => delete this.entries[t2], 3e3);
            })), () => {
              i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
            };
          }
        }, t.aL = function(t2, e2, r2) {
          const n2 = JSON.stringify(t2.request);
          return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
            const n3 = Ue(t2.request, (t3, n4, i2) => {
              t3 ? e3(t3) : n4 && e3(null, { rawData: n4, vectorTile: r2 ? void 0 : new ic(new Vg(n4)), responseHeaders: new Map(i2.entries()) });
            });
            return () => {
              n3.cancel(), e3();
            };
          }, e2);
        }, t.aM = function(t2) {
          return t2 ? { cacheControl: t2.get("Cache-Control"), expires: t2.get("Expires") } : { cacheControl: void 0, expires: void 0 };
        }, t.aN = Re, t.aO = function(t2) {
          ze++, ze > _e && (t2.getActor().send("enforceCacheSizeLimit", we), ze = 0);
        }, t.aP = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log2(t2)));
        }, t.aQ = Kc, t.aR = bb, t.aS = Sb, t.aT = Bu, t.aU = gb, t.aV = function(t2, e2) {
          const r2 = document.createElement("video");
          r2.muted = true, r2.onloadstart = function() {
            e2(null, r2);
          };
          for (let e3 = 0; e3 < t2.length; e3++) {
            const n2 = document.createElement("source");
            Ne(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
          }
          return { cancel: () => {
          } };
        }, t.aW = Rm, t.aX = Yb, t.aY = jt, t.aZ = _v, t.a_ = Du, t.aa = ao, t.ab = class {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            return Jt(t2.expression.evaluate(e2));
          }
          interpolate(t2, e2, r2) {
            return { x: dr(t2.x, e2.x, r2), y: dr(t2.y, e2.y, r2), z: dr(t2.z, e2.z, r2), azimuthal: dr(t2.azimuthal, e2.azimuthal, r2), polar: dr(t2.polar, e2.polar, r2) };
          }
        }, t.ac = Ja, t.ad = $s, t.ae = Gu, t.af = j, t.ag = M, t.ah = Ct, t.ai = so, t.aj = Mh, t.ak = dr, t.al = jn, t.am = fr, t.an = Bt, t.ao = ur, t.ap = class {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            return function([t3, e3]) {
              const r2 = Jt([1, t3, e3]);
              return { x: r2.x, y: r2.y, z: r2.z };
            }(t2.expression.evaluate(e2));
          }
          interpolate(t2, e2, r2) {
            return { x: dr(t2.x, e2.x, r2), y: dr(t2.y, e2.y, r2), z: dr(t2.z, e2.z, r2) };
          }
        }, t.aq = function(t2, e2, r2 = 0, n2 = true) {
          const i2 = new It(r2, r2), s2 = t2.sub(i2), a2 = e2.add(i2), o2 = [s2, new It(a2.x, s2.y), a2, new It(s2.x, a2.y)];
          return n2 && o2.push(s2.clone()), o2;
        }, t.ar = function(t2, e2) {
          const r2 = [];
          for (let n2 = 0; n2 < t2.length; n2++) {
            const i2 = Rt(n2 - 1, -1, t2.length - 1), s2 = Rt(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h2 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
            r2.push(a2.add(h2));
          }
          return r2;
        }, t.as = Av, t.at = Oc, t.au = function(t2, e2, r2 = 0) {
          return I(((e2.x - r2) * t2.scale - t2.x) * jn, (e2.y * t2.scale - t2.y) * jn, Ru(e2.z, e2.y));
        }, t.av = H, t.aw = L, t.ax = fc, t.ay = ng, t.az = function(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return { min: new It(e2, r2), max: new It(n2, i2) };
        }, t.b = function(t2) {
          return oe.API_FONTS_REGEX.test(t2);
        }, t.b$ = Xd, t.b0 = ll, t.b1 = Go, t.b2 = Ut, t.b3 = Ml, t.b4 = eb, t.b5 = function() {
          Ya.isLoading() || Ya.isLoaded() || "deferred" !== Za() || Wa();
        }, t.b6 = mo, t.b7 = Ku, t.b8 = Wb, t.b9 = Qt, t.bA = u, t.bB = y, t.bC = o, t.bD = function(t2, e2) {
          const { x: r2, y: n2 } = t2.point, i2 = Ah(r2, n2, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
          return h(i2, i2, bh(ch(e2)));
        }, t.bE = n, t.bF = q, t.bG = F, t.bH = E, t.bI = U, t.bJ = O, t.bK = mx, t.bL = Hg, t.bM = fx, t.bN = function(t2, e2, r2, n2, i2) {
          const s2 = 5 * e2 + 2;
          t2.float32[s2 + 0] = r2, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
        }, t.bO = Jv, t.bP = ht, t.bQ = mt, t.bR = dt, t.bS = wt, t.bT = Rt, t.bU = function(t2, e2, n2, i2) {
          var s2 = new r(4);
          return s2[0] = t2, s2[1] = e2, s2[2] = n2, s2[3] = i2, s2;
        }, t.bV = class {
          isDataAvailableAtPoint(t2) {
            const e2 = this._source();
            if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1) return false;
            const r2 = e2.getSource().maxzoom, n2 = 1 << r2, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), a2 = Math.floor(t2.y * n2), o2 = this.findDEMTileFor(new Kc(r2, i2, r2, s2, a2));
            return !(!o2 || !o2.dem);
          }
          getAtPointOrZero(t2, e2 = 0) {
            return this.getAtPoint(t2, e2) || 0;
          }
          getAtPoint(t2, e2, r2 = true) {
            if (this.isUsingMockSource()) return null;
            null == e2 && (e2 = null);
            const n2 = this._source();
            if (!n2) return e2;
            if (t2.y < 0 || t2.y > 1) return e2;
            const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Kc(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
            if (!u2 || !u2.dem) return e2;
            const c2 = u2.dem, h2 = 1 << u2.tileID.canonical.z, p2 = (o2 * h2 - u2.tileID.canonical.x) * c2.dim, d2 = (t2.y * h2 - u2.tileID.canonical.y) * c2.dim, f2 = Math.floor(p2), m2 = Math.floor(d2);
            return (r2 ? this.exaggeration() : 1) * dr(dr(c2.get(f2, m2), c2.get(f2, m2 + 1), d2 - m2), dr(c2.get(f2 + 1, m2), c2.get(f2 + 1, m2 + 1), d2 - m2), p2 - f2);
          }
          static getAtTileOffset(t2, e2, r2, n2) {
            const i2 = 1 << t2.canonical.z;
            return n2 ? n2.pointElevation(e2) : r2 ? r2.getAtPointOrZero(new Gu(t2.wrap + (t2.canonical.x + e2.x / jn) / i2, (t2.canonical.y + e2.y / jn) / i2)) : 0;
          }
          static getAtTileOffsetFunc(t2, e2, r2, n2) {
            return (i2, s2, a2) => {
              const o2 = this.getAtTileOffset(t2, i2, s2, a2), l2 = n2.upVector(t2.canonical, i2.x, i2.y);
              return V(l2, l2, o2 * n2.upVectorScale(t2.canonical, e2, r2).metersToTile), l2;
            };
          }
          getForTilePoints(t2, e2, r2, n2) {
            if (this.isUsingMockSource()) return false;
            const i2 = Rb.create(this, t2, n2);
            return !!i2 && (e2.forEach((t3) => {
              t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
            }), true);
          }
          getMinMaxForTile(t2) {
            if (this.isUsingMockSource()) return null;
            const e2 = this.findDEMTileFor(t2);
            if (!e2 || !e2.dem) return null;
            const r2 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
            let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
            for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[o2]; e3++) {
              s2 *= 2, a2 *= 2;
              const t3 = 2 * Math.floor(a2) + Math.floor(s2);
              o2 = r2.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
            }
            return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t2, e2, r2) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t2) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t2) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
          getMinMaxForVisibleTiles() {
            const t2 = this.visibleDemTiles;
            if (0 === t2.length) return null;
            let e2 = false, r2 = Number.MAX_VALUE, n2 = Number.MIN_VALUE;
            for (const i2 of t2) {
              const t3 = this.getMinMaxForTile(i2.tileID);
              t3 && (r2 = Math.min(r2, t3.min), n2 = Math.max(n2, t3.max), e2 = true);
            }
            return e2 ? { min: r2, max: n2 } : null;
          }
        }, t.bW = Ef, t.bX = Pc, t.bY = Mg, t.bZ = Rd, t.b_ = Bb, t.ba = Qy, t.bb = vd, t.bc = Ju, t.bd = No, t.be = xl, t.bf = ih, t.bg = Ol, t.bh = Qh, t.bi = db, t.bj = function(t2, e2) {
          const r2 = Mh(e2.zoom);
          if (0 === r2) return ch(t2);
          const n2 = fh(t2), i2 = mh(n2), s2 = Vu(n2.getWest()) * e2.worldSize, a2 = Vu(n2.getEast()) * e2.worldSize, o2 = Eu(n2.getNorth()) * e2.worldSize, l2 = Eu(n2.getSouth()) * e2.worldSize, u2 = [s2, o2, 0], h2 = [a2, o2, 0], p2 = [s2, l2, 0], d2 = [a2, l2, 0], f2 = c([], e2.globeMatrix);
          return j(u2, u2, f2), j(h2, h2, f2), j(p2, p2, f2), j(d2, d2, f2), i2[0] = hh(i2[0], p2, r2), i2[1] = hh(i2[1], d2, r2), i2[2] = hh(i2[2], h2, r2), i2[3] = hh(i2[3], u2, r2), wc.fromPoints(i2);
        }, t.bk = vh, t.bl = c, t.bm = yh, t.bn = hh, t.bo = jo, t.bp = nh, t.bq = g, t.br = p, t.bs = H_, t.bt = Vg, t.bu = Ue, t.bv = function(t2, e2) {
          const r2 = [];
          for (const n2 in t2) n2 in e2 || r2.push(n2);
          return r2;
        }, t.bw = Lt, t.bx = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.by = St, t.bz = l, t.c = ue, t.c$ = function(t2, e2, r2) {
          let n2 = 0;
          for (let r3 = 0; r3 < 2; ++r3) {
            const i2 = 0;
            t2[r3] > i2 && (n2 += (t2[r3] - i2) * (t2[r3] - i2)), e2[r3] < i2 && (n2 += (i2 - e2[r3]) * (i2 - e2[r3]));
          }
          return n2;
        }, t.c0 = Hd, t.c1 = ix, t.c2 = Yx, t.c3 = uv, t.c4 = eA, t.c5 = V, t.c6 = W, t.c7 = rt, t.c8 = function(t2, e2, r2) {
          r2 *= 0.5;
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
          return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
        }, t.c9 = nt, t.cA = _, t.cB = bc, t.cC = Xm, t.cD = Yc, t.cE = dh, t.cF = function(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          if ("globe" === l2.name) return dh(t2, e2, new Yc(r2, n2, i2), false);
          const u2 = _v({ z: r2, x: n2, y: i2 }, l2);
          return new wc([(s2 + u2.x / u2.scale) * e2, e2 * (u2.y / u2.scale), a2], [(s2 + u2.x2 / u2.scale) * e2, e2 * (u2.y2 / u2.scale), o2]);
        }, t.cG = function(t2, e2, r2) {
          return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2[3] = Math.min(e2[3], r2[3]), t2;
        }, t.cH = function(t2, e2, r2) {
          return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2[3] = Math.max(e2[3], r2[3]), t2;
        }, t.cI = function(t2) {
          const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
          return Tt[e2];
        }, t.cJ = Lu, t.cK = J, t.cL = 6, t.cM = function(t2) {
          const e2 = u(new Float64Array(16));
          h(e2, t2.pixelMatrix, t2.globeMatrix);
          const r2 = [0, Au, 0], n2 = [0, Mu, 0];
          return j(r2, r2, e2), j(n2, n2, e2), [r2[0] > 0 && r2[0] <= t2.width && r2[1] > 0 && r2[1] <= t2.height && !Sh(t2, new Bu(t2.center.lat, 90)), n2[0] > 0 && n2[0] <= t2.width && n2[1] > 0 && n2[1] <= t2.height && !Sh(t2, new Bu(t2.center.lat, -90))];
        }, t.cN = function(t2, e2) {
          const { scale: r2 } = t2.tileTransform, n2 = r2 * jn / (t2.tileSize * Math.pow(2, e2.zoom - t2.tileID.overscaledZ + t2.tileID.canonical.z));
          return function(t3, e3, r3) {
            var n3 = e3[1], i2 = e3[2], s2 = e3[3], a2 = r3[0], o2 = r3[1];
            return t3[0] = e3[0] * a2, t3[1] = n3 * a2, t3[2] = i2 * o2, t3[3] = s2 * o2, t3;
          }(new Float32Array(4), e2.inverseAdjustmentMatrix, [n2, n2]);
        }, t.cO = Hm, t.cP = w, t.cQ = qm, t.cR = function(t2) {
          const e2 = qm(t2, true);
          return n([], [e2[0], e2[1], e2[4], e2[5]]);
        }, t.cS = d, t.cT = mc, t.cU = f, t.cV = function(t2) {
          const { x: e2, y: r2 } = t2.point, { lng: n2, lat: i2 } = t2._center;
          return Ah(e2, r2, t2.worldSize, n2, i2);
        }, t.cW = B, t.cX = kt, t.cY = Qc, t.cZ = Uc, t.c_ = 5, t.ca = ee, t.cb = function(t2, e2) {
          return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
        }, t.cc = b, t.cd = function(t2, e2, r2, n2, i2) {
          var s2 = 1 / Math.tan(e2 / 2);
          if (t2[0] = s2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = s2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0) {
            var a2 = 1 / (n2 - i2);
            t2[10] = (i2 + n2) * a2, t2[14] = 2 * i2 * n2 * a2;
          } else t2[10] = -1, t2[14] = -2 * n2;
          return t2;
        }, t.ce = function(t2, e2, r2, n2, i2, s2, a2) {
          var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
        }, t.cf = Fu, t.cg = function(t2, e2, r2) {
          t2[4 * e2 + 0] = r2[0], t2[4 * e2 + 1] = r2[1], t2[4 * e2 + 2] = r2[2], t2[4 * e2 + 3] = r2[3];
        }, t.ch = Wl, t.ci = Kl, t.cj = Yl, t.ck = Jl, t.cl = ru, t.cm = $v, t.cn = function() {
          var t2 = new r(4);
          return r != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
        }, t.co = function(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
          return t2[0] = n2 * l2 + s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = n2 * -o2 + s2 * l2, t2[3] = i2 * -o2 + a2 * l2, t2;
        }, t.cp = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
        }, t.cq = X, t.cr = function(t2) {
          var e2 = t2[0], r2 = t2[1], n2 = t2[2], i2 = t2[3];
          return Math.sqrt(e2 * e2 + r2 * r2 + n2 * n2 + i2 * i2);
        }, t.cs = lt, t.ct = $, t.cu = Jc, t.cv = 3, t.cw = 2, t.cx = 7, t.cy = 6, t.cz = N, t.d = function(t2) {
          return oe.API_TILEJSON_REGEX.test(t2);
        }, t.d$ = class {
          constructor(t2, e2, r2, n2) {
            this.context = t2, this.format = n2, this.size = r2, this.texture = t2.gl.createTexture();
            const [i2, s2, a2] = this.size, { gl: o2 } = t2;
            o2.bindTexture(o2.TEXTURE_3D, this.texture), t2.pixelStoreUnpackFlipY.set(false), t2.pixelStoreUnpack.set(1), t2.pixelStoreUnpackPremultiplyAlpha.set(false), "data" in e2 && e2.data && o2.texImage3D(o2.TEXTURE_3D, 0, this.format, i2, s2, a2, 0, Fm(this.format), Dm(this.format), e2.data);
          }
          bind(t2, e2) {
            const { context: r2 } = this, { gl: n2 } = r2;
            n2.bindTexture(n2.TEXTURE_3D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e2 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }, t.d0 = function(t2) {
          return t2 * t2 * t2 * t2 * t2;
        }, t.d1 = Tu, t.d2 = 45, t.d3 = Ql, t.d4 = function(t2, e2, r2) {
          const n2 = Math.sqrt(t2 * t2 + e2 * e2 + r2 * r2), i2 = n2 > 0 ? Math.acos(r2 / n2) * zt : 0;
          let s2 = 0 !== t2 || 0 !== e2 ? Math.atan2(-e2, -t2) * zt + 90 : 0;
          return s2 < 0 && (s2 += 360), [n2, s2, i2];
        }, t.d5 = I, t.d6 = Jt, t.d7 = ju, t.d8 = P, t.d9 = wc, t.dA = function(t2) {
          return t2({ pluginStatus: Ga, pluginURL: $a }), Ha.on("pluginStateChange", t2), t2;
        }, t.dB = tu, t.dC = class extends Zl {
          constructor(t2) {
            super(t2), this.current = nu;
          }
          set(t2, e2, r2) {
            if (this.fetchUniformLocation(t2, e2)) {
              for (let t3 = 0; t3 < 9; t3++) if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                break;
              }
            }
          }
        }, t.dD = Vt, t.dE = function(t2, e2, r2) {
          const n2 = Mh(r2.zoom), i2 = t2.style.map._antialias, s2 = t2.terrain && t2.terrain.exaggeration() > 0;
          return 0 === n2 && !i2 && !s2;
        }, t.dF = function(t2) {
          const e2 = t2.pixelsPerMeter, r2 = e2 / Fu(1, t2.center.lat), n2 = u(new Float64Array(16));
          return p(n2, n2, [t2.point.x, t2.point.y, 0]), d(n2, n2, [r2, r2, e2]), Float32Array.from(n2);
        }, t.dG = fh, t.dH = function(t2) {
          const e2 = 80.051129;
          t2 = Dt(t2, -80.051129, e2) / e2 * 90;
          const r2 = Math.pow(Math.abs(Math.sin(Bt(t2))), 3);
          return Math.round(r2 * (_u.length - 1));
        }, t.dI = function(t2, e2, r2, n2) {
          const i2 = e2.getNorth(), s2 = e2.getSouth(), o2 = e2.getWest(), l2 = e2.getEast(), u2 = 1 << t2.z, c2 = l2 - o2, h2 = i2 - s2, p2 = c2 / wu, d2 = -h2 / _u[r2], f2 = [0, p2, 0, d2, 0, 0, i2, o2, 0];
          if (t2.z > 0) {
            const t3 = 180 / n2;
            a(f2, f2, [t3 / c2 + 1, 0, 0, 0, t3 / h2 + 1, 0, -0.5 * t3 / p2, 0.5 * t3 / d2, 1]);
          }
          return f2[2] = u2, f2[5] = t2.x, f2[8] = t2.y, f2;
        }, t.dJ = ch, t.dK = function(t2, e2, r2) {
          const n2 = u(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
          return m(n2, r2.globeMatrix, i2), Float32Array.from(n2);
        }, t.dL = Hh, t.dM = sh, t.dN = function(t2, e2) {
          return [Math.pow(t2[0], 2.2) * e2, Math.pow(t2[1], 2.2) * e2, Math.pow(t2[2], 2.2) * e2];
        }, t.dO = i, t.dP = function(t2, e2) {
          var r2 = Math.sin(e2), n2 = Math.cos(e2);
          return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, t.dQ = G, t.dR = _h, t.dS = ie, t.dT = se, t.dU = xb, t.dV = function(t2, e2) {
          const r2 = [0, 0, 0];
          return j(r2, r2, vh(ch(e2.canonical))), j(r2, r2, t2), r2;
        }, t.dW = (t2) => ({ u_matrix: new ru(t2), u_texsize: new Jl(t2), u_pixels_to_tile_units: new su(t2), u_device_pixel_ratio: new Yl(t2), u_width_scale: new Yl(t2), u_floor_width_scale: new Yl(t2), u_image: new Wl(t2), u_units_to_pixels: new Jl(t2), u_tile_units_to_pixels: new Yl(t2), u_alpha_discard_threshold: new Yl(t2), u_trim_offset: new Jl(t2), u_trim_fade_range: new Jl(t2), u_trim_gradient_mix_range: new Jl(t2), u_trim_color: new Ql(t2), u_zbias_factor: new Yl(t2), u_tile_to_meter: new Yl(t2), u_ground_shadow_factor: new Kl(t2), u_pattern_transition: new Yl(t2) }), t.dX = (t2) => ({ u_matrix: new ru(t2), u_pixels_to_tile_units: new su(t2), u_device_pixel_ratio: new Yl(t2), u_width_scale: new Yl(t2), u_floor_width_scale: new Yl(t2), u_units_to_pixels: new Jl(t2), u_dash_image: new Wl(t2), u_gradient_image: new Wl(t2), u_image_height: new Yl(t2), u_texsize: new Jl(t2), u_tile_units_to_pixels: new Yl(t2), u_alpha_discard_threshold: new Yl(t2), u_trim_offset: new Jl(t2), u_trim_fade_range: new Jl(t2), u_trim_gradient_mix_range: new Jl(t2), u_trim_color: new Ql(t2), u_zbias_factor: new Yl(t2), u_tile_to_meter: new Yl(t2), u_ground_shadow_factor: new Kl(t2) }), t.dY = (t2) => ({ u_camera_to_center_distance: new Yl(t2), u_extrude_scale: new su(t2), u_device_pixel_ratio: new Yl(t2), u_matrix: new ru(t2), u_inv_rot_matrix: new ru(t2), u_merc_center: new Jl(t2), u_tile_id: new Kl(t2), u_zoom_transition: new Yl(t2), u_up_dir: new Kl(t2), u_emissive_strength: new Yl(t2) }), t.dZ = al, t.d_ = Ag, t.da = z, t.db = function(t2) {
          return [Math.pow(t2[0], 1 / 2.2), Math.pow(t2[1], 1 / 2.2), Math.pow(t2[2], 1 / 2.2)];
        }, t.dc = Em, t.dd = xy, t.de = iy, t.df = Tb, t.dg = function(t2, e2) {
          return t2.readFields(ew, { icons: [] }, e2);
        }, t.dh = Jf, t.di = Vx, t.dj = Tx, t.dk = Le, t.dl = qa, t.dm = ve, t.dn = Qe, t.dp = qt, t.dq = function(t2) {
          const e2 = t2.indexOf(Po);
          return e2 >= 0 ? t2.slice(0, e2) : t2;
        }, t.dr = function(t2) {
          return t2.indexOf(Po) >= 0;
        }, t.ds = function(t2) {
          const e2 = t2.lastIndexOf(Po);
          return e2 >= 0 ? t2.slice(e2 + 1) : "";
        }, t.dt = function(t2) {
          const e2 = [], r2 = t2.id;
          return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.du = function(t2, e2, r2, n2) {
          return "custom" === t2.type ? new Pb(t2, e2) : new Qb[t2.type](t2, e2, r2, n2);
        }, t.dv = $t, t.dw = function(t2) {
          const e2 = t2.indexOf(Po);
          return e2 >= 0 ? t2.slice(e2 + 1) : "";
        }, t.dx = class extends Wb {
          constructor(t2, e2) {
            super(t2._vectorTileFeature, t2._z, t2._x, t2._y, t2.id), t2.state && (this.state = Object.assign({}, t2.state)), this.target = e2.target, this.namespace = e2.namespace, e2.properties && (this.properties = e2.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t2.source, this.sourceLayer = t2.sourceLayer, this.layer = t2.layer);
          }
          toJSON() {
            const t2 = super.toJSON();
            return t2.target = this.target, t2.namespace = this.namespace, t2;
          }
        }, t.dy = Ha, t.dz = Oe, t.e = oe, t.e$ = S, t.e0 = Th, t.e1 = (t2, e2, r2, n2, i2, s2) => {
          const a2 = t2.transform, o2 = "globe" === a2.projection.name;
          let l2;
          if ("map" === s2.paint.get("circle-pitch-alignment")) if (o2) {
            const t3 = _h(a2.zoom, e2.canonical) * a2._pixelsPerMercatorPixel;
            l2 = Float32Array.from([t3, 0, 0, t3]);
          } else l2 = a2.calculatePixelsToTileUnitsMatrix(r2);
          else l2 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
          const u2 = { u_camera_to_center_distance: t2.transform.getCameraToCenterDistance(a2.projection), u_matrix: t2.translatePosMatrix(e2.projMatrix, r2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: ge.devicePixelRatio, u_extrude_scale: l2, u_inv_rot_matrix: kh, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s2.paint.get("circle-emissive-strength") };
          if (o2) {
            u2.u_inv_rot_matrix = n2, u2.u_merc_center = i2, u2.u_tile_id = [e2.canonical.x, e2.canonical.y, 1 << e2.canonical.z], u2.u_zoom_transition = Mh(a2.zoom);
            const t3 = i2[0] * jn, r3 = i2[1] * jn;
            u2.u_up_dir = a2.projection.upVector(new Yc(0, 0, 0), t3, r3);
          }
          return u2;
        }, t.e2 = og, t.e3 = Or, t.e4 = (t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) => {
          const c2 = t2.transform, h2 = c2.pitch < 15 ? ig(0.07, 0.7, Dt((14 - c2.zoom) / 5, 0, 1)) : 0.07, p2 = "none" === r2.paint.get("line-trim-color-use-theme").constantOr("default");
          return { u_matrix: ag(t2, e2, r2, n2), u_texsize: e2.imageAtlasTexture ? e2.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: c2.calculatePixelsToTileUnitsMatrix(e2), u_device_pixel_ratio: i2, u_width_scale: s2, u_floor_width_scale: a2, u_image: 0, u_tile_units_to_pixels: sg(e2, c2), u_units_to_pixels: [1 / c2.pixelsToGLUnits[0], 1 / c2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: o2, u_trim_fade_range: r2.paint.get("line-trim-fade-range"), u_trim_gradient_mix_range: [1, 1], u_trim_color: r2.paint.get("line-trim-color").toPremultipliedRenderColor(p2 ? null : r2.lut).toArray01(), u_zbias_factor: h2, u_tile_to_meter: ju(e2.tileID.canonical, 0), u_ground_shadow_factor: l2, u_pattern_transition: u2 };
        }, t.e5 = (t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) => {
          const c2 = t2.transform, h2 = c2.calculatePixelsToTileUnitsMatrix(e2), p2 = "none" === r2.paint.get("line-trim-color-use-theme").constantOr("default"), d2 = c2.pitch < 15 ? ig(0.07, 0.7, Dt((14 - c2.zoom) / 5, 0, 1)) : 0.07;
          return { u_matrix: ag(t2, e2, r2, n2), u_pixels_to_tile_units: h2, u_device_pixel_ratio: s2, u_width_scale: a2, u_floor_width_scale: o2, u_units_to_pixels: [1 / c2.pixelsToGLUnits[0], 1 / c2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i2, u_texsize: lg(r2) && e2.lineAtlasTexture ? e2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: sg(e2, t2.transform), u_alpha_discard_threshold: 0, u_trim_offset: l2, u_trim_fade_range: r2.paint.get("line-trim-fade-range"), u_trim_gradient_mix_range: [1, 1], u_trim_color: r2.paint.get("line-trim-color").toPremultipliedRenderColor(p2 ? null : r2.lut).toArray01(), u_zbias_factor: d2, u_tile_to_meter: ju(e2.tileID.canonical, 0), u_ground_shadow_factor: u2 };
        }, t.e6 = Nt, t.e7 = Zh, t.e8 = Ru, t.e9 = th, t.eA = function(t2, r2) {
          var n2 = 2 * Math.acos(r2[3]), i2 = Math.sin(n2 / 2);
          return i2 > e ? (t2[0] = r2[0] / i2, t2[1] = r2[1] / i2, t2[2] = r2[2] / i2) : (t2[0] = 1, t2[1] = 0, t2[2] = 0), n2;
        }, t.eB = Jb, t.eC = ny, t.eD = Qm, t.eE = [1, 1, 1], t.eF = Rb, t.eG = Y, t.eH = function(t2, e2, r2, n2) {
          var i2 = e2[0], s2 = e2[1], a2 = e2[2], o2 = e2[3];
          return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2[2] = a2 + n2 * (r2[2] - a2), t2[3] = o2 + n2 * (r2[3] - o2), t2;
        }, t.eI = ry, t.eJ = nl, t.eK = yl, t.eL = function(t2, e2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, m2, y2) {
          var g2 = new r(16);
          return g2[0] = t2, g2[1] = e2, g2[2] = n2, g2[3] = i2, g2[4] = s2, g2[5] = a2, g2[6] = o2, g2[7] = l2, g2[8] = u2, g2[9] = c2, g2[10] = h2, g2[11] = p2, g2[12] = d2, g2[13] = f2, g2[14] = m2, g2[15] = y2, g2;
        }, t.eM = Pu, t.eN = ml, t.eO = fl, t.eP = class {
          constructor() {
            this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new It(1 / 0, 1 / 0), max: new It(-1 / 0, -1 / 0) };
          }
          clear() {
            this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
          }
          get updateTime() {
            return this._updateTime;
          }
          getReplacementRegionsForTile(t2, e2 = false) {
            const r2 = jd(new It(0, 0), new It(jn, jn), t2), n2 = [];
            if (e2 && !Ud(r2, this._globalClipBounds)) return n2;
            for (const e3 of this._activeRegions) {
              if (e3.hiddenByOverlap) continue;
              if (!Ud(r2, e3)) continue;
              const i2 = Gd(e3.min, e3.max, t2);
              n2.push({ min: i2.min, max: i2.max, sourceId: this._sourceIds[e3.priority], footprint: e3.footprint, footprintTileId: e3.tileId, order: e3.order, clipMask: e3.clipMask, clipScope: e3.clipScope });
            }
            return n2;
          }
          setSources(t2) {
            this._setSources(t2.map((t3) => ({ getSourceId: () => t3.cache.id, getFootprints: () => {
              const e2 = [];
              for (const r2 of t3.cache.getVisibleCoordinates()) {
                const n2 = t3.cache.getTile(r2).buckets[t3.layer];
                n2 && n2.updateFootprints(r2.toUnwrapped(), e2);
              }
              return e2;
            }, getOrder: () => t3.order, getClipMask: () => t3.clipMask, getClipScope: () => t3.clipScope })));
          }
          _addSource(t2) {
            const e2 = t2.getFootprints();
            if (0 === e2.length) return;
            const r2 = t2.getOrder(), n2 = t2.getClipMask(), i2 = t2.getClipScope();
            for (const t3 of e2) {
              if (!t3.footprint) continue;
              const e3 = jd(t3.footprint.min, t3.footprint.max, t3.id);
              this._activeRegions.push({ min: e3.min, max: e3.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t3.id, footprint: t3.footprint, order: r2, clipMask: n2, clipScope: i2 });
            }
            this._sourceIds.push(t2.getSourceId());
          }
          _computeReplacement() {
            this._activeRegions.sort((t3, e2) => t3.priority - e2.priority || Ld(t3.min, e2.min) || Ld(t3.max, e2.max) || t3.order - e2.order || t3.clipMask - e2.clipMask || function(t4, e3) {
              const r2 = (t5, e4) => t5 + e4;
              return t4.length - e3.length || t4.reduce(r2, "").localeCompare(e3.reduce(r2, ""));
            }(t3.clipScope, e2.clipScope));
            let t2 = this._activeRegions.length !== this._prevRegions.length;
            if (!t2) {
              let e2 = 0;
              for (; !t2 && e2 !== this._activeRegions.length; ) {
                const r2 = this._activeRegions[e2], n2 = this._prevRegions[e2];
                t2 = r2.priority !== n2.priority || !Od(r2, n2) || r2.order !== n2.order || r2.clipMask !== n2.clipMask || !St(r2.clipScope, n2.clipScope), this._activeRegions[e2].hiddenByOverlap = n2.hiddenByOverlap, ++e2;
              }
            }
            if (t2) {
              ++this._updateTime;
              for (const t4 of this._activeRegions) t4.order !== Dd && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t4.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t4.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t4.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t4.max.y));
              const t3 = (t4) => {
                const e2 = this._activeRegions;
                if (t4 >= e2.length) return t4;
                const r2 = e2[t4].priority;
                for (; t4 < e2.length && e2[t4].priority === r2; ) ++t4;
                return t4;
              };
              if (this._sourceIds.length > 1) {
                let e2 = 0, r2 = t3(e2);
                for (; e2 !== r2; ) {
                  let n2 = e2;
                  const i2 = e2;
                  for (; n2 !== r2; ) {
                    const t4 = this._activeRegions[n2];
                    t4.hiddenByOverlap = false;
                    for (let e3 = 0; e3 < i2; e3++) {
                      const r3 = this._activeRegions[e3];
                      if (!r3.hiddenByOverlap && t4.order === Dd && Ud(t4, r3) && (t4.hiddenByOverlap = qd(t4.footprint, t4.tileId, r3.footprint, r3.tileId), t4.hiddenByOverlap)) break;
                    }
                    ++n2;
                  }
                  e2 = r2, r2 = t3(e2);
                }
              }
            }
          }
          _setSources(t2) {
            [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
            for (let e2 = t2.length - 1; e2 >= 0; e2--) this._addSource(t2[e2]);
            this._computeReplacement();
          }
        }, t.eQ = Dd, t.eR = class {
          constructor(t2) {
            this._createGrid(t2), this._createPoles(t2);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const t2 of this._poleSegments) t2.destroy();
            for (const t2 of this._gridSegments) t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
          }
          _fillGridMeshWithLods(t2, e2) {
            const r2 = new No(), n2 = new ll(), i2 = [], s2 = t2 + 1 + 2, a2 = e2[0] + 1, o2 = e2[0] + 1 + (1 + e2.length), l2 = (t3, e3, r3) => {
              let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
              return n3 += r3 ? 24575 : 0, [n3, e3];
            };
            for (let t3 = 0; t3 < s2; ++t3) r2.emplaceBack(...l2(t3, 0, true));
            for (let t3 = 0; t3 < a2; ++t3) for (let e3 = 0; e3 < s2; ++e3) r2.emplaceBack(...l2(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
            for (let t3 = 0; t3 < e2.length; ++t3) {
              const n3 = e2[t3];
              for (let t4 = 0; t4 < s2; ++t4) r2.emplaceBack(...l2(t4, n3, true));
            }
            for (let t3 = 0; t3 < e2.length; ++t3) {
              const a3 = n2.length, l3 = e2[t3] + 1 + 2, u2 = new ll();
              for (let r3 = 0; r3 < l3 - 1; r3++) {
                const i3 = r3 === l3 - 2, a4 = i3 ? s2 * (o2 - e2.length + t3 - r3) : s2;
                for (let t4 = 0; t4 < s2 - 1; t4++) {
                  const e3 = r3 * s2 + t4;
                  0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u2.emplaceBack(e3 + 1, e3, e3 + a4), u2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + a4), n2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
                }
              }
              const c2 = Ol.simpleSegment(0, a3, r2.length, n2.length - a3);
              for (let t4 = 0; t4 < u2.uint16.length; t4 += 3) n2.emplaceBack(u2.uint16[t4], u2.uint16[t4 + 1], u2.uint16[t4 + 2]);
              const h2 = Ol.simpleSegment(0, a3, r2.length, n2.length - a3);
              i2.push({ withoutSkirts: c2, withSkirts: h2 });
            }
            return { vertices: r2, indices: n2, segments: i2 };
          }
          _createGrid(t2) {
            const e2 = this._fillGridMeshWithLods(wu, _u);
            this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, ih.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
          }
          _createPoles(t2) {
            const e2 = new ll();
            for (let t3 = 0; t3 <= wu; t3++) e2.emplaceBack(0, t3 + 1, t3 + 2);
            this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
            const r2 = new pl(), n2 = new pl(), i2 = new pl(), s2 = new pl();
            this._poleSegments = [];
            for (let t3 = 0, e3 = 0; t3 < 5; t3++) {
              const a2 = 360 / (1 << t3);
              r2.emplaceBack(0, -bu, 0, 0.5, 0), n2.emplaceBack(0, -bu, 0, 0.5, 1), i2.emplaceBack(0, -bu, 0, 0.5, 0.5), s2.emplaceBack(0, -bu, 0, 0.5, 0.5);
              for (let t4 = 0; t4 <= wu; t4++) {
                let e4 = t4 / wu, o2 = 0;
                const l2 = dr(0, a2, e4), [u2, c2, h2] = Iu(zh, Bh, l2, bu);
                r2.emplaceBack(u2, c2, h2, e4, o2), n2.emplaceBack(u2, c2, h2, e4, 1 - o2);
                const p2 = Bt(l2);
                e4 = 0.5 + 0.5 * Math.sin(p2), o2 = 0.5 + 0.5 * Math.cos(p2), i2.emplaceBack(u2, c2, h2, e4, o2), s2.emplaceBack(u2, c2, h2, e4, 1 - o2);
              }
              this._poleSegments.push(Ol.simpleSegment(e3, 0, 66, 64)), e3 += 66;
            }
            this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, rh, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, rh, false), this._texturedPoleNorthVertexBuffer = t2.createVertexBuffer(i2, rh, false), this._texturedPoleSouthVertexBuffer = t2.createVertexBuffer(s2, rh, false);
          }
          getGridBuffers(t2, e2) {
            return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
          }
          getPoleBuffers(t2, e2) {
            return [e2 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e2 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
          }
        }, t.eS = Cd, t.eT = Et, t.eU = function() {
          return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t.eV = Ft, t.eW = Nu, t.eX = function(t2, e2, r2) {
          return t2[0] = e2[0] / r2[0], t2[1] = e2[1] / r2[1], t2[2] = e2[2] / r2[2], t2;
        }, t.eY = Z, t.eZ = Su, t.e_ = C, t.ea = mf, t.eb = Mf, t.ec = rf, t.ed = 450, t.ee = 7, t.ef = Uu, t.eg = function(t2, e2) {
          if (t2 === e2) {
            var r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[6], a2 = e2[7], o2 = e2[11];
            t2[1] = e2[4], t2[2] = e2[8], t2[3] = e2[12], t2[4] = r2, t2[6] = e2[9], t2[7] = e2[13], t2[8] = n2, t2[9] = s2, t2[11] = e2[14], t2[12] = i2, t2[13] = a2, t2[14] = o2;
          } else t2[0] = e2[0], t2[1] = e2[4], t2[2] = e2[8], t2[3] = e2[12], t2[4] = e2[1], t2[5] = e2[5], t2[6] = e2[9], t2[7] = e2[13], t2[8] = e2[2], t2[9] = e2[6], t2[10] = e2[10], t2[11] = e2[14], t2[12] = e2[3], t2[13] = e2[7], t2[14] = e2[11], t2[15] = e2[15];
          return t2;
        }, t.eh = vb, t.ei = Oo, t.ej = wl, t.ek = 256, t.el = bh, t.em = Wo, t.en = m, t.eo = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
        }, t.ep = pl, t.eq = ys, t.er = dl, t.es = function(t2, e2, r2, n2, i2) {
          return Dt((t2 - e2) / (r2 - e2) * (i2 - n2) + n2, n2, i2);
        }, t.et = it, t.eu = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = c2 * a2 - o2 * u2, p2 = -c2 * s2 + o2 * l2, d2 = u2 * s2 - a2 * l2, f2 = r2 * h2 + n2 * p2 + i2 * d2;
          return f2 ? (t2[0] = h2 * (f2 = 1 / f2), t2[1] = (-c2 * n2 + i2 * u2) * f2, t2[2] = (o2 * n2 - i2 * a2) * f2, t2[3] = p2 * f2, t2[4] = (c2 * r2 - i2 * l2) * f2, t2[5] = (-o2 * r2 + i2 * s2) * f2, t2[6] = d2 * f2, t2[7] = (-u2 * r2 + n2 * l2) * f2, t2[8] = (a2 * r2 - n2 * s2) * f2, t2) : null;
        }, t.ev = 2, t.ew = R, t.ex = et, t.ey = v, t.ez = function(t2, e2) {
          var n2 = new r(3);
          v(n2, e2);
          var i2 = 1 / n2[0], s2 = 1 / n2[1], a2 = 1 / n2[2], o2 = e2[0] * i2, l2 = e2[1] * s2, u2 = e2[2] * a2, c2 = e2[4] * i2, h2 = e2[5] * s2, p2 = e2[6] * a2, d2 = e2[8] * i2, f2 = e2[9] * s2, m2 = e2[10] * a2, y2 = o2 + h2 + m2, g2 = 0;
          return y2 > 0 ? (g2 = 2 * Math.sqrt(y2 + 1), t2[3] = 0.25 * g2, t2[0] = (p2 - f2) / g2, t2[1] = (d2 - u2) / g2, t2[2] = (l2 - c2) / g2) : o2 > h2 && o2 > m2 ? (g2 = 2 * Math.sqrt(1 + o2 - h2 - m2), t2[3] = (p2 - f2) / g2, t2[0] = 0.25 * g2, t2[1] = (l2 + c2) / g2, t2[2] = (d2 + u2) / g2) : h2 > m2 ? (g2 = 2 * Math.sqrt(1 + h2 - o2 - m2), t2[3] = (d2 - u2) / g2, t2[0] = (l2 + c2) / g2, t2[1] = 0.25 * g2, t2[2] = (p2 + f2) / g2) : (g2 = 2 * Math.sqrt(1 + m2 - o2 - h2), t2[3] = (l2 - c2) / g2, t2[0] = (d2 + u2) / g2, t2[1] = (p2 + f2) / g2, t2[2] = 0.25 * g2), t2;
        }, t.f = function(t2) {
          return btoa(encodeURIComponent(t2).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2))));
        }, t.f0 = function([t2, e2, r2]) {
          const n2 = Math.hypot(t2, e2, r2), i2 = Math.atan2(t2, r2), s2 = 0.5 * Math.PI - Math.acos(-e2 / n2);
          return new Bu(kt(i2), kt(s2));
        }, t.f1 = K, t.f2 = Wm, t.f3 = function(t2) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          return !!function(t3) {
            if (null == te) {
              const e3 = t3.navigator ? t3.navigator.userAgent : null;
              te = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
            }
            return te;
          }(t2) && !(!e2 || !(e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));
        }, t.f4 = function(t2, e2) {
          we = t2, _e = e2;
        }, t.f5 = Sh, t.f6 = Ih, t.f7 = function(t2) {
          const e2 = [0, 0, 0], r2 = u(new Float64Array(16));
          return h(r2, t2.pixelMatrix, t2.globeMatrix), j(e2, e2, r2), new It(e2[0], e2[1]);
        }, t.f8 = function() {
          const t2 = Wf;
          t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(Xf), Wf = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t.f9 = function() {
          Jf().acquire(Xf);
        }, t.fA = r_, t.fB = Qu, t.fC = function(t2) {
          let e2 = 0;
          if (new Uint32Array(t2, 0, 1)[0] !== Sm) {
            const r2 = new Uint32Array(t2, 0, 7), [, , n2, i2, s2, a2] = r2;
            e2 = r2.byteLength + i2 + s2 + a2 + s2, (n2 !== t2.byteLength || e2 >= t2.byteLength) && Zt("Invalid b3dm header information.");
          }
          return Vm(t2, e2);
        }, t.fD = function(t2, e2) {
          const r2 = xy(t2);
          for (const t3 of r2) {
            for (const e3 of t3.meshes) vy(e3);
            t3.lights && (t3.lightMeshIndex = t3.meshes.length, t3.meshes.push(wy(t3.lights, e2)));
          }
          return r2;
        }, t.fE = $b, t.fF = Kt, t.fG = Gf, t.fH = Ya, t.fI = Na, t.fJ = function(t2) {
          Pe(), null != Me && Me.then((e2) => {
            e2.keys().then((r2) => {
              for (let n2 = 0; n2 < r2.length - t2; n2++) e2.delete(r2[n2]).catch((t3) => Zt(t3.message));
            }).catch((t3) => Zt(t3.message));
          }).catch((t3) => Zt(t3.message));
        }, t.fa = Za, t.fb = function(t2, e2, r2 = false) {
          if (Ga === Na.deferred || Ga === Na.loading || Ga === Na.loaded) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          $a = ge.resolveURL(t2), Ga = Na.deferred, ja = e2, Xa(), r2 || Wa();
        }, t.fc = function(t2) {
          nm = ge.resolveURL(t2), sm || (sm = new Zf(Jf(), new ir())), sm.broadcast("setMeshoptUrl", nm);
        }, t.fd = cm, t.fe = function(t2) {
          em = ge.resolveURL(t2), sm || (sm = new Zf(Jf(), new ir())), sm.broadcast("setDracoUrl", em);
        }, t.ff = um, t.fg = $f, t.fh = function(t2) {
          const e2 = Se();
          if (!e2) return;
          const r2 = e2.delete(be);
          t2 && r2.then(() => t2()).catch(t2);
        }, t.fi = Hf, t.fj = Qs, t.fk = qh, t.fl = 2, t.fm = Y_, t.fn = J_, t.fo = Wy, t.fp = ac, t.fq = "hd_road_elevation", t.fr = Mc, t.fs = Gt, t.ft = kp, t.fu = Sx, t.fv = 1, t.fw = function(t2, e2, r2, n2, i2, s2, a2, o2 = 1, l2, u2, c2, h2) {
          t2.createArrays(), t2.tilePixelRatio = jn / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
          const p2 = t2.layers[0].layout, d2 = t2.layers[0]._unevaluatedLayout._values, f2 = {};
          f2.scaleFactor = o2, f2.textSizeScaleRange = p2.get("text-size-scale-range"), f2.iconSizeScaleRange = p2.get("icon-size-scale-range");
          const [m2, y2] = f2.textSizeScaleRange, [g2, x2] = f2.iconSizeScaleRange;
          f2.textScaleFactor = Dt(f2.scaleFactor, m2, y2), f2.iconScaleFactor = Dt(f2.scaleFactor, g2, x2);
          const v2 = d2["text-size"], b2 = d2["icon-size"];
          if ("composite" === t2.textSizeData.kind) {
            const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
            f2.compositeTextSizes = [v2.possiblyEvaluate(new Ja(e3, { worldview: c2 }), s2), v2.possiblyEvaluate(new Ja(r3, { worldview: c2 }), s2)];
          }
          if ("composite" === t2.iconSizeData.kind) {
            const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
            f2.compositeIconSizes = [b2.possiblyEvaluate(new Ja(e3, { worldview: c2 }), s2, h2), b2.possiblyEvaluate(new Ja(r3, { worldview: c2 }), s2, h2)];
          }
          f2.layoutTextSize = v2.possiblyEvaluate(new Ja(a2 + 1, { worldview: c2 }), s2), f2.layoutIconSize = b2.possiblyEvaluate(new Ja(a2 + 1, { worldview: c2 }), s2, h2), f2.textMaxSize = v2.possiblyEvaluate(new Ja(18, { worldview: c2 }), s2);
          const w2 = p2.get("symbol-placement"), _2 = "map" === p2.get("text-rotation-alignment") && "point" !== w2, A2 = p2.get("text-size");
          let M2 = false;
          const I2 = [];
          for (const a3 of t2.features) {
            const o3 = p2.get("text-font").evaluate(a3, {}, s2).join(","), m3 = A2.evaluate(a3, {}, s2) * f2.textScaleFactor, y3 = f2.layoutTextSize.evaluate(a3, {}, s2) * f2.textScaleFactor, g3 = f2.layoutIconSize.evaluate(a3, {}, s2, h2) * f2.iconScaleFactor, x3 = { horizontal: {}, vertical: void 0 }, v3 = a3.text;
            let b3, S2 = [0, 0];
            if (v3) {
              const n3 = v3.toString(), u3 = p2.get("text-letter-spacing").evaluate(a3, {}, s2) * Mg, c3 = p2.get("text-line-height").evaluate(a3, {}, s2) * Mg, h3 = Ta(n3) ? u3 : 0, d3 = p2.get("text-anchor").evaluate(a3, {}, s2), f3 = p2.get("text-variable-anchor");
              if (!f3) {
                const t3 = p2.get("text-radial-offset").evaluate(a3, {}, s2);
                if (t3) S2 = Yx(d3, [t3 * Mg, Hx]);
                else {
                  const t4 = p2.get("text-offset").evaluate(a3, {}, s2);
                  S2 = [t4[0] * Mg, t4[1] * Mg];
                }
              }
              let g4 = _2 ? "center" : p2.get("text-justify").evaluate(a3, {}, s2);
              const b4 = "point" === w2, A3 = b4 ? p2.get("text-max-width").evaluate(a3, {}, s2) * Mg : 1 / 0, M3 = (s3) => {
                t2.allowVerticalPlacement && ka(n3) && (x3.vertical = Yg(v3, e2, r2, i2, o3, A3, c3, d3, s3, h3, S2, Hg.vertical, true, y3, m3, l2));
              };
              if (!_2 && f3) {
                const t3 = "auto" === g4 ? f3.map((t4) => uv(t4)) : [g4];
                let n4 = false;
                for (let s3 = 0; s3 < t3.length; s3++) {
                  const a4 = t3[s3];
                  if (!x3.horizontal[a4]) if (n4) x3.horizontal[a4] = x3.horizontal[0];
                  else {
                    const t4 = Yg(v3, e2, r2, i2, o3, A3, c3, "center", a4, h3, S2, Hg.horizontal, false, y3, m3, l2);
                    t4 && (x3.horizontal[a4] = t4, n4 = 1 === t4.positionedLines.length);
                  }
                }
                M3("left");
              } else {
                if ("auto" === g4 && (g4 = uv(d3)), b4 || p2.get("text-writing-mode").indexOf("horizontal") >= 0 || !ka(n3)) {
                  const t3 = Yg(v3, e2, r2, i2, o3, A3, c3, d3, g4, h3, S2, Hg.horizontal, false, y3, m3, l2);
                  t3 && (x3.horizontal[g4] = t3);
                }
                M3(b4 ? "left" : g4);
              }
            }
            let P2, z2, B2, k2, T2, V2, E2 = false;
            const F2 = p2.get("icon-text-fit").evaluate(a3, {}, s2);
            if (a3.icon && a3.icon.hasPrimary()) {
              const e3 = iv(a3.icon, t2.iconSizeData, d2["icon-size"], s2, t2.zoom, a3, l2, f2.iconScaleFactor, c2, h2);
              P2 = e3.iconPrimary, B2 = e3.iconSecondary;
              const r3 = P2.toString();
              if (z2 = n2.get(r3), z2 && (T2 = p2.get("icon-offset").evaluate(a3, {}, s2), V2 = p2.get("icon-anchor").evaluate(a3, {}, s2), b3 = ox(i2.get(r3), B2 ? i2.get(B2.toString()) : void 0, T2, V2), E2 = z2.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = z2.sdf : t2.sdfIcons !== z2.sdf && Zt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (z2.pixelRatio !== t2.pixelRatio || 0 !== p2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true)), B2) {
                const t3 = B2.toString();
                k2 = n2.get(t3);
              }
            }
            M2 = M2 || !(!a3.icon || !a3.icon.hasSecondary());
            const D2 = gv(x3.horizontal) || x3.vertical;
            t2.iconsInText || (t2.iconsInText = !!D2 && D2.iconsInText);
            const C2 = y3 * f2.textScaleFactor / Mg, { defaultShapedIcon: R2, verticallyShapedIcon: L2 } = cv(t2, b3, p2, a3, s2, x3, C2, T2, F2);
            "none" !== F2 && b3 && (ux(b3) || cx(b3)) && (rv(0, z2, P2, b3, R2, F2, u2, n2, i2), rv(0, k2, B2, b3, R2, F2, u2, n2, i2), L2 && (rv(0, z2, P2, b3, L2, F2, u2, n2, i2), rv(0, k2, B2, b3, L2, F2, u2, n2, i2))), b3 = R2;
            const { iconBBox: O2, iconVerticalBBox: U2, textBBox: N2, textVerticalBBox: j2 } = Jx(t2, b3, L2, p2, a3, s2, g3, T2, f2, i2, V2, x3, y3, S2, h2);
            I2.push({ feature: a3, shapedTextOrientations: x3, shapedText: D2, shapedIcon: b3, iconPrimary: P2, iconSecondary: B2, iconOffset: T2, iconAnchor: V2, verticallyShapedIcon: L2, layoutTextSize: y3, layoutIconSize: g3, textOffset: S2, isSDFIcon: E2, iconTextFit: F2, iconCollisionBounds: O2, iconVerticalCollisionBounds: U2, textCollisionBounds: N2, textVerticalCollisionBounds: j2 });
          }
          return { featureData: I2, sizes: f2, hasAnySecondaryIcon: M2, textAlongLine: _2, symbolPlacement: w2 };
        }, t.fx = Px, t.fy = function(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          t2.iconAtlasPositions = u2.iconPositions;
          const { featureData: c2, hasAnySecondaryIcon: h2, sizes: p2, textAlongLine: d2, symbolPlacement: f2 } = e2;
          for (const e3 of c2) {
            const { shapedIcon: r3, verticallyShapedIcon: s3, feature: c3, shapedTextOrientations: m2, shapedText: y2, layoutTextSize: g2, textOffset: x2, isSDFIcon: v2, iconPrimary: b2, iconSecondary: w2, iconTextFit: _2, iconOffset: A2, iconCollisionBounds: M2, iconVerticalCollisionBounds: I2, textCollisionBounds: S2 } = e3;
            av(r3, u2.iconPositions, b2, w2), av(s3, u2.iconPositions, b2, w2), ov(m2, u2.iconPositions), sv(b2, w2, u2.iconPositions), (y2 || r3) && pv(t2, c3, m2, r3, s3, l2, p2, g2, 0, x2, v2, n2, i2, a2, o2, h2, _2, A2, d2, f2, M2, I2, S2);
          }
          r2 && t2.generateCollisionDebugBuffers(s2, t2.collisionBoxArray, p2.textScaleFactor);
        }, t.fz = ic, t.g = function(t2, e2) {
          return Oe(Object.assign(t2, { method: "GET" }), e2);
        }, t.h = function(t2) {
          return 0 === t2.indexOf("mapbox:");
        }, t.i = function(t2) {
          return oe.API_STYLE_REGEX.test(t2) && !ue(t2);
        }, t.j = le, t.k = Be, t.l = function(t2) {
          return decodeURIComponent(atob(t2).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join(""));
        }, t.m = function(t2, e2) {
          return Oe(Object.assign(t2, { type: "json" }), e2);
        }, t.n = qe, t.o = ge, t.p = function(t2, e2) {
          return Oe(Object.assign(t2, { method: "POST" }), e2);
        }, t.q = Xh, t.r = ye, t.s = function(t2) {
          try {
            const e2 = self[t2];
            return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
          } catch (t3) {
            return false;
          }
        }, t.t = function() {
          return Yf || (Yf = new Hf("ImageRasterizer")), Yf;
        }, t.u = function() {
          return function t2(e2) {
            return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
          }();
        }, t.v = function(t2) {
          return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
        }, t.w = Zt, t.x = $w, t.y = er, t.z = tr;
      });
      define2(["./shared"], function(e) {
        function t(e2) {
          const t2 = e2 ? e2.url.toString() : void 0;
          return t2 ? performance.getEntriesByName(t2) : [];
        }
        function s(e2) {
          if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2) return JSON.stringify(e2);
          if (Array.isArray(e2)) {
            let t3 = "[";
            for (const i2 of e2) t3 += `${s(i2)},`;
            return `${t3}]`;
          }
          let t2 = "{";
          for (const i2 of Object.keys(e2).sort()) t2 += `${i2}:${s(e2[i2])},`;
          return `${t2}}`;
        }
        function i(t2) {
          let i2 = "";
          for (const o2 of e.bx) i2 += `/${s(t2[o2])}`;
          return i2;
        }
        function o(e2, t2) {
          return function e3(s2) {
            return "string" == typeof s2 && s2 === t2 || (Array.isArray(s2) ? s2.some(e3) : !(!s2 || "object" != typeof s2) && Object.values(s2).some(e3));
          }(e2);
        }
        class n {
          constructor(e2) {
            this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e2 && this.replace(e2);
          }
          replace(e2, t2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, [], t2);
          }
          update(t2, n2, r2) {
            this._options = r2;
            for (const s2 of t2) this._layerConfigs[s2.id] = s2, (this._layers[s2.id] = e.du(s2, this.scope, null, this._options)).compileFilter(r2), this.keyCache[s2.id] && delete this.keyCache[s2.id];
            for (const e2 of n2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const a2 = function(e2, t3) {
              const n3 = {};
              for (let r4 = 0; r4 < e2.length; r4++) {
                const a3 = e2[r4];
                let l2 = t3 && t3[a3.id];
                l2 || ("symbol" === a3.type ? l2 = a3.id : (l2 = i(a3), "line" === a3.type && a3.paint && o(a3.paint["line-width"], "line-progress") && (l2 += `/${s(a3.paint["line-width"])}`))), t3 && (t3[a3.id] = l2);
                let c2 = n3[l2];
                c2 || (c2 = n3[l2] = []), c2.push(a3);
              }
              const r3 = [];
              for (const e3 in n3) r3.push(n3[e3]);
              return r3;
            }(Object.values(this._layerConfigs), this.keyCache);
            for (const e2 of a2) {
              const t3 = e2.map((e3) => this._layers[e3.id]), s2 = t3[0];
              if ("none" === s2.visibility) continue;
              const i2 = s2.source || "";
              let o2 = this.familiesBySource[i2];
              o2 || (o2 = this.familiesBySource[i2] = {});
              const n3 = s2.sourceLayer || "_geojsonTileLayer";
              let r3 = o2[n3];
              r3 || (r3 = o2[n3] = []), r3.push(t3);
            }
          }
        }
        const r = 1 * e.fl;
        class a {
          constructor(t2) {
            const s2 = {}, i2 = [];
            for (const e2 in t2) {
              const o3 = t2[e2], n3 = s2[e2] = {};
              for (const e3 in o3.glyphs) {
                const t3 = o3.glyphs[+e3];
                if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
                const s3 = t3.metrics.localGlyph ? r : 1, a3 = { x: 0, y: 0, w: t3.bitmap.width + 2 * s3, h: t3.bitmap.height + 2 * s3 };
                i2.push(a3), n3[e3] = a3;
              }
            }
            const { w: o2, h: n2 } = e.G(i2), a2 = new e.fk({ width: o2 || 1, height: n2 || 1 });
            for (const i3 in t2) {
              const o3 = t2[i3];
              for (const t3 in o3.glyphs) {
                const n3 = o3.glyphs[+t3];
                if (!n3 || 0 === n3.bitmap.width || 0 === n3.bitmap.height) continue;
                const l2 = s2[i3][t3], c2 = n3.metrics.localGlyph ? r : 1;
                e.fk.copy(n3.bitmap, a2, { x: 0, y: 0 }, { x: l2.x + c2, y: l2.y + c2 }, n3.bitmap);
              }
            }
            this.image = a2, this.positions = s2;
          }
        }
        function l(e2, t2, s2) {
          e2[t2] ? s2 && (e2[t2].center = s2) : e2[t2] = { floorIds: /* @__PURE__ */ new Set(), center: s2 || [0, 0], floors: {} };
        }
        function c(e2, t2, s2, i2) {
          for (const o2 of t2) l(e2, o2), e2[o2].floors[s2] = i2, e2[o2].floorIds.add(s2);
        }
        function h(e2) {
          return { id: e2.properties.id.toString(), center: e2.properties.center.toString().split(";").map(Number) };
        }
        function u(e2) {
          return { id: e2.properties.id.toString(), isDefault: !!e2.properties.is_default && e2.properties.is_default, connections: e2.properties.connected_floor_ids ? new Set(e2.properties.connected_floor_ids.toString().split(";")) : /* @__PURE__ */ new Set(), conflicts: e2.properties.conflicted_floor_ids ? new Set(e2.properties.conflicted_floor_ids.toString().split(";")) : /* @__PURE__ */ new Set(), buildings: e2.properties.building_ids ? new Set(e2.properties.building_ids.toString().split(";")) : /* @__PURE__ */ new Set(), name: e2.properties.name.toString(), zIndex: e2.properties.z_index };
        }
        function d(e2, t2) {
          return t2.every((t3) => e2.properties && null != e2.properties[t3]);
        }
        function f(e2) {
          return d(e2, ["type", "id", "name"]) && "building" === e2.properties.type;
        }
        function p(e2) {
          return d(e2, ["type", "id", "name", "z_index"]) && "floor" === e2.properties.type;
        }
        e.fj(a, "GlyphAtlas");
        class g {
          constructor(t2) {
            this.tileID = new e.aQ(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.lut = t2.lut, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.scope = t2.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.request && t2.request.collectResourceTiming, this.promoteId = t2.promoteId, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = e.aZ(t2.tileID.canonical, t2.projection), this.projection = t2.projection, this.worldview = t2.worldview, this.localizableLayerIds = t2.localizableLayerIds, this.brightness = t2.brightness, this.extraShadowCaster = !!t2.extraShadowCaster, this.tessellationStep = t2.tessellationStep, this.scaleFactor = t2.scaleFactor, this.worldview = t2.worldview, this.indoor = t2.indoor;
          }
          parse(t2, s2, i2, o2, n2, r2) {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.b3();
            const d2 = new e.fm(Object.keys(t2.layers).sort()), g2 = new e.fn(this.tileID, this.promoteId);
            g2.bucketLayerIDs = [];
            const y2 = {}, w2 = new e.fo(256, 256), b2 = { featureIndex: g2, iconDependencies: /* @__PURE__ */ new Map(), patternDependencies: /* @__PURE__ */ new Map(), glyphDependencies: {}, lineAtlas: w2, availableImages: i2, brightness: this.brightness, scaleFactor: this.scaleFactor, elevationFeatures: void 0, activeFloors: void 0 };
            if (this.indoor) {
              const s3 = this.indoor.indoorState.activeFloorsVisible, i3 = function(t3, s4, i4) {
                const o3 = function(t4, s5) {
                  if (!t4) return e.w("No source layers defined in indoor specification"), s5;
                  if (0 === t4.size) return s5;
                  const i5 = t4.difference(s5);
                  for (const t5 of i5) e.w(`Missing source layer required in indoor specification: ${t5}`);
                  return s5.intersection(s5);
                }(s4.sourceLayers, new Set(Object.keys(t3.layers))), n3 = s4.indoorState, r3 = function(t4, s5, i5, o4) {
                  const n4 = /* @__PURE__ */ new Set(), r4 = /* @__PURE__ */ new Set(), a2 = /* @__PURE__ */ new Set(), d3 = /* @__PURE__ */ new Map(), g3 = {}, m2 = (e2) => {
                    const t5 = d3.get(e2) || /* @__PURE__ */ new Set();
                    for (const s6 of n4) if ((d3.get(s6) || /* @__PURE__ */ new Set()).has(e2) || t5.has(s6)) return true;
                    return false;
                  };
                  for (const i6 of s5) {
                    const s6 = t4.layers[i6];
                    if (s6) for (let e2 = 0; e2 < s6.length; e2++) {
                      const t5 = s6.feature(e2);
                      if (f(t5)) {
                        const { id: e3, center: s7 } = h(t5);
                        l(g3, e3, s7), n4.add(e3);
                        continue;
                      }
                      if (p(t5)) {
                        const { id: e3, isDefault: s7, connections: i7, conflicts: l2, buildings: h2, name: f2, zIndex: p2 } = u(t5);
                        c(g3, h2, e3, { name: f2, zIndex: p2 }), d3.set(e3, l2), (e3 === o4 || i7.has(o4)) && n4.add(e3), r4.add(e3), s7 && a2.add(e3);
                      }
                    }
                    else e.w(`indoor source layer not found: ${i6}`);
                  }
                  if (i5) for (const e2 of i5) r4.has(e2) && (m2(e2) || n4.add(e2));
                  for (const e2 of a2) n4.has(e2) || m2(e2) || n4.add(e2);
                  return { buildings: g3, activeFloors: n4 };
                }(t3, o3, n3.lastActiveFloors, n3.selectedFloorId);
                return i4.send("setIndoorData", r3), r3;
              }(t2, this.indoor, n2);
              b2.activeFloors = s3 ? i3.activeFloors : void 0;
            }
            const x2 = [], v2 = s2.familiesBySource[this.source];
            for (const s3 in v2) {
              const n3 = t2.layers[s3];
              if (!n3) continue;
              let r3 = false, a2 = false, l2 = false;
              for (const e2 of v2[s3]) "symbol" === e2[0].type ? r3 = true : a2 = true, e2[0].is3D() && "model" !== e2[0].type && (l2 = true);
              if (this.extraShadowCaster && !l2) continue;
              if (true === this.isSymbolTile && !r3) continue;
              if (false === this.isSymbolTile && !a2) continue;
              1 === n3.version && e.w(`Vector tile source "${this.source}" layer "${s3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const c2 = d2.encode(s3), h2 = [], u2 = this.localizableLayerIds && this.localizableLayerIds.has(s3);
              let f2 = false;
              for (let t3 = 0, i3 = 0; t3 < n3.length; t3++) {
                const o3 = n3.feature(t3), r4 = g2.getId(o3, s3), a3 = o3.properties ? o3.properties.worldview : null;
                if (u2 && this.worldview && "string" == typeof a3) if ("all" === a3) o3.properties.$localized = true;
                else {
                  if (!a3.split(",").includes(this.worldview)) continue;
                  o3.properties.$localized = true, o3.properties.worldview = this.worldview;
                }
                !f2 && o3.properties && o3.properties.hasOwnProperty(e.fp) && (f2 = true), h2.push({ feature: o3, id: r4, index: i3, sourceLayerIndex: c2 }), i3++;
              }
              f2 && !b2.elevationFeatures && t2.layers.hasOwnProperty(e.fq) && (b2.elevationFeatures = e.fr.parseFrom(t2.layers[e.fq], this.canonical));
              for (const t3 of v2[s3]) {
                const s4 = t3[0];
                if (this.extraShadowCaster && (!s4.is3D() || "model" === s4.type)) continue;
                if (void 0 !== this.isSymbolTile && "symbol" === s4.type !== this.isSymbolTile) continue;
                if (s4.minzoom && this.zoom < Math.floor(s4.minzoom)) continue;
                if (s4.maxzoom && this.zoom >= s4.maxzoom) continue;
                if ("none" === s4.visibility) continue;
                m(t3, this.zoom, b2.brightness, i2, this.worldview);
                const n4 = y2[s4.id] = s4.createBucket({ index: g2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: c2, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep, styleDefinedModelURLs: o2, worldview: this.worldview, localizable: u2, availableImages: i2 });
                g2.bucketLayerIDs.push(t3.map((t4) => e.B(t4.id, t4.scope)));
                let r4 = n4.prepare ? n4.prepare() : null;
                null != r4 ? (r4 = r4.then(() => n4.populate(h2, b2, this.tileID.canonical, this.tileTransform)), x2.push(r4)) : n4.populate(h2, b2, this.tileID.canonical, this.tileTransform);
              }
            }
            const I2 = () => {
              let s3, o3, l2, c2, h2, u2;
              w2.trim();
              const f2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, p2 = () => {
                if (s3) return this.status = "done", r2(s3);
                if (this.extraShadowCaster) this.status = "done", r2(null, { buckets: Object.values(y2).filter((e2) => !e2.isEmpty()), featureIndex: g2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: b2.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
                else if (o3 && l2 && c2) {
                  const t3 = new a(o3), s4 = /* @__PURE__ */ new Map();
                  for (const [t4, i3] of l2.entries()) {
                    const { imagePosition: o4 } = e.fu(t4, i3, e.fv);
                    s4.set(t4, o4);
                  }
                  const r3 = {};
                  for (const n3 in y2) {
                    const a2 = y2[n3];
                    a2 instanceof e.b4 && (m(a2.layers, this.zoom, b2.brightness, i2, this.worldview), r3[n3] = e.fw(a2, o3, t3.positions, l2, s4, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, h2, this.worldview, i2));
                  }
                  const d3 = { iconsPending: true, patternsPending: true };
                  this.rasterizeIfNeeded(n2, l2, h2, () => {
                    d3.iconsPending = false, x3(r3, t3, d3);
                  }), this.rasterizeIfNeeded(n2, c2, u2, () => {
                    d3.patternsPending = false, x3(r3, t3, d3);
                  });
                }
              }, x3 = (t3, s4, o4, n3) => {
                if (o4.iconsPending || o4.patternsPending) return;
                const a2 = new e.fx(l2, c2, this.lut);
                for (const s5 in y2) {
                  const o5 = y2[s5];
                  if (s5 in t3) e.fy(o5, t3[s5], this.showCollisionBoxes, i2, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, l2, a2);
                  else if (o5.hasPattern && (o5 instanceof e.ba || o5 instanceof e.bb || o5 instanceof e.ea)) {
                    m(o5.layers, this.zoom, b2.brightness, i2, this.worldview);
                    const e2 = Object.fromEntries(a2.patternPositions);
                    o5.addFeatures(b2, this.tileID.canonical, e2, i2, this.tileTransform, this.brightness);
                  }
                }
                this.status = "done", r2(null, { buckets: Object.values(y2).filter((e2) => !e2.isEmpty()), featureIndex: g2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: s4.image, lineAtlas: w2, imageAtlas: a2, brightness: b2.brightness });
              };
              if (!this.extraShadowCaster) {
                const t3 = e.fs(b2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
                Object.keys(t3).length ? n2.send("getGlyphs", { uid: this.uid, stacks: t3 }, (e2, t4) => {
                  s3 || (s3 = e2, o3 = t4, p2());
                }, void 0, false, f2) : o3 = {};
                const i3 = Array.from(b2.iconDependencies.keys()).map((t4) => e.I.parse(t4));
                i3.length ? n2.send("getImages", { images: i3, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e2, t4) => {
                  s3 || (s3 = e2, l2 = /* @__PURE__ */ new Map(), h2 = this.updateImageMapAndGetImageTaskQueue(l2, t4, b2.iconDependencies), p2());
                }, void 0, false, f2) : (l2 = /* @__PURE__ */ new Map(), h2 = /* @__PURE__ */ new Map());
                const r3 = Array.from(b2.patternDependencies.keys()).map((t4) => e.I.parse(t4));
                r3.length ? n2.send("getImages", { images: r3, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e2, t4) => {
                  s3 || (s3 = e2, c2 = /* @__PURE__ */ new Map(), u2 = this.updateImageMapAndGetImageTaskQueue(c2, t4, b2.patternDependencies), p2());
                }, void 0, false, f2) : (c2 = /* @__PURE__ */ new Map(), u2 = /* @__PURE__ */ new Map());
              }
              if (b2.elevationFeatures && b2.elevationFeatures.length > 0) {
                const s4 = [];
                for (const t3 of Object.values(y2)) if (t3 instanceof e.bb) {
                  const e2 = t3.getUnevaluatedPortalGraph();
                  e2 && s4.push(e2);
                }
                const i3 = e.ft.evaluate(s4);
                for (const s5 of Object.values(y2)) if (s5 instanceof e.bb) {
                  const e2 = t2.layers[d2.decode(s5.sourceLayerIndex)];
                  s5.setEvaluatedPortalGraph(i3, e2, this.tileID.canonical, b2.availableImages, b2.brightness);
                }
              }
              p2();
            };
            x2.length > 0 ? Promise.allSettled(x2).then(I2).catch(r2) : I2();
          }
          updateParameters(t2) {
            this.scaleFactor = t2.scaleFactor, this.showCollisionBoxes = t2.showCollisionBoxes, this.projection = t2.projection, this.brightness = t2.brightness, this.tileTransform = e.aZ(t2.tileID.canonical, t2.projection), this.extraShadowCaster = t2.extraShadowCaster, this.lut = t2.lut, this.worldview = t2.worldview, this.indoor = t2.indoor;
          }
          rasterizeIfNeeded(e2, t2, s2, i2) {
            Array.from(t2.values()).some((e3) => e3.usvg) ? this.rasterize(e2, t2, s2, i2) : i2();
          }
          updateImageMapAndGetImageTaskQueue(e2, t2, s2) {
            const i2 = /* @__PURE__ */ new Map();
            for (const o2 of t2.keys()) {
              const n2 = s2.get(o2) || [];
              for (const s3 of n2) {
                const o3 = s3.toString(), n3 = t2.get(s3.id.toString());
                n3.usvg ? i2.has(o3) || (i2.set(o3, s3), e2.set(o3, Object.assign({}, n3))) : e2.set(o3, n3);
              }
            }
            return i2;
          }
          rasterize(e2, t2, s2, i2) {
            this.rasterizeTask = e2.send("rasterizeImages", { scope: this.scope, tasks: s2 }, (e3, s3) => {
              if (!e3) for (const [e4, i3] of s3.entries()) {
                const s4 = Object.assign(t2.get(e4), { data: i3 });
                t2.set(e4, s4);
              }
              i2();
            });
          }
          cancelRasterize() {
            this.rasterizeTask && this.rasterizeTask.cancel();
          }
        }
        function m(t2, s2, i2, o2, n2) {
          const r2 = new e.ac(s2, { brightness: i2, worldview: n2 });
          for (const e2 of t2) e2.recalculate(r2, o2);
        }
        class y extends e.E {
          constructor(t2, s2, i2, o2, n2, r2, a2) {
            super(), this.actor = t2, this.layerIndex = s2, this.availableImages = i2, this.availableModels = o2, this.loadVectorData = r2 || e.aL, this.loading = {}, this.loaded = {}, this.deduped = new e.aK(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler, this.brightness = a2;
          }
          loadTile(s2, i2) {
            const o2 = s2.uid, n2 = s2 && s2.request, r2 = n2 && n2.collectResourceTiming, a2 = this.loading[o2] = new g(s2);
            a2.abort = this.loadVectorData(s2, (l2, c2) => {
              const h2 = !this.loading[o2];
              if (delete this.loading[o2], a2.cancelRasterize(), h2 || l2 || !c2) return a2.status = "done", h2 || (this.loaded[o2] = a2), i2(l2);
              const u2 = c2.rawData, d2 = {}, f2 = e.aM(c2.responseHeaders);
              f2 && f2.expires && (d2.expires = f2.expires), f2 && f2.cacheControl && (d2.cacheControl = f2.cacheControl), a2.vectorTile = c2.vectorTile || new e.fz(new e.bt(u2));
              const p2 = () => {
                a2.parse(a2.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (e2, s3) => {
                  if (e2 || !s3) return i2(e2);
                  const o3 = {};
                  if (r2) {
                    const e3 = t(n2);
                    e3.length > 0 && (o3.resourceTiming = JSON.parse(JSON.stringify(e3)));
                  }
                  i2(null, Object.assign({ rawTileData: u2.slice(0), responseHeaders: c2.responseHeaders }, s3, d2, o3));
                });
              };
              this.isSpriteLoaded ? p2() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(p2, { type: "parseTile", isSymbolTile: s2.isSymbolTile, zoom: s2.tileZoom }) : p2();
              }), this.loaded = this.loaded || {}, this.loaded[o2] = a2;
            });
          }
          reloadTile(e2, t2) {
            const s2 = this.loaded, i2 = e2.uid;
            if (s2 && s2[i2]) {
              const o2 = s2[i2];
              o2.updateParameters(e2);
              const n2 = (e3, s3) => {
                const i3 = o2.reloadCallback;
                i3 && (delete o2.reloadCallback, o2.parse(o2.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i3)), t2(e3, s3);
              };
              "parsing" === o2.status ? o2.reloadCallback = n2 : "done" === o2.status && (o2.vectorTile ? o2.parse(o2.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, n2) : n2());
            } else t2(null, void 0);
          }
          abortTile(e2, t2) {
            const s2 = e2.uid, i2 = this.loading[s2];
            i2 && (i2.abort && i2.abort(), delete this.loading[s2]), t2();
          }
          removeTile(e2, t2) {
            const s2 = this.loaded, i2 = e2.uid;
            s2 && s2[i2] && delete s2[i2], t2();
          }
        }
        class w {
          loadTile(t2, s2) {
            const { uid: i2, encoding: o2, rawImageData: n2, padding: r2 } = t2, a2 = ImageBitmap && n2 instanceof ImageBitmap ? this.getImageData(n2, r2) : n2;
            s2(null, new e.fA(i2, a2, o2, r2 < 1));
          }
          reloadTile(e2, t2) {
            t2(null, null);
          }
          abortTile(e2, t2) {
            t2();
          }
          removeTile(e2, t2) {
            t2();
          }
          getImageData(e2, t2) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
            const s2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s2;
          }
        }
        e.bs.setPbf(e.bt);
        class b {
          constructor(t2) {
            this._mrt = new e.bs(t2.partial ? 30 : 1 / 0), this._isHeaderLoaded = false, this.uid = t2.uid, this.tileID = t2.tileID, this.source = t2.source;
          }
          parse(t2, s2) {
            const i2 = this._mrt;
            this.status = "parsing", this._entireBuffer = t2;
            try {
              i2.parseHeader(t2), this._isHeaderLoaded = true;
              const o2 = [];
              for (const s3 in i2.layers) {
                const n2 = i2.getLayer(s3), r2 = n2.getDataRange(n2.getBandList()), a2 = i2.createDecodingTask(r2), l2 = t2.slice(r2.firstByte, r2.lastByte + 1), c2 = e.bs.performDecoding(l2, a2).then((e2) => a2.complete(null, e2)).catch((e2) => a2.complete(e2, null));
                o2.push(c2);
              }
              Promise.allSettled(o2).then(() => s2(null, i2)).catch((e2) => s2(e2));
            } catch (e2) {
              s2(e2);
            }
          }
        }
        class x {
          constructor(e2) {
            this.actor = e2, this.loading = {}, this.loaded = {};
          }
          loadTile(t2, s2) {
            const i2 = t2.uid, o2 = t2.request, n2 = this.loading[i2] = new b(t2), { cancel: r2 } = e.bu(o2, (e2, t3, o3) => {
              const r3 = !this.loading[i2];
              if (delete this.loading[i2], r3 || e2 || !t3) return n2.status = "done", r3 || (this.loaded[i2] = n2), s2(e2);
              n2.parse(t3, (e3, t4) => {
                if (e3 || !t4) return s2(e3);
                s2(null, t4, o3);
              }), this.loaded[i2] = n2;
            });
            n2.abort = r2;
          }
          reloadTile(e2, t2) {
            t2(null, void 0);
          }
          abortTile(e2, t2) {
            const s2 = e2.uid, i2 = this.loading[s2];
            i2 && (i2.abort && i2.abort(), delete this.loading[s2]), t2();
          }
          removeTile(e2, t2) {
            const s2 = e2.uid;
            this.loaded[s2] && delete this.loaded[s2], t2();
          }
          decodeRasterArray(t2, s2) {
            e.bs.performDecoding(t2.buffer, t2.task).then((e2) => s2(null, e2)).catch((e2) => s2(e2));
          }
        }
        const v = e.fB.prototype.toGeoJSON;
        class I {
          constructor(t2) {
            this._feature = t2, this.extent = e.al, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
          }
          loadGeometry() {
            if (1 === this._feature.type) {
              const t2 = [];
              for (const s2 of this._feature.geometry) t2.push([new e.P(s2[0], s2[1])]);
              return t2;
            }
            {
              const t2 = [];
              for (const s2 of this._feature.geometry) {
                const i2 = [];
                for (const t3 of s2) i2.push(new e.P(t3[0], t3[1]));
                t2.push(i2);
              }
              return t2;
            }
          }
          toGeoJSON(e2, t2, s2) {
            return v.call(this, e2, t2, s2);
          }
        }
        class S {
          constructor(t2, s2) {
            this.name = t2, this.extent = e.al, this.length = s2.length, this._jsonFeatures = s2;
          }
          feature(e2) {
            return new I(this._jsonFeatures[e2]);
          }
        }
        class M {
          constructor(t2) {
            this.layers = {}, this.extent = e.al;
            for (const e2 of Object.keys(t2)) this.layers[e2] = new S(e2, t2[e2]);
          }
        }
        const P = 64 / 4096;
        class T {
          constructor() {
            this.features = /* @__PURE__ */ new Map();
          }
          clear() {
            this.features.clear();
          }
          load(e2 = [], t2) {
            for (const s2 of e2) {
              const e3 = s2.id;
              if (null == e3) continue;
              let i2 = this.features.get(e3);
              i2 && this.updateCache(i2, t2), s2.geometry ? (i2 = k(s2), this.updateCache(i2, t2), this.features.set(e3, i2)) : this.features.delete(e3), this.updateCache(i2, t2);
            }
          }
          updateCache(e2, t2) {
            for (const { canonical: s2, uid: i2 } of Object.values(t2)) {
              const { z: o2, x: n2, y: r2 } = s2;
              _(e2, Math.pow(2, o2), n2, r2) && delete t2[i2];
            }
          }
          getTile(e2, t2, s2) {
            const i2 = Math.pow(2, e2), o2 = [];
            for (const e3 of this.features.values()) _(e3, i2, t2, s2) && o2.push(D(e3, i2, t2, s2));
            return { features: o2 };
          }
          getFeatures() {
            return [...this.features.values()];
          }
        }
        function _({ minX: e2, minY: t2, maxX: s2, maxY: i2 }, o2, n2, r2) {
          return e2 < (n2 + 1 + P) / o2 && t2 < (r2 + 1 + P) / o2 && s2 > (n2 - P) / o2 && i2 > (r2 - P) / o2;
        }
        function k(e2) {
          const { id: t2, geometry: s2, properties: i2 } = e2;
          if (!s2) return;
          if ("GeometryCollection" === s2.type) throw new Error("GeometryCollection not supported in dynamic mode.");
          const { type: o2, coordinates: n2 } = s2, r2 = { id: t2, type: 1, geometry: [], tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, a2 = r2.geometry;
          if ("Point" === o2) L(n2, a2, r2);
          else if ("MultiPoint" === o2) for (const e3 of n2) L(e3, a2, r2);
          else if ("LineString" === o2) r2.type = 2, z(n2, a2, r2);
          else if ("MultiLineString" === o2) r2.type = 2, C(n2, a2, r2);
          else if ("Polygon" === o2) r2.type = 3, C(n2, a2, r2, true);
          else {
            if ("MultiPolygon" !== o2) throw new Error("Input data is not a valid GeoJSON object.");
            r2.type = 3;
            for (const e3 of n2) C(e3, a2, r2, true);
          }
          return r2;
        }
        function L([t2, s2], i2, o2) {
          const n2 = e.aF(t2);
          let r2 = e.aJ(s2);
          r2 = r2 < 0 ? 0 : r2 > 1 ? 1 : r2, i2.push(n2, r2), o2.minX = Math.min(o2.minX, n2), o2.minY = Math.min(o2.minY, r2), o2.maxX = Math.max(o2.maxX, n2), o2.maxY = Math.max(o2.maxY, r2);
        }
        function z(e2, t2, s2, i2 = false, o2 = false) {
          const n2 = [];
          for (const t3 of e2) L(t3, n2, s2);
          t2.push(n2), i2 && function(e3, t3) {
            let s3 = 0;
            for (let t4 = 0, i3 = e3.length, o3 = i3 - 2; t4 < i3; o3 = t4, t4 += 2) s3 += (e3[t4] - e3[o3]) * (e3[t4 + 1] + e3[o3 + 1]);
            if (s3 > 0 === t3) for (let t4 = 0, s4 = e3.length; t4 < s4 / 2; t4 += 2) {
              const i3 = e3[t4], o3 = e3[t4 + 1];
              e3[t4] = e3[s4 - 2 - t4], e3[t4 + 1] = e3[s4 - 1 - t4], e3[s4 - 2 - t4] = i3, e3[s4 - 1 - t4] = o3;
            }
          }(n2, o2);
        }
        function C(e2, t2, s2, i2 = false) {
          for (let o2 = 0; o2 < e2.length; o2++) z(e2[o2], t2, s2, i2, 0 === o2);
        }
        function D(t2, s2, i2, o2) {
          const { id: n2, type: r2, geometry: a2, tags: l2 } = t2, c2 = [];
          if (1 === r2) !function(t3, s3, i3, o3, n3) {
            for (let r3 = 0; r3 < t3.length; r3 += 2) {
              const a3 = Math.round(e.al * (t3[r3 + 0] * s3 - i3)), l3 = Math.round(e.al * (t3[r3 + 1] * s3 - o3));
              n3.push([a3, l3]);
            }
          }(a2, s2, i2, o2, c2);
          else if (2 === r2) for (const e2 of a2) j(e2, s2, i2, o2, c2);
          else if (3 === r2) for (const e2 of a2) O(e2, s2, i2, o2, c2);
          return { id: n2, type: r2, geometry: c2, tags: l2 };
        }
        function j(t2, s2, i2, o2, n2) {
          const r2 = -128, a2 = e.al + 128;
          let l2;
          for (let c2 = 0; c2 < t2.length - 2; c2 += 2) {
            let h2 = Math.round(e.al * (t2[c2 + 0] * s2 - i2)), u2 = Math.round(e.al * (t2[c2 + 1] * s2 - o2)), d2 = Math.round(e.al * (t2[c2 + 2] * s2 - i2)), f2 = Math.round(e.al * (t2[c2 + 3] * s2 - o2));
            const p2 = d2 - h2, g2 = f2 - u2;
            h2 < r2 && d2 < r2 || (h2 < r2 ? (u2 += Math.round(g2 * ((r2 - h2) / p2)), h2 = r2) : d2 < r2 && (f2 = u2 + Math.round(g2 * ((r2 - h2) / p2)), d2 = r2), u2 < r2 && f2 < r2 || (u2 < r2 ? (h2 += Math.round(p2 * ((r2 - u2) / g2)), u2 = r2) : f2 < r2 && (d2 = h2 + Math.round(p2 * ((r2 - u2) / g2)), f2 = r2), h2 >= a2 && d2 >= a2 || (h2 >= a2 ? (u2 += Math.round(g2 * ((a2 - h2) / p2)), h2 = a2) : d2 >= a2 && (f2 = u2 + Math.round(g2 * ((a2 - h2) / p2)), d2 = a2), u2 >= a2 && f2 >= a2 || (u2 >= a2 ? (h2 += Math.round(p2 * ((a2 - u2) / g2)), u2 = a2) : f2 >= a2 && (d2 = h2 + Math.round(p2 * ((a2 - u2) / g2)), f2 = a2), l2 && h2 === l2[l2.length - 1][0] && u2 === l2[l2.length - 1][1] || (l2 = [[h2, u2]], n2.push(l2)), l2.push([d2, f2])))));
          }
        }
        function O(t2, s2, i2, o2, n2) {
          const r2 = (i2 - P) / s2, a2 = (o2 - P) / s2, l2 = (i2 + 1 + P) / s2, c2 = (o2 + 1 + P) / s2;
          function h2(e2, t3) {
            let s3 = 0;
            return e2 < r2 ? s3 |= 1 : e2 > l2 && (s3 |= 2), t3 < a2 ? s3 |= 4 : t3 > c2 && (s3 |= 8), s3;
          }
          let u2 = [];
          for (let e2 = 1; e2 <= 8; e2 *= 2) {
            let s3 = t2[t2.length - 2], i3 = t2[t2.length - 1], o3 = !(h2(s3, i3) & e2);
            for (let n3 = 0; n3 < t2.length; n3 += 2) {
              const d3 = t2[n3], f2 = t2[n3 + 1], p2 = !(h2(d3, f2) & e2);
              p2 !== o3 && (8 & e2 ? u2.push(s3 + (d3 - s3) * (c2 - i3) / (f2 - i3), c2) : 4 & e2 ? u2.push(s3 + (d3 - s3) * (a2 - i3) / (f2 - i3), a2) : 2 & e2 ? u2.push(l2, i3 + (f2 - i3) * (l2 - s3) / (d3 - s3)) : 1 & e2 && u2.push(r2, i3 + (f2 - i3) * (r2 - s3) / (d3 - s3))), p2 && u2.push(d3, f2), s3 = d3, i3 = f2, o3 = p2;
            }
            if (!(t2 = u2).length || 8 === e2) break;
            u2 = [];
          }
          const d2 = [];
          for (let t3 = 0; t3 < u2.length; t3 += 2) d2.push([Math.round(e.al * (u2[t3] * s2 - i2)), Math.round(e.al * (u2[t3 + 1] * s2 - o2))]);
          d2.length && n2.push(d2);
        }
        function F({ name: t2, features: s2 }, i2) {
          i2.writeStringField(1, t2), i2.writeVarintField(5, e.al);
          const o2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map(), r2 = { keys: o2, values: n2, feature: null };
          for (const e2 of s2) r2.feature = e2, i2.writeMessage(2, A, r2);
          for (const e2 of o2.keys()) i2.writeStringField(3, e2);
          for (const e2 of n2.keys()) i2.writeMessage(4, R, e2);
        }
        function A(e2, t2) {
          const s2 = e2.feature;
          void 0 !== s2.id && Number.isSafeInteger(+s2.id) && t2.writeVarintField(1, +s2.id), s2.tags && t2.writeMessage(2, Z, e2), t2.writeVarintField(3, s2.type), t2.writeMessage(4, E, s2);
        }
        function Z({ keys: e2, values: t2, feature: s2 }, i2) {
          for (const o2 of Object.keys(s2.tags)) {
            let n2 = s2.tags[o2];
            if (null === n2) continue;
            let r2 = e2.get(o2);
            void 0 === r2 && (r2 = e2.size, e2.set(o2, r2)), i2.writeVarint(r2);
            const a2 = typeof n2;
            "string" !== a2 && "boolean" !== a2 && "number" !== a2 && (n2 = JSON.stringify(n2));
            let l2 = t2.get(n2);
            void 0 === l2 && (l2 = t2.size, t2.set(n2, l2)), i2.writeVarint(l2);
          }
        }
        function B(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function N(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function E(e2, t2) {
          const { geometry: s2, type: i2 } = e2;
          let o2 = 0, n2 = 0;
          if (1 === i2) {
            t2.writeVarint(B(1, s2.length));
            for (const e3 of s2) {
              const s3 = e3[0] - o2, i3 = e3[1] - n2;
              t2.writeVarint(N(s3)), t2.writeVarint(N(i3)), o2 += s3, n2 += i3;
            }
          } else for (const e3 of s2) {
            if (0 === e3.length) continue;
            t2.writeVarint(B(1, 1));
            const s3 = e3.length - (3 === i2 ? 1 : 0);
            for (let i3 = 0; i3 < s3; i3++) {
              1 === i3 && t2.writeVarint(B(2, s3 - 1));
              const r2 = e3[i3][0] - o2, a2 = e3[i3][1] - n2;
              t2.writeVarint(N(r2)), t2.writeVarint(N(a2)), o2 += r2, n2 += a2;
            }
            3 === i2 && t2.writeVarint(B(7, 1));
          }
        }
        function R(e2, t2) {
          const s2 = typeof e2;
          "string" === s2 ? t2.writeStringField(1, e2) : "boolean" === s2 ? t2.writeBooleanField(7, e2) : "number" === s2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        const Y = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, X = Math.fround || (J = new Float32Array(1), (e2) => (J[0] = +e2, J[0]));
        var J;
        class G {
          constructor(e2) {
            this.options = Object.assign(Object.create(Y), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t2, minZoom: s2, maxZoom: i2 } = this.options;
            t2 && console.time("total time");
            const o2 = `prepare ${e2.length} points`;
            t2 && console.time(o2), this.points = e2;
            const n2 = [];
            for (let t3 = 0; t3 < e2.length; t3++) {
              const s3 = e2[t3];
              if (!s3.geometry) continue;
              const [i3, o3] = s3.geometry.coordinates, r3 = X(V(i3)), a2 = X(U(o3));
              n2.push(r3, a2, 1 / 0, t3, -1, 1), this.options.reduce && n2.push(0);
            }
            let r2 = this.trees[i2 + 1] = this._createTree(n2);
            t2 && console.timeEnd(o2);
            for (let e3 = i2; e3 >= s2; e3--) {
              const s3 = +Date.now();
              r2 = this.trees[e3] = this._createTree(this._cluster(r2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, r2.numItems, +Date.now() - s3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let s2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const i2 = Math.max(-90, Math.min(90, e2[1]));
            let o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const n2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360) s2 = -180, o2 = 180;
            else if (s2 > o2) {
              const e3 = this.getClusters([s2, i2, 180, n2], t2), r3 = this.getClusters([-180, i2, o2, n2], t2);
              return e3.concat(r3);
            }
            const r2 = this.trees[this._limitZoom(t2)], a2 = r2.range(V(s2), U(n2), V(o2), U(i2)), l2 = r2.data, c2 = [];
            for (const e3 of a2) {
              const t3 = this.stride * e3;
              c2.push(l2[t3 + 5] > 1 ? H(l2, t3, this.clusterProps) : this.points[l2[t3 + 3]]);
            }
            return c2;
          }
          getChildren(e2) {
            const t2 = this._getOriginId(e2), s2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", o2 = this.trees[s2];
            if (!o2) throw new Error(i2);
            const n2 = o2.data;
            if (t2 * this.stride >= n2.length) throw new Error(i2);
            const r2 = this.options.radius / (this.options.extent * Math.pow(2, s2 - 1)), a2 = o2.within(n2[t2 * this.stride], n2[t2 * this.stride + 1], r2), l2 = [];
            for (const t3 of a2) {
              const s3 = t3 * this.stride;
              n2[s3 + 4] === e2 && l2.push(n2[s3 + 5] > 1 ? H(n2, s3, this.clusterProps) : this.points[n2[s3 + 3]]);
            }
            if (0 === l2.length) throw new Error(i2);
            return l2;
          }
          getLeaves(e2, t2, s2) {
            const i2 = [];
            return this._appendLeaves(i2, e2, t2 = t2 || 10, s2 = s2 || 0, 0), i2;
          }
          getTile(e2, t2, s2) {
            const i2 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), { extent: n2, radius: r2 } = this.options, a2 = r2 / n2, l2 = (s2 - a2) / o2, c2 = (s2 + 1 + a2) / o2, h2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / o2, l2, (t2 + 1 + a2) / o2, c2), i2.data, t2, s2, o2, h2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / o2, l2, 1, c2), i2.data, o2, s2, o2, h2), t2 === o2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / o2, c2), i2.data, -1, s2, o2, h2), h2.features.length ? h2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const s2 = this.getChildren(e2);
              if (t2++, 1 !== s2.length) break;
              e2 = s2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, s2, i2, o2) {
            const n2 = this.getChildren(t2);
            for (const t3 of n2) {
              const n3 = t3.properties;
              if (n3 && n3.cluster ? o2 + n3.point_count <= i2 ? o2 += n3.point_count : o2 = this._appendLeaves(e2, n3.cluster_id, s2, i2, o2) : o2 < i2 ? o2++ : e2.push(t3), e2.length === s2) break;
            }
            return o2;
          }
          _createTree(t2) {
            const s2 = new e.c4(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t2.length; e2 += this.stride) s2.add(t2[e2], t2[e2 + 1]);
            return s2.finish(), s2.data = t2, s2;
          }
          _addTileFeatures(e2, t2, s2, i2, o2, n2) {
            for (const r2 of e2) {
              const e3 = r2 * this.stride, a2 = t2[e3 + 5] > 1;
              let l2, c2, h2;
              if (a2) l2 = $(t2, e3, this.clusterProps), c2 = t2[e3], h2 = t2[e3 + 1];
              else {
                const s3 = this.points[t2[e3 + 3]];
                l2 = s3.properties;
                const [i3, o3] = s3.geometry.coordinates;
                c2 = V(i3), h2 = U(o3);
              }
              const u2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * o2 - s2)), Math.round(this.options.extent * (h2 * o2 - i2))]], tags: l2 };
              let d2;
              d2 = a2 || this.options.generateId ? t2[e3 + 3] : this.points[t2[e3 + 3]].id, void 0 !== d2 && (u2.id = d2), n2.features.push(u2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            const { radius: s2, extent: i2, reduce: o2, minPoints: n2 } = this.options, r2 = s2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
            for (let s3 = 0; s3 < a2.length; s3 += c2) {
              if (a2[s3 + 2] <= t2) continue;
              a2[s3 + 2] = t2;
              const i3 = a2[s3], h2 = a2[s3 + 1], u2 = e2.within(a2[s3], a2[s3 + 1], r2), d2 = a2[s3 + 5];
              let f2 = d2;
              for (const e3 of u2) {
                const s4 = e3 * c2;
                a2[s4 + 2] > t2 && (f2 += a2[s4 + 5]);
              }
              if (f2 > d2 && f2 >= n2) {
                let e3, n3 = i3 * d2, r3 = h2 * d2, p2 = -1;
                const g2 = (s3 / c2 << 5) + (t2 + 1) + this.points.length;
                for (const i4 of u2) {
                  const l3 = i4 * c2;
                  if (a2[l3 + 2] <= t2) continue;
                  a2[l3 + 2] = t2;
                  const h3 = a2[l3 + 5];
                  n3 += a2[l3] * h3, r3 += a2[l3 + 1] * h3, a2[l3 + 4] = g2, o2 && (e3 || (e3 = this._map(a2, s3, true), p2 = this.clusterProps.length, this.clusterProps.push(e3)), o2(e3, this._map(a2, l3)));
                }
                a2[s3 + 4] = g2, l2.push(n3 / f2, r3 / f2, 1 / 0, g2, -1, f2), o2 && l2.push(p2);
              } else {
                for (let e3 = 0; e3 < c2; e3++) l2.push(a2[s3 + e3]);
                if (f2 > 1) for (const e3 of u2) {
                  const s4 = e3 * c2;
                  if (!(a2[s4 + 2] <= t2)) {
                    a2[s4 + 2] = t2;
                    for (let e4 = 0; e4 < c2; e4++) l2.push(a2[s4 + e4]);
                  }
                }
              }
            }
            return l2;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2, s2) {
            if (e2[t2 + 5] > 1) {
              const i3 = this.clusterProps[e2[t2 + 6]];
              return s2 ? Object.assign({}, i3) : i3;
            }
            const i2 = this.points[e2[t2 + 3]].properties, o2 = this.options.map(i2);
            return s2 && o2 === i2 ? Object.assign({}, o2) : o2;
          }
        }
        function H(e2, t2, s2) {
          return { type: "Feature", id: e2[t2 + 3], properties: $(e2, t2, s2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), q(e2[t2 + 1])] } };
          var i2;
        }
        function $(e2, t2, s2) {
          const i2 = e2[t2 + 5], o2 = i2 >= 1e4 ? `${Math.round(i2 / 1e3)}k` : i2 >= 1e3 ? Math.round(i2 / 100) / 10 + "k" : i2, n2 = e2[t2 + 6], r2 = -1 === n2 ? {} : Object.assign({}, s2[n2]);
          return Object.assign(r2, { cluster: true, cluster_id: e2[t2 + 3], point_count: i2, point_count_abbreviated: o2 });
        }
        function V(e2) {
          return e2 / 360 + 0.5;
        }
        function U(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), s2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return s2 < 0 ? 0 : s2 > 1 ? 1 : s2;
        }
        function q(e2) {
          const t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function W(e2, t2, s2, i2) {
          let o2 = i2;
          const n2 = t2 + (s2 - t2 >> 1);
          let r2, a2 = s2 - t2;
          const l2 = e2[t2], c2 = e2[t2 + 1], h2 = e2[s2], u2 = e2[s2 + 1];
          for (let i3 = t2 + 3; i3 < s2; i3 += 3) {
            const t3 = Q(e2[i3], e2[i3 + 1], l2, c2, h2, u2);
            if (t3 > o2) r2 = i3, o2 = t3;
            else if (t3 === o2) {
              const e3 = Math.abs(i3 - n2);
              e3 < a2 && (r2 = i3, a2 = e3);
            }
          }
          o2 > i2 && (r2 - t2 > 3 && W(e2, t2, r2, i2), e2[r2 + 2] = o2, s2 - r2 > 3 && W(e2, r2, s2, i2));
        }
        function Q(e2, t2, s2, i2, o2, n2) {
          let r2 = o2 - s2, a2 = n2 - i2;
          if (0 !== r2 || 0 !== a2) {
            const l2 = ((e2 - s2) * r2 + (t2 - i2) * a2) / (r2 * r2 + a2 * a2);
            l2 > 1 ? (s2 = o2, i2 = n2) : l2 > 0 && (s2 += r2 * l2, i2 += a2 * l2);
          }
          return r2 = e2 - s2, a2 = t2 - i2, r2 * r2 + a2 * a2;
        }
        function K(e2, t2, s2, i2) {
          const o2 = { id: e2 ?? null, type: t2, geometry: s2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2) ee(o2, s2);
          else if ("Polygon" === t2) ee(o2, s2[0]);
          else if ("MultiLineString" === t2) for (const e3 of s2) ee(o2, e3);
          else if ("MultiPolygon" === t2) for (const e3 of s2) ee(o2, e3[0]);
          return o2;
        }
        function ee(e2, t2) {
          for (let s2 = 0; s2 < t2.length; s2 += 3) e2.minX = Math.min(e2.minX, t2[s2]), e2.minY = Math.min(e2.minY, t2[s2 + 1]), e2.maxX = Math.max(e2.maxX, t2[s2]), e2.maxY = Math.max(e2.maxY, t2[s2 + 1]);
        }
        function te(e2, t2, s2, i2) {
          if (!t2.geometry) return;
          const o2 = t2.geometry.coordinates;
          if (o2 && 0 === o2.length) return;
          const n2 = t2.geometry.type, r2 = Math.pow(s2.tolerance / ((1 << s2.maxZoom) * s2.extent), 2);
          let a2 = [], l2 = t2.id;
          if (s2.promoteId ? l2 = t2.properties[s2.promoteId] : s2.generateId && (l2 = i2 || 0), "Point" === n2) se(o2, a2);
          else if ("MultiPoint" === n2) for (const e3 of o2) se(e3, a2);
          else if ("LineString" === n2) ie(o2, a2, r2, false);
          else if ("MultiLineString" === n2) {
            if (s2.lineMetrics) {
              for (const s3 of o2) a2 = [], ie(s3, a2, r2, false), e2.push(K(l2, "LineString", a2, t2.properties));
              return;
            }
            oe(o2, a2, r2, false);
          } else if ("Polygon" === n2) oe(o2, a2, r2, true);
          else {
            if ("MultiPolygon" !== n2) {
              if ("GeometryCollection" === n2) {
                for (const o3 of t2.geometry.geometries) te(e2, { id: l2, geometry: o3, properties: t2.properties }, s2, i2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const e3 of o2) {
              const t3 = [];
              oe(e3, t3, r2, true), a2.push(t3);
            }
          }
          e2.push(K(l2, n2, a2, t2.properties));
        }
        function se(e2, t2) {
          t2.push(ne(e2[0]), re(e2[1]), 0);
        }
        function ie(e2, t2, s2, i2) {
          let o2, n2, r2 = 0;
          for (let s3 = 0; s3 < e2.length; s3++) {
            const a3 = ne(e2[s3][0]), l2 = re(e2[s3][1]);
            t2.push(a3, l2, 0), s3 > 0 && (r2 += i2 ? (o2 * l2 - a3 * n2) / 2 : Math.sqrt(Math.pow(a3 - o2, 2) + Math.pow(l2 - n2, 2))), o2 = a3, n2 = l2;
          }
          const a2 = t2.length - 3;
          t2[2] = 1, W(t2, 0, a2, s2), t2[a2 + 2] = 1, t2.size = Math.abs(r2), t2.start = 0, t2.end = t2.size;
        }
        function oe(e2, t2, s2, i2) {
          for (let o2 = 0; o2 < e2.length; o2++) {
            const n2 = [];
            ie(e2[o2], n2, s2, i2), t2.push(n2);
          }
        }
        function ne(e2) {
          return e2 / 360 + 0.5;
        }
        function re(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), s2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return s2 < 0 ? 0 : s2 > 1 ? 1 : s2;
        }
        function ae(e2, t2, s2, i2, o2, n2, r2, a2) {
          if (i2 /= t2, n2 >= (s2 /= t2) && r2 < i2) return e2;
          if (r2 < s2 || n2 >= i2) return null;
          const l2 = [];
          for (const t3 of e2) {
            const e3 = t3.geometry;
            let n3 = t3.type;
            const r3 = 0 === o2 ? t3.minX : t3.minY, c2 = 0 === o2 ? t3.maxX : t3.maxY;
            if (r3 >= s2 && c2 < i2) {
              l2.push(t3);
              continue;
            }
            if (c2 < s2 || r3 >= i2) continue;
            let h2 = [];
            if ("Point" === n3 || "MultiPoint" === n3) le(e3, h2, s2, i2, o2);
            else if ("LineString" === n3) ce(e3, h2, s2, i2, o2, false, a2.lineMetrics);
            else if ("MultiLineString" === n3) ue(e3, h2, s2, i2, o2, false);
            else if ("Polygon" === n3) ue(e3, h2, s2, i2, o2, true);
            else if ("MultiPolygon" === n3) for (const t4 of e3) {
              const e4 = [];
              ue(t4, e4, s2, i2, o2, true), e4.length && h2.push(e4);
            }
            if (h2.length) {
              if (a2.lineMetrics && "LineString" === n3) {
                for (const e4 of h2) l2.push(K(t3.id, n3, e4, t3.tags));
                continue;
              }
              "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h2.length ? (n3 = "LineString", h2 = h2[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h2.length ? "Point" : "MultiPoint"), l2.push(K(t3.id, n3, h2, t3.tags));
            }
          }
          return l2.length ? l2 : null;
        }
        function le(e2, t2, s2, i2, o2) {
          for (let n2 = 0; n2 < e2.length; n2 += 3) {
            const r2 = e2[n2 + o2];
            r2 >= s2 && r2 <= i2 && de(t2, e2[n2], e2[n2 + 1], e2[n2 + 2]);
          }
        }
        function ce(e2, t2, s2, i2, o2, n2, r2) {
          let a2 = he(e2);
          const l2 = 0 === o2 ? fe : pe;
          let c2, h2, u2 = e2.start;
          for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
            const f3 = e2[d3], p3 = e2[d3 + 1], g3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], w2 = 0 === o2 ? f3 : p3, b2 = 0 === o2 ? m2 : y2;
            let x2 = false;
            r2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(p3 - y2, 2))), w2 < s2 ? b2 > s2 && (h2 = l2(a2, f3, p3, m2, y2, s2), r2 && (a2.start = u2 + c2 * h2)) : w2 > i2 ? b2 < i2 && (h2 = l2(a2, f3, p3, m2, y2, i2), r2 && (a2.start = u2 + c2 * h2)) : de(a2, f3, p3, g3), b2 < s2 && w2 >= s2 && (h2 = l2(a2, f3, p3, m2, y2, s2), x2 = true), b2 > i2 && w2 <= i2 && (h2 = l2(a2, f3, p3, m2, y2, i2), x2 = true), !n2 && x2 && (r2 && (a2.end = u2 + c2 * h2), t2.push(a2), a2 = he(e2)), r2 && (u2 += c2);
          }
          let d2 = e2.length - 3;
          const f2 = e2[d2], p2 = e2[d2 + 1], g2 = 0 === o2 ? f2 : p2;
          g2 >= s2 && g2 <= i2 && de(a2, f2, p2, e2[d2 + 2]), d2 = a2.length - 3, n2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && de(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
        }
        function he(e2) {
          const t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function ue(e2, t2, s2, i2, o2, n2) {
          for (const r2 of e2) ce(r2, t2, s2, i2, o2, n2, false);
        }
        function de(e2, t2, s2, i2) {
          e2.push(t2, s2, i2);
        }
        function fe(e2, t2, s2, i2, o2, n2) {
          const r2 = (n2 - t2) / (i2 - t2);
          return de(e2, n2, s2 + (o2 - s2) * r2, 1), r2;
        }
        function pe(e2, t2, s2, i2, o2, n2) {
          const r2 = (n2 - s2) / (o2 - s2);
          return de(e2, t2 + (i2 - t2) * r2, n2, 1), r2;
        }
        function ge(e2, t2) {
          const s2 = [];
          for (let i2 = 0; i2 < e2.length; i2++) {
            const o2 = e2[i2], n2 = o2.type;
            let r2;
            if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2) r2 = me(o2.geometry, t2);
            else if ("MultiLineString" === n2 || "Polygon" === n2) {
              r2 = [];
              for (const e3 of o2.geometry) r2.push(me(e3, t2));
            } else if ("MultiPolygon" === n2) {
              r2 = [];
              for (const e3 of o2.geometry) {
                const s3 = [];
                for (const i3 of e3) s3.push(me(i3, t2));
                r2.push(s3);
              }
            }
            s2.push(K(o2.id, n2, r2, o2.tags));
          }
          return s2;
        }
        function me(e2, t2) {
          const s2 = [];
          s2.size = e2.size, void 0 !== e2.start && (s2.start = e2.start, s2.end = e2.end);
          for (let i2 = 0; i2 < e2.length; i2 += 3) s2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
          return s2;
        }
        function ye(e2, t2) {
          if (e2.transformed) return e2;
          const s2 = 1 << e2.z, i2 = e2.x, o2 = e2.y;
          for (const n2 of e2.features) {
            const e3 = n2.geometry, r2 = n2.type;
            if (n2.geometry = [], 1 === r2) for (let r3 = 0; r3 < e3.length; r3 += 2) n2.geometry.push(we(e3[r3], e3[r3 + 1], t2, s2, i2, o2));
            else for (let r3 = 0; r3 < e3.length; r3++) {
              const a2 = [];
              for (let n3 = 0; n3 < e3[r3].length; n3 += 2) a2.push(we(e3[r3][n3], e3[r3][n3 + 1], t2, s2, i2, o2));
              n2.geometry.push(a2);
            }
          }
          return e2.transformed = true, e2;
        }
        function we(e2, t2, s2, i2, o2, n2) {
          return [Math.round(s2 * (e2 * i2 - o2)), Math.round(s2 * (t2 * i2 - n2))];
        }
        function be(e2, t2, s2, i2, o2) {
          const n2 = t2 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t2) * o2.extent), r2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: s2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const t3 of e2) xe(r2, t3, n2, o2);
          return r2;
        }
        function xe(e2, t2, s2, i2) {
          const o2 = t2.geometry, n2 = t2.type, r2 = [];
          if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === n2 || "MultiPoint" === n2) for (let t3 = 0; t3 < o2.length; t3 += 3) r2.push(o2[t3], o2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === n2) ve(r2, o2, e2, s2, false, false);
          else if ("MultiLineString" === n2 || "Polygon" === n2) for (let t3 = 0; t3 < o2.length; t3++) ve(r2, o2[t3], e2, s2, "Polygon" === n2, 0 === t3);
          else if ("MultiPolygon" === n2) for (let t3 = 0; t3 < o2.length; t3++) {
            const i3 = o2[t3];
            for (let t4 = 0; t4 < i3.length; t4++) ve(r2, i3[t4], e2, s2, true, 0 === t4);
          }
          if (r2.length) {
            let s3 = t2.tags || null;
            if ("LineString" === n2 && i2.lineMetrics) {
              s3 = {};
              for (const e3 in t2.tags) s3[e3] = t2.tags[e3];
              s3.mapbox_clip_start = o2.start / o2.size, s3.mapbox_clip_end = o2.end / o2.size;
            }
            const a2 = { geometry: r2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: s3 };
            null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
          }
        }
        function ve(e2, t2, s2, i2, o2, n2) {
          const r2 = i2 * i2;
          if (i2 > 0 && t2.size < (o2 ? r2 : i2)) return void (s2.numPoints += t2.length / 3);
          const a2 = [];
          for (let e3 = 0; e3 < t2.length; e3 += 3) (0 === i2 || t2[e3 + 2] > r2) && (s2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), s2.numPoints++;
          o2 && function(e3, t3) {
            let s3 = 0;
            for (let t4 = 0, i3 = e3.length, o3 = i3 - 2; t4 < i3; o3 = t4, t4 += 2) s3 += (e3[t4] - e3[o3]) * (e3[t4 + 1] + e3[o3 + 1]);
            if (s3 > 0 === t3) for (let t4 = 0, s4 = e3.length; t4 < s4 / 2; t4 += 2) {
              const i3 = e3[t4], o3 = e3[t4 + 1];
              e3[t4] = e3[s4 - 2 - t4], e3[t4 + 1] = e3[s4 - 1 - t4], e3[s4 - 2 - t4] = i3, e3[s4 - 1 - t4] = o3;
            }
          }(a2, n2), e2.push(a2);
        }
        const Ie = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class Se {
          constructor(e2, t2) {
            const s2 = (t2 = this.options = function(e3, t3) {
              for (const s3 in t3) e3[s3] = t3[s3];
              return e3;
            }(Object.create(Ie), t2)).debug;
            if (s2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let i2 = function(e3, t3) {
              const s3 = [];
              if ("FeatureCollection" === e3.type) for (let i3 = 0; i3 < e3.features.length; i3++) te(s3, e3.features[i3], t3, i3);
              else te(s3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
              return s3;
            }(e2, t2);
            this.tiles = {}, this.tileCoords = [], s2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
              const s3 = t3.buffer / t3.extent;
              let i3 = e3;
              const o2 = ae(e3, 1, -1 - s3, s3, 0, -1, 2, t3), n2 = ae(e3, 1, 1 - s3, 2 + s3, 0, -1, 2, t3);
              return (o2 || n2) && (i3 = ae(e3, 1, -s3, 1 + s3, 0, -1, 2, t3) || [], o2 && (i3 = ge(o2, 1).concat(i3)), n2 && (i3 = i3.concat(ge(n2, -1)))), i3;
            }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), s2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(e2, t2, s2, i2, o2, n2, r2) {
            const a2 = [e2, t2, s2, i2], l2 = this.options, c2 = l2.debug;
            for (; a2.length; ) {
              i2 = a2.pop(), s2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
              const h2 = 1 << t2, u2 = Me(t2, s2, i2);
              let d2 = this.tiles[u2];
              if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[u2] = be(e2, t2, s2, i2, l2), this.tileCoords.push({ z: t2, x: s2, y: i2 }), c2)) {
                c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, s2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
                const e3 = `z${t2}`;
                this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
              }
              if (d2.source = e2, null == o2) {
                if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints) continue;
              } else {
                if (t2 === l2.maxZoom || t2 === o2) continue;
                if (null != o2) {
                  const e3 = o2 - t2;
                  if (s2 !== n2 >> e3 || i2 !== r2 >> e3) continue;
                }
              }
              if (d2.source = null, 0 === e2.length) continue;
              c2 > 1 && console.time("clipping");
              const f2 = 0.5 * l2.buffer / l2.extent, p2 = 0.5 - f2, g2 = 0.5 + f2, m2 = 1 + f2;
              let y2 = null, w2 = null, b2 = null, x2 = null, v2 = ae(e2, h2, s2 - f2, s2 + g2, 0, d2.minX, d2.maxX, l2), I2 = ae(e2, h2, s2 + p2, s2 + m2, 0, d2.minX, d2.maxX, l2);
              e2 = null, v2 && (y2 = ae(v2, h2, i2 - f2, i2 + g2, 1, d2.minY, d2.maxY, l2), w2 = ae(v2, h2, i2 + p2, i2 + m2, 1, d2.minY, d2.maxY, l2), v2 = null), I2 && (b2 = ae(I2, h2, i2 - f2, i2 + g2, 1, d2.minY, d2.maxY, l2), x2 = ae(I2, h2, i2 + p2, i2 + m2, 1, d2.minY, d2.maxY, l2), I2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * s2, 2 * i2), a2.push(w2 || [], t2 + 1, 2 * s2, 2 * i2 + 1), a2.push(b2 || [], t2 + 1, 2 * s2 + 1, 2 * i2), a2.push(x2 || [], t2 + 1, 2 * s2 + 1, 2 * i2 + 1);
            }
          }
          getTile(e2, t2, s2) {
            e2 = +e2, t2 = +t2, s2 = +s2;
            const i2 = this.options, { extent: o2, debug: n2 } = i2;
            if (e2 < 0 || e2 > 24) return null;
            const r2 = 1 << e2, a2 = Me(e2, t2 = t2 + r2 & r2 - 1, s2);
            if (this.tiles[a2]) return ye(this.tiles[a2], o2);
            n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, s2);
            let l2, c2 = e2, h2 = t2, u2 = s2;
            for (; !l2 && c2 > 0; ) c2--, h2 >>= 1, u2 >>= 1, l2 = this.tiles[Me(c2, h2, u2)];
            return l2 && l2.source ? (n2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, h2, u2), console.time("drilling down")), this.splitTile(l2.source, c2, h2, u2, e2, t2, s2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ye(this.tiles[a2], o2) : null) : null;
          }
        }
        function Me(e2, t2, s2) {
          return 32 * ((1 << e2) * s2 + t2) + e2;
        }
        function Pe(t2, s2) {
          const i2 = t2.tileID.canonical;
          if (!this._geoJSONIndex) return void s2(null, null);
          const o2 = this._geoJSONIndex.getTile(i2.z, i2.x, i2.y);
          if (!o2) return void s2(null, null);
          const n2 = (e2) => e2.tags && "3d_elevation_id" in e2.tags && "source" in e2.tags && "elevation" === e2.tags.source, r2 = o2.features.filter((e2) => n2(e2));
          let a2 = { _geojsonTileLayer: o2.features };
          r2.length > 0 && (a2 = { _geojsonTileLayer: o2.features.filter((e2) => !n2(e2)), hd_road_elevation: r2 });
          const l2 = new M(a2), c2 = function(t3) {
            const s3 = new e.bt();
            for (const e2 of Object.keys(t3)) s3.writeMessage(3, F, { name: e2, features: t3[e2] });
            return s3.finish();
          }(a2).buffer;
          s2(null, { vectorTile: l2, rawData: c2 });
        }
        class Te extends y {
          constructor(e2, t2, s2, i2, o2, n2, r2) {
            super(e2, t2, s2, i2, o2, Pe, r2), n2 && (this.loadGeoJSON = n2), this._dynamicIndex = new T();
          }
          loadData(s2, i2) {
            const o2 = s2 && s2.request, n2 = o2 && o2.collectResourceTiming;
            this._geoJSONIndex = null, this.loadGeoJSON(s2, (r2, a2) => {
              if (r2 || !a2) return i2(r2);
              if ("object" != typeof a2) return i2(new Error(`Input data given to '${s2.source}' is not a valid GeoJSON object.`));
              {
                try {
                  if (s2.filter) {
                    const t2 = e.U(s2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === t2.result) throw new Error(t2.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                    a2.features = a2.features.filter((e2) => t2.value.evaluate({ zoom: 0 }, e2));
                  }
                  s2.dynamic ? ("Feature" === a2.type && (a2 = { type: "FeatureCollection", features: [a2] }), s2.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a2.features, this.loaded), s2.cluster && (a2.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s2.cluster ? new G(function({ superclusterOptions: t2, clusterProperties: s3 }) {
                    if (!s3 || !t2) return t2;
                    const i3 = {}, o3 = {}, n3 = { accumulated: null, zoom: 0 }, r4 = { properties: null }, a3 = Object.keys(s3);
                    for (const t3 of a3) {
                      const [n4, r5] = s3[t3], a4 = e.U(r5), l2 = e.U("string" == typeof n4 ? [n4, ["accumulated"], ["get", t3]] : n4);
                      i3[t3] = a4.value, o3[t3] = l2.value;
                    }
                    return t2.map = (e2) => {
                      r4.properties = e2;
                      const t3 = {};
                      for (const e3 of a3) t3[e3] = i3[e3].evaluate(n3, r4);
                      return t3;
                    }, t2.reduce = (e2, t3) => {
                      r4.properties = t3;
                      for (const t4 of a3) n3.accumulated = e2[t4], e2[t4] = o3[t4].evaluate(n3, r4);
                    }, t2;
                  }(s2)).load(a2.features) : s2.dynamic ? this._dynamicIndex : function(e2, t2) {
                    return new Se(e2, t2);
                  }(a2, s2.geojsonVtOptions);
                } catch (e2) {
                  return i2(e2);
                }
                const r3 = {};
                if (n2) {
                  const e2 = t(o2);
                  e2 && (r3.resourceTiming = {}, r3.resourceTiming[s2.source] = JSON.parse(JSON.stringify(e2)));
                }
                i2(null, r3);
              }
            });
          }
          reloadTile(e2, t2) {
            const s2 = this.loaded;
            return s2 && s2[e2.uid] ? e2.partial ? t2(null, void 0) : super.reloadTile(e2, t2) : this.loadTile(e2, t2);
          }
          loadGeoJSON(t2, s2) {
            if (t2.request) e.m(t2.request, s2);
            else {
              if ("string" != typeof t2.data) return s2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              setTimeout(() => {
                try {
                  return s2(null, JSON.parse(t2.data));
                } catch (e2) {
                  return s2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              }, 0);
            }
          }
          getClusterExpansionZoom(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterChildren(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterLeaves(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t2(e3);
            }
          }
        }
        class _e {
          constructor(t2, s2, i2) {
            this.tileID = new e.aQ(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t2.projection, this.brightness = s2, this.worldview = i2;
          }
          parse(t2, s2, i2, o2) {
            this.status = "parsing";
            const n2 = new e.aQ(i2.tileID.overscaledZ, i2.tileID.wrap, i2.tileID.canonical.z, i2.tileID.canonical.x, i2.tileID.canonical.y), r2 = [], a2 = s2.familiesBySource[i2.source], l2 = new e.fn(n2, i2.promoteId);
            l2.bucketLayerIDs = [], l2.is3DTile = true, e.fC(t2).then((t3) => {
              if (!t3) return o2(new Error("Could not parse tile"));
              const s3 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("MAPBOX_mesh_features") || t3.json.asset.extras && t3.json.asset.extras.MAPBOX_mesh_features, c2 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("EXT_meshopt_compression"), h2 = new e.ac(this.zoom, { brightness: this.brightness, worldview: this.worldview });
              for (const o3 in a2) for (const u2 of a2[o3]) {
                const o4 = u2[0];
                l2.bucketLayerIDs.push(u2.map((t4) => e.B(t4.id, t4.scope))), o4.recalculate(h2, []);
                const a3 = e.fD(t3, 1 / e.d7(i2.tileID.canonical)), d2 = new e.fE(u2, a3, n2, s3, c2, this.brightness, l2, this.worldview);
                s3 || (d2.needsUpload = true), r2.push(d2), d2.evaluate(o4);
              }
              this.status = "done", o2(null, { buckets: r2, featureIndex: l2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
            }).catch((e2) => o2(new Error(e2.message)));
          }
        }
        class ke {
          constructor(e2, t2, s2, i2, o2, n2, r2, a2) {
            this.actor = e2, this.layerIndex = t2, this.availableImages = s2, this.availableModels = i2, this.brightness = r2, this.loading = {}, this.loaded = {}, this.worldview = a2;
          }
          loadTile(t2, s2) {
            const i2 = t2.uid, o2 = this.loading[i2] = new _e(t2, this.brightness, this.worldview);
            e.bu(t2.request, (e2, n2) => {
              const r2 = !this.loading[i2];
              return delete this.loading[i2], r2 || e2 ? (o2.status = "done", r2 || (this.loaded[i2] = o2), s2(e2)) : n2 && 0 !== n2.byteLength ? void o2.parse(n2, this.layerIndex, t2, (e3, t3) => {
                o2.status = "done", this.loaded = this.loaded || {}, this.loaded[i2] = o2, e3 || !t3 ? s2(e3) : s2(null, t3);
              }) : (o2.status = "done", this.loaded[i2] = o2, s2());
            });
          }
          reloadTile(e2, t2) {
            const s2 = this.loaded, i2 = e2.uid;
            if (s2 && s2[i2]) {
              const o2 = s2[i2];
              o2.projection = e2.projection, o2.brightness = e2.brightness;
              const n2 = (s3, i3) => {
                o2.reloadCallback && (delete o2.reloadCallback, this.loadTile(e2, t2)), t2(s3, i3);
              };
              "parsing" === o2.status ? o2.reloadCallback = n2 : "done" === o2.status && this.loadTile(e2, t2);
            }
          }
          abortTile(e2, t2) {
            const s2 = e2.uid;
            this.loading[s2] && delete this.loading[s2], t2();
          }
          removeTile(e2, t2) {
            const s2 = this.loaded, i2 = e2.uid;
            s2 && s2[i2] && delete s2[i2], t2();
          }
        }
        class Le {
          constructor(t2) {
            this.self = t2, this.actor = new e.fG(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.x(), this.rtlPluginParsingListeners = [], this.projections = {}, this.defaultProjection = e.cm({ name: "mercator" }), this.workerSourceTypes = { vector: y, geojson: Te, "raster-dem": w, "raster-array": x, "batched-model": ke }, this.workerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
              if (this.workerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
              this.workerSourceTypes[e2] = t3;
            }, this.self.registerRTLTextPlugin = (t3) => {
              if (e.fH.isParsed()) throw new Error("RTL text plugin already registered.");
              e.fH.setState({ pluginStatus: e.fI.parsed, pluginURL: e.fH.getPluginURL() }), e.fH.applyArabicShaping = t3.applyArabicShaping, e.fH.processBidirectionalText = t3.processBidirectionalText, e.fH.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              for (const e2 of this.rtlPluginParsingListeners) e2(null, true);
              this.rtlPluginParsingListeners = [];
            };
          }
          clearCaches(e2, t2, s2) {
            delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.availableModels[e2], delete this.workerSources[e2], s2();
          }
          checkIfReady(e2, t2, s2) {
            s2();
          }
          setReferrer(e2, t2) {
            this.referrer = t2;
          }
          spriteLoaded(t2, s2) {
            this.isSpriteLoaded[t2] || (this.isSpriteLoaded[t2] = {});
            const { scope: i2, isLoaded: o2 } = s2;
            if (this.isSpriteLoaded[t2][i2] = o2, this.workerSources[t2] && this.workerSources[t2][i2]) for (const s3 in this.workerSources[t2][i2]) {
              const n2 = this.workerSources[t2][i2][s3];
              for (const t3 in n2) {
                const s4 = n2[t3];
                s4 instanceof y && (s4.isSpriteLoaded = o2, s4.fire(new e.z("isSpriteLoaded")));
              }
            }
          }
          setImages(e2, t2, s2) {
            this.availableImages[e2] || (this.availableImages[e2] = {});
            const { scope: i2, images: o2 } = t2;
            if (this.availableImages[e2][i2] = o2, this.workerSources[e2] && this.workerSources[e2][i2]) {
              for (const t3 in this.workerSources[e2][i2]) {
                const s3 = this.workerSources[e2][i2][t3];
                for (const e3 in s3) s3[e3].availableImages = o2;
              }
              s2();
            } else s2();
          }
          setModels(e2, { scope: t2, models: s2 }, i2) {
            if (this.availableModels[e2] || (this.availableModels[e2] = {}), this.availableModels[e2][t2] = s2, this.workerSources[e2] && this.workerSources[e2][t2]) {
              for (const i3 in this.workerSources[e2][t2]) {
                const o2 = this.workerSources[e2][t2][i3];
                for (const e3 in o2) o2[e3].availableModels = s2;
              }
              i2();
            } else i2();
          }
          setProjection(t2, s2) {
            this.projections[t2] = e.cm(s2);
          }
          setBrightness(e2, t2, s2) {
            this.brightness = t2, s2();
          }
          setWorldview(e2, t2, s2) {
            this.worldview = t2, s2();
          }
          setLayers(e2, t2, s2) {
            this.getLayerIndex(e2, t2.scope).replace(t2.layers, t2.options), s2();
          }
          updateLayers(e2, t2, s2) {
            this.getLayerIndex(e2, t2.scope).update(t2.layers, t2.removedIds, t2.options), s2();
          }
          loadTile(e2, t2, s2) {
            t2.projection = this.projections[e2] || this.defaultProjection, this.getWorkerSource(e2, t2.type, t2.source, t2.scope).loadTile(t2, s2);
          }
          decodeRasterArray(e2, t2, s2) {
            this.getWorkerSource(e2, t2.type, t2.source, t2.scope).decodeRasterArray(t2, s2);
          }
          reloadTile(e2, t2, s2) {
            t2.projection = this.projections[e2] || this.defaultProjection, this.getWorkerSource(e2, t2.type, t2.source, t2.scope).reloadTile(t2, s2);
          }
          abortTile(e2, t2, s2) {
            this.getWorkerSource(e2, t2.type, t2.source, t2.scope).abortTile(t2, s2);
          }
          removeTile(e2, t2, s2) {
            this.getWorkerSource(e2, t2.type, t2.source, t2.scope).removeTile(t2, s2);
          }
          removeSource(e2, t2, s2) {
            if (!(this.workerSources[e2] && this.workerSources[e2][t2.scope] && this.workerSources[e2][t2.scope][t2.type] && this.workerSources[e2][t2.scope][t2.type][t2.source])) return;
            const i2 = this.workerSources[e2][t2.scope][t2.type][t2.source];
            delete this.workerSources[e2][t2.scope][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, s2) : s2();
          }
          loadWorkerSource(e2, t2, s2) {
            try {
              this.self.importScripts(t2.url), s2();
            } catch (e3) {
              s2(e3);
            }
          }
          syncRTLPluginState(t2, s2, i2) {
            if (e.fH.isParsed()) i2(null, true);
            else if (e.fH.isParsing()) this.rtlPluginParsingListeners.push(i2);
            else try {
              e.fH.setState(s2);
              const t3 = e.fH.getPluginURL();
              !e.fH.isLoaded() || e.fH.isParsed() || e.fH.isParsing() || null == t3 || (e.fH.setState({ pluginStatus: e.fI.parsing, pluginURL: e.fH.getPluginURL() }), this.self.importScripts(t3), e.fH.isParsed() ? i2(null, true) : this.rtlPluginParsingListeners.push(i2));
            } catch (e2) {
              i2(e2);
            }
          }
          setDracoUrl(e2, t2) {
            this.dracoUrl = t2;
          }
          getAvailableImages(e2, t2) {
            this.availableImages[e2] || (this.availableImages[e2] = {});
            let s2 = this.availableImages[e2][t2];
            return s2 || (s2 = []), s2;
          }
          getAvailableModels(e2, t2) {
            this.availableModels[e2] || (this.availableModels[e2] = {});
            let s2 = this.availableModels[e2][t2];
            return s2 || (s2 = {}), s2;
          }
          getLayerIndex(e2, t2) {
            this.layerIndexes[e2] || (this.layerIndexes[e2] = {});
            let s2 = this.layerIndexes[e2][t2];
            return s2 || (s2 = this.layerIndexes[e2][t2] = new n(), s2.scope = t2), s2;
          }
          getWorkerSource(e2, t2, s2, i2) {
            const o2 = this.workerSources;
            return o2[e2] || (o2[e2] = {}), o2[e2][i2] || (o2[e2][i2] = {}), o2[e2][i2][t2] || (o2[e2][i2][t2] = {}), this.isSpriteLoaded[e2] || (this.isSpriteLoaded[e2] = {}), o2[e2][i2][t2][s2] || (o2[e2][i2][t2][s2] = new this.workerSourceTypes[t2]({ send: (t3, s3, i3, o3, n2, r2) => this.actor.send(t3, s3, i3, e2, n2, r2), scheduler: this.actor.scheduler }, this.getLayerIndex(e2, i2), this.getAvailableImages(e2, i2), this.getAvailableModels(e2, i2), this.isSpriteLoaded[e2][i2], void 0, this.brightness, this.worldview)), o2[e2][i2][t2][s2];
          }
          rasterizeImagesWorker(e2, t2, s2) {
            const i2 = /* @__PURE__ */ new Map();
            for (const [s3, { image: o2, imageVariant: n2 }] of t2.tasks.entries()) {
              const r2 = this.imageRasterizer.rasterize(n2, o2, t2.scope, e2);
              i2.set(s3, r2);
            }
            s2(void 0, i2);
          }
          removeRasterizedImages(e2, t2, s2) {
            this.imageRasterizer.removeImagesFromCacheByIds(t2.imageIds, t2.scope, e2), s2();
          }
          enforceCacheSizeLimit(t2, s2) {
            e.fJ(s2);
          }
          getWorkerPerformanceMetrics(e2, t2, s2) {
            s2(void 0, void 0);
          }
        }
        return e.fF(self) && (self.worker = new Le(self)), Le;
      });
      define2(["./shared"], function(e) {
        var t = "3.18.1";
        const i = { create: "create", load: "load", fullLoad: "fullLoad" }, o = { mark(e2) {
          performance.mark(e2);
        }, measure(e2, t2, i2) {
          performance.measure(e2, t2, i2);
        } };
        function s(t2) {
          const i2 = t2.name.split("?")[0];
          return e.a(i2) && i2.includes("mapbox-gl.js") ? "javascript" : e.a(i2) && i2.includes("mapbox-gl.css") ? "css" : e.b(i2) ? "fontRange" : e.c(i2) ? "sprite" : e.i(i2) ? "style" : e.d(i2) ? "tilejson" : "other";
        }
        var r, n = {}, a = function() {
          if (r) return n;
          function e2(e3) {
            return !t2(e3);
          }
          function t2(t3) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window)) return false;
              var e3, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
              try {
                t4 = new Worker(o3), e3 = true;
              } catch (t5) {
                e3 = false;
              }
              return t4 && t4.terminate(), URL.revokeObjectURL(o3), e3;
            }() ? function() {
              var e3 = document.createElement("canvas");
              e3.width = e3.height = 1;
              var t4 = e3.getContext("2d");
              if (!t4) return false;
              var i3 = t4.getImageData(0, 0, 1, 1);
              return i3 && i3.width === e3.width;
            }() ? (void 0 === i2[o2 = t3 && t3.failIfMajorPerformanceCaveat] && (i2[o2] = function(t4) {
              var i3, o3 = function(t5) {
                var i4 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
                return o4.failIfMajorPerformanceCaveat = t5, i4.getContext("webgl2", o4);
              }(t4);
              if (!o3) return false;
              try {
                i3 = o3.createShader(o3.VERTEX_SHADER);
              } catch (e3) {
                return false;
              }
              return !(!i3 || o3.isContextLost()) && (o3.shaderSource(i3, "void main() {}"), o3.compileShader(i3), true === o3.getShaderParameter(i3, o3.COMPILE_STATUS));
            }(o2)), i2[o2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
            var o2;
          }
          r = 1, n.supported = e2, n.notSupportedReason = t2;
          var i2 = {};
          return e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true }, n;
        }();
        function l(e2, t2, i2) {
          const o2 = document.createElement(e2);
          return null != t2 && (o2.className = t2), i2 && i2.appendChild(o2), o2;
        }
        function c(e2, t2, i2) {
          const o2 = document.createElementNS("http://www.w3.org/2000/svg", e2);
          for (const e3 of Object.keys(t2)) o2.setAttributeNS(null, e3, String(t2[e3]));
          return i2 && i2.appendChild(o2), o2;
        }
        const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, d = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
        let u;
        function _() {
          h && d && (u = h[d], h[d] = "none");
        }
        function p() {
          h && d && (h[d] = u);
        }
        function f(e2) {
          e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", f, true);
        }
        function m() {
          window.addEventListener("click", f, true), window.setTimeout(() => {
            window.removeEventListener("click", f, true);
          }, 0);
        }
        function g(e2, t2) {
          const i2 = e2.getBoundingClientRect();
          return x(e2, i2, t2);
        }
        function v(e2, t2) {
          const i2 = e2.getBoundingClientRect(), o2 = [];
          for (let s2 = 0; s2 < t2.length; s2++) o2.push(x(e2, i2, t2[s2]));
          return o2;
        }
        function y(e2) {
          return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e2.button && e2.ctrlKey ? 0 : e2.button;
        }
        function x(t2, i2, o2) {
          const s2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
          return new e.P((o2.clientX - i2.left) * s2, (o2.clientY - i2.top) * s2);
        }
        const b = "01", w = "NO_ACCESS_TOKEN";
        class T {
          constructor(e2, t2, i2) {
            this._transformRequestFn = e2, this._customAccessToken = t2, this._silenceAuthErrors = !!i2, this._createSkuToken();
          }
          _createSkuToken() {
            const e2 = function() {
              let e3 = "";
              for (let t2 = 0; t2 < 10; t2++) e3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", b, e3].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = e2.token, this._skuTokenExpiresAt = e2.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(e2, t2) {
            return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
          }
          normalizeStyleURL(i2, o2) {
            if (!e.h(i2)) return i2;
            const s2 = S(i2);
            return s2.params.push(`sdk=js-${t}`), s2.path = `/styles/v1${s2.path}`, this._makeAPIURL(s2, this._customAccessToken || o2);
          }
          normalizeGlyphsURL(t2, i2) {
            if (!e.h(t2)) return t2;
            const o2 = S(t2);
            return o2.path = `/fonts/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i2);
          }
          normalizeModelURL(t2, i2) {
            if (!e.h(t2)) return t2;
            const o2 = S(t2);
            return o2.path = `/models/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i2);
          }
          normalizeSourceURL(t2, i2, o2, s2) {
            if (!e.h(t2)) return t2;
            const r2 = S(t2);
            return r2.path = `/v4/${r2.authority}.json`, r2.params.push("secure"), o2 && r2.params.push(`language=${o2}`), s2 && r2.params.push(`worldview=${s2}`), this._makeAPIURL(r2, this._customAccessToken || i2);
          }
          normalizeIconsetURL(t2, i2) {
            const o2 = S(t2);
            return e.h(t2) ? (o2.path = `/styles/v1${o2.path}/iconset.pbf`, this._makeAPIURL(o2, this._customAccessToken || i2)) : I(o2);
          }
          normalizeSpriteURL(t2, i2, o2, s2) {
            const r2 = S(t2);
            return e.h(t2) ? (r2.path = `/styles/v1${r2.path}/sprite${i2}${o2}`, this._makeAPIURL(r2, this._customAccessToken || s2)) : (r2.path += `${i2}${o2}`, I(r2));
          }
          normalizeTileURL(t2, i2, o2) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !e.h(t2)) return t2;
            const s2 = S(t2);
            s2.path = s2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i2 || o2 && "raster" !== s2.authority && 512 === o2 ? "@2x" : ""}${e.k.supported ? ".webp" : "$1"}`), "raster" === s2.authority ? s2.path = `/${e.e.RASTER_URL_PREFIX}${s2.path}` : "rasterarrays" === s2.authority ? s2.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${s2.path}` : "3dtiles" === s2.authority ? s2.path = `/${e.e.TILES3D_URL_PREFIX}${s2.path}` : (s2.path = s2.path.replace(/^.+\/v4\//, "/"), s2.path = `/${e.e.TILE_URL_VERSION}${s2.path}`);
            const r2 = this._customAccessToken || function(e2) {
              for (const t3 of e2) {
                const e3 = t3.match(/^access_token=(.*)$/);
                if (e3) return e3[1];
              }
              return null;
            }(s2.params) || e.e.ACCESS_TOKEN;
            return e.e.REQUIRE_ACCESS_TOKEN && r2 && this._skuToken && s2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s2, r2);
          }
          canonicalizeTileURL(t2, i2) {
            const o2 = S(t2);
            if (!o2.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o2.path.match(/\.[\w]+$/)) return t2;
            let s2 = "mapbox://";
            o2.path.match(/^\/raster\/v1\//) ? s2 += `raster/${o2.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o2.path.match(/^\/rasterarrays\/v1\//) ? s2 += `rasterarrays/${o2.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : s2 += `tiles/${o2.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
            let r2 = o2.params;
            return i2 && (r2 = r2.filter((e2) => !e2.match(/^access_token=/))), r2.length && (s2 += `?${r2.join("&")}`), s2;
          }
          canonicalizeTileset(t2, i2) {
            const o2 = !!i2 && e.h(i2), s2 = [];
            for (const i3 of t2.tiles || []) e.j(i3) ? s2.push(this.canonicalizeTileURL(i3, o2)) : s2.push(i3);
            return s2;
          }
          _makeAPIURL(t2, i2) {
            const o2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", s2 = S(e.e.API_URL);
            if (t2.protocol = s2.protocol, t2.authority = s2.authority, "http" === t2.protocol) {
              const e2 = t2.params.indexOf("secure");
              e2 >= 0 && t2.params.splice(e2, 1);
            }
            if ("/" !== s2.path && (t2.path = `${s2.path}${t2.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return I(t2);
            if (i2 = i2 || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!i2) throw new Error(`An API access token is required to use Mapbox GL. ${o2}`);
              if ("s" === i2[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o2}`);
            }
            return t2.params = t2.params.filter((e2) => -1 === e2.indexOf("access_token")), t2.params.push(`access_token=${i2 || ""}`), I(t2);
          }
        }
        const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function S(e2) {
          const t2 = e2.match(E);
          if (!t2) throw new Error("Unable to parse URL object");
          return { protocol: t2[1], authority: t2[2], path: t2[3] || "/", params: t2[4] ? t2[4].split("&") : [] };
        }
        function I(e2) {
          const t2 = e2.params.length ? `?${e2.params.join("&")}` : "";
          return `${e2.protocol}://${e2.authority}${e2.path}${t2}`;
        }
        const C = "mapbox.eventData";
        function R(t2) {
          if (!t2) return null;
          const i2 = t2.split(".");
          if (!i2 || 3 !== i2.length) return null;
          try {
            return JSON.parse(e.l(i2[1]));
          } catch (e2) {
            return null;
          }
        }
        class A {
          constructor(e2) {
            this.type = e2, this.anonId = null, this.anonIdTimestamp = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t2) {
            const i2 = R(e.e.ACCESS_TOKEN);
            let o2 = "";
            return o2 = i2 && i2.u ? e.f(i2.u) : e.e.ACCESS_TOKEN || "", t2 ? `${C}.${t2}:${o2}` : `${C}:${o2}`;
          }
          fetchEventData() {
            const t2 = e.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid"), s2 = this.getStorageKey("uuidTimestamp");
            if (t2) try {
              const e2 = localStorage.getItem(i2);
              e2 && (this.eventData = JSON.parse(e2));
              const t3 = localStorage.getItem(o2);
              t3 && (this.anonId = t3);
              const r2 = localStorage.getItem(s2);
              r2 && (this.anonIdTimestamp = Number(r2));
              const n2 = Date.now() - 864e5;
              (!this.anonIdTimestamp || this.anonIdTimestamp < n2) && this.refreshUUID();
            } catch (t3) {
              e.w("Unable to read from LocalStorage");
            }
          }
          refreshUUID() {
            this.anonId = e.u(), this.anonIdTimestamp = Date.now();
          }
          saveEventData() {
            const t2 = e.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid"), s2 = this.getStorageKey("uuidTimestamp"), r2 = this.anonId, n2 = this.anonIdTimestamp;
            if (t2 && r2) try {
              localStorage.setItem(o2, r2), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i2, JSON.stringify(this.eventData)), n2 && localStorage.setItem(s2, n2.toString());
            } catch (t3) {
              e.w("Unable to write to LocalStorage");
            }
          }
          processRequests(e2) {
          }
          postEvent(t2, i2, o2, s2) {
            if (!e.e.EVENTS_URL) return;
            const r2 = S(e.e.EVENTS_URL);
            r2.params.push(`access_token=${s2 || e.e.ACCESS_TOKEN || ""}`);
            const n2 = { event: this.type, created: new Date(t2).toISOString() }, a2 = i2 ? Object.assign(n2, i2) : n2, l2 = { url: I(r2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a2]) };
            this.pendingRequest = e.p(l2, (e2) => {
              this.pendingRequest = null, o2(e2), this.saveEventData(), this.processRequests(s2);
            });
          }
          queueRequest(e2, t2) {
            this.queue.push(e2), this.processRequests(t2);
          }
        }
        class L extends A {
          constructor(e2) {
            super("metrics"), e2 && (this.data = e2);
          }
          postMetricsEvent(t2) {
            if (!e.e.EVENTS_URL || !t2 && !e.e.ACCESS_TOKEN) return;
            this.anonId || this.fetchEventData(), e.v(this.anonId) || this.refreshUUID();
            const i2 = Object.assign({}, this.data, { sessionId: this.anonId });
            this.queueRequest({ timestamp: Date.now(), payload: i2 }, t2);
          }
          processRequests(e2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { timestamp: t2, payload: i2 } = this.queue.shift();
            this.postEvent(t2, i2, () => {
            }, e2);
          }
        }
        const D = new class extends A {
          constructor(e2) {
            super("appUserTurnstile"), this._customAccessToken = e2;
          }
          postTurnstileEvent(t2, i2) {
            e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => e.h(t3) || e.j(t3)) && this.queueRequest(Date.now(), i2);
          }
          processRequests(i2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            this.anonId && this.anonIdTimestamp && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const o2 = R(e.e.ACCESS_TOKEN), s2 = o2 ? o2.u : e.e.ACCESS_TOKEN;
            let r2 = s2 !== this.eventData.tokenU;
            e.v(this.anonId) || (this.refreshUUID(), r2 = true);
            const n2 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const e2 = new Date(this.eventData.lastSuccess), t2 = new Date(n2), i3 = (n2 - this.eventData.lastSuccess) / 864e5;
              r2 = r2 || i3 >= 1 || i3 < -1 || e2.getDate() !== t2.getDate();
            } else r2 = true;
            r2 ? this.postEvent(n2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: b, "enabled.telemetry": false, userId: this.anonId }, (e2) => {
              e2 || (this.eventData.lastSuccess = n2, this.eventData.tokenU = s2);
            }, i2) : this.processRequests();
          }
        }(), P = D.postTurnstileEvent.bind(D), O = new class extends A {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t2, i2, o2, s2) {
            this.skuToken = i2, this.errorCb = s2, e.e.EVENTS_URL && (o2 || e.e.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, o2) : this.errorCb(new Error(w)));
          }
          processRequests(i2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { id: o2, timestamp: s2 } = this.queue.shift();
            o2 && this.success[o2] || (this.anonId && this.anonIdTimestamp || this.fetchEventData(), e.v(this.anonId) || this.refreshUUID(), this.postEvent(s2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: b, skuToken: this.skuToken, userId: this.anonId }, (e2) => {
              e2 ? this.errorCb(e2) : o2 && (this.success[o2] = true);
            }, i2));
          }
          remove() {
            this.errorCb = null;
          }
        }(), z = O.postMapLoadEvent.bind(O), M = new class extends A {
          constructor() {
            super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
          }
          getMapInstanceId(t2) {
            let i2 = this.mapInstanceIdMap.get(t2);
            return i2 || (i2 = e.u(), this.mapInstanceIdMap.set(t2, i2)), i2;
          }
          getEventId(e2) {
            const t2 = this.eventIdPerMapInstanceMap.get(e2) || 0;
            return this.eventIdPerMapInstanceMap.set(e2, t2 + 1), t2;
          }
          postStyleLoadEvent(t2, i2) {
            const { map: o2, style: s2, importedStyles: r2 } = i2;
            if (!e.e.EVENTS_URL || !t2 && !e.e.ACCESS_TOKEN) return;
            const n2 = this.getMapInstanceId(o2), a2 = { mapInstanceId: n2, eventId: this.getEventId(n2), style: s2 };
            r2.length && (a2.importedStyles = r2), this.queueRequest({ timestamp: Date.now(), payload: a2 }, t2);
          }
          processRequests(e2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { timestamp: t2, payload: i2 } = this.queue.shift();
            this.postEvent(t2, i2, () => {
            }, e2);
          }
        }(), F = M.postStyleLoadEvent.bind(M), B = new L({ attributes: [{ name: "maps/js/layer-animations/style-with-appearances" }] }), k = B.postMetricsEvent.bind(B), N = new L({ attributes: [{ name: "maps/js/layer-animations/runtime-appearances" }] }), U = N.postMetricsEvent.bind(N), j = new class extends A {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(t2, i2) {
            e.e.EVENTS_URL && (t2 || e.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: i2 }, t2);
          }
          processRequests(o2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { timestamp: r2, performanceData: n2 } = this.queue.shift(), a2 = function(o3) {
              const r3 = performance.getEntriesByType("resource"), n3 = performance.getEntriesByType("mark"), a3 = function(e2) {
                const t2 = {};
                if (e2) {
                  for (const i2 in e2) if ("other" !== i2) for (const o4 of e2[i2]) {
                    const e3 = `${i2}ResolveRangeMin`, s2 = `${i2}ResolveRangeMax`, r4 = `${i2}RequestCount`, n4 = `${i2}RequestCachedCount`;
                    t2[e3] = Math.min(t2[e3] || 1 / 0, o4.startTime), t2[s2] = Math.max(t2[s2] || -1 / 0, o4.responseEnd);
                    const a4 = (e4) => {
                      void 0 === t2[e4] && (t2[e4] = 0), ++t2[e4];
                    };
                    void 0 !== o4.transferSize && 0 === o4.transferSize && a4(n4), a4(r4);
                  }
                }
                return t2;
              }(function(e2, t2) {
                const i2 = {};
                if (e2) for (const o4 of e2) {
                  const e3 = t2(o4);
                  void 0 === i2[e3] && (i2[e3] = []), i2[e3].push(o4);
                }
                return i2;
              }(r3, s)), l2 = window.devicePixelRatio, c2 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h2 = c2 ? c2.effectiveType : void 0, d2 = { counters: [], metadata: [], attributes: [] }, u2 = (e2, t2, i2) => {
                null != i2 && e2.push({ name: t2, value: i2.toString() });
              };
              for (const e2 in a3) u2(d2.counters, e2, a3[e2]);
              if (o3.interactionRange[0] !== 1 / 0 && o3.interactionRange[1] !== -1 / 0 && (u2(d2.counters, "interactionRangeMin", o3.interactionRange[0]), u2(d2.counters, "interactionRangeMax", o3.interactionRange[1])), n3) for (const e2 of Object.values(i)) {
                const t2 = n3.find((t3) => t3.name === e2);
                t2 && u2(d2.counters, e2, t2.startTime);
              }
              return u2(d2.counters, "visibilityHidden", o3.visibilityHidden), u2(d2.attributes, "style", function(t2) {
                if (t2) for (const i2 of t2) {
                  const t3 = i2.name.split("?")[0];
                  if (e.i(t3)) {
                    const e2 = t3.split("/").slice(-2);
                    if (2 === e2.length) return `mapbox://styles/${e2[0]}/${e2[1]}`;
                  }
                }
              }(r3)), u2(d2.attributes, "terrainEnabled", o3.terrainEnabled ? "true" : "false"), u2(d2.attributes, "fogEnabled", o3.fogEnabled ? "true" : "false"), u2(d2.attributes, "projection", o3.projection), u2(d2.attributes, "zoom", o3.zoom), u2(d2.metadata, "devicePixelRatio", l2), u2(d2.metadata, "connectionEffectiveType", h2), u2(d2.metadata, "navigatorUserAgent", navigator.userAgent), u2(d2.metadata, "screenWidth", window.screen.width), u2(d2.metadata, "screenHeight", window.screen.height), u2(d2.metadata, "windowWidth", window.innerWidth), u2(d2.metadata, "windowHeight", window.innerHeight), u2(d2.metadata, "mapWidth", o3.width / l2), u2(d2.metadata, "mapHeight", o3.height / l2), u2(d2.metadata, "webglRenderer", o3.renderer), u2(d2.metadata, "webglVendor", o3.vendor), u2(d2.metadata, "sdkVersion", t), u2(d2.metadata, "sdkIdentifier", "mapbox-gl-js"), d2;
            }(n2);
            for (const e2 of a2.metadata) ;
            for (const e2 of a2.counters) ;
            for (const e2 of a2.attributes) ;
            this.postEvent(r2, a2, () => {
            }, o2);
          }
        }(), V = j.postPerformanceEvent.bind(j), G = new class extends A {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t2, i2, o2, s2) {
            if (!e.e.API_URL || !e.e.SESSION_PATH) return;
            const r2 = S(e.e.API_URL + e.e.SESSION_PATH);
            r2.params.push(`sku=${i2 || ""}`), r2.params.push(`access_token=${s2 || e.e.ACCESS_TOKEN || ""}`);
            const n2 = { url: I(r2), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = e.g(n2, (e2) => {
              this.pendingRequest = null, o2(e2), this.saveEventData(), this.processRequests(s2);
            });
          }
          getSessionAPI(t2, i2, o2, s2) {
            this.skuToken = i2, this.errorCb = s2, e.e.SESSION_PATH && e.e.API_URL && (o2 || e.e.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, o2) : this.errorCb(new Error(w)));
          }
          processRequests(e2) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { id: t2, timestamp: i2 } = this.queue.shift();
            t2 && this.success[t2] || this.getSession(i2, this.skuToken, (e3) => {
              e3 ? this.errorCb(e3) : t2 && (this.success[t2] = true);
            }, e2);
          }
          remove() {
            this.errorCb = null;
          }
        }(), H = G.getSessionAPI.bind(G), q = /* @__PURE__ */ new Set();
        function Z(e2, t2) {
          t2 ? q.add(e2) : q.delete(e2);
        }
        class W {
          constructor() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = {};
          }
          isDirty() {
            return this._changed;
          }
          setDirty() {
            this._changed = true;
          }
          getUpdatedSourceCaches() {
            return this._updatedSourceCaches;
          }
          updateSourceCache(e2, t2) {
            this._updatedSourceCaches[e2] = t2, this.setDirty();
          }
          discardSourceCacheUpdate(e2) {
            delete this._updatedSourceCaches[e2];
          }
          updateLayer(e2) {
            const t2 = e2.scope;
            this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._updatedLayers[t2].add(e2.id), this.setDirty();
          }
          removeLayer(e2) {
            const t2 = e2.scope;
            this._removedLayers[t2] = this._removedLayers[t2] || {}, this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._removedLayers[t2][e2.id] = e2, this._updatedLayers[t2].delete(e2.id), this._updatedPaintProps.delete(e2.fqid), this.setDirty();
          }
          getRemovedLayer(e2) {
            return this._removedLayers[e2.scope] ? this._removedLayers[e2.scope][e2.id] : null;
          }
          discardLayerRemoval(e2) {
            this._removedLayers[e2.scope] && delete this._removedLayers[e2.scope][e2.id];
          }
          getLayerUpdatesByScope() {
            const e2 = {};
            for (const t2 in this._updatedLayers) e2[t2] = e2[t2] || {}, e2[t2].updatedIds = Array.from(this._updatedLayers[t2].values());
            for (const t2 in this._removedLayers) e2[t2] = e2[t2] || {}, e2[t2].removedIds = Object.keys(this._removedLayers[t2]);
            return e2;
          }
          getUpdatedPaintProperties() {
            return this._updatedPaintProps;
          }
          updatePaintProperties(e2) {
            this._updatedPaintProps.add(e2.fqid), this.setDirty();
          }
          getUpdatedImages(e2) {
            return this._updatedImages[e2] ? Array.from(this._updatedImages[e2].values()) : [];
          }
          updateImage(t2, i2) {
            this._updatedImages[i2] = this._updatedImages[i2] || /* @__PURE__ */ new Set(), this._updatedImages[i2].add(e.I.toString(t2)), this.setDirty();
          }
          resetUpdatedImages(e2) {
            this._updatedImages[e2] && this._updatedImages[e2].clear();
          }
          reset() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};
          }
        }
        function $(e2) {
          const { userImage: t2 } = e2;
          return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
        }
        class X extends e.E {
          constructor(t2) {
            super(), this.imageProviders = /* @__PURE__ */ new Map(), this.images = /* @__PURE__ */ new Map(), this.updatedImages = /* @__PURE__ */ new Map(), this.callbackDispatchedThisFrame = /* @__PURE__ */ new Map(), this.loaded = /* @__PURE__ */ new Map(), this.requestors = [], this.patterns = /* @__PURE__ */ new Map(), this.patternsInFlight = /* @__PURE__ */ new Set(), this.atlasImage = /* @__PURE__ */ new Map(), this.atlasTexture = /* @__PURE__ */ new Map(), this.dirty = true, this.spriteFormat = t2, "raster" !== t2 && e.r() && (this.imageRasterizerDispatcher = new e.D(e.t(), this, "Image Rasterizer Worker", 1));
          }
          addScope(t2) {
            this.loaded.set(t2, false), this.imageProviders.set(t2, /* @__PURE__ */ new Map()), this.images.set(t2, /* @__PURE__ */ new Map()), this.updatedImages.set(t2, /* @__PURE__ */ new Set()), this.callbackDispatchedThisFrame.set(t2, /* @__PURE__ */ new Set()), this.patterns.set(t2, /* @__PURE__ */ new Map()), this.atlasImage.set(t2, new e.q({ width: 1, height: 1 }));
          }
          removeScope(e2) {
            this.loaded.delete(e2), this.imageProviders.delete(e2), this.images.delete(e2), this.updatedImages.delete(e2), this.callbackDispatchedThisFrame.delete(e2), this.patterns.delete(e2), this.atlasImage.delete(e2);
            const t2 = this.atlasTexture.get(e2);
            t2 && (t2.destroy(), this.atlasTexture.delete(e2));
          }
          addImageProvider(e2, t2) {
            this.imageProviders.has(t2) || this.imageProviders.set(t2, /* @__PURE__ */ new Map()), this.imageProviders.get(t2).set(e2.id, e2);
          }
          removeImageProvider(e2, t2) {
            this.imageProviders.has(t2) && this.imageProviders.get(t2).delete(e2);
          }
          getPendingImageProviders() {
            const e2 = [];
            for (const t2 of this.imageProviders.values()) for (const i2 of t2.values()) i2.hasPendingRequests() && e2.push(i2);
            return e2;
          }
          get imageRasterizer() {
            return this._imageRasterizer || (this._imageRasterizer = new e.x()), this._imageRasterizer;
          }
          isLoaded() {
            for (const e2 of this.loaded.keys()) if (!this.loaded.get(e2)) return false;
            return true;
          }
          setLoaded(e2, t2) {
            if (this.loaded.get(t2) !== e2 && (this.loaded.set(t2, e2), e2)) {
              for (const { ids: e3, callback: i2 } of this.requestors) this._notify(e3, t2, i2);
              this.requestors = [];
            }
          }
          hasImage(e2, t2) {
            return !!this.getImage(e2, t2);
          }
          getImage(e2, t2) {
            return this.images.get(t2).get(e2.toString());
          }
          addImage(e2, t2, i2) {
            this._validate(e2, i2) && this.images.get(t2).set(e2.toString(), i2);
          }
          _validate(t2, i2) {
            let o2 = true;
            return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.y(new Error(`Image "${t2.name}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.y(new Error(`Image "${t2.name}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.y(new Error(`Image "${t2.name}" has invalid "content" value`))), o2 = false), o2;
          }
          _validateStretch(e2, t2) {
            if (!e2) return true;
            let i2 = 0;
            for (const o2 of e2) {
              if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1]) return false;
              i2 = o2[1];
            }
            return true;
          }
          _validateContent(e2, t2) {
            if (!e2) return true;
            if (4 !== e2.length) return false;
            if (!t2.usvg) {
              if (e2[0] < 0 || t2.data.width < e2[0]) return false;
              if (e2[1] < 0 || t2.data.height < e2[1]) return false;
              if (e2[2] < 0 || t2.data.width < e2[2]) return false;
              if (e2[3] < 0 || t2.data.height < e2[3]) return false;
            }
            return !(e2[2] < e2[0] || e2[3] < e2[1]);
          }
          updateImage(e2, t2, i2) {
            const o2 = this.images.get(t2).get(e2.toString());
            i2.version = o2.version + 1, this.images.get(t2).set(e2.toString(), i2), this.updatedImages.get(t2).add(e2), this.removeFromImageRasterizerCache(e2, t2);
          }
          clearUpdatedImages(e2) {
            this.updatedImages.get(e2).clear();
          }
          removeFromImageRasterizerCache(t2, i2) {
            "raster" !== this.spriteFormat && (e.r() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t2], scope: i2 }) : this.imageRasterizer.removeImagesFromCacheByIds([t2], i2));
          }
          removeImage(e2, t2) {
            const i2 = this.images.get(t2), o2 = i2.get(e2.toString());
            i2.delete(e2.toString()), this.patterns.get(t2).delete(e2.toString()), this.removeFromImageRasterizerCache(e2, t2), o2.userImage && o2.userImage.onRemove && o2.userImage.onRemove();
          }
          listImages(t2) {
            return Array.from(this.images.get(t2).keys()).map((t3) => e.I.from(t3));
          }
          getImages(e2, t2, i2) {
            const o2 = [], s2 = [], r2 = this.imageProviders.get(t2);
            for (const i3 of e2) {
              if (!i3.iconsetId) {
                o2.push(i3);
                continue;
              }
              const e3 = r2.get(i3.iconsetId);
              e3 && (this.getImage(i3, t2) ? s2.push(i3) : e3.addPendingRequest(i3));
            }
            if (0 === o2.length) return void this._notify(s2, t2, i2);
            let n2 = true;
            const a2 = !!this.loaded.get(t2), l2 = this.images.get(t2);
            if (!a2) for (const e3 of o2) l2.has(e3.toString()) || (n2 = false);
            a2 || n2 ? this._notify(o2, t2, i2) : this.requestors.push({ ids: o2, scope: t2, callback: i2 });
          }
          rasterizeImages(e2, t2) {
            const i2 = /* @__PURE__ */ new Map(), { tasks: o2, scope: s2 } = e2;
            for (const [e3, t3] of o2.entries()) {
              const o3 = this.getImage(t3.id, s2);
              o3 && i2.set(e3, { image: o3, imageVariant: t3 });
            }
            this._rasterizeImages(s2, i2, t2);
          }
          _rasterizeImages(t2, i2, o2) {
            if (e.r()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", { tasks: i2, scope: t2 }, o2);
            else {
              const e2 = /* @__PURE__ */ new Map();
              for (const [o3, { image: s2, imageVariant: r2 }] of i2.entries()) e2.set(o3, this.imageRasterizer.rasterize(r2, s2, t2, 0));
              o2(void 0, e2);
            }
          }
          getUpdatedImages(e2) {
            return this.updatedImages.get(e2) || /* @__PURE__ */ new Set();
          }
          _notify(t2, i2, o2) {
            const s2 = this.images.get(i2), r2 = /* @__PURE__ */ new Map();
            for (const i3 of t2) {
              if (!s2.get(i3.toString())) {
                if (i3.iconsetId) continue;
                this.fire(new e.z("styleimagemissing", { id: i3.name }));
              }
              const t3 = s2.get(i3.toString());
              if (!t3) {
                e.w(`Image "${i3.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                continue;
              }
              const o3 = { data: t3.usvg ? null : t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, usvg: t3.usvg, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) };
              t3.usvg && Object.assign(o3, { width: t3.icon.usvg_tree.width, height: t3.icon.usvg_tree.height }), r2.set(e.I.toString(i3), o3);
            }
            o2(null, r2);
          }
          getPixelSize(e2) {
            const { width: t2, height: i2 } = this.atlasImage.get(e2);
            return { width: t2, height: i2 };
          }
          getPattern(t2, i2, o2) {
            const s2 = t2.toString(), r2 = this.patterns.get(i2), n2 = r2.get(s2), a2 = this.getImage(t2, i2);
            if (!a2) return null;
            if (n2) {
              if (n2.position.version === a2.version) return n2.position;
              n2.position.version = a2.version;
            } else {
              if (a2.usvg && !a2.data) {
                const r3 = this.getPatternInFlightId(s2, i2);
                if (this.patternsInFlight.has(r3)) return null;
                this.patternsInFlight.add(r3);
                const n3 = new e.A(t2).scaleSelf(e.o.devicePixelRatio), l2 = /* @__PURE__ */ new Map([[n3.toString(), { image: a2, imageVariant: n3 }]]);
                return this._rasterizeImages(i2, l2, (e2, t3) => this.storePatternImage(n3, i2, a2, o2, t3)), null;
              }
              this.storePattern(t2, i2, a2);
            }
            return this._updatePatternAtlas(i2, o2), r2.get(s2).position;
          }
          getPatternInFlightId(t2, i2) {
            return e.B(t2, i2);
          }
          hasPatternsInFlight() {
            return 0 !== this.patternsInFlight.size;
          }
          storePatternImage(e2, t2, i2, o2, s2) {
            const r2 = e2.toString(), n2 = s2 ? s2.get(r2) : void 0;
            n2 && (i2.data = n2, this.storePattern(e2.id, t2, i2), this._updatePatternAtlas(t2, o2), this.patternsInFlight.delete(this.getPatternInFlightId(e2.id.toString(), t2)));
          }
          storePattern(t2, i2, o2) {
            const s2 = { w: o2.data.width + 2 * e.C, h: o2.data.height + 2 * e.C, x: 0, y: 0 }, r2 = new e.F(s2, o2, e.C);
            this.patterns.get(i2).set(t2.toString(), { bin: s2, position: r2 });
          }
          destroyAtlasTextures() {
            for (const e2 of this.atlasTexture.values()) e2 && e2.destroy();
            this.atlasTexture.clear();
          }
          bind(t2, i2) {
            const o2 = t2.gl;
            let s2 = this.atlasTexture.get(i2);
            s2 ? this.dirty && (s2.update(this.atlasImage.get(i2)), this.dirty = false) : (s2 = new e.T(t2, this.atlasImage.get(i2), o2.RGBA8), this.atlasTexture.set(i2, s2)), s2.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas(t2, i2) {
            const o2 = this.patterns.get(t2), s2 = Array.from(o2.values()).map(({ bin: e2 }) => e2), { w: r2, h: n2 } = e.G(s2), a2 = this.atlasImage.get(t2);
            a2.resize({ width: r2 || 1, height: n2 || 1 });
            const l2 = this.images.get(t2);
            for (const [t3, { bin: s3, position: r3 }] of o2.entries()) {
              let o3 = r3.padding;
              const n3 = s3.x + o3, c2 = s3.y + o3, h2 = l2.get(t3).data, d2 = h2.width, u2 = h2.height;
              o3 = o3 > 1 ? o3 - 1 : o3, e.q.copy(h2, a2, { x: 0, y: 0 }, { x: n3, y: c2 }, { width: d2, height: u2 }, i2), e.q.copy(h2, a2, { x: 0, y: u2 - o3 }, { x: n3, y: c2 - o3 }, { width: d2, height: o3 }, i2), e.q.copy(h2, a2, { x: 0, y: 0 }, { x: n3, y: c2 + u2 }, { width: d2, height: o3 }, i2), e.q.copy(h2, a2, { x: d2 - o3, y: 0 }, { x: n3 - o3, y: c2 }, { width: o3, height: u2 }, i2), e.q.copy(h2, a2, { x: 0, y: 0 }, { x: n3 + d2, y: c2 }, { width: o3, height: u2 }, i2), e.q.copy(h2, a2, { x: d2 - o3, y: u2 - o3 }, { x: n3 - o3, y: c2 - o3 }, { width: o3, height: o3 }, i2), e.q.copy(h2, a2, { x: 0, y: u2 - o3 }, { x: n3 + d2, y: c2 - o3 }, { width: o3, height: o3 }, i2), e.q.copy(h2, a2, { x: 0, y: 0 }, { x: n3 + d2, y: c2 + u2 }, { width: o3, height: o3 }, i2), e.q.copy(h2, a2, { x: d2 - o3, y: 0 }, { x: n3 - o3, y: c2 + u2 }, { width: o3, height: o3 }, i2);
            }
            this.dirty = true;
          }
          beginFrame() {
            for (const e2 of this.images.keys()) this.callbackDispatchedThisFrame.set(e2, /* @__PURE__ */ new Set());
          }
          dispatchRenderCallbacks(e2, t2) {
            const i2 = this.images.get(t2);
            for (const o2 of e2) {
              if (this.callbackDispatchedThisFrame.get(t2).has(o2.toString())) continue;
              this.callbackDispatchedThisFrame.get(t2).add(o2.toString());
              const e3 = i2.get(o2.toString());
              $(e3) && this.updateImage(o2, t2, e3);
            }
          }
          destroy() {
            this.imageRasterizerDispatcher && this.imageRasterizerDispatcher.remove();
          }
        }
        function Y(t2) {
          const i2 = t2.value, o2 = t2.valueSpec, s2 = t2.style, r2 = t2.styleSpec, n2 = t2.key, a2 = t2.arrayElementValidator || ve;
          if (!Array.isArray(i2)) return [new e.V(n2, i2, `array expected, ${e.K(i2)} found`)];
          if (o2.length && i2.length !== o2.length) return [new e.V(n2, i2, `array length ${o2.length} expected, length ${i2.length} found`)];
          if (o2["min-length"] && i2.length < o2["min-length"]) return [new e.V(n2, i2, `array length at least ${o2["min-length"]} expected, length ${i2.length} found`)];
          let l2 = { type: o2.value, values: o2.values, minimum: o2.minimum, maximum: o2.maximum, function: void 0 };
          r2.$version < 7 && (l2.function = o2.function), e.H(o2.value) && (l2 = o2.value);
          let c2 = [];
          for (let e2 = 0; e2 < i2.length; e2++) c2 = c2.concat(a2({ array: i2, arrayIndex: e2, value: i2[e2], valueSpec: l2, style: s2, styleSpec: r2, key: `${n2}[${e2}]` }, true));
          return c2;
        }
        function K(t2) {
          const i2 = t2.key, o2 = t2.value, s2 = t2.valueSpec;
          if (!e.L(o2)) return [new e.V(i2, o2, `number expected, ${e.K(o2)} found`)];
          if (o2 != o2) return [new e.V(i2, o2, "number expected, NaN found")];
          if ("minimum" in s2) {
            let r2 = s2.minimum;
            if (Array.isArray(s2.minimum) && (r2 = s2.minimum[t2.arrayIndex]), o2 < r2) return [new e.V(i2, o2, `${o2} is less than the minimum value ${r2}`)];
          }
          if ("maximum" in s2) {
            let r2 = s2.maximum;
            if (Array.isArray(s2.maximum) && (r2 = s2.maximum[t2.arrayIndex]), o2 > r2) return [new e.V(i2, o2, `${o2} is greater than the maximum value ${r2}`)];
          }
          return [];
        }
        function J(t2) {
          const i2 = t2.key, o2 = t2.value;
          if (!e.H(o2)) return [new e.V(i2, o2, `object expected, ${e.K(o2)} found`)];
          const s2 = t2.valueSpec, r2 = e.J(o2.type);
          let n2, a2, l2, c2 = {};
          const h2 = "categorical" !== r2 && void 0 === o2.property, d2 = !h2, u2 = function(t3) {
            const i3 = t3.stops;
            return Array.isArray(i3) && Array.isArray(i3[0]) && e.H(i3[0][0]);
          }(o2), _2 = ye({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r2) return [new e.V(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let i3 = [];
            const o3 = t3.value;
            return i3 = i3.concat(Y({ key: t3.key, value: o3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: p2 })), Array.isArray(o3) && 0 === o3.length && i3.push(new e.V(t3.key, o3, "array must have at least one stop")), i3;
          }, default: function(e2) {
            return ve({ key: e2.key, value: e2.value, valueSpec: s2, style: e2.style, styleSpec: e2.styleSpec });
          } } });
          return "identity" === r2 && h2 && _2.push(new e.V(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || o2.stops || _2.push(new e.V(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && s2.expression && !e.M(s2) && _2.push(new e.V(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (d2 && !e.N(s2) ? _2.push(new e.V(t2.key, t2.value, "property functions not supported")) : h2 && !e.O(s2) && _2.push(new e.V(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== o2.property || _2.push(new e.V(t2.key, t2.value, '"property" property is required')), _2;
          function p2(t3) {
            let i3 = [];
            const o3 = t3.value, r3 = t3.key;
            if (!Array.isArray(o3)) return [new e.V(r3, o3, `array expected, ${e.K(o3)} found`)];
            if (2 !== o3.length) return [new e.V(r3, o3, `array length 2 expected, length ${o3.length} found`)];
            if (u2) {
              if (!e.H(o3[0])) return [new e.V(r3, o3, `object expected, ${e.K(o3[0])} found`)];
              const s3 = o3[0];
              if (void 0 === s3.zoom) return [new e.V(r3, o3, "object stop key must have zoom")];
              if (void 0 === s3.value) return [new e.V(r3, o3, "object stop key must have value")];
              const n3 = e.J(s3.zoom);
              if ("number" != typeof n3) return [new e.V(r3, s3.zoom, "stop zoom values must be numbers")];
              if (l2 && l2 > n3) return [new e.V(r3, s3.zoom, "stop zoom values must appear in ascending order")];
              n3 !== l2 && (l2 = n3, a2 = void 0, c2 = {}), i3 = i3.concat(ye({ key: `${r3}[0]`, value: o3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: K, value: f2 } }));
            } else i3 = i3.concat(f2({ key: `${r3}[0]`, value: o3[0], style: t3.style, styleSpec: t3.styleSpec }, o3));
            return e.Q(e.S(o3[1])) ? i3.concat([new e.V(`${r3}[1]`, o3[1], "expressions are not allowed in function stops.")]) : i3.concat(ve({ key: `${r3}[1]`, value: o3[1], valueSpec: s2, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function f2(t3, i3) {
            const o3 = e.K(t3.value), l3 = e.J(t3.value), h3 = null !== t3.value ? t3.value : i3;
            if (n2) {
              if (o3 !== n2) return [new e.V(t3.key, h3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3 && "number" != typeof l3 && "string" != typeof l3 && "boolean" != typeof l3) return [new e.V(t3.key, h3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let i4 = `number expected, ${o3} found`;
              return e.N(s2) && void 0 === r2 && (i4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e.V(t3.key, h3, i4)];
            }
            return "categorical" !== r2 || "number" !== o3 || "number" == typeof l3 && isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && "number" == typeof l3 && "number" == typeof a2 && void 0 !== a2 && l3 < a2 ? [new e.V(t3.key, h3, "stop domain values must appear in ascending order")] : (a2 = l3, "categorical" === r2 && l3 in c2 ? [new e.V(t3.key, h3, "stop domain values must be unique")] : (c2[l3] = true, [])) : [new e.V(t3.key, h3, `integer expected, found ${String(l3)}`)];
          }
        }
        function Q(t2) {
          const i2 = ("property" === t2.expressionContext ? e.W : e.U)(e.S(t2.value), t2.valueSpec);
          if ("error" === i2.result) return i2.value.map((i3) => new e.V(`${t2.key}${i3.key}`, t2.value, i3.message));
          const o2 = i2.value.expression || i2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !o2.outputDefined()) return [new e.V(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !e.Z(o2)) return [new e.V(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext) return ee(o2, t2);
          if ("appearance" === t2.expressionContext) return te(o2, t2);
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!e.X(o2, ["zoom", "feature-state"])) return [new e.V(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !e.Y(o2)) return [new e.V(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ee(t2, i2) {
          const o2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (i2.valueSpec && i2.valueSpec.expression) for (const e2 of i2.valueSpec.expression.parameters) o2.delete(e2);
          if (0 === o2.size) return [];
          const s2 = [];
          return t2 instanceof e._ && o2.has(t2.name) ? [new e.V(i2.key, i2.value, `["${t2.name}"] expression is not supported in a filter for a ${i2.object.type} layer with id: ${i2.object.id}`)] : (t2.eachChild((e2) => {
            s2.push(...ee(e2, i2));
          }), s2);
        }
        function te(t2, i2) {
          const o2 = /* @__PURE__ */ new Set();
          if (i2.valueSpec && i2.valueSpec.expression) for (const e2 of i2.valueSpec.expression.parameters) o2.add(e2);
          if (0 === o2.size) return [];
          const s2 = [];
          return t2 instanceof e._ && !o2.has(t2.name) ? [new e.V(i2.key, i2.value, `["${t2.name}"] is not an allowed parameter`)] : (t2.eachChild((e2) => {
            s2.push(...te(e2, i2));
          }), s2);
        }
        function ie(t2) {
          const i2 = t2.key, o2 = t2.value, s2 = t2.valueSpec, r2 = [];
          return Array.isArray(s2.values) ? -1 === s2.values.indexOf(e.J(o2)) && r2.push(new e.V(i2, o2, `expected one of [${s2.values.join(", ")}], ${JSON.stringify(o2)} found`)) : -1 === Object.keys(s2.values).indexOf(e.J(o2)) && r2.push(new e.V(i2, o2, `expected one of [${Object.keys(s2.values).join(", ")}], ${JSON.stringify(o2)} found`)), r2;
        }
        function oe(t2) {
          return e.a2(e.S(t2.value)) ? Q(Object.assign({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : se(t2);
        }
        function se(t2) {
          const i2 = t2.value, o2 = t2.key;
          if (!Array.isArray(i2)) return [new e.V(o2, i2, `array expected, ${e.K(i2)} found`)];
          if (i2.length < 1) return [new e.V(o2, i2, "filter array must have at least 1 element")];
          const s2 = t2.styleSpec;
          let r2 = ie({ key: `${o2}[0]`, value: i2[0], valueSpec: s2.filter_operator });
          const n2 = () => {
            i2.length >= 2 && (e.a0(i2[1]) || r2.push(new e.V(`${o2}[1]`, i2[1], `string expected, ${e.K(i2[1])} found`)));
            for (let t3 = 2; t3 < i2.length; t3++) "$type" === e.J(i2[1]) ? r2 = r2.concat(ie({ key: `${o2}[${t3}]`, value: i2[t3], valueSpec: s2.geometry_type })) : e.a0(i2[t3]) || e.L(i2[t3]) || e.$(i2[t3]) || r2.push(new e.V(`${o2}[${t3}]`, i2[t3], `string, number, or boolean expected, ${e.K(i2[t3])} found.`));
          };
          switch (e.J(i2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              i2.length >= 2 && "$type" === e.J(i2[1]) && r2.push(new e.V(o2, i2, `"$type" cannot be use with operator "${i2[0]}"`)), 3 !== i2.length && r2.push(new e.V(o2, i2, `filter array for operator "${i2[0]}" must have 3 elements`)), n2();
              break;
            case "==":
            case "!=":
              3 !== i2.length && r2.push(new e.V(o2, i2, `filter array for operator "${i2[0]}" must have 3 elements`)), n2();
              break;
            case "in":
            case "!in":
              n2();
              break;
            case "any":
            case "all":
            case "none":
              for (let e2 = 1; e2 < i2.length; e2++) r2 = r2.concat(se({ key: `${o2}[${e2}]`, value: i2[e2], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              2 !== i2.length ? r2.push(new e.V(o2, i2, `filter array for "${i2[0]}" operator must have 2 elements`)) : e.a0(i2[1]) || r2.push(new e.V(`${o2}[1]`, i2[1], `string expected, ${e.K(i2[1])} found`));
          }
          return r2;
        }
        function re(t2, i2) {
          const o2 = t2.key, s2 = t2.style, r2 = t2.layer, n2 = t2.styleSpec, a2 = t2.value, l2 = t2.objectKey, c2 = n2[`${i2}_${t2.layerType}`];
          if (!c2) return [];
          const h2 = l2.match(/^(.*)-use-theme$/);
          if (h2 && c2[h2[1]]) return e.Q(e.S(a2)) ? [].concat(ve({ key: o2, value: a2, valueSpec: { type: "string", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, style: s2, styleSpec: n2, expressionContext: "property", propertyType: i2, propertyKey: l2 })) : ve({ key: o2, value: a2, valueSpec: { type: "string" }, style: s2, styleSpec: n2 });
          const d2 = l2.match(/^(.*)-transition$/);
          if ("paint" === i2 && d2 && c2[d2[1]] && c2[d2[1]].transition) return ve({ key: o2, value: a2, valueSpec: n2.transition, style: s2, styleSpec: n2 });
          const u2 = t2.valueSpec || c2[l2];
          if (!u2) return [new e.a3(o2, a2, `unknown property "${l2}"`)];
          let _2;
          if (e.a0(a2) && e.N(u2) && !u2.tokens && (_2 = /^{([^}]+)}$/.exec(a2))) {
            const t3 = `\`{ "type": "identity", "property": ${_2 ? JSON.stringify(_2[1]) : '"_"'} }\``;
            return [new e.V(o2, a2, `"${l2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
          }
          const p2 = [];
          if ("symbol" === t2.layerType) "text-field" !== l2 || !s2 || s2.glyphs || s2.imports || p2.push(new e.V(o2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l2 && e.a4(e.S(a2)) && "identity" === e.J(a2.type) && p2.push(new e.V(o2, a2, '"text-font" does not support identity functions'));
          else if ("model" === t2.layerType && "paint" === i2 && r2 && r2.layout && r2.layout.hasOwnProperty("model-id") && e.N(u2) && (e.a5(u2) || e.O(u2))) {
            const t3 = e.W(e.S(a2), u2).value, i3 = "expression" in t3 && t3.expression || "_styleExpression" in t3 && t3._styleExpression && t3._styleExpression.expression;
            i3 && !e.X(i3, ["measure-light"]) && ("model-emissive-strength" === l2 && e.Y(i3) && e.Z(i3) || p2.push(new e.V(o2, a2, `${l2} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
          }
          return p2.concat(ve({ key: t2.key, value: a2, valueSpec: u2, style: s2, styleSpec: n2, expressionContext: "property", propertyType: i2, propertyKey: l2 }));
        }
        function ne(e2) {
          return re(e2, "paint");
        }
        function ae(e2) {
          return re(e2, "layout");
        }
        function le(t2) {
          let i2 = [];
          const o2 = t2.value, s2 = t2.key, r2 = t2.style, n2 = t2.styleSpec;
          if (!e.H(o2)) return [new e.V(s2, o2, "object expected")];
          o2.type || o2.ref || i2.push(new e.V(s2, o2, 'either "type" or "ref" is required'));
          let a2 = e.J(o2.type);
          const l2 = e.J(o2.ref);
          if (o2.id) {
            const n3 = e.J(o2.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = r2.layers[a3];
              e.J(t3.id) === n3 && i2.push(new e.V(s2, o2.id, `duplicate layer id "${n3}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in o2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in o2 && i2.push(new e.V(s2, o2[t4], `"${t4}" is prohibited for ref layers`));
            }), r2.layers.forEach((i3) => {
              e.J(i3.id) === l2 && (t3 = i3);
            }), t3 ? t3.ref ? i2.push(new e.V(s2, o2.ref, "ref cannot reference another ref layer")) : a2 = e.J(t3.type) : "string" == typeof l2 && i2.push(new e.V(s2, o2.ref, `ref layer "${l2}" not found`));
          } else if ("background" !== a2 && "sky" !== a2 && "slot" !== a2) if (o2.source) if (e.a0(o2.source)) {
            const t3 = r2.sources && r2.sources[o2.source], n3 = t3 && e.J(t3.type);
            t3 ? "vector" === n3 && "raster" === a2 ? i2.push(new e.V(s2, o2.source, `layer "${o2.id}" requires a raster source`)) : "raster" === n3 && "raster" !== a2 ? i2.push(new e.V(s2, o2.source, `layer "${o2.id}" requires a vector source`)) : "vector" !== n3 || o2["source-layer"] ? "raster-dem" === n3 && "hillshade" !== a2 ? i2.push(new e.V(s2, o2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n3 || ["raster", "raster-particle"].includes(a2) ? "line" === a2 && o2.paint && (o2.paint["line-gradient"] || o2.paint["line-trim-offset"]) && "geojson" === n3 && !t3.lineMetrics ? i2.push(new e.V(s2, o2, `layer "${o2.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : "raster-particle" === a2 && "raster-array" !== n3 && i2.push(new e.V(s2, o2.source, `layer "${o2.id}" requires a 'raster-array' source.`)) : i2.push(new e.V(s2, o2.source, "raster-array source can only be used with layer type 'raster'.")) : i2.push(new e.V(s2, o2, `layer "${o2.id}" must specify a "source-layer"`)) : i2.push(new e.V(s2, o2.source, `source "${o2.source}" not found`));
          } else i2.push(new e.V(`${s2}.source`, o2.source, '"source" must be a string'));
          else i2.push(new e.V(s2, o2, 'missing required property "source"'));
          return i2 = i2.concat(ye({ key: s2, value: o2, valueSpec: n2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => ve({ key: `${s2}.type`, value: o2.type, valueSpec: n2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: o2, objectKey: "type" }), filter: (e2) => oe(Object.assign({ layerType: a2 }, e2)), layout: (e2) => ye({ layer: o2, key: e2.key, value: e2.value, valueSpec: {}, style: e2.style, styleSpec: e2.styleSpec, objectElementValidators: { "*": (e3) => ae(Object.assign({ layerType: a2 }, e3)) } }), paint: (e2) => ye({ layer: o2, key: e2.key, value: e2.value, valueSpec: {}, style: e2.style, styleSpec: e2.styleSpec, objectElementValidators: { "*": (e3) => ne(Object.assign({ layerType: a2, layer: o2 }, e3)) } }), appearances(t3) {
            const i3 = Y({ key: t3.key, value: t3.value, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: (t4) => function(t5) {
              const { key: i4, layer: o3, layerType: s4 } = t5, r4 = e.J(t5.value), n3 = e.J(r4.name), a3 = e.J(r4.condition), l3 = ye({ key: i4, value: r4, valueSpec: t5.styleSpec.appearance, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { condition: (t6) => function(t7) {
                const i5 = [];
                return i5.push(...Q({ key: t7.key, value: t7.object.condition, valueSpec: e.a6.appearance.condition, expressionContext: "appearance" })), i5;
              }(Object.assign({ layer: o3, layerType: s4 }, t6)), properties: (t6) => function(t7) {
                const i5 = [], { styleSpec: o4, layer: s5, layerType: r5 } = t7, n4 = o4[`paint_${r5}`], a4 = o4[`layout_${r5}`], l4 = t7.object[t7.objectKey];
                for (const o5 in l4) {
                  const c2 = o5 in n4 ? "paint" : o5 in a4 ? "layout" : void 0;
                  if (!c2) {
                    i5.push(new e.V(t7.key, o5, `unknown property "${o5}" for layer type "${r5}"`));
                    continue;
                  }
                  const h2 = Object.assign({}, t7, { key: `${t7.key}.${o5}`, object: l4, objectKey: o5, layer: s5, layerType: r5, value: l4[o5], valueSpec: "paint" === c2 ? n4[o5] : a4[o5] });
                  i5.push(...re(h2, c2));
                }
                return i5;
              }(Object.assign({ layer: o3, layerType: s4 }, t6)) } });
              return "hidden" !== n3 && void 0 === a3 && l3.push(new e.V(t5.key, "name", 'Appearance with name different than "hidden" must have a condition')), l3;
            }(Object.assign({ layerType: a2, layer: o2 }, t4)) }), s3 = Array.isArray(t3.value) ? t3.value : [], r3 = /* @__PURE__ */ new Set();
            return s3.forEach((s4, n3) => {
              const a3 = e.J(s4.name);
              if (a3) if (r3.has(a3)) {
                const s5 = e.J(o2.id);
                i3.push(new e.V(t3.key, a3, `Duplicated appearance name "${a3}" for layer "${s5}"`));
              } else r3.add(a3);
            }), i3;
          } } })), i2;
        }
        function ce({ key: t2, value: i2 }) {
          return e.a0(i2) ? [] : [new e.V(t2, i2, `string expected, ${e.K(i2)} found`)];
        }
        const he = { promoteId: function t2({ key: i2, value: o2 }) {
          if (e.a0(o2)) return ce({ key: i2, value: o2 });
          if (Array.isArray(o2)) {
            const t3 = [], s3 = e.S(o2), r2 = e.U(s3);
            return "error" === r2.result && r2.value.forEach((o3) => {
              t3.push(new e.V(`${i2}${o3.key}`, null, `${o3.message}`));
            }), e.X(r2.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || t3.push(new e.V(`${i2}`, null, "promoteId expression should be only feature dependent")), t3;
          }
          if (!e.H(o2)) return [new e.V(i2, o2, `string, expression or object expected, "${e.K(o2)}" found`)];
          const s2 = [];
          for (const e2 in o2) s2.push(...t2({ key: `${i2}.${e2}`, value: o2[e2] }));
          return s2;
        } };
        function de(t2) {
          const i2 = t2.value, o2 = t2.key, s2 = t2.styleSpec, r2 = t2.style;
          if (!e.H(i2)) return [new e.V(o2, i2, `object expected, ${e.K(i2)} found`)];
          if (!("type" in i2)) return [new e.V(o2, i2, '"type" is required')];
          const n2 = e.J(i2.type);
          let a2 = [];
          switch (["vector", "raster", "raster-dem", "raster-array"].includes(n2) && ("url" in i2 || "tiles" in i2 || a2.push(new e.a3(o2, i2, 'Either "url" or "tiles" is required.'))), n2) {
            case "vector":
            case "raster":
            case "raster-dem":
            case "raster-array":
              return a2 = a2.concat(ye({ key: o2, value: i2, valueSpec: s2[`source_${n2.replace("-", "_")}`], style: t2.style, styleSpec: s2, objectElementValidators: he })), a2;
            case "geojson":
              if (a2 = ye({ key: o2, value: i2, valueSpec: s2.source_geojson, style: r2, styleSpec: s2, objectElementValidators: he }), "cluster" in i2 && "clusterProperties" in i2) {
                if (!e.H(i2.clusterProperties)) return [new e.V(`${o2}.clusterProperties`, i2, `object expected, ${e.K(i2)} found`)];
                for (const t3 in i2.clusterProperties) {
                  const s3 = i2.clusterProperties[t3];
                  if (!Array.isArray(s3)) return [new e.V(`${o2}.clusterProperties.${t3}`, s3, "array expected")];
                  const [r3, n3] = s3, l2 = "string" == typeof r3 ? [r3, ["accumulated"], ["get", t3]] : r3;
                  a2.push(...Q({ key: `${o2}.${t3}.map`, value: n3, expressionContext: "cluster-map" })), a2.push(...Q({ key: `${o2}.${t3}.reduce`, value: l2, expressionContext: "cluster-reduce" }));
                }
              }
              return a2;
            case "video":
              return ye({ key: o2, value: i2, valueSpec: s2.source_video, style: r2, styleSpec: s2 });
            case "image":
              return ye({ key: o2, value: i2, valueSpec: s2.source_image, style: r2, styleSpec: s2 });
            case "canvas":
              return [new e.V(o2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ie({ key: `${o2}.type`, value: i2.type, valueSpec: { values: ue(s2) } });
          }
        }
        function ue(e2) {
          return e2.source.reduce((t2, i2) => {
            const o2 = e2[i2];
            return "enum" === o2.type.type && (t2 = t2.concat(Object.keys(o2.type.values || {}))), t2;
          }, []);
        }
        function _e(t2) {
          const i2 = t2.value, o2 = t2.styleSpec, s2 = o2.light, r2 = t2.style;
          if (void 0 === i2) return [];
          if (!e.H(i2)) return [new e.V("light", i2, `object expected, ${e.K(i2)} found`)];
          let n2 = [];
          for (const t3 in i2) {
            const a2 = t3.match(/^(.*)-transition$/), l2 = t3.match(/^(.*)-use-theme$/);
            n2 = n2.concat(l2 && s2[l2[1]] ? ve({ key: t3, value: i2[t3], valueSpec: { type: "string" }, style: r2, styleSpec: o2 }) : a2 && s2[a2[1]] && s2[a2[1]].transition ? ve({ key: t3, value: i2[t3], valueSpec: o2.transition, style: r2, styleSpec: o2 }) : s2[t3] ? ve({ key: t3, value: i2[t3], valueSpec: s2[t3], style: r2, styleSpec: o2 }) : [new e.V(t3, i2[t3], `unknown property "${t3}"`)]);
          }
          return n2;
        }
        function pe(t2) {
          const i2 = t2.value;
          if (!i2) return [];
          const o2 = t2.key;
          if (!e.H(i2)) return [new e.V(o2, i2, `object expected, ${e.K(i2)} found`)];
          let s2 = [];
          const r2 = t2.styleSpec, n2 = r2["light-3d"], a2 = t2.style, l2 = t2.style.lights;
          for (const t3 of ["type", "id"]) if (!(t3 in i2)) return s2 = s2.concat([new e.V(o2, i2, `missing property "${t3}"`)]), s2;
          if (!e.a0(i2.type)) return s2 = s2.concat([new e.V(`${o2}.type`, i2.type, "string expected")]), s2;
          if (l2) for (let r3 = 0; r3 < t2.arrayIndex; r3++) {
            const t3 = e.J(i2.type), n3 = l2[r3];
            e.J(n3.type) === t3 && s2.push(new e.V(o2, i2.id, `duplicate light type "${i2.type}", previously defined at line ${n3.id.__line__}`));
          }
          const c2 = `properties_light_${i2.type}`;
          if (!(c2 in r2)) return s2 = s2.concat([new e.V(`${o2}.type`, i2, `Invalid light type ${i2.type}`)]), s2;
          const h2 = r2[c2];
          for (const o3 in i2) if ("properties" === o3) {
            const n3 = i2[o3];
            if (!e.H(n3)) return s2 = s2.concat([new e.V("properties", n3, `object expected, ${e.K(n3)} found`)]), s2;
            for (const l3 in n3) {
              const c3 = l3.match(/^(.*)-transition$/), d2 = l3.match(/^(.*)-use-theme$/);
              s2 = s2.concat(d2 && h2[d2[1]] ? ve({ key: o3, value: n3[l3], valueSpec: { type: "string" }, style: a2, styleSpec: r2 }) : c3 && h2[c3[1]] && h2[c3[1]].transition ? ve({ key: o3, value: i2[o3], valueSpec: r2.transition, style: a2, styleSpec: r2 }) : h2[l3] ? ve({ key: l3, value: n3[l3], valueSpec: h2[l3], style: a2, styleSpec: r2 }) : [new e.a3(t2.key, n3[l3], `unknown property "${l3}"`)]);
            }
          } else s2 = s2.concat(n2[o3] ? ve({ key: o3, value: i2[o3], valueSpec: n2[o3], style: a2, styleSpec: r2 }) : [new e.a3(o3, i2[o3], `unknown property "${o3}"`)]);
          return s2;
        }
        function fe(t2) {
          const i2 = t2.value, o2 = t2.key, s2 = t2.style, r2 = t2.styleSpec, n2 = r2.terrain;
          if (null == i2) return [];
          if (!e.H(i2)) return [new e.V("terrain", i2, `object expected, ${e.K(i2)} found`)];
          let a2 = [];
          for (const t3 in i2) {
            const o3 = t3.match(/^(.*)-transition$/), l2 = t3.match(/^(.*)-use-theme$/);
            a2 = a2.concat(l2 && n2[l2[1]] ? ve({ key: t3, value: i2[t3], valueSpec: { type: "string" }, style: s2, styleSpec: r2 }) : o3 && n2[o3[1]] && n2[o3[1]].transition ? ve({ key: t3, value: i2[t3], valueSpec: r2.transition, style: s2, styleSpec: r2 }) : n2[t3] ? ve({ key: t3, value: i2[t3], valueSpec: n2[t3], style: s2, styleSpec: r2 }) : [new e.a3(t3, i2[t3], `unknown property "${t3}"`)]);
          }
          if (i2.source) if (e.a0(i2.source)) {
            const t3 = s2.sources && s2.sources[i2.source], r3 = t3 && e.J(t3.type);
            t3 ? "raster-dem" !== r3 && a2.push(new e.V(`${o2}.source`, i2.source, `terrain cannot be used with a source of type ${r3}, it only be used with a "raster-dem" source type`)) : a2.push(new e.V(`${o2}.source`, i2.source, `source "${i2.source}" not found`));
          } else a2.push(new e.V(`${o2}.source`, i2.source, "source must be a string"));
          else a2.push(new e.V(o2, i2, 'terrain is missing required property "source"'));
          return a2;
        }
        function me(t2) {
          const i2 = t2.value, o2 = t2.style, s2 = t2.styleSpec, r2 = s2.fog;
          if (void 0 === i2) return [];
          if (!e.H(i2)) return [new e.V("fog", i2, `object expected, ${e.K(i2)} found`)];
          let n2 = [];
          for (const t3 in i2) {
            const a2 = t3.match(/^(.*)-transition$/), l2 = t3.match(/^(.*)-use-theme$/);
            n2 = n2.concat(l2 && r2[l2[1]] ? ve({ key: t3, value: i2[t3], valueSpec: { type: "string" }, style: o2, styleSpec: s2 }) : a2 && r2[a2[1]] && r2[a2[1]].transition ? ve({ key: t3, value: i2[t3], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r2[t3] ? ve({ key: t3, value: i2[t3], valueSpec: r2[t3], style: o2, styleSpec: s2 }) : [new e.a3(t3, i2[t3], `unknown property "${t3}"`)]);
          }
          return n2;
        }
        const ge = { "*": () => [], array: Y, boolean: function(t2) {
          const i2 = t2.value, o2 = t2.key;
          return e.$(i2) ? [] : [new e.V(o2, i2, `boolean expected, ${e.K(i2)} found`)];
        }, number: K, color: function({ key: t2, value: i2 }) {
          return e.a0(i2) ? null === e.a1.parseCSSColor(i2) ? [new e.V(t2, i2, `color expected, "${i2}" found`)] : [] : [new e.V(t2, i2, `color expected, ${e.K(i2)} found`)];
        }, enum: ie, filter: oe, function: J, layer: le, object: ye, source: de, model: e.a7, light: _e, "light-3d": pe, terrain: fe, fog: me, string: ce, formatted: function(e2) {
          return 0 === ce(e2).length ? [] : Q(e2);
        }, resolvedImage: function(e2) {
          return 0 === ce(e2).length ? [] : Q(e2);
        }, projection: function(t2) {
          const i2 = t2.value, o2 = t2.styleSpec, s2 = o2.projection, r2 = t2.style;
          if (e.H(i2)) {
            let e2 = [];
            for (const t3 in i2) e2 = e2.concat(ve({ key: t3, value: i2[t3], valueSpec: s2[t3], style: r2, styleSpec: o2 }));
            return e2;
          }
          return e.a0(i2) ? [] : [new e.V("projection", i2, `object or string expected, ${e.K(i2)} found`)];
        }, import: function(t2) {
          const i2 = t2.key, { value: o2, styleSpec: s2 } = t2;
          if (!e.H(o2)) return [new e.V(i2, o2, "import must be an object")];
          const { data: r2, ...n2 } = o2;
          Object.defineProperty(n2, "__line__", { value: o2.__line__, enumerable: false });
          let a2 = ye(Object.assign({}, t2, { value: n2, valueSpec: s2.import }));
          return "" === e.J(n2.id) && a2.push(new e.V(`${t2.key}.id`, n2, "import id can't be an empty string")), r2 && (a2 = a2.concat(be(r2, s2, { key: `${t2.key}.data` }))), a2;
        }, iconset: function(t2) {
          const i2 = t2.value, o2 = t2.key, s2 = t2.styleSpec, r2 = t2.style;
          if (!e.H(i2)) return [new e.V(o2, i2, "object expected")];
          if (!i2.type) return [new e.V(o2, i2, '"type" is required')];
          const n2 = e.J(i2.type);
          let a2 = [];
          if (a2 = a2.concat(ye({ key: o2, value: i2, valueSpec: s2[`iconset_${n2}`], style: r2, styleSpec: s2 })), function(e2, t3) {
            return !("source" !== e2 || !t3.source);
          }(n2, i2)) {
            const t3 = r2.sources && r2.sources[i2.source], s3 = t3 && e.J(t3.type);
            t3 ? "raster-array" !== s3 && a2.push(new e.V(o2, i2.source, `iconset cannot be used with a source of type ${String(s3)}, it only be used with a "raster-array" source type`)) : a2.push(new e.V(o2, i2.source, `source "${i2.source}" not found`));
          }
          return a2;
        } };
        function ve(t2, i2 = false) {
          const o2 = t2.value, s2 = t2.valueSpec, r2 = t2.styleSpec;
          if (s2.expression) {
            if (e.a4(e.J(o2))) return J(t2);
            if (e.Q(e.S(o2))) return Q(t2);
          }
          if (s2.type && ge[s2.type]) {
            const e2 = ge[s2.type](t2);
            return true === i2 && e2.length > 0 && Array.isArray(t2.value) ? Q(t2) : e2;
          }
          return ye(Object.assign({}, t2, { valueSpec: s2.type ? r2[s2.type] : s2 }));
        }
        function ye(t2) {
          const i2 = t2.key, o2 = t2.value, s2 = t2.valueSpec || {}, r2 = t2.objectElementValidators || {}, n2 = t2.style, a2 = t2.styleSpec;
          if (!e.H(o2)) return [new e.V(i2, o2, `object expected, ${e.K(o2)} found`)];
          let l2 = [];
          for (const t3 in o2) {
            const c2 = t3.split(".")[0];
            let h2;
            r2[c2] ? h2 = r2[c2] : s2[c2] ? h2 = ve : r2["*"] ? h2 = r2["*"] : s2["*"] && (h2 = ve), h2 ? l2 = l2.concat(h2({ key: (i2 ? `${i2}.` : i2) + t3, value: o2[t3], valueSpec: s2[c2] || s2["*"], style: n2, styleSpec: a2, object: o2, objectKey: t3 }, o2)) : l2.push(new e.a3(i2, o2[t3], `unknown property "${t3}"`));
          }
          for (const t3 in s2) {
            if (r2[t3]) continue;
            const n3 = s2[t3];
            n3.required && void 0 === n3.default && void 0 === o2[t3] && l2.push(new e.V(i2, o2, `missing required property "${t3}"`));
          }
          return l2;
        }
        function xe({ key: t2, value: i2 }) {
          const o2 = ce({ key: t2, value: i2 });
          if (o2.length) return o2;
          const s2 = i2;
          return -1 === s2.indexOf("{fontstack}") && o2.push(new e.V(t2, i2, '"glyphs" url must include a "{fontstack}" token')), -1 === s2.indexOf("{range}") && o2.push(new e.V(t2, i2, '"glyphs" url must include a "{range}" token')), o2;
        }
        function be(t2, i2 = e.a6, o2 = {}) {
          return ye({ key: o2.key || "", value: t2, valueSpec: Object.assign(i2.$root, { "*": { type: "*" } }), styleSpec: i2, style: t2, objectElementValidators: { glyphs: xe } });
        }
        function we(t2, i2 = e.a6) {
          return Me(be(t2, i2));
        }
        const Te = (e2) => Me(de(e2)), Ee = (e2) => Me(_e(e2)), Se = (e2) => Me(pe(e2)), Ie = (e2) => Me(fe(e2)), Ce = (e2) => Me(me(e2)), Re = (t2) => Me(function(t3) {
          const i2 = t3.value, o2 = t3.style, s2 = t3.styleSpec, r2 = s2.snow;
          if (void 0 === i2) return [];
          if (!e.H(i2)) return [new e.V("snow", i2, `object expected, ${e.K(i2)} found`)];
          let n2 = [];
          for (const t4 in i2) {
            const a2 = t4.match(/^(.*)-transition$/);
            n2 = n2.concat(a2 && r2[a2[1]] && r2[a2[1]].transition ? ve({ key: t4, value: i2[t4], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r2[t4] ? ve({ key: t4, value: i2[t4], valueSpec: r2[t4], style: o2, styleSpec: s2 }) : [new e.a3(t4, i2[t4], `unknown property "${t4}"`)]);
          }
          return n2;
        }(t2)), Ae = (t2) => Me(function(t3) {
          const i2 = t3.value, o2 = t3.style, s2 = t3.styleSpec, r2 = s2.rain;
          if (void 0 === i2) return [];
          if (!e.H(i2)) return [new e.V("rain", i2, `object expected, ${e.K(i2)} found`)];
          let n2 = [];
          for (const t4 in i2) {
            const a2 = t4.match(/^(.*)-transition$/);
            n2 = n2.concat(a2 && r2[a2[1]] && r2[a2[1]].transition ? ve({ key: t4, value: i2[t4], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r2[t4] ? ve({ key: t4, value: i2[t4], valueSpec: r2[t4], style: o2, styleSpec: s2 }) : [new e.a3(t4, i2[t4], `unknown property "${t4}"`)]);
          }
          return n2;
        }(t2)), Le = (e2) => Me(le(e2)), De = (e2) => Me(oe(e2)), Pe = (e2) => Me(ne(e2)), Oe = (e2) => Me(ae(e2)), ze = (t2) => Me(e.a7(t2));
        function Me(e2) {
          return e2.slice().sort((e3, t2) => e3.line && t2.line ? e3.line - t2.line : 0);
        }
        function Fe(t2, i2) {
          let o2 = false;
          if (i2 && i2.length) for (const s2 of i2) s2 instanceof e.a3 ? e.w(s2.message) : (t2.fire(new e.y(new Error(s2.message))), o2 = true);
          return o2;
        }
        const Be = e.a6.light;
        let ke;
        class Ne extends e.E {
          constructor(t2, i2 = "flat") {
            super(), this._transitionable = new e.a8(ke || (ke = new e.a9({ anchor: new e.aa(Be.anchor), position: new e.ab(Be.position), color: new e.aa(Be.color), intensity: new e.aa(Be.intensity) }))), this.setLight(t2, i2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e2, t2, i2 = {}) {
            this._validate(Ee, e2, i2) || (this._transitionable.setTransitionOrValue(e2), this.id = t2);
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && Fe(this, t2.call(we, Object.assign({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a6 })));
          }
        }
        const Ue = e.a6.terrain;
        let je = class extends e.E {
          constructor(t2, i2, o2, s2, r2) {
            super(), this.scope = o2, this._transitionable = new e.a8(new e.a9({ source: new e.aa(Ue.source), exaggeration: new e.aa(Ue.exaggeration) }), o2, s2), this._transitionable.setTransitionOrValue(t2, s2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2, this.worldview = r2;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(e2, t2) {
            this._transitionable.setTransitionOrValue(e2, t2);
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          getExaggeration(t2) {
            return this._transitioning.possiblyEvaluate(new e.ac(t2, { worldview: this.worldview })).get("exaggeration");
          }
          getAttenuationRange() {
            if (!this.isZoomDependent()) return null;
            const t2 = this._transitionable._values.exaggeration;
            if (!t2) return null;
            const i2 = t2.value.expression;
            if (!i2) return null;
            let o2 = -1, s2 = -1, r2 = 1;
            for (const t3 of i2.zoomStops) r2 = i2.evaluate(new e.ac(t3, { worldview: this.worldview })), r2 > 0.01 ? (o2 = t3, s2 = -1) : s2 = t3;
            return r2 < 0.01 && o2 > 0 && s2 > o2 ? [o2, s2] : null;
          }
          isZoomDependent() {
            const t2 = this._transitionable._values.exaggeration;
            return null != t2 && null != t2.value && null != t2.value.expression && t2.value.expression instanceof e.ad;
          }
        };
        const Ve = 0.05;
        function Ge(t2, i2, o2, s2) {
          const r2 = e.ah(45, 65, o2), [n2, a2] = He(t2, s2);
          let l2 = 1 - Math.min(1, Math.exp((i2 - n2) / (a2 - n2) * -6));
          return l2 *= l2 * l2, l2 = Math.min(1, 1.00747 * l2), l2 * r2 * t2.alpha;
        }
        function He(e2, t2) {
          const i2 = 0.5 / Math.tan(0.5 * t2);
          return [e2.range[0] + i2, e2.range[1] + i2];
        }
        function qe(t2, i2, o2, s2, r2) {
          const n2 = e.af([], [i2, o2, s2], r2.mercatorFogMatrix);
          return Ge(t2, e.ag(n2), r2.pitch, r2._fov);
        }
        function Ze(t2, i2, o2, s2, r2, n2, a2) {
          const l2 = [[o2, s2, 0], [r2, s2, 0], [r2, n2, 0], [o2, n2, 0]];
          let c2 = Number.MAX_VALUE, h2 = -Number.MAX_VALUE;
          for (const t3 of l2) {
            const o3 = e.af([], t3, i2), s3 = e.ag(o3);
            c2 = Math.min(c2, s3), h2 = Math.max(h2, s3);
          }
          return [Ge(t2, c2, a2.pitch, a2._fov), Ge(t2, h2, a2.pitch, a2._fov)];
        }
        const We = e.a6.fog;
        class $e extends e.E {
          constructor(t2, i2, o2, s2) {
            super();
            const r2 = new e.a9({ range: new e.aa(We.range), color: new e.aa(We.color), "color-use-theme": new e.aa({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new e.aa(We["high-color"]), "high-color-use-theme": new e.aa({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new e.aa(We["space-color"]), "space-color-use-theme": new e.aa({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new e.aa(We["horizon-blend"]), "star-intensity": new e.aa(We["star-intensity"]), "vertical-range": new e.aa(We["vertical-range"]) });
            this._transitionable = new e.a8(r2, o2, new Map(s2)), this.set(t2, s2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2, this.properties = new e.ai(r2), this.scope = o2;
          }
          get state() {
            const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.aj(t2.zoom), s2 = this.properties.get("range"), r2 = [0.5, 3];
            return { range: i2 ? [e.ak(r2[0], s2[0], o2), e.ak(r2[1], s2[1], o2)] : s2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(e2, t2, i2 = {}) {
            if (this._validate(Ce, e2, i2)) return;
            const o2 = Object.assign({}, e2);
            for (const e3 of Object.keys(We)) void 0 === o2[e3] && (o2[e3] = We[e3].default);
            this._options = o2, this._transitionable.setTransitionOrValue(this._options, t2);
          }
          getOpacity(t2) {
            if (!this._transform.projection.supportsFog) return 0;
            const i2 = this.properties && this.properties.get("color") || 1;
            return ("globe" === this._transform.projection.name ? 1 : e.ah(45, 65, t2)) * i2.a;
          }
          getOpacityAtLatLng(t2, i2) {
            return this._transform.projection.supportsFog ? function(t3, i3, o2) {
              const s2 = e.ae.fromLngLat(i3), r2 = o2.elevation ? o2.elevation.getAtPointOrZero(s2) : 0;
              return qe(t3, s2.x, s2.y, r2, o2);
            }(this.state, t2, i2) : 0;
          }
          getOpacityForTile(t2) {
            if (!this._transform.projection.supportsFog) return [1, 1];
            const i2 = this._transform.calculateFogTileMatrix(t2.toUnwrapped());
            return Ze(this.state, i2, 0, 0, e.al, e.al, this._transform);
          }
          getOpacityForBounds(e2, t2, i2, o2, s2) {
            return this._transform.projection.supportsFog ? Ze(this.state, e2, t2, i2, o2, s2, this._transform) : [1, 1];
          }
          getFovAdjustedRange(e2) {
            return this._transform.projection.supportsFog ? He(this.state, e2) : [0, 1];
          }
          isVisibleOnFrustum(t2) {
            if (!this._transform.projection.supportsFog) return false;
            const i2 = [4, 5, 6, 7];
            for (const o2 of i2) {
              const i3 = t2.points[o2];
              let s2;
              if (i3[2] >= 0) s2 = i3;
              else {
                const r2 = t2.points[o2 - 4];
                s2 = e.am(r2, i3, r2[2] / (r2[2] - i3[2]));
              }
              if (qe(this.state, s2[0], s2[1], 0, this._transform) >= Ve) return true;
            }
            return false;
          }
          updateConfig(e2) {
            this._transitionable.setTransitionOrValue(this._options, new Map(e2));
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && Fe(this, t2.call(we, Object.assign({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a6 })));
          }
        }
        let Xe, Ye, Ke, Je = class extends e.E {
          constructor(t2, i2, o2, s2) {
            super();
            const r2 = Xe || (Xe = new e.a9({ density: new e.aa(e.a6.snow.density), intensity: new e.aa(e.a6.snow.intensity), color: new e.aa(e.a6.snow.color), opacity: new e.aa(e.a6.snow.opacity), vignette: new e.aa(e.a6.snow.vignette), "vignette-color": new e.aa(e.a6.snow["vignette-color"]), "center-thinning": new e.aa(e.a6.snow["center-thinning"]), direction: new e.aa(e.a6.snow.direction), "flake-size": new e.aa(e.a6.snow["flake-size"]) }));
            this._transitionable = new e.a8(r2, o2, new Map(s2)), this.set(t2, s2), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r2), this.scope = o2;
          }
          get state() {
            const t2 = this.properties.get("opacity"), i2 = this.properties.get("color"), o2 = this.properties.get("direction"), s2 = e.an(o2[0]), r2 = -Math.max(e.an(o2[1]), 0.01), n2 = [Math.cos(s2) * Math.cos(r2), Math.sin(s2) * Math.cos(r2), Math.sin(r2)], a2 = this.properties.get("vignette"), l2 = this.properties.get("vignette-color");
            return l2.a = a2, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new e.ao(i2.r, i2.g, i2.b, i2.a * t2), direction: n2, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: l2 };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t2, i2, o2 = {}) {
            if (this._validate(Re, t2, o2)) return;
            const s2 = Object.assign({}, t2), r2 = e.a6.snow;
            for (const e2 of Object.keys(r2)) void 0 === s2[e2] && (s2[e2] = r2[e2].default);
            this._options = s2, this._transitionable.setTransitionOrValue(this._options, i2);
          }
          updateConfig(e2) {
            this._transitionable.setTransitionOrValue(this._options, new Map(e2));
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && Fe(this, t2.call(we, Object.assign({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a6 })));
          }
        }, Qe = class extends e.E {
          constructor(t2, i2, o2, s2) {
            super();
            const r2 = Ye || (Ye = new e.a9({ density: new e.aa(e.a6.rain.density), intensity: new e.aa(e.a6.rain.intensity), color: new e.aa(e.a6.rain.color), opacity: new e.aa(e.a6.rain.opacity), vignette: new e.aa(e.a6.rain.vignette), "vignette-color": new e.aa(e.a6.rain["vignette-color"]), "center-thinning": new e.aa(e.a6.rain["center-thinning"]), direction: new e.aa(e.a6.rain.direction), "droplet-size": new e.aa(e.a6.rain["droplet-size"]), "distortion-strength": new e.aa(e.a6.rain["distortion-strength"]) }));
            this._transitionable = new e.a8(r2, o2, new Map(s2)), this.set(t2, s2), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r2), this.scope = o2;
          }
          get state() {
            const t2 = this.properties.get("opacity"), i2 = this.properties.get("color"), o2 = this.properties.get("direction"), s2 = e.an(o2[0]), r2 = -Math.max(e.an(o2[1]), 0.01), n2 = [Math.cos(s2) * Math.cos(r2), Math.sin(s2) * Math.cos(r2), Math.sin(r2)], a2 = this.properties.get("vignette-color");
            return a2.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new e.ao(i2.r, i2.g, i2.b, i2.a * t2), direction: n2, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: a2 };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t2, i2, o2 = {}) {
            if (this._validate(Ae, t2, o2)) return;
            const s2 = Object.assign({}, t2), r2 = e.a6.rain;
            for (const e2 of Object.keys(r2)) void 0 === s2[e2] && (s2[e2] = r2[e2].default);
            this._options = s2, this._transitionable.setTransitionOrValue(this._options, i2);
          }
          updateConfig(e2) {
            this._transitionable.setTransitionOrValue(this._options, new Map(e2));
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && Fe(this, t2.call(we, Object.assign({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a6 })));
          }
        };
        class et extends e.E {
          constructor(t2, i2, o2, s2) {
            super(), this.scope = o2, this._options = t2, this.properties = new e.ai(i2), this._transitionable = new e.a8(i2, o2, new Map(s2)), this._transitionable.setTransitionOrValue(t2.properties), this._transitioning = this._transitionable.untransitioned();
          }
          updateConfig(e2) {
            this._transitionable.setTransitionOrValue(this._options.properties, new Map(e2));
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          get() {
            return this._options.properties = this._transitionable.serialize(), this._options;
          }
          set(e2, t2) {
            this._options = e2, this._transitionable.setTransitionOrValue(e2.properties, t2);
          }
          shadowsEnabled() {
            return !!this.properties && true === this.properties.get("cast-shadows");
          }
        }
        const tt = () => Ke || (Ke = new e.a9({ color: new e.aa(e.a6.properties_light_ambient.color), "color-use-theme": new e.aa({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new e.aa(e.a6.properties_light_ambient.intensity) }));
        let it;
        const ot = () => it || (it = new e.a9({ direction: new e.ap(e.a6.properties_light_directional.direction), color: new e.aa(e.a6.properties_light_directional.color), "color-use-theme": new e.aa({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new e.aa(e.a6.properties_light_directional.intensity), "cast-shadows": new e.aa(e.a6.properties_light_directional["cast-shadows"]), "shadow-quality": new e.aa(e.a6.properties_light_directional["shadow-quality"]), "shadow-intensity": new e.aa(e.a6.properties_light_directional["shadow-intensity"]), "shadow-draw-before-layer": new e.aa(e.a6.properties_light_directional["shadow-draw-before-layer"]) }));
        class st {
          constructor(e2, t2, i2) {
            this.screenBounds = e2, this.cameraPoint = i2.getCameraPoint(), this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = t2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, i2);
          }
          static createFromScreenPoints(t2, i2) {
            let o2, s2;
            if (t2 instanceof e.P || "number" == typeof t2[0]) {
              const r2 = e.P.convert(t2);
              o2 = [r2], s2 = i2.isPointAboveHorizon(r2);
            } else {
              const r2 = e.P.convert(t2[0]), n2 = e.P.convert(t2[1]), a2 = r2.add(n2)._div(2);
              o2 = [r2, n2], s2 = e.aq(r2, n2).every((e2) => i2.isPointAboveHorizon(e2)) && i2.isPointAboveHorizon(a2);
            }
            return new st(o2, s2, i2);
          }
          isPointQuery() {
            return 1 === this.screenBounds.length;
          }
          bufferedScreenGeometry(t2) {
            return e.aq(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
          }
          bufferedCameraGeometry(t2) {
            const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s2 = e.aq(i2, o2, 0, false);
            return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? s2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? s2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (s2[3] = this.cameraPoint)), e.ar(s2, t2);
          }
          bufferedCameraGeometryGlobe(t2) {
            const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s2 = e.aq(i2, o2, t2), r2 = this.cameraPoint.clone();
            switch (3 * ((r2.y > i2.y) + (r2.y > o2.y)) + ((r2.x > i2.x) + (r2.x > o2.x))) {
              case 0:
                s2[0] = r2, s2[4] = r2.clone();
                break;
              case 1:
                s2.splice(1, 0, r2);
                break;
              case 2:
                s2[1] = r2;
                break;
              case 3:
                s2.splice(4, 0, r2);
                break;
              case 5:
                s2.splice(2, 0, r2);
                break;
              case 6:
                s2[3] = r2;
                break;
              case 7:
                s2.splice(3, 0, r2);
                break;
              case 8:
                s2[2] = r2;
            }
            return s2;
          }
          containsTile(t2, i2, o2, s2 = 0) {
            const r2 = Math.max(t2.queryPadding, t2.evaluateQueryRenderedFeaturePadding()) / i2._pixelsPerMercatorPixel + 1, n2 = o2 ? this._bufferedCameraMercator(r2, i2) : this._bufferedScreenMercator(r2, i2);
            let a2 = t2.tileID.wrap + (n2.unwrapped ? s2 : 0);
            const l2 = n2.polygon.map((i3) => e.as(t2.tileTransform, i3, a2));
            if (!e.at(l2, 0, 0, e.al, e.al)) return;
            a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s2 : 0);
            const c2 = this.screenGeometryMercator.polygon.map((i3) => e.au(t2.tileTransform, i3, a2)), h2 = c2.map((t3) => new e.P(t3[0], t3[1])), d2 = i2.getFreeCameraOptions().position || new e.ae(0, 0, 0), u2 = e.au(t2.tileTransform, d2, a2), _2 = c2.map((t3) => {
              const i3 = e.av(t3, t3, u2);
              return e.aw(i3, i3), new e.ax(u2, i3);
            }), p2 = e.ay(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: h2, tilespaceRays: _2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (f2 = e.az(l2), f2.min.x = e.aA(f2.min.x, 0, e.al), f2.min.y = e.aA(f2.min.y, 0, e.al), f2.max.x = e.aA(f2.max.x, 0, e.al), f2.max.y = e.aA(f2.max.y, 0, e.al), f2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
            var f2;
          }
          _bufferedScreenMercator(e2, t2) {
            const i2 = at(e2);
            if (this._screenRaycastCache[i2]) return this._screenRaycastCache[i2];
            {
              let o2;
              return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
            }
          }
          _bufferedCameraMercator(e2, t2) {
            const i2 = at(e2);
            if (this._cameraRaycastCache[i2]) return this._cameraRaycastCache[i2];
            {
              let o2;
              return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
            }
          }
          _projectAndResample(t2, i2) {
            const o2 = function(t3, i3) {
              const o3 = e.aB([], i3.pixelMatrix, i3.globeMatrix), s3 = [0, -e.aD, 0, 1], r2 = [0, e.aD, 0, 1], n2 = [0, 0, 0, 1];
              e.aC(s3, s3, o3), e.aC(r2, r2, o3), e.aC(n2, n2, o3);
              const a2 = new e.P(s3[0] / s3[3], s3[1] / s3[3]), l2 = new e.P(r2[0] / r2[3], r2[1] / r2[3]), c2 = e.aE(t3, a2) && s3[3] < n2[3], h2 = e.aE(t3, l2) && r2[3] < n2[3];
              if (!c2 && !h2) return null;
              const d2 = function(e2, t4, i4) {
                for (let o4 = 1; o4 < e2.length; o4++) {
                  const s4 = nt(t4.pointCoordinate3D(e2[o4 - 1]).x), r3 = nt(t4.pointCoordinate3D(e2[o4]).x);
                  if (i4 < 0) {
                    if (s4 < r3) return { idx: o4, t: -s4 / (r3 - 1 - s4) };
                  } else if (r3 < s4) return { idx: o4, t: (1 - s4) / (r3 + 1 - s4) };
                }
                return null;
              }(t3, i3, c2 ? -1 : 1);
              if (!d2) return null;
              const { idx: u2, t: _2 } = d2;
              let p2 = u2 > 1 ? rt(t3.slice(0, u2), i3) : [], f2 = u2 < t3.length ? rt(t3.slice(u2), i3) : [];
              p2 = p2.map((t4) => new e.P(nt(t4.x), t4.y)), f2 = f2.map((t4) => new e.P(nt(t4.x), t4.y));
              const m2 = [...p2];
              0 === m2.length && m2.push(f2[f2.length - 1]);
              const g2 = e.ak(m2[m2.length - 1].y, (0 === f2.length ? p2[0] : f2[0]).y, _2);
              let v2;
              return v2 = c2 ? [new e.P(0, g2), new e.P(0, 0), new e.P(1, 0), new e.P(1, g2)] : [new e.P(1, g2), new e.P(1, 1), new e.P(0, 1), new e.P(0, g2)], m2.push(...v2), 0 === f2.length ? m2.push(p2[0]) : m2.push(...f2), { polygon: m2.map((t4) => new e.ae(t4.x, t4.y)), unwrapped: false };
            }(t2, i2);
            if (o2) return o2;
            const s2 = function(t3, i3) {
              let o3 = false, s3 = -1 / 0, r2 = 0;
              for (let e2 = 0; e2 < t3.length - 1; e2++) t3[e2].x > s3 && (s3 = t3[e2].x, r2 = e2);
              for (let e2 = 0; e2 < t3.length - 1; e2++) {
                const i4 = (r2 + e2) % (t3.length - 1), s4 = t3[i4], n3 = t3[i4 + 1];
                Math.abs(s4.x - n3.x) > 0.5 && (s4.x < n3.x ? (s4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (n3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
              }
              const n2 = e.aF(i3.center.lng);
              return o3 && n2 < Math.abs(n2 - 1) && t3.forEach((e2) => {
                e2.x -= 1;
              }), { polygon: t3, unwrapped: o3 };
            }(rt(t2, i2).map((t3) => new e.P(nt(t3.x), t3.y)), i2);
            return { polygon: s2.polygon.map((t3) => new e.ae(t3.x, t3.y)), unwrapped: s2.unwrapped };
          }
        }
        function rt(t2, i2) {
          return e.aG(t2, (e2) => {
            const t3 = i2.pointCoordinate3D(e2);
            e2.x = t3.x, e2.y = t3.y;
          }, 1 / 256);
        }
        function nt(e2) {
          return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
        }
        function at(e2) {
          return 100 * e2 | 0;
        }
        function lt(t2, i2, o2, s2, r2) {
          const n2 = function(o3, s3) {
            if (o3) return r2(o3);
            if (s3) {
              if (t2.url && s3.tiles && t2.tiles && delete t2.tiles, s3.variants) {
                if (!Array.isArray(s3.variants)) return r2(new Error("variants must be an array"));
                for (const e2 of s3.variants) {
                  if (null == e2 || "object" != typeof e2 || e2.constructor !== Object) return r2(new Error("variant must be an object"));
                  if (!Array.isArray(e2.capabilities)) return r2(new Error("capabilities must be an array"));
                  if (1 === e2.capabilities.length && "meshopt" === e2.capabilities[0]) {
                    s3 = Object.assign(s3, e2);
                    break;
                  }
                }
              }
              const o4 = e.aH(Object.assign({}, s3, t2), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "extra_bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
              o4.tiles = i2.canonicalizeTileset(o4, t2.url), r2(null, o4);
            }
          }, a2 = function(e2, t3, i3) {
            if (!e2) return null;
            if (!t3 && !i3) return e2;
            i3 = i3 || e2.worldview_default;
            const o3 = Object.values(e2.language || {});
            if (0 === o3.length) return null;
            const s3 = Object.values(e2.worldview || {});
            if (0 === s3.length) return null;
            const r3 = o3.every((e3) => e3 === t3), n3 = s3.every((e3) => e3 === i3);
            return r3 && n3 ? e2 : t3 in (e2.language_options || {}) || i3 in (e2.worldview_options || {}) ? null : e2.language_options && e2.worldview_options ? e2 : null;
          }(t2.data, o2, s2);
          return a2 ? e.o.frame(() => n2(null, a2)) : t2.url ? e.m(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, s2), e.R.Source), n2) : e.o.frame(() => {
            const { data: e2, ...i3 } = t2;
            n2(null, i3);
          });
        }
        function ct(t2, i2) {
          const o2 = Math.pow(2, i2.z), s2 = Math.floor(e.aF(t2.getWest()) * o2), r2 = Math.floor(e.aJ(t2.getNorth()) * o2), n2 = Math.ceil(e.aF(t2.getEast()) * o2), a2 = Math.ceil(e.aJ(t2.getSouth()) * o2);
          return i2.x >= s2 && i2.x < n2 && i2.y >= r2 && i2.y < a2;
        }
        class ht {
          constructor(t2, i2, o2) {
            this.bounds = t2 ? e.aI.convert(this.validateBounds(t2)) : null, this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
          }
          validateBounds(e2) {
            return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
          }
          addExtraBounds(t2) {
            if (t2) {
              this.extraBounds || (this.extraBounds = []);
              for (const i2 of t2) this.extraBounds.push(e.aI.convert(this.validateBounds(i2)));
            }
          }
          contains(e2) {
            if (e2.z > this.maxzoom || e2.z < this.minzoom) return false;
            if (this.bounds && !ct(this.bounds, e2)) return false;
            if (!this.extraBounds) return true;
            for (const t2 of this.extraBounds) if (ct(t2, e2)) return true;
            return false;
          }
          static fromTileJSON(e2) {
            if (!e2.bounds && !e2.extra_bounds) return null;
            const t2 = new ht(e2.bounds, e2.minzoom, e2.maxzoom);
            return t2.addExtraBounds(e2.extra_bounds), t2;
          }
        }
        class dt extends e.E {
          constructor(t2, i2, o2, s2) {
            if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, Object.assign(this, e.aH(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = Object.assign({ type: "vector" }, i2), this._collectResourceTiming = !!i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(s2), this._tileWorkers = {}, this._deduped = new e.aK();
          }
          load(t2) {
            this._loaded = false, this.fire(new e.z("dataloading", { dataType: "source" }));
            const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map.getWorldview();
            this._tileJSONRequest = lt(this._options, this.map._requestManager, i2, o2, (s2, r2) => {
              if (this._tileJSONRequest = null, this._loaded = true, s2) i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.y(s2));
              else if (r2) {
                if (Object.assign(this, r2), this.hasWorldviews = !!r2.worldview_options, r2.worldview_default && (this.worldviewDefault = r2.worldview_default), r2.vector_layers) {
                  this.vectorLayers = r2.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                  for (const e2 of r2.vector_layers) this.vectorLayerIds.push(e2.id), r2.worldview && r2.worldview[e2.source] && this.localizableLayerIds.add(e2.id);
                }
                this.tileBounds = ht.fromTileJSON(r2), P(r2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.z("data", { dataType: "source", sourceDataType: "content" }));
              }
              t2 && t2(s2);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t2 = e.B(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t2));
          }
          setTiles(e2) {
            return this._options.tiles = e2, this.reload(), this;
          }
          setUrl(e2) {
            return this.url = e2, this._options.url = e2, this.reload(), this;
          }
          onRemove(e2) {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return Object.assign({}, this._options);
          }
          loadTile(t2, i2) {
            const o2 = t2.tileID.canonical.url(this.tiles, this.scheme), s2 = this.map._requestManager.normalizeTileURL(o2), r2 = this.map._requestManager.transformRequest(s2, e.R.Tile), n2 = this.map.style ? this.map.style.getLut(this.scope) : null, a2 = n2 ? { image: n2.image.clone() } : null, l2 = { request: r2, data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, lut: a2, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e.o.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t2.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor(), worldview: this.map.getWorldview() || this.worldviewDefault, indoor: this.map.getIndoorTileOptions(this.id, this.scope) };
            if (this.hasWorldviews && e.h(o2) && (l2.localizableLayerIds = this.localizableLayerIds), l2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state) "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", l2, c2.bind(this));
            else if (t2.actor = this._tileWorkers[s2] = this._tileWorkers[s2] || this.dispatcher.getActor(), this.dispatcher.ready) t2.request = t2.actor.send("loadTile", l2, c2.bind(this), void 0, true);
            else {
              const i3 = e.aL.call({ deduped: this._deduped }, l2, (i4, o3) => {
                if (i4 || !o3) c2.call(this, i4);
                else {
                  const i5 = e.aM(o3.responseHeaders);
                  l2.data = { rawData: o3.rawData.slice(0), expires: i5.expires, cacheControl: i5.cacheControl }, t2.actor && t2.actor.send("loadTile", l2, c2.bind(this), void 0, true);
                }
              }, true);
              t2.request = { cancel: i3 };
            }
            function c2(o3, s3) {
              return delete t2.request, t2.aborted ? i2(null) : o3 && o3 instanceof e.aN && 404 !== o3.status ? i2(o3) : (s3 && s3.resourceTiming && (t2.resourceTiming = s3.resourceTiming), this.map._refreshExpiredTiles && s3 && t2.setExpiryData(s3), t2.loadVectorData(s3, this.map.painter), e.aO(this.dispatcher), i2(null, s3), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
            }
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope });
          }
          unloadTile(e2, t2) {
            e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope }), e2.destroy();
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class ut extends e.E {
          constructor(t2, i2, o2, s2) {
            super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(s2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = Object.assign({ type: "raster" }, i2), Object.assign(this, e.aH(i2, ["url", "scheme", "tileSize"]));
          }
          load(t2) {
            this._loaded = false, this.fire(new e.z("dataloading", { dataType: "source" }));
            const i2 = this.map.getWorldview();
            this._tileJSONRequest = lt(this._options, this.map._requestManager, null, i2, (i3, o2) => {
              this._tileJSONRequest = null, this._loaded = true, i3 ? this.fire(new e.y(i3)) : o2 && (Object.assign(this, o2), o2.raster_layers && (this.rasterLayers = o2.raster_layers, this.rasterLayerIds = this.rasterLayers.map((e2) => e2.id)), this.tileBounds = ht.fromTileJSON(o2), P(o2.tiles), this.fire(new e.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.z("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i3);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t2 = e.B(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t2));
          }
          setTiles(e2) {
            return this._options.tiles = e2, this.reload(), this;
          }
          setUrl(e2) {
            return this.url = e2, this._options.url = e2, this.reload(), this;
          }
          onRemove(e2) {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return Object.assign({}, this._options);
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(t2, i2) {
            const o2 = e.o.devicePixelRatio >= 2, s2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
            t2.request = e.n(this.map._requestManager.transformRequest(s2, e.R.Tile), (o3, s3, r2) => {
              if (delete t2.request, t2.aborted) return t2.state = "unloaded", i2(null);
              if (o3) return t2.state = "errored", i2(o3);
              if (!s3) return i2(null);
              const n2 = e.aM(r2);
              this.map._refreshExpiredTiles && t2.setExpiryData(n2), t2.setTexture(s3, this.map.painter), t2.state = "loaded", e.aO(this.dispatcher), i2(null);
            });
          }
          abortTile(e2, t2) {
            e2.request && (e2.request.cancel(), delete e2.request), t2 && t2();
          }
          unloadTile(t2, i2) {
            t2.texture && t2.texture instanceof e.T ? (t2.destroy(false), t2.texture && t2.texture instanceof e.T && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), i2 && i2();
          }
          hasTransition() {
            return false;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        function _t([t2, i2], o2, s2, { scaled: r2 = true } = {}) {
          const { tileSize: n2, buffer: a2 } = s2, { x: l2, y: c2, z: h2 } = o2;
          if (!isFinite(l2) || !isFinite(c2) || !isFinite(h2)) throw new Error("Invalid MRT header");
          const d2 = 2 ** h2, u2 = d2 * e.aF(t2), _2 = d2 * e.aJ(i2);
          return function([e2, t3], i3, { scaled: o3 = true } = {}) {
            if (!i3) throw new Error("bandView is undefined");
            const { data: s3, tileSize: r3, buffer: n3, offset: a3, scale: l3, dimension: c3 } = i3;
            if (e2 < -n3 || e2 > r3 + n3 || t3 < -n3 || t3 > r3 + n3) throw new Error(`Point (${e2}, ${t3}) out of bounds for tileSize=${r3}, buffer=${n3}`);
            const h3 = (t3 + n3) * (r3 + 2 * n3) + (e2 + n3);
            if (4294967295 === new Uint32Array(s3.buffer)[h3]) return null;
            let d3 = [];
            d3 = o3 ? [] : new (0, i3.data.constructor)(c3);
            for (let e3 = 0; e3 < c3; e3++) d3[e3] = Math.round(1e12 * (s3[c3 * h3 + e3] * l3 + a3)) / 1e12;
            return d3;
          }([Math.min(Math.max(-a2, Math.floor((u2 - l2) * n2)), n2 - 1 + a2), Math.min(Math.max(-a2, Math.floor((_2 - c2) * n2)), n2 - 1 + a2)], s2, { scaled: r2 });
        }
        class pt extends ut {
          constructor(e2, t2, i2, o2) {
            super(e2, t2, i2, o2), this.type = "raster-array", this.maxzoom = 22, this.partial = true, this._loadTilePending = {}, this._loadTileLoaded = {}, this._options = Object.assign({ type: "raster-array" }, t2);
          }
          triggerRepaint(e2) {
            const t2 = this.map.painter._terrain, i2 = this.map.style.getSourceCache(this.id);
            t2 && t2.enabled && i2 && t2._clearRenderCacheForTile(i2.id, e2.tileID), this.map.triggerRepaint();
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), s2 = this.map._requestManager.transformRequest(o2, e.R.Tile), r2 = { request: s2, uid: t2.uid, tileID: t2.tileID, type: this.type, source: this.id, scope: this.scope, partial: this.partial };
            t2.source = this.id, t2.scope = this.scope, t2.requestParams = s2, t2.actor || (t2.actor = this.dispatcher.getActor());
            const n2 = (o3, s3, r3) => {
              if (delete t2.request, t2.aborted) return t2.state = "unloaded", i2(null);
              if (o3) {
                if ("AbortError" === o3.name) return;
                return t2.state = "errored", i2(o3);
              }
              if (this.map._refreshExpiredTiles && s3) {
                const i3 = e.aM(r3);
                t2.setExpiryData(i3);
              }
              if (this.partial && "expired" !== t2.state) t2.state = "empty";
              else if (!this.partial) {
                if (!s3) return i2(null);
                t2.state = "loaded", t2._isHeaderLoaded = true, t2._mrt = s3;
              }
              i2(null);
            };
            t2.request = this.partial ? t2.fetchHeader(void 0, n2.bind(this)) : t2.actor.send("loadTile", r2, n2.bind(this), void 0, true);
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope });
          }
          unloadTile(e2, t2) {
            const i2 = e2.texturePerLayer;
            if (e2.flushAllQueues(), i2.size) {
              e2.destroy(false);
              for (const e3 of i2.values()) this.map.painter.saveTileTexture(e3);
            } else e2.destroy();
          }
          prepareTile(t2, i2, o2, s2) {
            t2._isHeaderLoaded && ("empty" !== t2.state && (t2.state = "reloading"), t2.fetchBandForRender(i2, o2, s2, (i3, s3) => {
              if (i3) return t2.state = "errored", this.fire(new e.y(i3)), void this.triggerRepaint(t2);
              s3 && (t2._isHeaderLoaded = true, t2.setTexturePerLayer(o2, s3, this.map.painter), t2.state = "loaded", this.triggerRepaint(t2));
            }));
          }
          getInitialBand(e2) {
            if (!this.rasterLayers) return 0;
            const t2 = this.rasterLayers.find(({ id: t3 }) => t3 === e2), i2 = t2 && t2.fields, o2 = i2 && i2.bands && i2.bands;
            return o2 ? o2[0] : 0;
          }
          getTextureDescriptor(t2, i2, o2) {
            if (!t2) return;
            const s2 = i2.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
            if (!s2) return;
            let r2 = null;
            i2 instanceof e.aR ? r2 = i2.paint.get("raster-array-band") : i2 instanceof e.aS && (r2 = i2.paint.get("raster-particle-array-band"));
            const n2 = r2 || this.getInitialBand(s2);
            if (null == n2) return;
            if (!t2.textureDescriptorPerLayer.get(i2.id)) return void this.prepareTile(t2, s2, i2.id, n2);
            if (t2.updateNeeded(i2.id, n2) && !o2) return;
            const a2 = t2.textureDescriptorPerLayer.get(i2.id);
            return Object.assign({}, a2, { texture: t2.texturePerLayer.get(i2.id) });
          }
          getImages(t2, i2) {
            const o2 = /* @__PURE__ */ new Map();
            for (const s2 of t2) for (const t3 of i2) {
              const [i3, r2] = t3.split("/"), n2 = s2.getLayer(i3);
              if (!n2) continue;
              if (!n2.hasBand(r2) || !n2.hasDataForBand(r2)) continue;
              const { bytes: a2, tileSize: l2, buffer: c2 } = n2.getBandView(r2), h2 = l2 + 2 * c2, d2 = { data: new e.q({ width: h2, height: h2 }, a2), pixelRatio: 2, sdf: false, usvg: false, version: 0 };
              o2.set(t3, d2);
            }
            return o2;
          }
          queryRasterArrayValueByBandId(t2, i2, o2) {
            const s2 = i2._mrt;
            return new Promise((r2) => {
              const n2 = {}, a2 = /* @__PURE__ */ new Set();
              for (const [l2, c2] of Object.entries(s2.layers)) {
                if (o2.layerName && l2 !== o2.layerName) continue;
                const h2 = {};
                n2[l2] = h2;
                for (const { bands: d2 } of c2.dataIndex) for (const u2 of d2) o2.bands && !o2.bands.includes(u2) || (a2.add(e.B(l2, u2)), i2.fetchBand(l2, null, u2, (i3) => {
                  e.o.frame(() => {
                    h2[u2] = i3 ? null : _t([t2.lng, t2.lat], s2, c2.getBandView(u2)), a2.delete(e.B(l2, u2)), 0 === a2.size && r2(n2);
                  });
                }, false));
              }
              0 === a2.size && r2(n2);
            });
          }
          _loadTileForQuery(t2, i2) {
            if (this._loadTileLoaded[t2.uid]) return void i2(null, t2._mrt);
            if (this._loadTilePending[t2.uid]) return void this._loadTilePending[t2.uid].push(i2);
            this._loadTilePending[t2.uid] = [i2];
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), s2 = this.map._requestManager.transformRequest(o2, e.R.Tile);
            t2.actor.send("loadTile", { request: s2, uid: t2.uid, tileID: t2.tileID, type: this.type, source: this.id, scope: this.scope, partial: false }, (i3, o3, s3) => {
              if (i3) return this._loadTilePending[t2.uid].forEach((e2) => e2(i3, null)), void delete this._loadTilePending[t2.uid];
              if (!o3) return this._loadTilePending[t2.uid].forEach((e2) => e2(null, null)), void delete this._loadTilePending[t2.uid];
              if (this.map._refreshExpiredTiles && o3) {
                const i4 = e.aM(s3);
                t2.setExpiryData(i4);
              }
              t2._mrt = o3, t2._isHeaderLoaded = true, t2.state = "loaded", this._loadTilePending[t2.uid].forEach((e2) => e2(null, o3)), this._loadTileLoaded[t2.uid] = true, delete this._loadTilePending[t2.uid];
            }, void 0, true);
          }
          queryRasterArrayValueByAllBands(e2, t2, i2) {
            return new Promise((o2, s2) => {
              this._loadTileForQuery(t2, (r2, n2) => {
                r2 ? s2(r2) : o2(n2 ? this.queryRasterArrayValueByBandId(e2, t2, i2) : null);
              });
            });
          }
          queryRasterArrayValue(t2, i2) {
            const o2 = e.aT.convert(t2), s2 = this.findLoadedParent(o2);
            return s2 && s2._mrt ? i2.bands || !this.partial ? this.queryRasterArrayValueByBandId(o2, s2, i2) : this.queryRasterArrayValueByAllBands(o2, s2, i2) : Promise.resolve(null);
          }
          findLoadedParent(t2) {
            const i2 = e.ae.fromLngLat(t2, this.map.transform.tileSize), o2 = this.maxzoom + 1, s2 = 1 << o2, r2 = Math.floor(i2.x), n2 = Math.floor((i2.x - r2) * s2), a2 = Math.floor(i2.y * s2), l2 = this.map.style.getSourceCache(this.id), c2 = new e.aQ(o2, r2, o2, n2, a2);
            return l2.findLoadedParent(c2, this.minzoom);
          }
        }
        const ft = { vector: dt, raster: ut, "raster-dem": class extends ut {
          constructor(e2, t2, i2, o2) {
            super(e2, t2, i2, o2), this.type = "raster-dem", this.maxzoom = 22, this._options = Object.assign({ type: "raster-dem" }, t2), this.encoding = t2.encoding || "mapbox";
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function s2(e2, o3) {
              e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
            }
            t2.request = e.n(this.map._requestManager.transformRequest(o2, e.R.Tile), (function(o3, r2, n2) {
              if (delete t2.request, t2.aborted) t2.state = "unloaded", i2(null);
              else if (o3) t2.state = "errored", i2(o3);
              else if (r2) {
                const i3 = e.aM(n2);
                this.map._refreshExpiredTiles && t2.setExpiryData(i3);
                const o4 = ImageBitmap && r2 instanceof ImageBitmap && e.r(), a2 = 1 - (r2.width - e.aP(r2.width)) / 2;
                a2 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
                const l2 = o4 ? r2 : e.o.getImageData(r2, a2), c2 = { uid: t2.uid, tileID: t2.tileID, source: this.id, type: this.type, scope: this.scope, rawImageData: l2, encoding: this.encoding, padding: a2 };
                t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadTile", c2, s2.bind(this), void 0, true));
              }
            }).bind(this));
          }
          _getNeighboringTiles(t2) {
            const i2 = t2.canonical, o2 = Math.pow(2, i2.z), s2 = (i2.x - 1 + o2) % o2, r2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, n2 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
            return l2[new e.aQ(t2.overscaledZ, r2, i2.z, s2, i2.y).key] = { backfilled: false }, l2[new e.aQ(t2.overscaledZ, a2, i2.z, n2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.aQ(t2.overscaledZ, r2, i2.z, s2, i2.y - 1).key] = { backfilled: false }, l2[new e.aQ(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.aQ(t2.overscaledZ, a2, i2.z, n2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.aQ(t2.overscaledZ, r2, i2.z, s2, i2.y + 1).key] = { backfilled: false }, l2[new e.aQ(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.aQ(t2.overscaledZ, a2, i2.z, n2, i2.y + 1).key] = { backfilled: false }), l2;
          }
        }, "raster-array": pt, geojson: class extends e.E {
          constructor(t2, i2, o2, s2) {
            super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(s2), this._data = i2.data, this._options = Object.assign({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), void 0 !== i2.minzoom && (this.minzoom = i2.minzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            const r2 = e.al / this.tileSize;
            this.workerOptions = Object.assign({ source: this.id, scope: this.scope, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * r2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * r2, extent: e.al, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.al, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * r2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter, dynamic: i2.dynamic }, i2.workerOptions);
          }
          onAdd(e2) {
            this.map = e2, this.setData(this._data);
          }
          setData(e2) {
            return this._data = e2, this._updateWorkerData(), this;
          }
          updateData(t2) {
            if (!this._options.dynamic) return this.fire(new e.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
            if ("string" != typeof t2 && ("Feature" === t2.type && (t2 = { type: "FeatureCollection", features: [t2] }), "FeatureCollection" !== t2.type)) return this.fire(new e.y(new Error("Data to update should be a feature or a feature collection.")));
            if (this._coalesce && "string" != typeof t2 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
              const e2 = /* @__PURE__ */ new Map();
              for (const t3 of this._data.features) e2.set(t3.id, t3);
              for (const i2 of t2.features) e2.set(i2.id, i2);
              this._data.features = [...e2.values()];
            } else this._data = t2;
            return this._updateWorkerData(true), this;
          }
          getClusterExpansionZoom(e2, t2) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id, scope: this.scope }, t2), this;
          }
          getClusterChildren(e2, t2) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id, scope: this.scope }, t2), this;
          }
          getClusterLeaves(e2, t2, i2, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e2, limit: t2, offset: i2 }, o2), this;
          }
          _updateWorkerData(t2 = false) {
            if (this._pendingLoad) return void (this._coalesce = true);
            this.fire(new e.z("dataloading", { dataType: "source" })), this._loaded = false;
            const i2 = Object.assign({ append: t2 }, this.workerOptions);
            i2.scope = this.scope;
            const o2 = this._data;
            "string" == typeof o2 ? (i2.request = this.map._requestManager.transformRequest(e.o.resolveURL(o2), e.R.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i2, (i3, o3) => {
              if (this._loaded = true, this._pendingLoad = null, i3) this.fire(new e.y(i3));
              else {
                const i4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (i4.resourceTiming = o3.resourceTiming[this.id]), t2 && (this._partialReload = true), this.fire(new e.z("data", i4)), this._partialReload = false, this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(t2), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          reload() {
            const t2 = e.B(this.id, this.scope);
            this.map.style.clearSource(t2), this._updateWorkerData();
          }
          loadTile(t2, i2) {
            const o2 = t2.actor ? "reloadTile" : "loadTile";
            t2.actor = this.actor;
            const s2 = this.map.style ? this.map.style.getLut(this.scope) : null, r2 = s2 ? { image: s2.image.clone() } : null, n2 = this._partialReload, a2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: r2, scope: this.scope, pixelRatio: e.o.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t2.isExtraShadowCaster, scaleFactor: this.map.getScaleFactor(), partial: n2, worldview: this.map.getWorldview(), indoor: this.map.getIndoorTileOptions(this.id, this.scope) };
            t2.request = this.actor.send(o2, a2, (e2, s3) => n2 && !s3 ? (t2.state = "loaded", i2(null)) : (delete t2.request, t2.destroy(false), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(s3, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
          }
          unloadTile(e2, t2) {
            this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope }), e2.destroy();
          }
          onRemove(e2) {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return Object.assign({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends e.aU {
          constructor(e2, t2, i2, o2) {
            super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
          }
          load() {
            this._loaded = false;
            const t2 = this.options;
            this.urls = [];
            for (const i2 of t2.urls) this.urls.push(this.map._requestManager.transformRequest(i2, e.R.Source).url);
            e.aV(this.urls, (t3, i2) => {
              this._loaded = true, t3 ? this.fire(new e.y(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t2) {
            if (this.video) {
              const i2 = this.video.seekable;
              t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.y(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e2) {
            this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t2, this.video, i2.RGBA8), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: e.aU, model: e.aX, "batched-model": class extends e.E {
          constructor(e2, t2, i2, o2) {
            super(), this.type = "batched-model", this.id = e2, this.tileSize = 512, this._options = t2, this.tiles = this._options.tiles, this.maxzoom = t2.maxzoom || 19, this.minzoom = t2.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i2, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o2);
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t2 = e.B(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t2));
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          load(t2) {
            this._loaded = false, this.fire(new e.z("dataloading", { dataType: "source" }));
            const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map.getWorldview();
            this._tileJSONRequest = lt(this._options, this.map._requestManager, i2, o2, (s2, r2) => {
              this._tileJSONRequest = null, this._loaded = true, s2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.y(s2))) : r2 && (Object.assign(this, r2), r2.bounds && (this.tileBounds = new ht(r2.bounds, this.minzoom, this.maxzoom)), P(r2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.z("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(s2);
            });
          }
          hasTransition() {
            return false;
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), s2 = { request: this.map._requestManager.transformRequest(o2, e.R.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, pixelRatio: e.o.devicePixelRatio, promoteId: this.promoteId };
            if (t2.actor && "expired" !== t2.state) if ("loading" === t2.state) t2.reloadCallback = i2;
            else {
              if (t2.buckets) {
                const e2 = Object.values(t2.buckets);
                for (const t3 of e2) t3.dirty = true;
                return void (t2.state = "loaded");
              }
              t2.request = t2.actor.send("reloadTile", s2, r2.bind(this));
            }
            else t2.actor = this.dispatcher.getActor(), t2.request = t2.actor.send("loadTile", s2, r2.bind(this), void 0, true);
            function r2(e2, o3) {
              return t2.aborted ? i2(null) : e2 && 404 !== e2.status ? i2(e2) : (this.map._refreshExpiredTiles && o3 && t2.setExpiryData(o3), t2.loadModelData(o3, this.map.painter), t2.state = "loaded", void i2(null));
            }
          }
          serialize() {
            return Object.assign({}, this._options);
          }
        }, canvas: class extends e.aU {
          constructor(t2, i2, o2, s2) {
            super(t2, i2, o2, s2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.y(new e.V(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.y(new e.V(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.y(new e.V(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.y(new e.V(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.y(new e.V(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e2) {
            this.map = e2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove(e2) {
            this.pause();
          }
          prepare() {
            let t2 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i2 = this.map.painter.context;
            this.texture ? !t2 && !this._playing || this.texture instanceof e.aW || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.T(i2, this.canvas, i2.gl.RGBA8, { premultiply: true }), this._prepareData(i2);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e2 of [this.canvas.width, this.canvas.height]) if (isNaN(e2) || e2 <= 0) return true;
            return false;
          }
        }, custom: class extends e.E {
          constructor(t2, i2, o2, s2) {
            super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(s2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new ht(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), Object.assign(this, e.aH(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e.aH(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = true, this.fire(new e.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.z("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this.map = t2, this._loaded = false, this.fire(new e.z("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
          }
          onRemove(e2) {
            this._implementation.onRemove && this._implementation.onRemove(e2);
          }
          hasTile(e2) {
            if (this._implementation.hasTile) {
              const { x: t2, y: i2, z: o2 } = e2.canonical;
              return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
            }
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(e2, t2) {
            const { x: i2, y: o2, z: s2 } = e2.tileID.canonical, r2 = new AbortController();
            e2.request = Promise.resolve(this._implementation.loadTile({ x: i2, y: o2, z: s2 }, { signal: r2.signal })).then((function(i3) {
              return delete e2.request, e2.aborted ? (e2.state = "unloaded", t2(null)) : void 0 === i3 ? (e2.state = "errored", t2(null)) : null === i3 ? (this.loadTileData(e2, { width: this.tileSize, height: this.tileSize, data: null }), e2.state = "loaded", t2(null)) : function(e3) {
                return e3 instanceof ImageData || e3 instanceof HTMLCanvasElement || e3 instanceof ImageBitmap || e3 instanceof HTMLImageElement;
              }(i3) ? (this.loadTileData(e2, i3), e2.state = "loaded", void t2(null)) : (e2.state = "errored", t2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }).bind(this)).catch((i3) => {
              "AbortError" !== i3.name && (e2.state = "errored", t2(i3));
            }), e2.request.cancel = () => r2.abort();
          }
          loadTileData(e2, t2) {
            e2.setTexture(t2, this.map.painter);
          }
          unloadTile(t2, i2) {
            if (t2.texture && t2.texture instanceof e.T ? (t2.destroy(false), t2.texture && t2.texture instanceof e.T && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), this._implementation.unloadTile) {
              const { x: e2, y: i3, z: o2 } = t2.tileID.canonical;
              this._implementation.unloadTile({ x: e2, y: i3, z: o2 });
            }
            i2 && i2();
          }
          abortTile(e2, t2) {
            e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2 && t2();
          }
          hasTransition() {
            return false;
          }
          _coveringTiles() {
            return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
          }
          _clearTiles() {
            const t2 = e.B(this.id, this.scope);
            this.map.style.clearSource(t2);
          }
          _update() {
            this.fire(new e.z("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, mt = function(t2, i2, o2, s2) {
          const r2 = new ft[i2.type](t2, i2, o2, s2);
          if (r2.id !== t2) throw new Error(`Expected Source id to be ${t2} instead of ${r2.id}`);
          return e.aY(["load", "abort", "unload", "serialize", "prepare"], r2), r2;
        };
        function gt(e2, t2, i2 = "") {
          return `${i2}:${t2.id || ""}:${t2.layer.id}:${function(e3) {
            if ("layerId" in e3) return `layer:${e3.layerId}`;
            {
              const { featuresetId: t3, importId: i3 } = e3;
              return `featureset:${t3}${i3 ? `:import:${i3}` : ""}`;
            }
          }(e2.target)}`;
        }
        function vt(e2, t2, i2, o2 = "") {
          if (e2.uniqueFeatureID) {
            const s2 = gt(e2, t2, o2);
            if (i2.has(s2)) return true;
            i2.add(s2);
          }
          return false;
        }
        function yt(e2, t2, i2, o2, s2 = false, r2 = void 0) {
          const n2 = t2.sourceCache.transform, a2 = t2.sourceCache.tilesIn(e2, t2.has3DLayers, s2);
          a2.sort(wt);
          const l2 = [];
          for (const e3 of a2) {
            const a3 = e3.tile.queryRenderedFeatures(t2, e3, i2, o2, n2, s2, r2);
            Object.keys(a3).length && l2.push({ wrappedTileID: e3.tile.tileID.wrapped().key, queryResults: a3 });
          }
          for (const i3 in t2.layers) {
            const s3 = t2.layers[i3];
            if (s3.styleLayer) {
              const i4 = s3.styleLayer.queryRenderedFeatures(e2, t2.sourceCache, o2);
              Object.keys(i4).length && l2.push({ wrappedTileID: 0, queryResults: i4 });
            }
          }
          return 0 === l2.length ? {} : function(e3) {
            const t3 = {}, i3 = {};
            for (const o3 of e3) {
              const e4 = o3.queryResults, s3 = o3.wrappedTileID, r3 = i3[s3] = i3[s3] || {};
              for (const i4 in e4) {
                const o4 = e4[i4], s4 = r3[i4] = r3[i4] || {}, n3 = t3[i4] = t3[i4] || [];
                for (const e5 of o4) s4[e5.featureIndex] || (s4[e5.featureIndex] = true, n3.push(e5));
              }
            }
            return t3;
          }(l2);
        }
        function xt(e2, t2, i2, o2, s2, r2) {
          const n2 = {}, a2 = o2.queryRenderedSymbols(e2), l2 = [];
          for (const e3 of Object.keys(a2).map(Number)) l2.push(s2[e3]);
          l2.sort(wt);
          for (const e3 of l2) {
            const o3 = e3.featureIndex.lookupSymbolFeatures(a2[e3.bucketInstanceId], e3.bucketIndex, e3.sourceLayerIndex, t2, i2, r2);
            for (const t3 in o3) {
              const i3 = n2[t3] = n2[t3] || [], s3 = o3[t3];
              s3.sort((t4, i4) => {
                const o4 = e3.featureSortOrder;
                if (o4) {
                  const e4 = o4.indexOf(t4.featureIndex);
                  return o4.indexOf(i4.featureIndex) - e4;
                }
                return i4.featureIndex - t4.featureIndex;
              });
              for (const e4 of s3) i3.push(e4);
            }
          }
          return n2;
        }
        function bt(e2, t2) {
          const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], s2 = {};
          for (let e3 = 0; e3 < i2.length; e3++) {
            const r2 = i2[e3], n2 = r2.tileID.canonical.key;
            s2[n2] || (s2[n2] = true, r2.querySourceFeatures(o2, t2));
          }
          return o2;
        }
        function wt(e2, t2) {
          const i2 = e2.tileID, o2 = t2.tileID;
          return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
        }
        function Tt(e2, t2) {
          const i2 = {};
          if (!t2) return i2;
          for (const o2 of e2) {
            const e3 = o2.layerIds.map((e4) => t2.getLayer(e4)).filter(Boolean);
            if (0 !== e3.length) {
              o2.layers = e3, o2.stateDependentLayerIds && (o2.stateDependentLayers = o2.stateDependentLayerIds.map((t3) => e3.filter((e4) => e4.id === t3)[0]));
              for (const t3 of e3) i2[t3.fqid] = o2;
            }
          }
          return i2;
        }
        const Et = 32, St = 33, It = new Uint16Array(8184);
        for (let e2 = 0; e2 < 2046; e2++) {
          let t2 = e2 + 2, i2 = 0, o2 = 0, s2 = 0, r2 = 0, n2 = 0, a2 = 0;
          for (1 & t2 ? s2 = r2 = n2 = Et : i2 = o2 = a2 = Et; (t2 >>= 1) > 1; ) {
            const e3 = i2 + s2 >> 1, l3 = o2 + r2 >> 1;
            1 & t2 ? (s2 = i2, r2 = o2, i2 = n2, o2 = a2) : (i2 = s2, o2 = r2, s2 = n2, r2 = a2), n2 = e3, a2 = l3;
          }
          const l2 = 4 * e2;
          It[l2 + 0] = i2, It[l2 + 1] = o2, It[l2 + 2] = s2, It[l2 + 3] = r2;
        }
        const Ct = new Uint16Array(2178), Rt = new Uint8Array(1089), At = new Uint16Array(1089);
        function Lt(e2) {
          return 0 === e2 ? -0.03125 : 32 === e2 ? 0.03125 : 0;
        }
        const Dt = (() => ({ type: 2, extent: e.al, loadGeometry: () => [[new e.P(0, 0), new e.P(e.al + 1, 0), new e.P(e.al + 1, e.al + 1), new e.P(0, e.al + 1), new e.P(0, 0)]] }))();
        class Pt {
          constructor(t2, i2, o2, s2, r2, n2) {
            this.tileID = t2, this.uid = e.b2(), this.uses = 0, this.tileSize = i2, this.tileZoom = o2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = r2, s2 && s2.style && (this._lastUpdatedBrightness = s2.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", s2 && s2.transform && (this.projection = s2.transform.projection), this.worldview = n2, this._hasAppearances = null;
          }
          registerFadeDuration(t2) {
            const i2 = t2 + this.timeAdded;
            i2 < e.o.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = e.aZ(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t2, i2, o2) {
            if (this.unloadVectorData(), this.state = "loaded", t2) {
              t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = Tt(t2.buckets, i2.style), this.hasSymbolBuckets = false;
              for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.b4) {
                  if (this.hasSymbolBuckets = true, !o2) break;
                  i3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.b4 && i3.hasRTLText) {
                  this.hasRTLText = true, e.b5();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const e2 in this.buckets) {
                const t3 = this.buckets[e2], o3 = i2.style.getOwnLayer(e2);
                if (!o3) continue;
                const s2 = o3.queryRadius(t3);
                this.queryPadding = Math.max(this.queryPadding, s2);
              }
              t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas), this._lastUpdatedBrightness = t2.brightness;
            } else this.collisionBoxArray = new e.b3();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const e2 in this.buckets) this.buckets[e2].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          loadModelData(e2, t2, i2) {
            e2 && (e2.resourceTiming && (this.resourceTiming = e2.resourceTiming), this.buckets = Object.assign({}, this.buckets, Tt(e2.buckets, t2.style)), e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex));
          }
          getBucket(e2) {
            return this.buckets[e2.fqid];
          }
          upload(t2, i2) {
            for (const e2 in this.buckets) {
              const o3 = this.buckets[e2];
              if (o3.uploadPending()) {
                let e3 = {}, s3 = [], r2 = { zoom: 0, pitch: 0, brightness: 0, worldview: "" };
                if (i2) {
                  if (i2.style) {
                    s3 = i2.style.listImages();
                    const t3 = o3.layers[0], r3 = t3.sourceLayer || "_geojsonTileLayer", n2 = i2.style.getLayerSourceCache(t3);
                    n2 && (e3 = n2._state.getState(r3, void 0));
                  }
                  r2 = { zoom: i2.transform.zoom || 0, pitch: i2.transform.pitch || 0, brightness: i2.style.getBrightness() || 0, worldview: i2.worldview || "" };
                }
                o3.upload(t2, this.tileID.canonical, e3, s3, r2);
              }
            }
            const o2 = t2.gl, s2 = this.imageAtlas;
            s2 && !s2.uploaded && (this.imageAtlasTexture = new e.T(t2, s2.image, o2.RGBA8, { useMipmap: !!s2.patternPositions.size }), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t2, this.glyphAtlasImage, o2.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t2, this.lineAtlas.image, o2.R8), this.lineAtlas.uploaded = true);
          }
          prepare(e2, t2, i2) {
            if (this.imageAtlas && this.imageAtlasTexture && t2) {
              const o3 = t2.style.getLut(i2);
              this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture, i2, o3);
            }
            if (!t2 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
            const o2 = t2.style.getBrightness();
            null === this._hasAppearances && (this._hasAppearances = this.hasAppearances(t2)), (this._lastUpdatedBrightness || o2 || this._hasAppearances) && (!this._hasAppearances && this._lastUpdatedBrightness && o2 && Math.abs(this._lastUpdatedBrightness - o2) < 1e-3 || (this.updateBuckets(t2, this._lastUpdatedBrightness !== o2), this._lastUpdatedBrightness = o2));
          }
          evaluateQueryRenderedFeaturePadding() {
            let e2 = 0;
            for (const t2 in this.buckets) {
              const i2 = this.buckets[t2];
              i2.evaluateQueryRenderedFeaturePadding && (e2 = Math.max(e2, i2.evaluateQueryRenderedFeaturePadding()));
            }
            return e2;
          }
          queryRenderedFeatures(t2, i2, o2, s2, r2, n2, a2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
            const l2 = this.evaluateQueryRenderedFeaturePadding(), c2 = function(t3, i3) {
              const o3 = e.bq([], [0.5 * t3.width, 0.5 * -t3.height, 1]);
              return e.br(o3, o3, [1, -1, 0]), e.aB(o3, o3, t3.calculateProjMatrix(i3.toUnwrapped())), Float32Array.from(o3);
            }(r2, this.tileID);
            return this.latestFeatureIndex.query(t2, { tilespaceGeometry: i2, pixelPosMatrix: c2, transform: s2, availableImages: o2, tileTransform: this.tileTransform, worldview: this.worldview, queryRadius: l2, scope: a2 });
          }
          querySourceFeatures(t2, i2) {
            const o2 = this.latestFeatureIndex;
            if (!o2 || !o2.rawTileData) return;
            const s2 = o2.loadVTLayers(), r2 = i2 ? i2.sourceLayer : "", n2 = s2._geojsonTileLayer || s2[r2];
            if (!n2) return;
            const a2 = e.b6(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, d2 = { z: l2, x: c2, y: h2 };
            for (let i3 = 0; i3 < n2.length; i3++) {
              const s3 = n2.feature(i3);
              if (a2.needGeometry) {
                const t3 = e.b7(s3, true);
                if (!a2.filter(new e.ac(this.tileID.overscaledZ, { worldview: this.worldview }), t3, this.tileID.canonical)) continue;
              } else if (!a2.filter(new e.ac(this.tileID.overscaledZ, { worldview: this.worldview }), s3)) continue;
              const u2 = o2.getId(s3, r2), _2 = new e.b8(s3, l2, c2, h2, u2);
              _2.tile = d2, t2.push(_2);
            }
          }
          loaded() {
            return "loaded" === this.state || "errored" === this.state;
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;
          }
          setExpiryData(t2) {
            const i2 = this.expirationTime;
            if (t2.cacheControl) {
              const i3 = e.b9(t2.cacheControl);
              i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
            } else t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
            if (this.expirationTime) {
              const e2 = Date.now();
              let t3 = false;
              if (this.expirationTime > e2) t3 = false;
              else if (i2) if (this.expirationTime < i2) t3 = true;
              else {
                const o2 = this.expirationTime - i2;
                o2 ? this.expirationTime = e2 + Math.max(o2, 3e4) : t3 = true;
              }
              else t3 = true;
              t3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          refreshFeatureState(e2) {
            this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e2 && this.updateBuckets(e2);
          }
          hasAppearances(e2) {
            for (const t2 in this.buckets) if (e2.style.hasLayer(t2) && this.buckets[t2].layers.some((e3) => e3.appearances && e3.appearances.length > 0)) return true;
            return false;
          }
          updateBuckets(t2, i2) {
            if (!this.latestFeatureIndex) return;
            if (!t2.style) return;
            const o2 = t2.style.listImages(), s2 = t2.style.getBrightness();
            for (const r2 in this.buckets) {
              if (!t2.style.hasLayer(r2)) continue;
              const n2 = this.buckets[r2], a2 = n2.layers[0], l2 = a2.sourceLayer || "_geojsonTileLayer", c2 = t2.style.getLayerSourceCache(a2);
              let h2 = {};
              c2 && (h2 = c2._state.getState(l2, void 0));
              const d2 = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, u2 = Object.keys(h2).length > 0 && !i2;
              n2.hasAppearances = n2.layers.some((e2) => e2.appearances && e2.appearances.length > 0);
              const _2 = u2 ? n2.stateDependentLayers : n2.layers;
              if (u2 && 0 !== n2.stateDependentLayers.length || i2) {
                const e2 = this.latestFeatureIndex.loadVTLayers();
                n2.update(h2, e2[l2], o2, d2, _2, i2, s2);
              }
              if (u2 && 0 !== n2.stateDependentLayers.length || i2 || n2.hasAppearances) {
                const e2 = { zoom: t2.transform.zoom, pitch: t2.transform.pitch, brightness: t2.style.getBrightness() || 0, worldview: t2.worldview };
                n2.updateAppearances(this.tileID.canonical, h2, o2, e2, t2.imageManager);
              }
              (n2 instanceof e.ba || n2 instanceof e.bb) && t2._terrain && t2._terrain.enabled && c2 && n2.uploadPending() && t2._terrain._clearRenderCacheForTile(c2.id, this.tileID);
              const p2 = t2 && t2.style && t2.style.getOwnLayer(r2);
              p2 && (this.queryPadding = Math.max(this.queryPadding, p2.queryRadius(n2)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.o.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t2) {
            this.symbolFadeHoldUntil = e.o.now() + t2;
          }
          setTexture(t2, i2) {
            const o2 = i2.context, s2 = o2.gl;
            this.texture = this.texture || i2.getTileTexture(t2.width), this.texture && this.texture instanceof e.T ? this.texture.update(t2) : (this.texture = new e.T(o2, t2, s2.RGBA8, { useMipmap: true }), this.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE));
          }
          setDependencies(e2, t2) {
            const i2 = {};
            for (const e3 of t2) i2[e3] = true;
            this.dependencies[e2] = i2;
          }
          hasDependency(e2, t2) {
            for (const i2 of e2) {
              const e3 = this.dependencies[i2];
              if (e3) {
                for (const i3 of t2) if (e3[i3]) return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t2, i2) {
            if (!i2 || "mercator" === i2.name || this._tileDebugBuffer) return;
            const o2 = e.bc(Dt, this.tileID.canonical, this.tileTransform)[0], s2 = new e.bd(), r2 = new e.be();
            for (let e2 = 0; e2 < o2.length; e2++) {
              const { x: t3, y: i3 } = o2[e2];
              s2.emplaceBack(t3, i3), r2.emplaceBack(e2);
            }
            r2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(r2), this._tileDebugBuffer = t2.createVertexBuffer(s2, e.bf.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, s2.length, r2.length);
          }
          _makeTileBoundsBuffers(t2, i2) {
            if (this._tileBoundsBuffer || !i2 || "mercator" === i2.name) return;
            const o2 = e.bc(Dt, this.tileID.canonical, this.tileTransform)[0];
            let s2, r2;
            if (this.isRaster) {
              const t3 = function(t4, i3) {
                const o3 = e.aZ(t4, i3), s3 = Math.pow(2, t4.z);
                for (let r4 = 0; r4 < St; r4++) for (let n3 = 0; n3 < St; n3++) {
                  const a3 = e.a_((t4.x + (n3 + Lt(n3)) / Et) / s3), l3 = e.a$((t4.y + (r4 + Lt(r4)) / Et) / s3), c3 = i3.project(a3, l3), h2 = r4 * St + n3;
                  Ct[2 * h2 + 0] = Math.round((c3.x * o3.scale - o3.x) * e.al), Ct[2 * h2 + 1] = Math.round((c3.y * o3.scale - o3.y) * e.al);
                }
                Rt.fill(0), At.fill(0);
                for (let e2 = 2045; e2 >= 0; e2--) {
                  const t5 = 4 * e2, i4 = It[t5 + 0], o4 = It[t5 + 1], s4 = It[t5 + 2], r4 = It[t5 + 3], n3 = i4 + s4 >> 1, a3 = o4 + r4 >> 1, l3 = n3 + a3 - o4, c3 = a3 + i4 - n3, h2 = o4 * St + i4, d2 = r4 * St + s4, u2 = a3 * St + n3, _2 = Math.hypot((Ct[2 * h2 + 0] + Ct[2 * d2 + 0]) / 2 - Ct[2 * u2 + 0], (Ct[2 * h2 + 1] + Ct[2 * d2 + 1]) / 2 - Ct[2 * u2 + 1]) >= 16;
                  Rt[u2] = Rt[u2] || (_2 ? 1 : 0), e2 < 1022 && (Rt[u2] = Rt[u2] || Rt[(o4 + c3 >> 1) * St + (i4 + l3 >> 1)] || Rt[(r4 + c3 >> 1) * St + (s4 + l3 >> 1)]);
                }
                const r3 = new e.b1(), n2 = new e.b0();
                let a2 = 0;
                function l2(t5, i4) {
                  const o4 = i4 * St + t5;
                  return 0 === At[o4] && (r3.emplaceBack(Ct[2 * o4 + 0], Ct[2 * o4 + 1], t5 * e.al / Et, i4 * e.al / Et), At[o4] = ++a2), At[o4] - 1;
                }
                function c2(e2, t5, i4, o4, s4, r4) {
                  const a3 = e2 + i4 >> 1, h2 = t5 + o4 >> 1;
                  if (Math.abs(e2 - s4) + Math.abs(t5 - r4) > 1 && Rt[h2 * St + a3]) c2(s4, r4, e2, t5, a3, h2), c2(i4, o4, s4, r4, a3, h2);
                  else {
                    const a4 = l2(e2, t5), c3 = l2(i4, o4), h3 = l2(s4, r4);
                    n2.emplaceBack(a4, c3, h3);
                  }
                }
                return c2(0, 0, Et, Et, Et, 0), c2(Et, Et, 0, 0, 0, Et), { vertices: r3, indices: n2 };
              }(this.tileID.canonical, i2);
              s2 = t3.vertices, r2 = t3.indices;
            } else {
              s2 = new e.b1(), r2 = new e.b0();
              for (const { x: e2, y: t4 } of o2) s2.emplaceBack(e2, t4, 0, 0);
              const t3 = e.bh(s2.int16.subarray(0, 4 * s2.length), void 0, 4);
              for (let e2 = 0; e2 < t3.length; e2 += 3) r2.emplaceBack(t3[e2], t3[e2 + 1], t3[e2 + 2]);
            }
            this._tileBoundsBuffer = t2.createVertexBuffer(s2, e.bi.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(r2), this._tileBoundsSegments = e.bg.simpleSegment(0, 0, s2.length, r2.length);
          }
          _makeGlobeTileDebugBuffers(t2, i2) {
            const o2 = i2.projection;
            if (!o2 || "globe" !== o2.name || i2.freezeTileCoverage) return;
            const s2 = this.tileID.canonical, r2 = e.bj(s2, i2), n2 = e.bk(r2), a2 = e.aj(i2.zoom);
            let l2;
            a2 > 0 && (l2 = e.bl(new Float64Array(16), i2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, s2, i2, n2, l2, a2), this._makeGlobeTileDebugTextBuffer(t2, s2, i2, n2, l2, a2);
          }
          _globePoint(t2, i2, o2, s2, r2, n2, a2) {
            let l2 = e.bm(t2, i2, o2);
            if (n2) {
              const r3 = 1 << o2.z, c2 = e.aF(s2.center.lng), h2 = e.aJ(s2.center.lat), d2 = (o2.x + 0.5) / r3 - c2;
              let u2 = 0;
              d2 > 0.5 ? u2 = -1 : d2 < -0.5 && (u2 = 1);
              let _2 = (t2 / e.al + o2.x) / r3 + u2, p2 = (i2 / e.al + o2.y) / r3;
              _2 = (_2 - c2) * s2._pixelsPerMercatorPixel + c2, p2 = (p2 - h2) * s2._pixelsPerMercatorPixel + h2;
              const f2 = [_2 * s2.worldSize, p2 * s2.worldSize, 0];
              e.af(f2, f2, n2), l2 = e.bn(l2, f2, a2);
            }
            return e.af(l2, l2, r2);
          }
          _makeGlobeTileDebugBorderBuffer(t2, i2, o2, s2, r2, n2) {
            const a2 = new e.bd(), l2 = new e.be(), c2 = new e.bo(), h2 = (e2, t3, h3, d3, u2) => {
              const _2 = (h3 - e2) / (u2 - 1), p2 = (d3 - t3) / (u2 - 1), f2 = a2.length;
              for (let h4 = 0; h4 < u2; h4++) {
                const d4 = e2 + h4 * _2, u3 = t3 + h4 * p2;
                a2.emplaceBack(d4, u3);
                const m2 = this._globePoint(d4, u3, i2, o2, s2, r2, n2);
                c2.emplaceBack(m2[0], m2[1], m2[2]), l2.emplaceBack(f2 + h4);
              }
            }, d2 = e.al;
            h2(0, 0, d2, 0, 16), h2(d2, 0, d2, d2, 16), h2(d2, d2, 0, d2, 16), h2(0, d2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(l2), this._tileDebugBuffer = t2.createVertexBuffer(a2, e.bf.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(c2, e.bp.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, a2.length, l2.length);
          }
          _makeGlobeTileDebugTextBuffer(t2, i2, o2, s2, r2, n2) {
            const a2 = e.al / 4, l2 = new e.bd(), c2 = new e.b0(), h2 = new e.bo(), d2 = 25;
            c2.reserve(32), l2.reserve(d2), h2.reserve(d2);
            const u2 = (e2, t3) => d2 * e2 + t3;
            for (let e2 = 0; e2 < d2; e2++) {
              const t3 = e2 * a2;
              for (let e3 = 0; e3 < d2; e3++) {
                const c3 = e3 * a2;
                l2.emplaceBack(c3, t3);
                const d3 = this._globePoint(c3, t3, i2, o2, s2, r2, n2);
                h2.emplaceBack(d3[0], d3[1], d3[2]);
              }
            }
            for (let e2 = 0; e2 < 4; e2++) for (let t3 = 0; t3 < 4; t3++) {
              const i3 = u2(e2, t3), o3 = u2(e2, t3 + 1), s3 = u2(e2 + 1, t3), r3 = u2(e2 + 1, t3 + 1);
              c2.emplaceBack(i3, o3, s3), c2.emplaceBack(s3, o3, r3);
            }
            this._tileDebugTextIndexBuffer = t2.createIndexBuffer(c2), this._tileDebugTextBuffer = t2.createVertexBuffer(l2, e.bf.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(h2, e.bp.members), this._tileDebugTextSegments = e.bg.simpleSegment(0, 0, d2, 32);
          }
          destroy(t2 = true) {
            for (const e2 in this.buckets) this.buckets[e2].destroy(t2);
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), t2 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.emissiveTexture && this.emissiveTexture instanceof e.T && (this.emissiveTexture.destroy(), delete this.emissiveTexture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        e.bs.setPbf(e.bt);
        class Ot extends Pt {
          constructor(e2, t2, i2, o2, s2) {
            super(e2, t2, i2, o2, s2), this._workQueuePerLayer = /* @__PURE__ */ new Map(), this._fetchQueuePerLayer = /* @__PURE__ */ new Map(), this._taskQueue = /* @__PURE__ */ new Map(), this._isHeaderLoaded = false, this.textureDescriptorPerLayer = /* @__PURE__ */ new Map(), this.texturePerLayer = /* @__PURE__ */ new Map();
          }
          getLayers() {
            return this._mrt ? Object.values(this._mrt.layers) : [];
          }
          getLayer(e2) {
            return this._mrt && this._mrt.getLayer(e2);
          }
          setTexturePerLayer(t2, i2, o2) {
            const s2 = o2.context, r2 = s2.gl;
            let n2 = this.texturePerLayer.get(t2) || o2.getTileTexture(i2.width);
            n2 && n2 instanceof e.T ? n2.update(i2, { premultiply: false }) : n2 = new e.T(s2, i2, r2.RGBA8, { premultiply: false }), this.texturePerLayer.has(t2) || this.texturePerLayer.set(t2, n2);
          }
          flushQueues(e2) {
            const t2 = this._workQueuePerLayer.get(e2) || [], i2 = this._fetchQueuePerLayer.get(e2) || [];
            for (; t2.length; ) t2.pop()();
            for (; i2.length; ) i2.pop()();
          }
          flushAllQueues() {
            for (const e2 of this._workQueuePerLayer.keys()) {
              const t2 = this._workQueuePerLayer.get(e2) || [];
              for (; t2.length; ) t2.pop()();
            }
            for (const e2 of this._fetchQueuePerLayer.keys()) {
              const t2 = this._fetchQueuePerLayer.get(e2) || [];
              for (; t2.length; ) t2.pop()();
            }
          }
          fetchHeader(t2 = 16384, i2) {
            const o2 = this._mrt = new e.bs(30), s2 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t2 - 1) } });
            return this.entireBuffer = null, this.request = e.bu(s2, (e2, s3, r2) => {
              if (e2) i2(e2);
              else try {
                const e3 = o2.getHeaderLength(s3);
                if (e3 > t2) return void (this.request = this.fetchHeader(e3, i2));
                o2.parseHeader(s3), this._isHeaderLoaded = true;
                let n2 = 0;
                for (const e4 of Object.values(o2.layers)) n2 = Math.max(n2, e4.dataIndex[e4.dataIndex.length - 1].lastByte);
                s3.byteLength >= n2 && (this.entireBuffer = s3), i2(null, this.entireBuffer || s3, r2);
              } catch (e3) {
                i2(e3);
              }
            }), this.request;
          }
          fetchBandForRender(e2, t2, i2, o2) {
            this.fetchBand(e2, t2, i2, (s2) => {
              if (s2) return void o2(s2);
              this.updateTextureDescriptor(e2, t2, i2);
              const r2 = this.textureDescriptorPerLayer.get(t2);
              o2(null, r2 ? r2.img : null);
            });
          }
          fetchBand(t2, i2, o2, s2, r2 = true) {
            const n2 = this._mrt;
            if (!this._isHeaderLoaded || !n2) return void s2(new Error("Tile header is not ready"));
            const a2 = this.actor;
            if (!a2) return void s2(new Error("Can't fetch tile band without an actor"));
            let l2;
            const c2 = e.B(String(o2), e.B(this.tileID.key, t2));
            let h2 = this._taskQueue.get(c2);
            h2 ? h2.add(s2) : (h2 = /* @__PURE__ */ new Set(), h2.add(s2), this._taskQueue.set(c2, h2));
            const d2 = (e2, t3) => {
              l2.complete(e2, t3), e2 ? s2(e2) : (h2.forEach((e3) => e3(null, t3)), this._taskQueue.delete(c2));
            }, u2 = (e2, t3) => {
              if (e2) return s2(e2);
              const o3 = a2.send("decodeRasterArray", { type: "raster-array", source: this.source, scope: this.scope, tileID: this.tileID, uid: this.uid, buffer: t3, task: l2 }, d2, void 0, true);
              if (null !== i2) {
                const e3 = this._workQueuePerLayer.get(i2) || [];
                e3.push(() => {
                  o3 && o3.cancel(), l2.cancel();
                }), this._workQueuePerLayer.has(i2) || this._workQueuePerLayer.set(i2, e3);
              }
            };
            let _2;
            try {
              _2 = n2.getLayer(t2);
            } catch (e2) {
              if ("reloading" === this.state) return;
              throw e2;
            }
            if (!_2) return void s2(new Error(`Unknown sourceLayer "${t2}"`));
            if (_2.hasDataForBand(o2)) return h2.forEach((e2) => e2(null, null)), void this._taskQueue.delete(c2);
            const p2 = _2.getDataRange([o2]);
            if (l2 = n2.createDecodingTask(p2), !l2 || l2.tasks.length) if (null !== i2 && this.flushQueues(i2), this.entireBuffer) u2(null, this.entireBuffer.slice(p2.firstByte, p2.lastByte + 1));
            else {
              const t3 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${p2.firstByte}-${p2.lastByte}` } }), o3 = e.bu(t3, u2);
              if (null !== i2) {
                const e2 = this._fetchQueuePerLayer.get(i2) || [];
                e2.push(() => {
                  o3.cancel(), l2.cancel();
                }), this._fetchQueuePerLayer.has(i2) || this._fetchQueuePerLayer.set(i2, e2);
              }
            }
          }
          updateNeeded(e2, t2) {
            return (!this.textureDescriptorPerLayer.get(e2) || this.textureDescriptorPerLayer.get(e2).band !== t2 || this.refreshedUponExpiration) && "errored" !== this.state;
          }
          updateTextureDescriptor(t2, i2, o2) {
            if (!this._mrt) return;
            const s2 = this._mrt.getLayer(t2);
            if (!s2 || !s2.hasBand(o2) || !s2.hasDataForBand(o2)) return;
            const { bytes: r2, tileSize: n2, buffer: a2, offset: l2, scale: c2 } = s2.getBandView(o2), h2 = n2 + 2 * a2, d2 = new e.q({ width: h2, height: h2 }, r2), u2 = this.texturePerLayer.get(i2);
            u2 && u2 instanceof e.T && u2.update(d2, { premultiply: false }), this.textureDescriptorPerLayer.set(i2, { layer: t2, band: o2, img: d2, buffer: a2, offset: l2, tileSize: n2, format: s2.pixelFormat, mix: [c2, 256 * c2, 65536 * c2, 16777216 * c2] });
          }
          destroy(t2 = false) {
            if (super.destroy(t2), delete this._mrt, !t2) for (const t3 of this.texturePerLayer.values()) t3 && t3 instanceof e.T && t3.destroy();
            this.texturePerLayer.clear(), this.textureDescriptorPerLayer.clear(), this.fbo && (this.fbo.destroy(), delete this.fbo), delete this.request, delete this.requestParams, this._isHeaderLoaded = false;
          }
        }
        class zt {
          constructor(e2, t2) {
            this.max = e2, this.onRemove = t2, this.reset();
          }
          reset() {
            for (const e2 in this.data) for (const t2 of this.data[e2]) t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
            return this.data = {}, this.order = [], this;
          }
          add(e2, t2, i2) {
            const o2 = e2.wrapped().key;
            void 0 === this.data[o2] && (this.data[o2] = []);
            const s2 = { value: t2, timeout: void 0 };
            if (void 0 !== i2 && (s2.timeout = setTimeout(() => {
              this.remove(e2, s2);
            }, i2)), this.data[o2].push(s2), this.order.push(o2), this.order.length > this.max) {
              const e3 = this._getAndRemoveByKey(this.order[0]);
              e3 && this.onRemove(e3);
            }
            return this;
          }
          has(e2) {
            return e2.wrapped().key in this.data;
          }
          getAndRemove(e2) {
            return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
          }
          _getAndRemoveByKey(e2) {
            const t2 = this.data[e2].shift();
            return t2.timeout && clearTimeout(t2.timeout), 0 === this.data[e2].length && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
          }
          getByKey(e2) {
            const t2 = this.data[e2];
            return t2 ? t2[0].value : null;
          }
          get(e2) {
            return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
          }
          remove(e2, t2) {
            if (!this.has(e2)) return this;
            const i2 = e2.wrapped().key, o2 = void 0 === t2 ? 0 : this.data[i2].indexOf(t2), s2 = this.data[i2][o2];
            return this.data[i2].splice(o2, 1), s2.timeout && clearTimeout(s2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(s2.value), this.order.splice(this.order.indexOf(i2), 1), this;
          }
          setMaxSize(e2) {
            for (this.max = e2; this.order.length > this.max; ) {
              const e3 = this._getAndRemoveByKey(this.order[0]);
              e3 && this.onRemove(e3);
            }
            return this;
          }
          filter(e2) {
            const t2 = [];
            for (const i2 in this.data) for (const o2 of this.data[i2]) e2(o2.value) || t2.push(o2);
            for (const e3 of t2) this.remove(e3.value.tileID, e3);
          }
        }
        class Mt {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e2, t2, i2) {
            const o2 = String(t2);
            if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][o2] = this.stateChanges[e2][o2] || {}, Object.assign(this.stateChanges[e2][o2], i2), null === this.deletedStates[e2]) {
              this.deletedStates[e2] = {};
              for (const t3 in this.state[e2]) t3 !== o2 && (this.deletedStates[e2][t3] = null);
            } else if (this.deletedStates[e2] && null === this.deletedStates[e2][o2]) {
              this.deletedStates[e2][o2] = {};
              for (const t3 in this.state[e2][o2]) i2[t3] || (this.deletedStates[e2][o2][t3] = null);
            } else for (const t3 in i2) this.deletedStates[e2] && this.deletedStates[e2][o2] && null === this.deletedStates[e2][o2][t3] && delete this.deletedStates[e2][o2][t3];
          }
          removeFeatureState(e2, t2, i2) {
            if (null === this.deletedStates[e2]) return;
            const o2 = String(t2);
            if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2) null !== this.deletedStates[e2][o2] && (this.deletedStates[e2][o2] = this.deletedStates[e2][o2] || {}, this.deletedStates[e2][o2][i2] = null);
            else if (void 0 !== t2) if (this.stateChanges[e2] && this.stateChanges[e2][o2]) for (i2 in this.deletedStates[e2][o2] = {}, this.stateChanges[e2][o2]) this.deletedStates[e2][o2][i2] = null;
            else this.deletedStates[e2][o2] = null;
            else this.deletedStates[e2] = null;
          }
          getState(e2, t2) {
            const i2 = this.state[e2] || {}, o2 = this.stateChanges[e2] || {}, s2 = this.deletedStates[e2];
            if (null === s2) return {};
            if (void 0 !== t2) {
              const e3 = String(t2), r3 = Object.assign({}, i2[e3], o2[e3]);
              if (s2) {
                const e4 = s2[t2];
                if (null === e4) return {};
                for (const t3 in e4) delete r3[t3];
              }
              return r3;
            }
            const r2 = Object.assign({}, i2, o2);
            if (s2) for (const e3 in s2) delete r2[e3];
            return r2;
          }
          initializeTileState(e2, t2) {
            e2.refreshFeatureState(t2);
          }
          coalesceChanges(e2, t2) {
            const i2 = {};
            for (const e3 in this.stateChanges) {
              this.state[e3] = this.state[e3] || {};
              const t3 = {};
              for (const i3 in this.stateChanges[e3]) this.state[e3][i3] || (this.state[e3][i3] = {}), Object.assign(this.state[e3][i3], this.stateChanges[e3][i3]), t3[i3] = this.state[e3][i3];
              i2[e3] = t3;
            }
            for (const e3 in this.deletedStates) {
              this.state[e3] = this.state[e3] || {};
              const t3 = {};
              if (null === this.deletedStates[e3]) for (const i3 in this.state[e3]) t3[i3] = {}, this.state[e3][i3] = {};
              else for (const i3 in this.deletedStates[e3]) {
                if (null === this.deletedStates[e3][i3]) this.state[e3][i3] = {};
                else if (this.state[e3][i3]) for (const t4 of Object.keys(this.deletedStates[e3][i3])) delete this.state[e3][i3][t4];
                t3[i3] = this.state[e3][i3];
              }
              i2[e3] = i2[e3] || {}, Object.assign(i2[e3], t3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i2).length) for (const i3 in e2) e2[i3].refreshFeatureState(t2);
          }
        }
        class Ft extends e.E {
          constructor(e2, t2, i2) {
            super(), this.id = e2, this._onlySymbols = i2, t2.on("data", (e3) => {
              "source" === e3.dataType && "metadata" === e3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e3.dataType && "content" === e3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), t2.on("error", () => {
              this._sourceErrored = true;
            }), this._source = t2, this._tiles = {}, this._cache = new zt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Mt(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
          }
          onAdd(e2) {
            this.map = e2, this._minTileCacheSize = void 0 === this._minTileCacheSize && e2 ? e2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e2 ? e2._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            for (const e2 in this._tiles) if (!this._tiles[e2].loaded()) return false;
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(e2, t2) {
            return e2.isSymbolTile = this._onlySymbols, e2.isExtraShadowCaster = this._shadowCasterTiles[e2.tileID.key], this._source.loadTile(e2, t2);
          }
          _unloadTile(e2) {
            if (this._source.unloadTile) return this._source.unloadTile(e2);
          }
          _abortTile(e2) {
            if (this._source.abortTile) return this._source.abortTile(e2);
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const t2 in this._tiles) {
              const i2 = this._tiles[t2];
              i2.upload(e2, this.map ? this.map.painter : void 0), i2.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e2) => e2.tileID).sort(Bt).map((e2) => e2.key);
          }
          getRenderableIds(t2, i2) {
            const o2 = [];
            for (const e2 in this._tiles) this._isIdRenderable(+e2, t2, i2) && o2.push(this._tiles[e2]);
            return t2 ? o2.sort((t3, i3) => {
              const o3 = t3.tileID, s2 = i3.tileID, r2 = new e.P(o3.canonical.x, o3.canonical.y)._rotate(this.transform.angle), n2 = new e.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle);
              return o3.overscaledZ - s2.overscaledZ || n2.y - r2.y || n2.x - r2.x;
            }).map((e2) => e2.tileID.key) : o2.map((e2) => e2.tileID).sort(Bt).map((e2) => e2.key);
          }
          hasRenderableParent(e2) {
            const t2 = this.findLoadedParent(e2, 0);
            return !!t2 && this._isIdRenderable(t2.tileID.key);
          }
          _isIdRenderable(e2, t2, i2) {
            return this._tiles[e2] && this._tiles[e2].hasData() && !this._coveredTiles[e2] && (t2 || !this._tiles[e2].holdingForFade()) && (i2 || !this._shadowCasterTiles[e2]);
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const e2 in this._tiles) "errored" !== this._tiles[e2].state && this._reloadTile(+e2, "reloading");
            }
          }
          _reloadTile(e2, t2) {
            const i2 = this._tiles[e2];
            i2 && ("loading" !== i2.state && (i2.state = t2), this._loadTile(i2, this._tileLoaded.bind(this, i2, e2, t2)));
          }
          _tileLoaded(t2, i2, o2, s2, r2) {
            if (s2) {
              if (t2.state = "errored", 404 !== s2.status) this._source.fire(new e.y(s2, { tile: t2 }));
              else {
                if (this._source.fire(new e.z("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t2 })), !(t2.tileID.key in this._loadedParentTiles)) return;
                if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                  const e2 = this.map.painter.terrain;
                  this.update(this.transform, e2.getScaledDemTileSize(), true), e2.resetTileLookupCache(this.id);
                } else this.update(this.transform);
              }
              return;
            }
            t2.timeAdded = e.o.now(), "expired" === o2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null);
            let n2 = /* @__PURE__ */ new Map();
            r2 && r2.responseHeaders && (n2 = r2.responseHeaders), this._source.fire(new e.z("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id, responseHeaders: n2 }));
          }
          _backfillDEM(e2) {
            const t2 = this.getRenderableIds();
            for (let o2 = 0; o2 < t2.length; o2++) {
              const s2 = t2[o2];
              if (e2.neighboringTiles && e2.neighboringTiles[s2]) {
                const t3 = this.getTileByID(s2);
                i2(e2, t3), i2(t3, e2);
              }
            }
            function i2(e3, t3) {
              if (!e3.dem || e3.dem.borderReady) return;
              e3.needsHillshadePrepare = true, e3.needsDEMTextureUpload = true;
              let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
              const o2 = t3.tileID.canonical.y - e3.tileID.canonical.y, s2 = Math.pow(2, e3.tileID.canonical.z), r2 = t3.tileID.key;
              0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + s2) ? i3 += s2 : 1 === Math.abs(i3 - s2) && (i3 -= s2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, o2), e3.neighboringTiles && e3.neighboringTiles[r2] && (e3.neighboringTiles[r2].backfilled = true)));
            }
          }
          getTile(e2) {
            return this.getTileByID(e2.key);
          }
          getTileByID(e2) {
            return this._tiles[e2];
          }
          _retainLoadedChildren(e2, t2, i2, o2) {
            for (const s2 in this._tiles) {
              let r2 = this._tiles[s2];
              if (o2[s2] || !r2.hasData() || r2.tileID.overscaledZ <= t2 || r2.tileID.overscaledZ > i2) continue;
              let n2 = r2.tileID;
              for (; r2 && r2.tileID.overscaledZ > t2 + 1; ) {
                const e3 = r2.tileID.scaledTo(r2.tileID.overscaledZ - 1);
                r2 = this._tiles[e3.key], r2 && r2.hasData() && (n2 = e3);
              }
              let a2 = n2;
              for (; a2.overscaledZ > t2; ) if (a2 = a2.scaledTo(a2.overscaledZ - 1), e2[a2.key]) {
                o2[n2.key] = n2;
                break;
              }
            }
          }
          findLoadedParent(e2, t2) {
            if (e2.key in this._loadedParentTiles) {
              const i2 = this._loadedParentTiles[e2.key];
              return i2 && i2.tileID.overscaledZ >= t2 ? i2 : null;
            }
            for (let i2 = e2.overscaledZ - 1; i2 >= t2; i2--) {
              const t3 = e2.scaledTo(i2), o2 = this._getLoadedTile(t3);
              if (o2) return o2;
            }
          }
          _getLoadedTile(e2) {
            const t2 = this._tiles[e2.key];
            return t2 && t2.hasData() ? t2 : this._cache.getByKey(this._source.reparseOverscaled ? e2.wrapped().key : e2.canonical.key);
          }
          updateCacheSize(e2, t2) {
            t2 = t2 || this._source.tileSize;
            const i2 = Math.ceil(e2.width / t2) + 1, o2 = Math.ceil(e2.height / t2) + 1, s2 = Math.floor(i2 * o2 * 5), r2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s2) : s2, n2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r2) : r2;
            this._cache.setMaxSize(n2);
          }
          handleWrapJump(e2) {
            const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
            if (this._prevLng = e2, t2) {
              const e3 = {};
              for (const i2 in this._tiles) {
                const o2 = this._tiles[i2];
                o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t2), e3[o2.tileID.key] = o2;
              }
              this._tiles = e3;
              for (const e4 in this._timers) clearTimeout(this._timers[e4]), delete this._timers[e4];
              for (const e4 in this._tiles) this._setTileReloadTimer(+e4, this._tiles[e4]);
            }
          }
          update(t2, i2, o2, s2, r2) {
            if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
            if (this.usedForTerrain && !o2) return;
            this.updateCacheSize(t2, i2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
            const n2 = "batched-model" === this._source.type;
            let a2, l2 = this._source.maxzoom;
            const c2 = this.map && this.map.painter ? this.map.painter._terrain : null;
            if (c2 && c2.sourceCache === this && c2.attenuationRange()) {
              const e2 = c2.attenuationRange()[0], t3 = Math.floor(e2) - Math.log2(c2.getDemUpscale());
              l2 > t3 && (l2 = t3);
            }
            if (this.used || this.usedForTerrain) {
              if (this._source.tileID) a2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.aQ(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y));
              else if (0 !== this.tileCoverLift) {
                const s3 = t2.clone();
                s3.tileCoverLift = this.tileCoverLift, a2 = s3.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: l2, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: n2 }), this._source.minzoom <= 1 && "globe" === t2.projection.name && (a2.push(new e.aQ(1, 0, 1, 0, 0)), a2.push(new e.aQ(1, 0, 1, 1, 0)), a2.push(new e.aQ(1, 0, 1, 0, 1)), a2.push(new e.aQ(1, 0, 1, 1, 1)));
              } else if (a2 = t2.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: l2, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: n2 }), this._source.hasTile) {
                const e2 = this._source.hasTile.bind(this._source);
                a2 = a2.filter((t3) => e2(t3));
              }
            } else a2 = [];
            if (a2.length > 0 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !kt(this._source.type)) {
              const e2 = t2.coveringZoomLevel({ tileSize: i2 || this._source.tileSize, roundZoom: this._source.roundZoom && !o2 }), l3 = Math.min(e2, this._source.maxzoom);
              if (n2) {
                const e3 = t2.extendTileCover(a2, l3);
                for (const t3 of e3) a2.push(t3);
              } else if (r2) {
                const e3 = t2.extendTileCoverToNearPlane(a2, this.transform.getFrustum(l3), l3);
                for (const t3 of e3) a2.push(t3);
              } else if (this.castsShadows && s2) {
                const e3 = t2.extendTileCover(a2, l3, s2, 16);
                for (const t3 of e3) this._shadowCasterTiles[t3.key] = true, a2.push(t3);
              }
            }
            const h2 = this._updateRetainedTiles(a2);
            if (kt(this._source.type) && 0 !== a2.length) {
              const t3 = {}, i3 = {}, o3 = Object.keys(h2);
              for (const s4 of o3) {
                const o4 = h2[s4], r3 = this._tiles[s4];
                if (!r3 || r3.fadeEndTime && r3.fadeEndTime <= e.o.now()) continue;
                const n3 = this.findLoadedParent(o4, Math.max(o4.overscaledZ - Ft.maxOverzooming, this._source.minzoom));
                n3 && (this._addTile(n3.tileID), t3[n3.tileID.key] = n3.tileID), i3[s4] = o4;
              }
              const s3 = a2[a2.length - 1].overscaledZ;
              for (const e2 in this._tiles) {
                const t4 = this._tiles[e2];
                if (h2[e2] || !t4.hasData()) continue;
                let o4 = t4.tileID;
                for (; o4.overscaledZ > s3; ) {
                  o4 = o4.scaledTo(o4.overscaledZ - 1);
                  const s4 = this._tiles[o4.key];
                  if (s4 && s4.hasData() && i3[o4.key]) {
                    h2[e2] = t4.tileID;
                    break;
                  }
                }
              }
              for (const e2 in t3) h2[e2] || (this._coveredTiles[e2] = true, h2[e2] = t3[e2]);
            }
            for (const e2 in h2) this._tiles[e2].clearFadeHold();
            const d2 = e.bv(this._tiles, h2);
            for (const e2 of d2) {
              const t3 = this._tiles[e2];
              t3.hasSymbolBuckets && !t3.holdingForFade() ? t3.setHoldDuration(this.map._fadeDuration) : t3.hasSymbolBuckets && !t3.symbolFadeFinished() || this._removeTile(+e2);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const e2 in this._tiles) this._tiles[e2].holdingForFade() && this._removeTile(+e2);
          }
          _updateRetainedTiles(e2) {
            const t2 = {};
            if (0 === e2.length) return t2;
            const i2 = {}, o2 = e2.reduce((e3, t3) => Math.min(e3, t3.overscaledZ), 1 / 0), s2 = e2[0].overscaledZ, r2 = Math.max(s2 - Ft.maxOverzooming, this._source.minzoom), n2 = Math.max(s2 + Ft.maxUnderzooming, this._source.minzoom), a2 = {};
            for (const i3 of e2) {
              const e3 = this._addTile(i3);
              t2[i3.key] = i3, e3.hasData() || o2 < this._source.maxzoom && (a2[i3.key] = i3);
            }
            this._retainLoadedChildren(a2, o2, n2, t2);
            for (const o3 of e2) {
              let e3 = this._tiles[o3.key];
              if (e3.hasData()) continue;
              if (o3.canonical.z >= this._source.maxzoom) {
                const e4 = o3.children(this._source.maxzoom)[0], i3 = this.getTile(e4);
                if (i3 && i3.hasData()) {
                  t2[e4.key] = e4;
                  continue;
                }
              } else {
                const e4 = o3.children(this._source.maxzoom);
                if (t2[e4[0].key] && t2[e4[1].key] && t2[e4[2].key] && t2[e4[3].key]) continue;
              }
              let s3 = e3.wasRequested();
              for (let n3 = o3.overscaledZ - 1; n3 >= r2; --n3) {
                const r3 = o3.scaledTo(n3);
                if (i2[r3.key]) break;
                if (i2[r3.key] = true, e3 = this.getTile(r3), !e3 && s3 && (e3 = this._addTile(r3)), e3 && (t2[r3.key] = r3, s3 = e3.wasRequested(), e3.hasData())) break;
              }
            }
            return t2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e2 in this._tiles) {
              const t2 = [];
              let i2, o2 = this._tiles[e2].tileID;
              for (; o2.overscaledZ > 0; ) {
                if (o2.key in this._loadedParentTiles) {
                  i2 = this._loadedParentTiles[o2.key];
                  break;
                }
                t2.push(o2.key);
                const e3 = o2.scaledTo(o2.overscaledZ - 1);
                if (i2 = this._getLoadedTile(e3), i2) break;
                o2 = e3;
              }
              for (const e3 of t2) this._loadedParentTiles[e3] = i2;
            }
          }
          _addTile(t2) {
            let i2 = this._tiles[t2.key];
            if (i2) return true !== i2.isExtraShadowCaster || !!this._shadowCasterTiles[t2.key] || this._reloadTile(t2.key, "reloading"), i2;
            i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
            const o2 = Boolean(i2);
            if (!o2) {
              const e2 = this.map ? this.map.painter : null, o3 = this._source.tileSize * t2.overscaleFactor();
              i2 = "raster-array" === this._source.type ? new Ot(t2, o3, this.transform.tileZoom, e2, this._isRaster) : new Pt(t2, o3, this.transform.tileZoom, e2, this._isRaster, this._source.worldview), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2.key, i2.state));
            }
            return i2.uses++, this._tiles[t2.key] = i2, o2 || this._source.fire(new e.z("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
          }
          _setTileReloadTimer(e2, t2) {
            e2 in this._timers && (clearTimeout(this._timers[e2]), delete this._timers[e2]);
            const i2 = t2.getExpiryTimeout();
            i2 && (this._timers[e2] = setTimeout(() => {
              this._reloadTile(e2, "expired"), delete this._timers[e2];
            }, i2));
          }
          _removeTile(e2) {
            const t2 = this._tiles[e2];
            t2 && (t2.uses--, delete this._tiles[e2], this._timers[e2] && (clearTimeout(this._timers[e2]), delete this._timers[e2]), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state || "empty" === t2.state ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e2 in this._tiles) this._removeTile(+e2);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t2, i2, o2) {
            const s2 = [], r2 = this.transform;
            if (!r2) return s2;
            const n2 = "globe" === r2.projection.name, a2 = e.aF(r2.center.lng);
            for (const l2 in this._tiles) {
              const c2 = this._tiles[l2];
              if (o2 && c2.clearQueryDebugViz(), c2.holdingForFade()) continue;
              let h2;
              if (n2) {
                const t3 = c2.tileID.canonical;
                if (0 === t3.z) {
                  const i3 = [Math.abs(e.aA(a2, ...Nt(t3, -1)) - a2), Math.abs(e.aA(a2, ...Nt(t3, 1)) - a2)];
                  h2 = [0, 2 * i3.indexOf(Math.min(...i3)) - 1];
                } else {
                  const i3 = [Math.abs(e.aA(a2, ...Nt(t3, -1)) - a2), Math.abs(e.aA(a2, ...Nt(t3, 0)) - a2), Math.abs(e.aA(a2, ...Nt(t3, 1)) - a2)];
                  h2 = [i3.indexOf(Math.min(...i3)) - 1];
                }
              } else h2 = [0];
              for (const e2 of h2) {
                const o3 = t2.containsTile(c2, r2, i2, e2);
                o3 && s2.push(o3);
              }
            }
            return s2;
          }
          getShadowCasterCoordinates() {
            return this._getRenderableCoordinates(false, true);
          }
          getVisibleCoordinates(e2) {
            return this._getRenderableCoordinates(e2);
          }
          _getRenderableCoordinates(e2, t2) {
            const i2 = this.getRenderableIds(e2, t2).map((e3) => this._tiles[e3].tileID), o2 = "globe" === this.transform.projection.name;
            for (const e3 of i2) e3.projMatrix = this.transform.calculateProjMatrix(e3.toUnwrapped()), e3.expandedProjMatrix = o2 ? this.transform.calculateProjMatrix(e3.toUnwrapped(), false, true) : e3.projMatrix;
            return i2;
          }
          sortCoordinatesByDistance(e2) {
            const t2 = e2.slice(), i2 = this.transform._camera.position, o2 = this.transform._camera.forward(), s2 = {};
            for (const e3 of t2) {
              const t3 = 1 / (1 << e3.canonical.z);
              s2[e3.key] = ((e3.canonical.x + 0.5) * t3 + e3.wrap - i2[0]) * o2[0] + ((e3.canonical.y + 0.5) * t3 - i2[1]) * o2[1] - i2[2] * o2[2];
            }
            return t2.sort((e3, t3) => s2[e3.key] - s2[t3.key]), t2;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (kt(this._source.type)) for (const t2 in this._tiles) {
              const i2 = this._tiles[t2];
              if (void 0 !== i2.fadeEndTime && i2.fadeEndTime >= e.o.now()) return true;
            }
            return false;
          }
          setFeatureState(e2, t2, i2) {
            this._state.updateState(e2 = e2 || "_geojsonTileLayer", t2, i2);
          }
          removeFeatureState(e2, t2, i2) {
            this._state.removeFeatureState(e2 = e2 || "_geojsonTileLayer", t2, i2);
          }
          getFeatureState(e2, t2) {
            return this._state.getState(e2 = e2 || "_geojsonTileLayer", t2);
          }
          setDependencies(e2, t2, i2) {
            const o2 = this._tiles[e2];
            o2 && o2.setDependencies(t2, i2);
          }
          reloadTilesForDependencies(e2, t2) {
            for (const i2 in this._tiles) this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(+i2, "reloading");
            this._cache.filter((i2) => !i2.hasDependency(e2, t2));
          }
          _preloadTiles(t2, i2) {
            if (!this._sourceLoaded) {
              const e2 = () => {
                this._sourceLoaded && (this._source.off("data", e2), this._preloadTiles(t2, i2));
              };
              return void this._source.on("data", e2);
            }
            const o2 = /* @__PURE__ */ new Map(), s2 = Array.isArray(t2) ? t2 : [t2], r2 = this.map.painter.terrain, n2 = this.usedForTerrain && r2 ? r2.getScaledDemTileSize() : this._source.tileSize;
            for (const e2 of s2) {
              const t3 = e2.coveringTiles({ tileSize: n2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const e3 of t3) o2.set(e3.key, e3);
              this.usedForTerrain && e2.updateElevation(false);
            }
            const a2 = Array.from(o2.values());
            e.bw(a2, (e2, t3) => {
              const i3 = new Pt(e2, this._source.tileSize * e2.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster, this._source.worldview);
              this._loadTile(i3, (e3) => {
                "raster-dem" === this._source.type && i3.dem && this._backfillDEM(i3), t3(e3, i3);
              });
            }, i2);
          }
        }
        function Bt(e2, t2) {
          const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), o2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
          return e2.overscaledZ - t2.overscaledZ || o2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
        }
        function kt(e2) {
          return "raster" === e2 || "image" === e2 || "video" === e2 || "custom" === e2;
        }
        function Nt(e2, t2) {
          const i2 = 1 << e2.z;
          return [e2.x / i2 + t2, (e2.x + 1) / i2 + t2];
        }
        Ft.maxOverzooming = 10, Ft.maxUnderzooming = 3;
        class Ut {
          constructor(e2) {
            this.style = e2, this.layersGotHidden = false, this.layers = [];
          }
          processLayersChanged() {
            this.layers = [];
            const e2 = false, t2 = false;
            for (const i2 in this.style._mergedLayers) {
              const o2 = this.style._mergedLayers[i2];
              if ("fill-extrusion" === o2.type || "building" === o2.type) this.layers.push({ layer: o2, visible: e2, visibilityChanged: t2 });
              else if ("model" === o2.type) {
                const i3 = this.style.getLayerSource(o2);
                i3 && "batched-model" === i3.type && this.layers.push({ layer: o2, visible: e2, visibilityChanged: t2 });
              }
            }
          }
          onNewFrame(e2) {
            this.layersGotHidden = false;
            for (const t2 of this.layers) {
              const i2 = t2.layer;
              let o2 = false;
              "fill-extrusion" === i2.type ? o2 = !i2.isHidden(e2) && i2.paint.get("fill-extrusion-opacity") > 0 : "building" === i2.type ? o2 = !i2.isHidden(e2) && i2.paint.get("building-opacity") > 0 : "model" === i2.type && (o2 = !i2.isHidden(e2) && i2.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o2 && t2.visible, t2.visible = o2;
            }
          }
          updateZOffset(e2, t2) {
            this.currentBuildingBuckets = [];
            for (const e3 of this.layers) {
              const i3 = e3.layer, o2 = this.style.getLayerSourceCache(i3);
              let s2 = 1;
              "fill-extrusion" === i3.type ? s2 = e3.visible ? i3.paint.get("fill-extrusion-vertical-scale") : 0 : "building" === i3.type && (s2 = e3.visible ? i3.paint.get("building-vertical-scale") : 0);
              let r2 = o2 ? o2.getTile(t2) : null;
              if (!r2 && o2) for (const e4 in o2._tiles) {
                const i4 = o2._tiles[e4];
                if (t2.canonical.isChildOf(i4.tileID.canonical)) {
                  r2 = i4;
                  break;
                }
              }
              this.currentBuildingBuckets.push({ bucket: r2 ? r2.getBucket(i3) : null, tileID: r2 ? r2.tileID : t2, verticalScale: s2 });
            }
            e2.hasAnyZOffset = false;
            let i2 = false;
            for (let o2 = 0; o2 < e2.symbolInstances.length; o2++) {
              const s2 = e2.symbolInstances.get(o2), r2 = s2.zOffset, n2 = this._getHeightAtTileOffset(t2, s2.tileAnchorX, s2.tileAnchorY);
              s2.zOffset = n2 !== Number.NEGATIVE_INFINITY ? n2 : r2, i2 || r2 === s2.zOffset || (i2 = true), e2.hasAnyZOffset || 0 === s2.zOffset || (e2.hasAnyZOffset = true);
            }
            i2 && (e2.zOffsetBuffersNeedUpload = true, e2.zOffsetSortDirty = true);
          }
          _mapCoordToOverlappingTile(t2, i2, o2, s2) {
            let r2 = i2, n2 = o2;
            if (t2.canonical.z !== s2.canonical.z) {
              const a2 = s2.canonical, l2 = 1 / (1 << t2.canonical.z - a2.z);
              r2 = (i2 + t2.canonical.x * e.al) * l2 - a2.x * e.al | 0, n2 = (o2 + t2.canonical.y * e.al) * l2 - a2.y * e.al | 0;
            }
            return { tileX: r2, tileY: n2 };
          }
          _getHeightAtTileOffset(e2, t2, i2) {
            let o2, s2;
            for (let r2 = 0; r2 < this.layers.length; ++r2) {
              const n2 = this.layers[r2].layer;
              if ("fill-extrusion" !== n2.type && "building" !== n2.type) continue;
              const { bucket: a2, tileID: l2, verticalScale: c2 } = this.currentBuildingBuckets[r2];
              if (!a2) continue;
              const { tileX: h2, tileY: d2 } = this._mapCoordToOverlappingTile(e2, t2, i2, l2), u2 = a2.getHeightAtTileCoord(h2, d2);
              u2 && void 0 !== u2.height && (u2.hidden ? o2 = u2.height : s2 = Math.max(u2.height * c2, s2 || 0));
            }
            if (void 0 !== s2) return s2;
            for (let s3 = 0; s3 < this.layers.length; ++s3) {
              const r2 = this.layers[s3];
              if ("model" !== r2.layer.type || !r2.visible) continue;
              const { bucket: n2, tileID: a2 } = this.currentBuildingBuckets[s3];
              if (!n2) continue;
              const { tileX: l2, tileY: c2 } = this._mapCoordToOverlappingTile(e2, t2, i2, a2), h2 = n2.getHeightAtTileCoord(l2, c2);
              if (h2 && !h2.hidden) return void 0 === h2.height && void 0 !== o2 ? Math.min(h2.maxHeight, o2) * h2.verticalScale : h2.height ? h2.height * h2.verticalScale : Number.NEGATIVE_INFINITY;
            }
            return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
          }
        }
        function jt(t2, i2) {
          const o2 = {};
          for (const e2 in t2) "ref" !== e2 && (o2[e2] = t2[e2]);
          return e.bx.forEach((e2) => {
            e2 in i2 && (o2[e2] = i2[e2]);
          }), o2;
        }
        function Vt(e2) {
          e2 = e2.slice();
          const t2 = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < e2.length; i2++) t2[e2[i2].id] = e2[i2];
          for (let i2 = 0; i2 < e2.length; i2++) "ref" in e2[i2] && (e2[i2] = jt(e2[i2], t2[e2[i2].ref]));
          return e2;
        }
        const Gt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport", addIconset: "addIconset", removeIconset: "removeIconset" };
        function Ht(e2, t2, i2) {
          i2.push({ command: Gt.addSource, args: [e2, t2[e2]] });
        }
        function qt(e2, t2, i2) {
          t2.push({ command: Gt.removeSource, args: [e2] }), i2[e2] = true;
        }
        function Zt(e2, t2, i2, o2) {
          qt(e2, i2, o2), Ht(e2, t2, i2);
        }
        function Wt(t2, i2, o2) {
          let s2;
          for (s2 in t2[o2]) if (t2[o2].hasOwnProperty(s2) && "data" !== s2 && !e.by(t2[o2][s2], i2[o2][s2])) return false;
          for (s2 in i2[o2]) if (i2[o2].hasOwnProperty(s2) && "data" !== s2 && !e.by(t2[o2][s2], i2[o2][s2])) return false;
          return true;
        }
        function $t(t2, i2, o2, s2, r2, n2) {
          let a2;
          for (a2 in i2 = i2 || {}, t2 = t2 || {}) t2.hasOwnProperty(a2) && (e.by(t2[a2], i2[a2]) || o2.push({ command: n2, args: [s2, a2, i2[a2], r2] }));
          for (a2 in i2) i2.hasOwnProperty(a2) && !t2.hasOwnProperty(a2) && (e.by(t2[a2], i2[a2]) || o2.push({ command: n2, args: [s2, a2, i2[a2], r2] }));
        }
        function Xt(e2) {
          return e2.id;
        }
        function Yt(e2, t2) {
          return e2[t2.id] = t2, e2;
        }
        function Kt(t2, i2, o2) {
          const s2 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
          return e.aB(new Float32Array(16), t2.projMatrix, s2);
        }
        function Jt(e2, t2, i2) {
          if (t2.projection.name === i2.projection.name) return e2.projMatrix;
          const o2 = i2.clone();
          return o2.setProjection(t2.projection), Kt(o2, t2.getProjection(), e2);
        }
        function Qt(e2, t2, i2) {
          return t2.name === i2.projection.name ? e2.projMatrix : Kt(i2, t2, e2);
        }
        class ei {
          constructor(e2, t2) {
            this.reset(e2, t2);
          }
          reset(e2, t2) {
            this.points = e2 || [], this._distances = [0];
            for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t2) {
            if (1 === this.points.length) return this.points[0];
            t2 = e.aA(t2, 0, 1);
            let i2 = 1, o2 = this._distances[i2];
            const s2 = t2 * this.paddedLength + this.padding;
            for (; o2 < s2 && i2 < this._distances.length; ) o2 = this._distances[++i2];
            const r2 = i2 - 1, n2 = this._distances[r2], a2 = o2 - n2, l2 = a2 > 0 ? (s2 - n2) / a2 : 0;
            return this.points[r2].mult(1 - l2).add(this.points[i2].mult(l2));
          }
        }
        class ti {
          constructor(e2, t2, i2) {
            const o2 = this.boxCells = [], s2 = this.circleCells = [];
            this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
            for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) o2.push([]), s2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e2, t2, i2, o2, s2) {
            this._forEachCell(t2, i2, o2, s2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(s2);
          }
          insertCircle(e2, t2, i2, o2) {
            this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
          }
          _insertBoxCell(e2, t2, i2, o2, s2, r2) {
            this.boxCells[s2].push(r2);
          }
          _insertCircleCell(e2, t2, i2, o2, s2, r2) {
            this.circleCells[s2].push(r2);
          }
          _query(e2, t2, i2, o2, s2, r2) {
            if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height) return !s2 && [];
            const n2 = [];
            if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
              if (s2) return true;
              for (let e3 = 0; e3 < this.boxKeys.length; e3++) n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
              for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
                n2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
              }
              return r2 ? n2.filter(r2) : n2;
            }
            return this._forEachCell(e2, t2, i2, o2, this._queryCell, n2, { hitTest: s2, seenUids: { box: {}, circle: {} } }, r2), s2 ? n2.length > 0 : n2;
          }
          _queryCircle(e2, t2, i2, o2, s2) {
            const r2 = e2 - i2, n2 = e2 + i2, a2 = t2 - i2, l2 = t2 + i2;
            if (n2 < 0 || r2 > this.width || l2 < 0 || a2 > this.height) return !o2 && [];
            const c2 = [];
            return this._forEachCell(r2, a2, n2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, s2), o2 ? c2.length > 0 : c2;
          }
          query(e2, t2, i2, o2, s2) {
            return this._query(e2, t2, i2, o2, false, s2);
          }
          hitTest(e2, t2, i2, o2, s2) {
            return this._query(e2, t2, i2, o2, true, s2);
          }
          hitTestCircle(e2, t2, i2, o2) {
            return this._queryCircle(e2, t2, i2, true, o2);
          }
          _queryCell(e2, t2, i2, o2, s2, r2, n2, a2) {
            const l2 = n2.seenUids, c2 = this.boxCells[s2];
            if (null !== c2) {
              const s3 = this.bboxes;
              for (const h3 of c2) if (!l2.box[h3]) {
                l2.box[h3] = true;
                const c3 = 4 * h3;
                if (e2 <= s3[c3 + 2] && t2 <= s3[c3 + 3] && i2 >= s3[c3 + 0] && o2 >= s3[c3 + 1] && (!a2 || a2(this.boxKeys[h3]))) {
                  if (n2.hitTest) return r2.push(true), true;
                  r2.push({ key: this.boxKeys[h3], x1: s3[c3], y1: s3[c3 + 1], x2: s3[c3 + 2], y2: s3[c3 + 3] });
                }
              }
            }
            const h2 = this.circleCells[s2];
            if (null !== h2) {
              const s3 = this.circles;
              for (const c3 of h2) if (!l2.circle[c3]) {
                l2.circle[c3] = true;
                const h3 = 3 * c3;
                if (this._circleAndRectCollide(s3[h3], s3[h3 + 1], s3[h3 + 2], e2, t2, i2, o2) && (!a2 || a2(this.circleKeys[c3]))) {
                  if (n2.hitTest) return r2.push(true), true;
                  {
                    const e3 = s3[h3], t3 = s3[h3 + 1], i3 = s3[h3 + 2];
                    r2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
            }
          }
          _queryCellCircle(e2, t2, i2, o2, s2, r2, n2, a2) {
            const l2 = n2.circle, c2 = n2.seenUids, h2 = this.boxCells[s2];
            if (null !== h2) {
              const e3 = this.bboxes;
              for (const t3 of h2) if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3]))) return r2.push(true), true;
              }
            }
            const d2 = this.circleCells[s2];
            if (null !== d2) {
              const e3 = this.circles;
              for (const t3 of d2) if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3]))) return r2.push(true), true;
              }
            }
          }
          _forEachCell(e2, t2, i2, o2, s2, r2, n2, a2) {
            const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), d2 = this._convertToYCellCoord(o2);
            for (let u2 = l2; u2 <= h2; u2++) for (let l3 = c2; l3 <= d2; l3++) if (s2.call(this, e2, t2, i2, o2, this.xCellCount * l3 + u2, r2, n2, a2)) return;
          }
          _convertToXCellCoord(e2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
          }
          _convertToYCellCoord(e2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
          }
          _circlesCollide(e2, t2, i2, o2, s2, r2) {
            const n2 = o2 - e2, a2 = s2 - t2, l2 = i2 + r2;
            return l2 * l2 > n2 * n2 + a2 * a2;
          }
          _circleAndRectCollide(e2, t2, i2, o2, s2, r2, n2) {
            const a2 = (r2 - o2) / 2, l2 = Math.abs(e2 - (o2 + a2));
            if (l2 > a2 + i2) return false;
            const c2 = (n2 - s2) / 2, h2 = Math.abs(t2 - (s2 + c2));
            if (h2 > c2 + i2) return false;
            if (l2 <= a2 || h2 <= c2) return true;
            const d2 = l2 - a2, u2 = h2 - c2;
            return d2 * d2 + u2 * u2 <= i2 * i2;
          }
        }
        const ii = Math.tan(85 * Math.PI / 180);
        function oi(t2, i2, o2, s2, r2, n2, a2) {
          const l2 = e.bC();
          if (o2) if ("globe" === n2.name) {
            const t3 = e.bD(r2, i2);
            e.aB(l2, l2, t3);
          } else {
            const t3 = e.bE([], a2);
            l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], s2 || e.bB(l2, l2, r2.angle);
          }
          else e.aB(l2, r2.labelPlaneMatrix, t2);
          return l2;
        }
        function si(e2, t2, i2, o2, s2, r2, n2) {
          const a2 = oi(e2, t2, i2, o2, s2, r2, n2);
          return "globe" === r2.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
        }
        function ri(t2, i2, o2, s2, r2, n2, a2) {
          if (o2) {
            if ("globe" === n2.name) {
              const l2 = oi(t2, i2, o2, s2, r2, n2, a2);
              return e.bl(l2, l2), e.aB(l2, t2, l2), l2;
            }
            {
              const i3 = e.bz(t2), o3 = e.bA([]);
              return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.aB(i3, i3, o3), s2 || e.bB(i3, i3, -r2.angle), i3;
            }
          }
          return r2.glCoordMatrix;
        }
        function ni(t2, i2, o2, s2) {
          const r2 = [t2, i2, o2, 1];
          o2 ? e.aC(r2, r2, s2) : gi(r2, r2, s2);
          const n2 = r2[3];
          return r2[0] /= n2, r2[1] /= n2, r2[2] /= n2, r2;
        }
        function ai(e2, t2) {
          return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
        }
        function li(e2, t2) {
          const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
          return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
        }
        function ci(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2 = 1) {
          const u2 = o2.transform, _2 = s2 ? t2.textSizeData : t2.iconSizeData, p2 = e.bK(_2, o2.transform.zoom, d2), f2 = "globe" === u2.projection.name, m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], g2 = s2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
          g2.clear();
          let v2 = null;
          f2 && (v2 = s2 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
          const y2 = t2.lineVertexArray, x2 = s2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, b2 = o2.transform.width / o2.transform.height;
          let w2, T2 = false;
          for (let s3 = 0; s3 < x2.length; s3++) {
            const d3 = x2.get(s3), { numGlyphs: f3, writingMode: E2 } = d3;
            if (E2 !== e.bL.vertical || T2 || w2 === e.bL.horizontal || (T2 = true), w2 = E2, (d3.hidden || E2 === e.bL.vertical) && !T2) {
              mi(f3, g2);
              continue;
            }
            T2 = false;
            const S2 = new e.P(d3.tileAnchorX, d3.tileAnchorY), I2 = "road" === t2.elevationType, C2 = !!u2.elevation || I2;
            let { x: R2, y: A2, z: L2 } = u2.projection.projectTilePoint(S2.x, S2.y, h2.canonical), D2 = null;
            if (C2) {
              const e2 = I2 ? t2.getElevationFeatureForText(s3) : null;
              D2 = { getElevation: c2, elevation: u2.elevation, elevationFeature: e2 };
              const [i3, o3, r3] = c2(S2, u2.elevation, e2);
              R2 += i3, A2 += o3, L2 += r3;
            }
            const P2 = [R2, A2, L2, 1];
            if (e.aC(P2, P2, i2), !li(P2, m2)) {
              mi(f3, g2);
              continue;
            }
            const O2 = P2[3], z2 = ai(o2.transform.getCameraToCenterDistance(u2.projection), O2), M2 = e.bM(_2, p2, d3), F2 = a2 ? M2 / z2 : M2 * z2, B2 = ni(R2, A2, L2, r2);
            if (B2[3] <= 0) {
              mi(f3, g2);
              continue;
            }
            let k2 = {};
            const N2 = e.an(t2.layers[0].layout.get("text-max-angle")), U2 = Math.cos(N2), j2 = a2 ? null : D2, V2 = ui(d3, F2, false, l2, i2, r2, n2, t2.glyphOffsetArray, y2, g2, v2, B2, S2, k2, b2, j2, u2.projection, h2, a2, U2);
            T2 = V2.useVertical, j2 && V2.needsFlipping && (k2 = {}), (V2.notEnoughRoom || T2 || V2.needsFlipping && ui(d3, F2, true, l2, i2, r2, n2, t2.glyphOffsetArray, y2, g2, v2, B2, S2, k2, b2, j2, u2.projection, h2, a2, U2).notEnoughRoom) && mi(f3, g2);
          }
          s2 ? (t2.text.dynamicLayoutVertexBuffer.updateData(g2), v2 && t2.text.globeExtVertexBuffer && t2.text.globeExtVertexBuffer.updateData(v2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(g2), v2 && t2.icon.globeExtVertexBuffer && t2.icon.globeExtVertexBuffer.updateData(v2));
        }
        function hi(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2) {
          const { lineStartIndex: g2, glyphStartIndex: v2, segment: y2 } = a2, x2 = v2 + a2.numGlyphs, b2 = g2 + a2.lineLength, w2 = t2.getoffsetX(v2), T2 = t2.getoffsetX(x2 - 1), E2 = fi(e2 * w2, i2, o2, s2, r2, n2, y2, g2, b2, l2, c2, h2, d2, u2, true, _2, p2, f2, m2);
          if (!E2) return null;
          const S2 = fi(e2 * T2, i2, o2, s2, r2, n2, y2, g2, b2, l2, c2, h2, d2, u2, true, _2, p2, f2, m2);
          return S2 ? { first: E2, last: S2 } : null;
        }
        function di(t2, i2, o2, s2) {
          return t2 === e.bL.horizontal && Math.abs(s2) > Math.abs(o2) ? { useVertical: true } : t2 === e.bL.vertical ? s2 > 0 ? { needsFlipping: true } : null : 0 !== i2 && function(e2, t3) {
            return 0 === e2 || Math.abs(t3 / e2) > ii;
          }(o2, s2) ? 1 === i2 ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
        }
        function ui(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2, y2, x2) {
          const b2 = i2 / 24, w2 = t2.lineOffsetX * b2, T2 = t2.lineOffsetY * b2, { lineStartIndex: E2, glyphStartIndex: S2, numGlyphs: I2, segment: C2, writingMode: R2, flipState: A2 } = t2, L2 = E2 + t2.lineLength, D2 = (t3) => {
            if (d2) {
              const [i4, o4, s4] = t3.up, r3 = h2.length;
              e.bN(d2, r3 + 0, i4, o4, s4), e.bN(d2, r3 + 1, i4, o4, s4), e.bN(d2, r3 + 2, i4, o4, s4), e.bN(d2, r3 + 3, i4, o4, s4);
            }
            const [i3, o3, s3] = t3.point;
            e.bO(h2, i3, o3, s3, t3.angle);
          };
          if (I2 > 1) {
            const e2 = hi(b2, l2, w2, T2, o2, u2, _2, t2, c2, n2, p2, m2, false, g2, v2, y2, x2);
            if (!e2) return { notEnoughRoom: true };
            if (s2 && !o2) {
              let [i3, o3, s3] = e2.first.point, [r3, n3, l3] = e2.last.point;
              [i3, o3] = ni(i3, o3, s3, a2), [r3, n3] = ni(r3, n3, l3, a2);
              const c3 = di(R2, A2, (r3 - i3) * f2, n3 - o3);
              if (t2.flipState = c3 && c3.needsFlipping ? 1 : 2, c3) return c3;
            }
            D2(e2.first);
            for (let e3 = S2 + 1; e3 < S2 + I2 - 1; e3++) {
              const t3 = fi(b2 * l2.getoffsetX(e3), w2, T2, o2, u2, _2, C2, E2, L2, c2, n2, p2, m2, false, false, g2, v2, y2, x2);
              if (!t3) return h2.length -= 4 * (e3 - S2), { notEnoughRoom: true };
              D2(t3);
            }
            D2(e2.last);
          } else {
            if (s2 && !o2) {
              const i4 = ni(_2.x, _2.y, 0, r2), o3 = E2 + C2 + 1, s3 = new e.P(c2.getx(o3), c2.gety(o3)), n3 = ni(s3.x, s3.y, 0, r2), a3 = n3[3] > 0 ? n3 : pi(_2, s3, i4, 1, r2, void 0, g2, v2.canonical), l3 = di(R2, A2, (a3[0] - i4[0]) * f2, a3[1] - i4[1]);
              if (t2.flipState = l3 && l3.needsFlipping ? 1 : 2, l3) return l3;
            }
            const i3 = fi(b2 * l2.getoffsetX(S2), w2, T2, o2, u2, _2, C2, E2, L2, c2, n2, p2, m2, false, false, g2, v2, y2, x2);
            if (!i3) return { notEnoughRoom: true };
            D2(i3);
          }
          return {};
        }
        function _i(e2, t2, i2, o2, s2) {
          const { x: r2, y: n2, z: a2 } = o2.projectTilePoint(e2.x, e2.y, t2);
          if (!s2) return ni(r2, n2, a2, i2);
          const [l2, c2, h2] = s2.getElevation(e2, s2.elevation, s2.elevationFeature);
          return ni(r2 + l2, n2 + c2, a2 + h2, i2);
        }
        function pi(t2, i2, o2, s2, r2, n2, a2, l2) {
          const c2 = _i(t2.sub(i2)._unit()._add(t2), l2, r2, a2, n2);
          return e.av(c2, o2, c2), e.aw(c2, c2), e.bH(c2, o2, c2, s2);
        }
        function fi(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2, y2) {
          const x2 = s2 ? t2 - i2 : t2 + i2;
          let b2 = x2 > 0 ? 1 : -1, w2 = 0;
          s2 && (b2 *= -1, w2 = Math.PI), b2 < 0 && (w2 += Math.PI);
          let T2 = l2 + a2 + (b2 > 0 ? 0 : 1) | 0, E2 = r2, S2 = r2, I2 = 0, C2 = 0;
          const R2 = Math.abs(x2), A2 = [], L2 = [];
          let D2 = n2, P2 = D2, O2 = e.bF([]);
          const z2 = () => pi(P2, D2, S2, R2 - I2 + 1, d2, _2, m2, g2.canonical);
          for (; I2 + C2 <= R2; ) {
            if (T2 += b2, T2 < l2 || T2 >= c2) return null;
            if (S2 = E2, P2 = D2, A2.push(S2), p2 && L2.push(P2), D2 = new e.P(h2.getx(T2), h2.gety(T2)), E2 = u2[T2], !E2) {
              const e2 = _i(D2, g2.canonical, d2, m2, _2);
              E2 = e2[3] > 0 ? u2[T2] = e2 : z2();
            }
            I2 += C2;
            const t3 = e.av([], E2, S2), i3 = e.bG(S2, E2);
            if (o2 && i3 > 0 && C2 > 0 && e.bJ(O2, t3) / (C2 * i3) < y2) return null;
            C2 = i3, O2 = t3;
          }
          f2 && _2 && (u2[T2] && (E2 = z2(), C2 = e.bG(S2, E2), O2 = e.av([], E2, S2)), u2[T2] = E2);
          const M2 = (R2 - I2) / C2, F2 = D2.sub(P2)._mult(M2)._add(P2), B2 = e.bH([], S2, O2, M2);
          let k2 = [0, 0, 1], N2 = O2[0], U2 = O2[1];
          if (v2 && (k2 = m2.upVector(g2.canonical, F2.x, F2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
            const t3 = [k2[2], 0, -k2[0]], i3 = e.bI([], k2, t3);
            e.aw(t3, t3), e.aw(i3, i3), N2 = e.bJ(O2, t3), U2 = e.bJ(O2, i3);
          }
          if (o2) {
            const t3 = e.bI([], k2, O2);
            e.aw(t3, t3), e.bH(B2, B2, t3, o2 * b2);
          }
          const j2 = w2 + Math.atan2(U2, N2);
          return A2.push(B2), p2 && L2.push(F2), { point: B2, angle: j2, path: A2, tilePath: L2, up: k2 };
        }
        function mi(e2, t2) {
          const i2 = t2.length, o2 = i2 + 4 * e2;
          t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
        }
        function gi(e2, t2, i2) {
          const o2 = t2[0], s2 = t2[1];
          return e2[0] = i2[0] * o2 + i2[4] * s2 + i2[12], e2[1] = i2[1] * o2 + i2[5] * s2 + i2[13], e2[3] = i2[3] * o2 + i2[7] * s2 + i2[15], e2;
        }
        const vi = 100;
        class yi {
          constructor(e2, t2, i2 = new ti(e2.width + 200, e2.height + 200, 25), o2 = new ti(e2.width + 200, e2.height + 200, 25)) {
            this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + vi, this.screenBottomBoundary = e2.height + vi, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
          }
          placeCollisionBox(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2) {
            let u2 = o2.projectedAnchorX, _2 = o2.projectedAnchorY, p2 = o2.projectedAnchorZ;
            const f2 = o2.tileAnchorX, m2 = o2.tileAnchorY, g2 = o2.elevation, v2 = o2.tileID, y2 = t2.getProjection();
            if (g2 && v2) {
              const [e2, t3, i3] = y2.upVector(v2.canonical, o2.tileAnchorX, o2.tileAnchorY), s3 = y2.upVectorScale(v2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              u2 += e2 * g2 * s3, _2 += t3 * g2 * s3, p2 += i3 * g2 * s3;
            }
            const x2 = "globe" === t2.projection.name, b2 = "globe" === t2.projection.name ? e.aj(this.transform.zoom) : 0;
            if (v2 && x2 && b2 < 1 && !n2) {
              const t3 = 1 << v2.canonical.z, i3 = e.bP(f2, m2);
              e.bQ(i3, i3, 1 / e.al), e.bR(i3, i3, e.bP(v2.canonical.x, v2.canonical.y)), e.bQ(i3, i3, 1 / t3), e.bS(i3, i3, e.bP(s2[0], s2[1])), i3[0] = e.bT(i3[0], -0.5, 0.5), e.bQ(i3, i3, e.al);
              const o3 = e.bU(i3[0], i3[1], e.al / (2 * Math.PI), 1);
              e.aC(o3, o3, r2), u2 = e.ak(u2, o3[0], b2), _2 = e.ak(_2, o3[1], b2), p2 = e.ak(p2, o3[2], b2);
            }
            const w2 = this.projectAndGetPerspectiveRatio(h2, u2, _2, p2, o2.tileID, "globe" === y2.name || !!g2 || this.transform.pitch > 0, y2), T2 = c2 * w2.perspectiveRatio, E2 = (o2.x1 * i2 + a2.x - o2.padding) * T2 + w2.point.x, S2 = (o2.y1 * i2 + a2.y - o2.padding) * T2 + w2.point.y, I2 = (o2.x2 * i2 + a2.x + o2.padding) * T2 + w2.point.x, C2 = (o2.y2 * i2 + a2.y + o2.padding) * T2 + w2.point.y, R2 = w2.perspectiveRatio <= 0.55 || w2.occluded;
            return !this.isInsideGrid(E2, S2, I2, C2) || !l2 && this.grid.hitTest(E2, S2, I2, C2, d2) || R2 ? { box: [], offscreen: false, occluded: w2.occluded } : { box: [E2, S2, I2, C2], offscreen: this.isOffscreen(E2, S2, I2, C2), occluded: false };
          }
          placeCollisionCircles(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2) {
            const g2 = [], v2 = this.transform.elevation, y2 = t2.getProjection(), x2 = "road" === t2.elevationType, b2 = !!v2 || x2, w2 = e.bV.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, y2), T2 = new e.P(o2.tileAnchorX, o2.tileAnchorY), E2 = new e.P(o2.tileAnchorX, o2.tileAnchorY);
            let { x: S2, y: I2, z: C2 } = y2.projectTilePoint(E2.x, E2.y, m2.canonical), R2 = null;
            if (b2) {
              const e2 = x2 ? t2.getElevationFeatureForText(s2) : null;
              R2 = { getElevation: w2, elevation: v2, elevationFeature: e2 };
              const [i3, o3, r3] = w2(T2, v2, e2);
              S2 += i3, I2 += o3, C2 += r3;
            }
            const A2 = "globe" === y2.name, L2 = this.projectAndGetPerspectiveRatio(l2, S2, I2, C2, m2, A2 || !!v2 || this.transform.pitch > 0, y2), { perspectiveRatio: D2 } = L2, P2 = (u2 ? a2 / D2 : a2 * D2) / e.bY, O2 = ni(S2, I2, C2, c2), z2 = o2.lineOffsetX * P2, M2 = o2.lineOffsetY * P2, F2 = e.an(t2.layers[0].layout.get("text-max-angle")), B2 = Math.cos(F2), k2 = L2.signedDistanceFromCamera > 0 ? hi(P2, n2, z2, M2, x2 && 1 === o2.flipState, O2, E2, o2, r2, c2, {}, b2 && !u2 ? R2 : null, u2 && b2, y2, m2, u2, B2) : null;
            let N2 = false, U2 = false, j2 = true;
            if (k2 && !L2.occluded) {
              const t3 = 0.5 * p2 * D2 + f2, o3 = new e.P(-100, -100), s3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), r3 = new ei(), { first: n3, last: a3 } = k2, l3 = n3.path.length;
              let c3 = [];
              for (let e2 = l3 - 1; e2 >= 1; e2--) c3.push(n3.path[e2]);
              for (let e2 = 1; e2 < a3.path.length; e2++) c3.push(a3.path[e2]);
              const u3 = 2.5 * t3;
              h2 && (c3 = c3.map(([e2, t4, i3], o4) => (b2 && !A2 && (i3 = w2(o4 < l3 - 1 ? n3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2], v2, R2.elevationFeature)[2]), ni(e2, t4, i3, h2))), c3.some((e2) => e2[3] <= 0) && (c3 = []));
              let m3 = [];
              if (c3.length > 0) {
                let t4 = 1 / 0, i3 = -1 / 0, r4 = 1 / 0, n4 = -1 / 0;
                for (const e2 of c3) t4 = Math.min(t4, e2[0]), r4 = Math.min(r4, e2[1]), i3 = Math.max(i3, e2[0]), n4 = Math.max(n4, e2[1]);
                i3 >= o3.x && t4 <= s3.x && n4 >= o3.y && r4 <= s3.y && (m3 = [c3.map((t5) => new e.P(t5[0], t5[1]))], (t4 < o3.x || i3 > s3.x || r4 < o3.y || n4 > s3.y) && (m3 = e.bW(m3, o3.x, o3.y, s3.x, s3.y)));
              }
              for (const e2 of m3) {
                r3.reset(e2, 0.25 * t3);
                let o4 = 0;
                o4 = r3.length <= 0.5 * t3 ? 1 : Math.ceil(r3.paddedLength / u3) + 1;
                for (let e3 = 0; e3 < o4; e3++) {
                  const s4 = e3 / Math.max(o4 - 1, 1), n4 = r3.lerp(s4), a4 = n4.x + vi, l4 = n4.y + vi;
                  g2.push(a4, l4, t3, 0);
                  const c4 = a4 - t3, h3 = l4 - t3, u4 = a4 + t3, p3 = l4 + t3;
                  if (j2 = j2 && this.isOffscreen(c4, h3, u4, p3), U2 = U2 || this.isInsideGrid(c4, h3, u4, p3), !i2 && this.grid.hitTestCircle(a4, l4, t3, _2) && (N2 = true, !d2)) return { circles: [], offscreen: false, collisionDetected: N2, occluded: false };
                }
              }
            }
            return { circles: !d2 && N2 || !U2 ? [] : g2, offscreen: j2, collisionDetected: N2, occluded: L2.occluded };
          }
          queryRenderedSymbols(t2) {
            if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i2 = [];
            let o2 = 1 / 0, s2 = 1 / 0, r2 = -1 / 0, n2 = -1 / 0;
            for (const a3 of t2) {
              const t3 = new e.P(a3.x + vi, a3.y + vi);
              o2 = Math.min(o2, t3.x), s2 = Math.min(s2, t3.y), r2 = Math.max(r2, t3.x), n2 = Math.max(n2, t3.y), i2.push(t3);
            }
            const a2 = this.grid.query(o2, s2, r2, n2).concat(this.ignoredGrid.query(o2, s2, r2, n2)), l2 = {}, c2 = {};
            for (const t3 of a2) {
              const o3 = t3.key;
              if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex]) continue;
              const s3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
              e.bX(i2, s3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
            }
            return c2;
          }
          insertCollisionBox(e2, t2, i2, o2, s2) {
            (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: s2 }, e2[0], e2[1], e2[2], e2[3]);
          }
          insertCollisionCircles(e2, t2, i2, o2, s2) {
            const r2 = t2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: s2 };
            for (let t3 = 0; t3 < e2.length; t3 += 4) r2.insertCircle(n2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
          }
          projectAndGetPerspectiveRatio(t2, i2, o2, s2, r2, n2, a2) {
            const l2 = [i2, o2, s2, 1];
            let c2 = false;
            if (s2 || this.transform.pitch > 0) {
              if (e.aC(l2, l2, t2), this.fogState && r2 && "globe" !== a2.name) {
                const t3 = function(t4, i3, o3, s3, r3, n3) {
                  const a3 = n3.calculateFogTileMatrix(r3), l3 = [i3, o3, s3];
                  return e.af(l3, l3, a3), Ge(t4, e.ag(l3), n3.pitch, n3._fov);
                }(this.fogState, i2, o2, s2, r2.toUnwrapped(), this.transform);
                c2 = t3 > 0.9;
              }
            } else gi(l2, l2, t2);
            const h2 = l2[3];
            return { point: new e.P((l2[0] / h2 + 1) / 2 * this.transform.width + vi, (-l2[1] / h2 + 1) / 2 * this.transform.height + vi), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h2 * 0.5, 1.5), signedDistanceFromCamera: h2, occluded: n2 && l2[2] > h2 || c2 };
          }
          isOffscreen(e2, t2, i2, o2) {
            return i2 < vi || e2 >= this.screenRightBoundary || o2 < vi || t2 > this.screenBottomBoundary;
          }
          isInsideGrid(e2, t2, i2, o2) {
            return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t2 = e.bA([]);
            return e.br(t2, t2, [-100, -100, 0]), t2;
          }
        }
        class xi {
          constructor(e2, t2, i2, o2) {
            this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class bi {
          constructor(e2, t2, i2, o2, s2, r2 = false) {
            this.text = new xi(e2 ? e2.text : null, t2, i2, s2), this.icon = new xi(e2 ? e2.icon : null, t2, o2, s2), this.clipped = r2;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class wi {
          constructor(e2, t2, i2, o2 = false) {
            this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
          }
        }
        class Ti {
          constructor() {
            this.invProjMatrix = e.bC(), this.viewportMatrix = e.bC(), this.circles = [];
          }
        }
        class Ei {
          constructor(e2, t2, i2, o2, s2) {
            this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = s2;
          }
        }
        class Si {
          constructor(e2) {
            this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e2) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e2]) {
              const t2 = ++this.maxGroupID;
              this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
            }
            return this.collisionGroups[e2];
          }
        }
        function Ii(t2, i2, o2, s2, r2) {
          const { horizontalAlign: n2, verticalAlign: a2 } = e.c1(t2), l2 = -(n2 - 0.5) * i2, c2 = -(a2 - 0.5) * o2, h2 = e.c2(t2, s2);
          return new e.P(l2 + h2[0] * r2, c2 + h2[1] * r2);
        }
        function Ci(t2, i2, o2, s2, r2) {
          const n2 = new e.P(t2, i2);
          return o2 && n2._rotate(s2 ? r2 : -r2), n2;
        }
        class Ri {
          constructor(e2, t2, i2, o2, s2, r2) {
            this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new yi(this.transform, s2), this.buildingIndex = r2, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new Si(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {}, this.lastReplacementSourceUpdateTime = 0;
          }
          getBucketParts(t2, i2, o2, s2, r2 = 1) {
            const n2 = o2.getBucket(i2), a2 = o2.latestFeatureIndex;
            if (!n2 || !a2 || i2.fqid !== n2.layerIds[0]) return;
            const l2 = n2.layers[0].layout, c2 = n2.layers[0].paint, h2 = o2.collisionBoxArray, d2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u2 = o2.tileSize / e.al, _2 = o2.tileID.toUnwrapped();
            this.transform.setProjection(n2.projection);
            const p2 = (f2 = o2.tileID, m2 = n2.getProjection(), g2 = this.transform, m2.name === this.projection ? g2.calculateProjMatrix(f2.toUnwrapped()) : Kt(g2, m2, f2));
            var f2, m2, g2;
            const v2 = "map" === l2.get("text-pitch-alignment"), y2 = "map" === l2.get("text-rotation-alignment");
            i2.compileFilter(i2.options);
            const x2 = i2.dynamicFilter(), b2 = i2.dynamicFilterNeedsFeature(), w2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), T2 = si(p2, o2.tileID.canonical, v2, y2, this.transform, n2.getProjection(), w2);
            let E2 = null;
            const S2 = n2.getProjection().createInversionMatrix(this.transform, o2.tileID.canonical);
            if (v2) {
              const t3 = ri(p2, o2.tileID.canonical, v2, y2, this.transform, n2.getProjection(), w2);
              E2 = e.aB([], this.transform.labelPlaneMatrix, t3);
            }
            let I2 = null;
            x2 && o2.latestFeatureIndex && (I2 = { unwrappedTileID: _2, dynamicFilter: x2, dynamicFilterNeedsFeature: b2 }), this.retainedQueryData[n2.bucketInstanceId] = new Ei(n2.bucketInstanceId, a2, n2.sourceLayerIndex, n2.index, o2.tileID);
            const [C2, R2] = n2.layers[0].layout.get("text-size-scale-range"), A2 = e.aA(r2, C2, R2), [L2, D2] = l2.get("icon-size-scale-range"), P2 = e.aA(r2, L2, D2), O2 = { bucket: n2, layout: l2, paint: c2, posMatrix: p2, invMatrix: S2, mercatorCenter: [e.aF(this.transform.center.lng), e.aJ(this.transform.center.lat)], textLabelPlaneMatrix: T2, labelToScreenMatrix: E2, clippingData: I2, scale: d2, textPixelRatio: u2, holdingForFade: o2.holdingForFade(), collisionBoxArray: h2, partiallyEvaluatedTextSize: e.bK(n2.textSizeData, this.transform.zoom, A2), partiallyEvaluatedIconSize: e.bK(n2.iconSizeData, this.transform.zoom, P2), collisionGroup: this.collisionGroups.get(n2.sourceID), latestFeatureIndex: o2.latestFeatureIndex };
            if (s2) for (const e2 of n2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: s3 } = e2;
              t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: s3, parameters: O2 });
            }
            else t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: O2 });
          }
          attemptAnchorPlacement(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2, y2, x2) {
            const { textOffset0: b2, textOffset1: w2, crossTileID: T2 } = p2, E2 = [b2, w2], S2 = Ii(e2, r2, n2, E2, a2), I2 = this.collisionIndex.placeCollisionBox(m2, a2, t2, i2, o2, s2, Ci(S2.x, S2.y, l2, c2, this.transform.angle), _2, h2, d2, u2.predicate);
            if (v2) {
              const e3 = m2.getSymbolInstanceIconSize(x2, this.transform.zoom, p2.placedIconSymbolIndex);
              if (0 === this.collisionIndex.placeCollisionBox(m2, e3, v2, i2, o2, s2, Ci(S2.x, S2.y, l2, c2, this.transform.angle), _2, h2, d2, u2.predicate).box.length) return;
            }
            if (I2.box.length > 0) {
              let t3;
              return this.prevPlacement && this.prevPlacement.variableOffsets[T2] && this.prevPlacement.placements[T2] && this.prevPlacement.placements[T2].text && (t3 = this.prevPlacement.variableOffsets[T2].anchor), this.variableOffsets[T2] = { textOffset: E2, width: r2, height: n2, anchor: e2, textScale: a2, prevAnchor: t3 }, this.markUsedJustification(m2, e2, p2, g2), m2.allowVerticalPlacement && (this.markUsedOrientation(m2, g2, p2), this.placedOrientations[T2] = g2), { shift: S2, placedGlyphBoxes: I2 };
            }
          }
          placeLayerBucketPart(t2, i2, o2, s2, r2 = 1) {
            const { bucket: n2, layout: a2, paint: l2, posMatrix: c2, textLabelPlaneMatrix: h2, labelToScreenMatrix: d2, clippingData: u2, textPixelRatio: _2, mercatorCenter: p2, invMatrix: f2, holdingForFade: m2, collisionBoxArray: g2, partiallyEvaluatedTextSize: v2, partiallyEvaluatedIconSize: y2, collisionGroup: x2, latestFeatureIndex: b2 } = t2.parameters, w2 = a2.get("text-optional"), T2 = a2.get("icon-optional"), E2 = a2.get("text-allow-overlap"), S2 = a2.get("icon-allow-overlap"), I2 = "map" === a2.get("text-rotation-alignment"), C2 = "map" === a2.get("icon-rotation-alignment"), R2 = "map" === a2.get("text-pitch-alignment"), A2 = l2.get("symbol-z-offset"), L2 = "sea" === a2.get("symbol-elevation-reference"), D2 = a2.get("symbol-placement"), [P2, O2] = a2.get("text-size-scale-range"), [z2, M2] = a2.get("icon-size-scale-range"), F2 = e.aA(r2, P2, O2), B2 = e.aA(r2, z2, M2), k2 = a2.get("text-variable-anchor"), N2 = I2 && "point" !== D2, U2 = C2 && "point" !== D2, j2 = k2 && n2.hasTextData(), V2 = n2.hasIconTextFit() && j2 && n2.hasIconData();
            this.transform.setProjection(n2.projection);
            const G2 = j2 || N2, H2 = U2 || V2;
            let q2 = E2 && (S2 || !n2.hasIconData() || T2), Z2 = S2 && (E2 || !n2.hasTextData() || w2);
            const W2 = !A2.isConstant();
            !n2.collisionArrays && g2 && n2.deserializeCollisionBoxes(g2), o2 && s2 && n2.updateCollisionDebugBuffers(this.transform.zoom, g2, F2, B2);
            const $2 = (t3, s3, r3) => {
              const { crossTileID: l3, numVerticalGlyphVertices: g3 } = t3;
              let C3 = null;
              if (u2 && u2.dynamicFilterNeedsFeature || W2) {
                const e2 = this.retainedQueryData[n2.bucketInstanceId];
                C3 = b2.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                const i3 = C3.properties ? C3.properties.worldview : null;
                if (n2.localizable && n2.worldview && "string" == typeof i3) if ("all" === i3) C3.properties.$localized = true;
                else {
                  if (!i3.split(",").includes(n2.worldview)) return;
                  C3.properties.$localized = true, C3.properties.worldview = n2.worldview;
                }
              }
              if (u2 && !(0, u2.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch, worldview: n2.worldview }, C3, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new e.P(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(u2.unwrappedTileID))) return this.placements[l3] = new wi(false, false, false, true), void i2.add(l3);
              const D3 = A2.evaluate(C3, {});
              if (i2.has(l3)) return;
              if (m2) return void (this.placements[l3] = new wi(false, false, false));
              let P3 = false, O3 = false, z3 = true, M3 = false, F3 = false, B3 = null, N3 = { box: null, offscreen: null, occluded: null }, U3 = { box: null }, j3 = null, V3 = null, $3 = null, X3 = 0, Y2 = 0, K2 = 0;
              r3.textFeatureIndex ? X3 = r3.textFeatureIndex : t3.useRuntimeCollisionCircles && (X3 = t3.featureIndex), r3.verticalTextFeatureIndex && (Y2 = r3.verticalTextFeatureIndex);
              const J2 = n2.elevationFeatures ? n2.elevationFeatures[t3.elevationFeatureIndex] : void 0, Q2 = (i3) => {
                i3.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID;
                const o3 = this.transform.elevation;
                i3.elevation = L2 ? D3 : D3 + e.bV.getAtTileOffset(i3.tileID, new e.P(i3.tileAnchorX, i3.tileAnchorY), o3, J2), i3.elevation += t3.zOffset;
              }, ee2 = r3.textBox;
              if (ee2) {
                Q2(ee2);
                const i3 = (i4) => {
                  let o4 = e.bL.horizontal;
                  if (n2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const e2 = this.prevPlacement.placedOrientations[l3];
                    e2 && (this.placedOrientations[l3] = e2, o4 = e2, this.markUsedOrientation(n2, o4, t3));
                  }
                  return o4;
                }, o3 = (t4, i4) => {
                  if (n2.allowVerticalPlacement && g3 > 0 && r3.verticalTextBox) {
                    for (const o4 of n2.writingModes) if (o4 === e.bL.vertical ? (N3 = i4(), U3 = N3) : N3 = t4(), N3 && N3.box && N3.box.length) break;
                  } else N3 = t4();
                };
                if (k2) {
                  let a3 = k2;
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[l3]) {
                    const e2 = this.prevPlacement.variableOffsets[l3];
                    a3.indexOf(e2.anchor) > 0 && (a3 = a3.filter((t4) => t4 !== e2.anchor), a3.unshift(e2.anchor));
                  }
                  const h3 = (e2, i4, o4) => {
                    const r4 = n2.getSymbolInstanceTextSize(v2, t3, this.transform.zoom, s3), l4 = (e2.x2 - e2.x1) * r4 + 2 * e2.padding, h4 = (e2.y2 - e2.y1) * r4 + 2 * e2.padding, d4 = t3.hasIconTextFit && !S2 ? i4 : null;
                    d4 && Q2(d4);
                    let u3 = { box: [], offscreen: false, occluded: false };
                    const m3 = E2 ? 2 * a3.length : a3.length;
                    for (let i5 = 0; i5 < m3; ++i5) {
                      const m4 = this.attemptAnchorPlacement(a3[i5 % a3.length], e2, p2, f2, G2, l4, h4, r4, I2, R2, _2, c2, x2, i5 >= a3.length, t3, s3, n2, o4, d4, v2, y2);
                      if (m4 && (u3 = m4.placedGlyphBoxes, u3 && u3.box && u3.box.length)) {
                        P3 = true, B3 = m4.shift;
                        break;
                      }
                    }
                    return u3;
                  };
                  o3(() => h3(ee2, r3.iconBox, e.bL.horizontal), () => {
                    const t4 = r3.verticalTextBox;
                    return t4 && Q2(t4), n2.allowVerticalPlacement && !(N3 && N3.box && N3.box.length) && g3 > 0 && t4 ? h3(t4, r3.verticalIconBox, e.bL.vertical) : { box: null, offscreen: null, occluded: null };
                  }), N3 && (P3 = N3.box, z3 = N3.offscreen, M3 = N3.occluded);
                  const d3 = i3(!(!N3 || !N3.box));
                  if (!P3 && this.prevPlacement) {
                    const e2 = this.prevPlacement.variableOffsets[l3];
                    e2 && (this.variableOffsets[l3] = e2, this.markUsedJustification(n2, e2.anchor, t3, d3));
                  }
                } else {
                  const a3 = (i4, o4) => {
                    const r4 = n2.getSymbolInstanceTextSize(v2, t3, this.transform.zoom, s3), a4 = this.collisionIndex.placeCollisionBox(n2, r4, i4, p2, f2, G2, new e.P(0, 0), E2, _2, c2, x2.predicate);
                    return a4 && a4.box && a4.box.length && (this.markUsedOrientation(n2, o4, t3), this.placedOrientations[l3] = o4), a4;
                  };
                  o3(() => a3(ee2, e.bL.horizontal), () => {
                    const t4 = r3.verticalTextBox;
                    return n2.allowVerticalPlacement && g3 > 0 && t4 ? (Q2(t4), a3(t4, e.bL.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), i3(!!(N3 && N3.box && N3.box.length));
                }
              }
              if (j3 = N3, P3 = j3 && j3.box && j3.box.length > 0, z3 = j3 && j3.offscreen, M3 = j3 && j3.occluded, t3.useRuntimeCollisionCircles) {
                const i3 = t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex, s4 = n2.text.placedSymbolArray.get(i3), r4 = e.bM(n2.textSizeData, v2, s4), l4 = a2.get("text-padding");
                V3 = this.collisionIndex.placeCollisionCircles(n2, E2, s4, i3, n2.lineVertexArray, n2.glyphOffsetArray, r4, c2, h2, d2, o2, R2, x2.predicate, t3.collisionCircleDiameter * r4 / e.bY, l4, this.retainedQueryData[n2.bucketInstanceId].tileID), P3 = E2 || V3.circles.length > 0 && !V3.collisionDetected, z3 = z3 && V3.offscreen, M3 = V3.occluded;
              }
              if (r3.iconFeatureIndex && (K2 = r3.iconFeatureIndex), r3.iconBox) {
                const i3 = (i4) => {
                  Q2(i4);
                  const o3 = t3.hasIconTextFit && B3 ? Ci(B3.x, B3.y, I2, R2, this.transform.angle) : new e.P(0, 0), s4 = n2.getSymbolInstanceIconSize(y2, this.transform.zoom, t3.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(n2, s4, i4, p2, f2, H2, o3, S2, _2, c2, x2.predicate);
                };
                U3 && U3.box && U3.box.length && r3.verticalIconBox ? ($3 = i3(r3.verticalIconBox), O3 = $3.box.length > 0) : ($3 = i3(r3.iconBox), O3 = $3.box.length > 0), z3 = z3 && $3.offscreen, F3 = $3.occluded;
              }
              const te2 = w2 || 0 === t3.numHorizontalGlyphVertices && 0 === g3, ie2 = T2 || 0 === t3.numIconVertices;
              if (te2 || ie2 ? ie2 ? te2 || (O3 = O3 && P3) : P3 = O3 && P3 : O3 = P3 = O3 && P3, P3 && j3 && j3.box && this.collisionIndex.insertCollisionBox(j3.box, a2.get("text-ignore-placement"), n2.bucketInstanceId, U3 && U3.box && Y2 ? Y2 : X3, x2.ID), O3 && $3 && this.collisionIndex.insertCollisionBox($3.box, a2.get("icon-ignore-placement"), n2.bucketInstanceId, K2, x2.ID), V3 && (P3 && this.collisionIndex.insertCollisionCircles(V3.circles, a2.get("text-ignore-placement"), n2.bucketInstanceId, X3, x2.ID), o2)) {
                const e2 = n2.bucketInstanceId;
                let t4 = this.collisionCircleArrays[e2];
                void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new Ti());
                for (let e3 = 0; e3 < V3.circles.length; e3 += 4) t4.circles.push(V3.circles[e3 + 0]), t4.circles.push(V3.circles[e3 + 1]), t4.circles.push(V3.circles[e3 + 2]), t4.circles.push(V3.collisionDetected ? 1 : 0);
              }
              const oe2 = "globe" !== n2.projection.name;
              q2 = q2 && (oe2 || !M3), Z2 = Z2 && (oe2 || !F3), this.placements[l3] = new wi(P3 || q2, O3 || Z2, z3 || n2.justReloaded), i2.add(l3);
            }, X2 = this.retainedQueryData[n2.bucketInstanceId].tileID;
            if ("offset" === n2.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n2, X2), "road" === n2.elevationType && n2.updateRoadElevation(X2.canonical), n2.updateZOffset(), n2.sortFeaturesByY) {
              const t3 = n2.getSortedSymbolIndexes(this.transform.angle);
              for (let e2 = t3.length - 1; e2 >= 0; --e2) {
                const i3 = t3[e2];
                $2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
              }
              n2.hasAnyZOffset && e.w(`${n2.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
            } else if (n2.hasAnyZOffset) {
              const e2 = n2.getSortedIndexesByZOffset();
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const i3 = e2[t3];
                $2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
              }
            } else for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++) $2(n2.symbolInstances.get(e2), e2, n2.collisionArrays[e2]);
            if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
              const t3 = this.collisionCircleArrays[n2.bucketInstanceId];
              e.bl(t3.invProjMatrix, c2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            n2.justReloaded = false;
          }
          markUsedJustification(t2, i2, o2, s2) {
            const { leftJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h2 = e.c3(i2), d2 = s2 === e.bL.vertical ? l2 : "left" === h2 ? r2 : "center" === h2 ? n2 : "right" === h2 ? a2 : -1;
            r2 >= 0 && (t2.text.placedSymbolArray.get(r2).crossTileID = d2 >= 0 && r2 !== d2 ? 0 : c2), n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = d2 >= 0 && n2 !== d2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = d2 >= 0 && a2 !== d2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = d2 >= 0 && l2 !== d2 ? 0 : c2);
          }
          markUsedOrientation(t2, i2, o2) {
            const s2 = i2 === e.bL.horizontal || i2 === e.bL.horizontalOnly ? i2 : 0, r2 = i2 === e.bL.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h2 = t2.text.placedSymbolArray;
            n2 >= 0 && (h2.get(n2).placedOrientation = s2), a2 >= 0 && (h2.get(a2).placedOrientation = s2), l2 >= 0 && (h2.get(l2).placedOrientation = s2), c2 >= 0 && (h2.get(c2).placedOrientation = r2);
          }
          commit(e2) {
            this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t2 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
            const o2 = t2 ? t2.symbolFadeChange(e2) : 1, s2 = t2 ? t2.opacities : {}, r2 = t2 ? t2.variableOffsets : {}, n2 = t2 ? t2.placedOrientations : {};
            for (const e3 in this.placements) {
              const t3 = this.placements[e3], r3 = s2[e3];
              r3 ? (this.opacities[e3] = new bi(r3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== r3.text.placed || t3.icon !== r3.icon.placed) : (this.opacities[e3] = new bi(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
            }
            for (const e3 in s2) {
              const t3 = s2[e3];
              if (!this.opacities[e3]) {
                const s3 = new bi(t3, o2, false, false);
                s3.isHidden() || (this.opacities[e3] = s3, i2 = i2 || t3.text.placed || t3.icon.placed);
              }
            }
            for (const e3 in r2) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = r2[e3]);
            for (const e3 in n2) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = n2[e3]);
            i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
          }
          updateLayerOpacities(e2, t2, i2, o2) {
            o2 && (this.lastReplacementSourceUpdateTime = o2.updateTime);
            const s2 = /* @__PURE__ */ new Set();
            for (const r2 of t2) {
              const t3 = r2.getBucket(e2);
              t3 && r2.latestFeatureIndex && e2.fqid === t3.layerIds[0] && (this.updateBucketOpacities(t3, s2, r2, r2.collisionBoxArray, i2, o2, r2.tileID, e2.scope), "offset" === t3.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t3, r2.tileID), "road" === t3.elevationType && t3.updateRoadElevation(r2.tileID.canonical), t3.updateZOffset());
            }
          }
          updateBucketOpacities(t2, i2, o2, s2, r2, n2, a2, l2) {
            t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
            const c2 = t2.layers[0].layout, h2 = t2.layers[0].paint, d2 = !!t2.layers[0].dynamicFilter(), u2 = new bi(null, 0, false, false, true), _2 = c2.get("text-allow-overlap"), p2 = c2.get("icon-allow-overlap"), f2 = c2.get("text-variable-anchor"), m2 = "map" === c2.get("text-rotation-alignment"), g2 = "map" === c2.get("text-pitch-alignment"), v2 = h2.get("symbol-z-offset"), y2 = "sea" === c2.get("symbol-elevation-reference"), x2 = !v2.isConstant(), b2 = new bi(null, 0, _2 && (p2 || !t2.hasIconData() || c2.get("icon-optional")), p2 && (_2 || !t2.hasTextData() || c2.get("text-optional")), true);
            !t2.collisionArrays && s2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(s2);
            const w2 = (e2, t3, i3) => {
              for (let o3 = 0; o3 < t3 / 4; o3++) e2.opacityVertexArray.emplaceBack(i3);
            };
            let T2 = 0;
            n2 && t2.updateReplacement(a2, n2);
            for (let s3 = 0; s3 < t2.symbolInstances.length; s3++) {
              const c3 = t2.symbolInstances.get(s3), { numHorizontalGlyphVertices: h3, numVerticalGlyphVertices: _3, crossTileID: p3, numIconVertices: E2, tileAnchorX: S2, tileAnchorY: I2 } = c3;
              let C2 = null;
              const R2 = this.retainedQueryData[t2.bucketInstanceId];
              x2 && c3 && R2 && (C2 = o2.latestFeatureIndex.loadFeature({ featureIndex: c3.featureIndex, bucketIndex: R2.bucketIndex, sourceLayerIndex: R2.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
              const A2 = v2.evaluate(C2, {}), L2 = i2.has(p3);
              let D2 = this.opacities[p3];
              L2 ? D2 = u2 : D2 || (D2 = b2, this.opacities[p3] = D2), i2.add(p3);
              const P2 = h3 > 0 || _3 > 0, O2 = E2 > 0, z2 = this.placedOrientations[p3], M2 = z2 === e.bL.vertical, F2 = z2 === e.bL.horizontal || z2 === e.bL.horizontalOnly;
              !P2 && !O2 || D2.isHidden() || T2++;
              let B2 = false;
              if ((P2 || O2) && n2) for (const i3 of t2.activeReplacements) {
                if (e.bZ(i3, r2, e.b_.Symbol, l2)) continue;
                if (i3.min.x > S2 || S2 > i3.max.x || i3.min.y > I2 || I2 > i3.max.y) continue;
                const t3 = e.b$(S2, I2, a2.canonical, i3.footprintTileId.canonical);
                if (B2 = e.c0(t3, i3.footprint), B2) break;
              }
              if (P2) {
                const e2 = B2 ? ki : Bi(D2.text);
                w2(t2.text, h3, M2 ? ki : e2), w2(t2.text, _3, F2 ? ki : e2);
                const i3 = D2.text.isHidden(), { leftJustifiedTextSymbolIndex: o3, centerJustifiedTextSymbolIndex: s4, rightJustifiedTextSymbolIndex: r3, verticalPlacedTextSymbolIndex: n3 } = c3, a3 = t2.text.placedSymbolArray, l3 = i3 || M2 ? 1 : 0;
                o3 >= 0 && (a3.get(o3).hidden = l3), s4 >= 0 && (a3.get(s4).hidden = l3), r3 >= 0 && (a3.get(r3).hidden = l3), n3 >= 0 && (a3.get(n3).hidden = i3 || F2 ? 1 : 0);
                const d3 = this.variableOffsets[p3];
                d3 && this.markUsedJustification(t2, d3.anchor, c3, z2);
                const u3 = this.placedOrientations[p3];
                u3 && (this.markUsedJustification(t2, "left", c3, u3), this.markUsedOrientation(t2, u3, c3));
              }
              if (O2) {
                const e2 = B2 ? ki : Bi(D2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o3 } = c3, s4 = t2.icon.placedSymbolArray, r3 = D2.icon.isHidden() ? 1 : 0;
                i3 >= 0 && (w2(t2.icon, E2, M2 ? ki : e2), s4.get(i3).hidden = r3), o3 >= 0 && (w2(t2.icon, c3.numVerticalIconVertices, F2 ? ki : e2), s4.get(o3).hidden = r3);
              }
              if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                const i3 = t2.collisionArrays[s3];
                if (i3) {
                  let o3 = new e.P(0, 0), s4 = true;
                  if (i3.textBox || i3.verticalTextBox) {
                    if (f2) {
                      const e2 = this.variableOffsets[p3];
                      e2 ? (o3 = Ii(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), m2 && o3._rotate(g2 ? this.transform.angle : -this.transform.angle)) : s4 = false;
                    }
                    d2 && (s4 = !D2.clipped), i3.textBox && Ai(t2.textCollisionBox.collisionVertexArray, D2.text.placed, !s4 || M2, A2, y2, o3.x, o3.y), i3.verticalTextBox && Ai(t2.textCollisionBox.collisionVertexArray, D2.text.placed, !s4 || F2, A2, y2, o3.x, o3.y);
                  }
                  const r3 = s4 && Boolean(!F2 && i3.verticalIconBox);
                  i3.iconBox && Ai(t2.iconCollisionBox.collisionVertexArray, D2.icon.placed, r3, A2, y2, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0), i3.verticalIconBox && Ai(t2.iconCollisionBox.collisionVertexArray, D2.icon.placed, !r3, A2, y2, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0);
                }
              }
            }
            if (t2.fullyClipped = 0 === T2, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
              const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
              t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
            }
          }
          symbolFadeChange(e2) {
            return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e2) {
            return Math.max(0, (this.transform.zoom - e2) / 1.5);
          }
          hasTransitions(e2) {
            return e2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e2, t2) {
            const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
            return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
          }
          isStale() {
            return this.stale;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Ai(e2, t2, i2, o2, s2, r2, n2) {
          e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0);
        }
        const Li = Math.pow(2, 25), Di = Math.pow(2, 24), Pi = Math.pow(2, 17), Oi = Math.pow(2, 16), zi = Math.pow(2, 9), Mi = Math.pow(2, 8), Fi = Math.pow(2, 1);
        function Bi(e2) {
          if (0 === e2.opacity && !e2.placed) return 0;
          if (1 === e2.opacity && e2.placed) return 4294967295;
          const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
          return i2 * Li + t2 * Di + i2 * Pi + t2 * Oi + i2 * zi + t2 * Mi + i2 * Fi + t2;
        }
        const ki = 0;
        class Ni {
          constructor(e2) {
            this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(e2, t2, i2, o2, s2, r2) {
            const n2 = this._bucketParts;
            for (; this._currentTileIndex < e2.length; ) if (t2.getBucketParts(n2, o2, e2[this._currentTileIndex], this._sortAcrossTiles, r2), this._currentTileIndex++, s2()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n2.length; ) {
              const e3 = n2[this._currentPartIndex];
              if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart, r2), this._currentPartIndex++, s2()) return true;
            }
            return false;
          }
        }
        class Ui {
          startNewPlacement(e2, t2, i2, o2, s2, r2, n2, a2) {
            return this.placement = new Ri(e2, o2, s2, r2, n2, a2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = false, this._showCollisionBoxes = i2, this._fadeDuration = o2, this._done = false, this._inProgressLayer = null, this;
          }
          requestFullPlacement() {
            this._forceFullPlacement = true;
          }
          isFullPlacementRequested() {
            return this._forceFullPlacement;
          }
          setStale() {
            this.placement && (this.placement.stale = true);
          }
          isStale() {
            return !!this.placement && this.placement.stale;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t2, i2, o2, s2, r2) {
            const n2 = e.o.now(), a2 = () => {
              const t3 = e.o.now() - n2;
              return !this.isFullPlacementRequested() && 0 !== this._fadeDuration && t3 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const n3 = i2[t2[this._currentPlacementIndex]], l2 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === n3.type && "none" !== n3.visibility && (!n3.minzoom || n3.minzoom <= l2) && (!n3.maxzoom || n3.maxzoom > l2)) {
                const t3 = n3, i3 = t3.layout.get("symbol-z-elevate"), l3 = void 0 !== t3.layout.get("symbol-sort-key").constantOr(1), c2 = t3.layout.get("symbol-z-order"), h2 = "viewport-y" === c2 || "auto" === c2 && !("viewport-y" !== c2 && l3), d2 = t3.layout.get("text-allow-overlap") || t3.layout.get("icon-allow-overlap") || t3.layout.get("text-ignore-placement") || t3.layout.get("icon-ignore-placement"), u2 = h2 && d2, _2 = this._inProgressLayer = this._inProgressLayer || new Ni(t3), p2 = e.B(n3.source, n3.scope);
                if (_2.continuePlacement(i3 || u2 ? s2[p2] : o2[p2], this.placement, this._showCollisionBoxes, n3, a2, r2)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._forceFullPlacement = false, this._done = true;
          }
          commit(e2) {
            return this.placement.commit(e2), this.placement;
          }
        }
        const ji = 512 / e.al / 2;
        class Vi {
          constructor(t2, i2, o2) {
            this.tileID = t2, this.bucketInstanceId = o2, this.index = new e.c4(i2.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const s2 = t2.canonical.x * e.al, r2 = t2.canonical.y * e.al;
            for (let e2 = 0; e2 < i2.length; e2++) {
              const { key: t3, crossTileID: o3, tileAnchorX: n2, tileAnchorY: a2 } = i2.get(e2), l2 = Math.floor((s2 + n2) * ji), c2 = Math.floor((r2 + a2) * ji);
              this.index.add(l2, c2), this.keys.push(t3), this.crossTileIDs.push(o3);
            }
            this.index.finish();
          }
          findMatches(t2, i2, o2) {
            const s2 = this.tileID.canonical.z < i2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i2.canonical.z), r2 = ji / Math.pow(2, i2.canonical.z - this.tileID.canonical.z), n2 = i2.canonical.x * e.al, a2 = i2.canonical.y * e.al;
            for (let e2 = 0; e2 < t2.length; e2++) {
              const i3 = t2.get(e2);
              if (i3.crossTileID) continue;
              const { key: l2, tileAnchorX: c2, tileAnchorY: h2 } = i3, d2 = Math.floor((n2 + c2) * r2), u2 = Math.floor((a2 + h2) * r2), _2 = this.index.range(d2 - s2, u2 - s2, d2 + s2, u2 + s2).sort((e3, t3) => e3 - t3);
              for (const e3 of _2) {
                const t3 = this.crossTileIDs[e3];
                if (this.keys[e3] === l2 && !o2.has(t3)) {
                  o2.add(t3), i3.crossTileID = t3;
                  break;
                }
              }
            }
          }
        }
        class Gi {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Hi {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e2) {
            const t2 = Math.round((e2 - this.lng) / 360);
            if (0 !== t2) for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const s2 = i2[e4];
                s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + t2), o2[s2.tileID.key] = s2;
              }
              this.indexes[e3] = o2;
            }
            this.lng = e2;
          }
          addBucket(e2, t2, i2) {
            if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
              if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) t2.symbolInstances.get(e3).crossTileID = 0;
            this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = /* @__PURE__ */ new Set());
            const o2 = this.usedCrossTileIDs[e2.overscaledZ];
            for (const i3 in this.indexes) {
              const s2 = this.indexes[i3];
              if (Number(i3) > e2.overscaledZ) for (const i4 in s2) {
                const r2 = s2[i4];
                r2.tileID.isChildOf(e2) && r2.findMatches(t2.symbolInstances, e2, o2);
              }
              else {
                const r2 = s2[e2.scaledTo(Number(i3)).key];
                r2 && r2.findMatches(t2.symbolInstances, e2, o2);
              }
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
              const s2 = t2.symbolInstances.get(e3);
              s2.crossTileID || (s2.crossTileID = i2.generate(), o2.add(s2.crossTileID));
            }
            return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Vi(e2, t2.symbolInstances, t2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e2, t2) {
            for (const i2 of t2.crossTileIDs) this.usedCrossTileIDs[e2].delete(i2);
          }
          removeStaleBuckets(e2) {
            let t2 = false;
            for (const i2 in this.indexes) {
              const o2 = this.indexes[i2];
              for (const s2 in o2) e2[o2[s2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[s2]), delete o2[s2], t2 = true);
            }
            return t2;
          }
        }
        class qi {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Gi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e2, t2, i2, o2) {
            let s2 = this.layerIndexes[e2.fqid];
            void 0 === s2 && (s2 = this.layerIndexes[e2.fqid] = new Hi());
            let r2 = false;
            const n2 = {};
            "globe" !== o2.name && s2.handleWrapJump(i2);
            for (const i3 of t2) {
              const t3 = i3.getBucket(e2);
              t3 && e2.fqid === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), s2.addBucket(i3.tileID, t3, this.crossTileIDs) && (r2 = true), n2[t3.bucketInstanceId] = true);
            }
            return s2.removeStaleBuckets(n2) && (r2 = true), r2;
          }
          pruneUnusedLayers(e2) {
            const t2 = {};
            e2.forEach((e3) => {
              t2[e3] = true;
            });
            for (const e3 in this.layerIndexes) t2[e3] || delete this.layerIndexes[e3];
          }
        }
        const Zi = 771;
        class Wi {
          constructor(e2, t2, i2, o2) {
            this.blendFunction = e2, this.blendColor = t2.toNonPremultipliedRenderColor(null), this.mask = i2, this.blendEquation = o2;
          }
        }
        Wi.Replace = [1, 0, 1, 0], Wi.disabled = new Wi(Wi.Replace, e.ao.transparent, [false, false, false, false]), Wi.unblended = new Wi(Wi.Replace, e.ao.transparent, [true, true, true, true]), Wi.alphaBlended = new Wi([1, Zi, 1, Zi], e.ao.transparent, [true, true, true, true]), Wi.alphaBlendedNonPremultiplied = new Wi([770, Zi, 770, Zi], e.ao.transparent, [true, true, true, true]), Wi.multiply = new Wi([774, 0, 774, 0], e.ao.transparent, [true, true, true, true]), Wi.additive = new Wi([1, 1, 1, 1], e.ao.transparent, [true, true, true, true]);
        class $i {
          constructor(e2, t2, i2) {
            this.func = e2, this.mask = t2, this.range = i2;
          }
        }
        $i.ReadOnly = false, $i.ReadWrite = true, $i.disabled = new $i(519, $i.ReadOnly, [0, 1]);
        const Xi = 7680;
        class Yi {
          constructor(e2, t2, i2, o2, s2, r2) {
            this.test = e2, this.ref = t2, this.mask = i2, this.fail = o2, this.depthFail = s2, this.pass = r2;
          }
        }
        Yi.disabled = new Yi({ func: 519, mask: 0 }, 0, 0, Xi, Xi, Xi);
        const Ki = 1029, Ji = 2305;
        class Qi {
          constructor(e2, t2, i2) {
            this.enable = e2, this.mode = t2, this.frontFace = i2;
          }
        }
        function eo(t2, i2) {
          const o2 = e.ca(t2, 3);
          e.cc(t2, i2), e.cg(t2, 3, o2);
        }
        function to(t2, i2) {
          const o2 = e.c7([]);
          return e.c8(o2, o2, -i2), e.c9(o2, o2, -t2), o2;
        }
        function io(t2, i2) {
          const o2 = [t2[0], t2[1], 0], s2 = [i2[0], i2[1], 0];
          if (e.ag(o2) >= 1e-15) {
            const t3 = e.aw([], o2);
            e.c5(s2, t3, e.bJ(s2, t3)), i2[0] = s2[0], i2[1] = s2[1];
          }
          const r2 = e.bI([], i2, t2);
          if (e.c6(r2) < 1e-15) return null;
          const n2 = Math.atan2(-r2[1], r2[0]);
          return to(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), n2);
        }
        Qi.disabled = new Qi(false, Ki, Ji), Qi.backCCW = new Qi(true, Ki, Ji), Qi.backCW = new Qi(true, Ki, 2304), Qi.frontCW = new Qi(true, 1028, 2304), Qi.frontCCW = new Qi(true, 1028, Ji);
        class oo {
          constructor(e2, t2) {
            this.position = e2, this.orientation = t2;
          }
          get position() {
            return this._position;
          }
          set position(t2) {
            if (t2) {
              const i2 = t2 instanceof e.ae ? t2 : new e.ae(t2[0], t2[1], t2[2]);
              this._renderWorldCopies && (i2.x = e.bT(i2.x, 0, 1)), this._position = i2;
            } else this._position = null;
          }
          lookAtPoint(t2, i2, o2) {
            if (this.orientation = null, !this.position) return;
            const s2 = this.position, r2 = o2 || (this._elevation ? this._elevation.getAtPointOrZero(e.ae.fromLngLat(t2)) : 0), n2 = e.ae.fromLngLat(t2, r2), a2 = [n2.x - s2.x, n2.y - s2.y, n2.z - s2.z];
            i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = io(a2, i2);
          }
          setPitchBearing(t2, i2) {
            this.orientation = to(e.an(t2), e.an(-i2));
          }
        }
        class so {
          constructor(t2, i2) {
            this._transform = e.bA([]), this.orientation = i2, this.position = t2;
          }
          get mercatorPosition() {
            const t2 = this.position;
            return new e.ae(t2[0], t2[1], t2[2]);
          }
          get position() {
            const t2 = e.ca(this._transform, 3);
            return [t2[0], t2[1], t2[2]];
          }
          set position(t2) {
            var i2;
            t2 && e.cg(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t2) {
            this._orientation = t2 || e.c7([]), t2 && eo(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e2 = this.forward(), t2 = this.right();
            return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
          }
          setPitchBearing(e2, t2) {
            this._orientation = to(e2, t2), eo(this._transform, this._orientation);
          }
          forward() {
            const t2 = e.ca(this._transform, 2);
            return [-t2[0], -t2[1], -t2[2]];
          }
          up() {
            const t2 = e.ca(this._transform, 1);
            return [-t2[0], -t2[1], -t2[2]];
          }
          right() {
            const t2 = e.ca(this._transform, 0);
            return [t2[0], t2[1], t2[2]];
          }
          getCameraToWorld(t2, i2) {
            const o2 = new Float64Array(16);
            return e.bl(o2, this.getWorldToCamera(t2, i2)), o2;
          }
          getCameraToWorldMercator() {
            return this._transform;
          }
          getWorldToCameraPosition(t2, i2, o2) {
            const s2 = this.position;
            e.c5(s2, s2, -t2);
            const r2 = new Float64Array(16);
            return e.bq(r2, [o2, o2, o2]), e.br(r2, r2, s2), r2[10] *= i2, r2;
          }
          getWorldToCamera(t2, i2) {
            const o2 = new Float64Array(16), s2 = new Float64Array(4), r2 = this.position;
            return e.cb(s2, this._orientation), e.c5(r2, r2, -t2), e.cc(o2, s2), e.br(o2, o2, r2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
          }
          getCameraToClipPerspective(t2, i2, o2, s2) {
            const r2 = new Float64Array(16);
            return e.cd(r2, t2, i2, o2, s2), r2;
          }
          getCameraToClipOrthographic(t2, i2, o2, s2, r2, n2) {
            const a2 = new Float64Array(16);
            return e.ce(a2, t2, i2, o2, s2, r2, n2), a2;
          }
          getDistanceToElevation(t2, i2 = false) {
            const o2 = 0 === t2 ? 0 : e.cf(t2, i2 ? e.a$(this.position[1]) : this.position[1]), s2 = this.forward();
            return (o2 - this.position[2]) / s2[2];
          }
          clone() {
            return new so([...this.position], [...this.orientation]);
          }
        }
        const ro = (e2, t2) => ({ u_matrix: e2, u_ground_shadow_factor: t2 });
        class no {
          constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
            if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
          }
          interpolate(t2, i2, o2) {
            return null != i2.top && null != t2.top && (this.top = e.ak(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.ak(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.ak(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.ak(t2.right, i2.right, o2)), this;
          }
          getCenter(t2, i2) {
            const o2 = e.aA((this.left + t2 - this.right) / 2, 0, t2), s2 = e.aA((this.top + i2 - this.bottom) / 2, 0, i2);
            return new e.P(o2, s2);
          }
          equals(e2) {
            return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
          }
          clone() {
            return new no(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        const ao = 15;
        class lo {
          constructor(t2, i2, o2, s2, r2, n2, a2) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === r2 || r2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 ?? 0, this._maxPitch = s2 ?? 60, this.setProjection(n2), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.aT(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new no(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new so(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false, this._allowWorldUnderZoom = false;
          }
          clone() {
            const e2 = new lo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
            return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2._allowWorldUnderZoom = this._allowWorldUnderZoom, e2;
          }
          get isOrthographic() {
            return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < ao;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e2) {
            this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          get depthOcclusionForSymbolsAndCircles() {
            return "globe" !== this.projection.name && !this.isOrthographic;
          }
          updateElevation(e2, t2 = false) {
            const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
          }
          getProjection() {
            return e.aH(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(t2) {
            this.projectionOptions = t2 || { name: "mercator" };
            const i2 = this.projection ? this.getProjection() : void 0;
            this.projection = e.cm(this.projectionOptions);
            const o2 = this.getProjection(), s2 = !e.by(i2, o2);
            return s2 && this._calcMatrices(), this.mercatorFromTransition = false, s2;
          }
          setOrthographicProjectionAtLowPitch(e2) {
            return this._orthographicProjectionAtLowPitch !== e2 && (this._orthographicProjectionAtLowPitch = e2, this._calcMatrices(), true);
          }
          setMercatorFromTransition() {
            const t2 = this.projection.name;
            this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.cm({ name: "mercator" });
            const i2 = t2 !== this.projection.name;
            return i2 && this._calcMatrices(), i2;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e2) {
            this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e2) {
            this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e2) {
            this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e2) {
            this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
          }
          set renderWorldCopies(e2) {
            void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
          }
          get cameraWorldSize() {
            const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return e.cf(1, this.center.lat) * this.cameraWorldSizeForFog;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e.P(this.width, this.height);
          }
          get bearing() {
            return e.bT(this.rotation, -180, 180);
          }
          set bearing(e2) {
            this.rotation = e2;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t2) {
            const i2 = -t2 * Math.PI / 180;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = e.cn(), e.co(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t2) {
            const i2 = e.aA(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.an(t2), this._calcMatrices());
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const e2 = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / e2);
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e2) {
            this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e2) {
            const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
            this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e2) {
            this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
          }
          get tileCoverLift() {
            return this._tileCoverLift;
          }
          set tileCoverLift(e2) {
            this._tileCoverLift !== e2 && (this._tileCoverLift = e2);
          }
          _updateCameraOnTerrain() {
            const e2 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t2 = this.elevation && e2 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
            if (!this._elevation || e2 === Number.NEGATIVE_INFINITY && (!t2 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const i2 = this._elevation;
            t2 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i2.exaggeration() && this._centerAltitudeValidForExaggeration !== i2.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i2.exaggeration(), this._centerAltitudeValidForExaggeration = i2.exaggeration()) : (this._centerAltitude = e2 || 0, this._centerAltitudeValidForExaggeration = i2.exaggeration()), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            if (void 0 === this._centerAltitudeValidForExaggeration) return;
            const e2 = Math.max(0, (this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);
            this._seaLevelZoom = this._zoomFromMercatorZ(e2);
          }
          sampleAverageElevation() {
            if (!this._elevation) return 0;
            const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
            let s2 = 0, r2 = 0;
            for (let n2 = 0; n2 < i2.length; n2++) {
              const a2 = new e.P(i2[n2][0] * this.width, o2 + i2[n2][1] * (this.height - o2)), l2 = t2.pointCoordinate(a2);
              if (!l2) continue;
              const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
              s2 += l2[3] * c2, r2 += c2;
            }
            return 0 === r2 ? NaN : s2 / r2;
          }
          get center() {
            return this._center;
          }
          set center(e2) {
            e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (null == this._seaLevelZoom || !this._elevation) return;
            const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), s2 = this._mercatorZfromZoom(this._maxZoom), r2 = Math.max(o2 - i2, s2);
            this._setZoom(this._zoomFromMercatorZ(r2));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e2) {
            this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
          }
          equals(e2) {
            const t2 = this.elevation, i2 = e2.elevation, o2 = null != t2 != (null != i2) || t2 && i2 && t2.exaggeration() !== i2.exaggeration();
            return this.width === e2.width && this.height === e2.height && this.center.lng === e2.center.lng && this.center.lat === e2.center.lat && this.zoom === e2.zoom && this.bearing === e2.bearing && this.pitch === e2.pitch && this.fov === e2.fov && this.projection.name === e2.projection.name && this._edgeInsets.equals(e2.padding) && !o2;
          }
          computeZoomRelativeTo(t2) {
            const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
            let o2;
            o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
            const s2 = e.ag(e.av([], this._camera.position, o2));
            return e.aA(this._zoomFromMercatorZ(s2), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t2) {
            if (!this.height) return;
            if (!t2.position && !t2.orientation) return;
            this._updateCameraState();
            let i2 = false;
            if (t2.orientation && !e.cp(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
              const o2 = [t2.position.x, t2.position.y, t2.position.z];
              e.cq(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
            }
            i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t2 = this._camera.position, i2 = new oo();
            return i2.position = new e.ae(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
          }
          _setCameraOrientation(t2) {
            if (!e.cr(t2)) return false;
            e.cs(t2, t2);
            const i2 = e.ct([], [0, 0, -1], t2), o2 = e.ct([], [0, -1, 0], t2);
            if (o2[2] < 0) return false;
            const s2 = io(i2, o2);
            return !!s2 && (this._camera.orientation = s2, true);
          }
          _setCameraPosition(t2) {
            const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, s2 = this.cameraToCenterDistance;
            t2[2] = e.aA(t2[2], s2 / o2, s2 / i2), this._camera.position = t2;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e2) {
            return this._edgeInsets.equals(e2);
          }
          interpolatePadding(e2, t2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e2) {
            const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
            return Math.max(0, t2);
          }
          getVisibleUnwrappedCoordinates(t2) {
            const i2 = [new e.cu(0, t2)];
            if (this.renderWorldCopies) {
              const o2 = this.pointCoordinate(new e.P(0, 0)), s2 = this.pointCoordinate(new e.P(this.width, 0)), r2 = this.pointCoordinate(new e.P(this.width, this.height)), n2 = this.pointCoordinate(new e.P(0, this.height)), a2 = Math.floor(Math.min(o2.x, s2.x, r2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, s2.x, r2.x, n2.x)), c2 = 1;
              for (let o3 = a2 - c2; o3 <= l2 + c2; o3++) 0 !== o3 && i2.push(new e.cu(o3, t2));
            }
            return i2;
          }
          isLODDisabled(e2) {
            return (!e2 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
          }
          extendTileCover(t2, i2, o2, s2) {
            let r2 = [];
            const n2 = null != o2, a2 = !n2;
            if (a2 && this.zoom < i2) return r2;
            if (n2 && 0 === o2[0] && 0 === o2[1]) return r2;
            const l2 = /* @__PURE__ */ new Set(), c2 = (t3, i3, o3, s3, n3) => {
              const a3 = e.cY(i3, t3, o3, s3, n3);
              l2.has(a3) || (r2.push(new e.aQ(t3, i3, o3, s3, n3)), l2.add(a3));
            };
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r3 = t2[e2];
              if (a2 && r3.canonical.z !== i2) continue;
              if (n2 && void 0 !== s2 && s2 > r3.canonical.z) continue;
              const l3 = r3.canonical, h3 = r3.overscaledZ, d2 = r3.wrap, u2 = 1 << l3.z, _2 = l3.x + 1 < u2, p2 = l3.x > 0, f2 = l3.y + 1 < u2, m2 = l3.y > 0, g2 = r3.wrap - (p2 ? 0 : 1), v2 = r3.wrap + (_2 ? 0 : 1), y2 = p2 ? l3.x - 1 : u2 - 1, x2 = _2 ? l3.x + 1 : 0;
              if (n2) o2[0] < 0 ? (c2(h3, v2, l3.z, x2, l3.y), o2[1] < 0 && f2 && (c2(h3, d2, l3.z, l3.x, l3.y + 1), c2(h3, v2, l3.z, x2, l3.y + 1)), o2[1] > 0 && m2 && (c2(h3, d2, l3.z, l3.x, l3.y - 1), c2(h3, v2, l3.z, x2, l3.y - 1))) : o2[0] > 0 ? (c2(h3, g2, l3.z, y2, l3.y), o2[1] < 0 && f2 && (c2(h3, d2, l3.z, l3.x, l3.y + 1), c2(h3, g2, l3.z, y2, l3.y + 1)), o2[1] > 0 && m2 && (c2(h3, d2, l3.z, l3.x, l3.y - 1), c2(h3, g2, l3.z, y2, l3.y - 1))) : o2[1] < 0 && f2 ? c2(h3, d2, l3.z, l3.x, l3.y + 1) : m2 && c2(h3, d2, l3.z, l3.x, l3.y - 1);
              else {
                const e3 = r3.visibleQuadrants;
                1 & e3 && (c2(h3, g2, l3.z, y2, l3.y), m2 && (c2(h3, d2, l3.z, l3.x, l3.y - 1), c2(h3, g2, l3.z, y2, l3.y - 1))), 2 & e3 && (c2(h3, v2, l3.z, x2, l3.y), m2 && (c2(h3, d2, l3.z, l3.x, l3.y - 1), c2(h3, v2, l3.z, x2, l3.y - 1))), 4 & e3 && (c2(h3, g2, l3.z, y2, l3.y), f2 && (c2(h3, d2, l3.z, l3.x, l3.y + 1), c2(h3, g2, l3.z, y2, l3.y + 1))), 8 & e3 && (c2(h3, v2, l3.z, x2, l3.y), f2 && (c2(h3, d2, l3.z, l3.x, l3.y + 1), c2(h3, v2, l3.z, x2, l3.y + 1)));
              }
            }
            const h2 = [];
            for (const e2 of r2) r2.some((t3) => e2.isChildOf(t3)) || h2.push(e2);
            if (r2 = h2.filter((e2) => !t2.some((t3) => !!(e2.overscaledZ < i2 && t3.isChildOf(e2)) || e2.equals(t3) || e2.isChildOf(t3))), a2) {
              const e2 = 1 << i2, t3 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o3 = [e2 * t3.x, e2 * t3.y], s3 = 4, n3 = s3 * s3;
              r2 = r2.filter((e3) => {
                const t4 = e3.canonical.x + 0.5 - o3[0], i3 = e3.canonical.y + 0.5 - o3[1];
                return t4 * t4 + i3 * i3 < n3;
              });
            }
            return r2;
          }
          extendTileCoverToNearPlane(t2, i2, o2) {
            const s2 = [], r2 = /* @__PURE__ */ new Set();
            for (const e2 of t2) r2.add(e2.key);
            const n2 = (t3, i3, o3, n3, a3) => {
              const l3 = e.cY(i3, t3, o3, n3, a3);
              r2.has(l3) || (s2.push(new e.aQ(t3, i3, o3, n3, a3)), r2.add(l3));
            }, a2 = t2.reduce((e2, t3) => Math.max(e2, t3.overscaledZ), o2), l2 = 1 << o2, c2 = [new e.P(0, 0), new e.P(e.al, 0), new e.P(e.al, e.al), new e.P(0, e.al)], h2 = new e.P(0, 0), d2 = new e.P(0, 0), u2 = (t3, i3) => {
              const s3 = Math.floor(t3[0]), r3 = Math.floor(t3[1]), u3 = (t3[0] - s3) * e.al, _3 = (t3[1] - r3) * e.al, p3 = Math.floor(i3[0]), f3 = Math.floor(i3[1]), m3 = (i3[0] - p3) * e.al, g3 = (i3[1] - f3) * e.al;
              for (let t4 = -1; t4 <= 1; t4++) {
                const i4 = s3 + t4;
                if (!(i4 < 0 || i4 >= l2)) {
                  h2.x = u3 - t4 * e.al, d2.x = m3 - (i4 - p3) * e.al;
                  for (let t5 = -1; t5 <= 1; t5++) {
                    const s4 = r3 + t5;
                    h2.y = _3 - t5 * e.al, d2.y = g3 - (s4 - f3) * e.al, e.cZ(h2, d2, c2) && n2(a2, 0, o2, i4, s4);
                  }
                }
              }
            }, _2 = i2.points, p2 = _2[e.cv], f2 = _2[e.cw], m2 = this._projectToGround(p2, _2[e.cx]), g2 = this._projectToGround(f2, _2[e.cy]);
            return u2(p2, m2), u2(f2, g2), s2;
          }
          _projectToGround(t2, i2) {
            return e.cz(e.cA(), t2, i2, t2[2] / (t2[2] - i2[2]));
          }
          coveringTiles(t2) {
            let i2 = this.coveringZoomLevel(t2);
            const o2 = i2, s2 = this.elevation && this.elevation.exaggeration(), r2 = s2 && !t2.isTerrainDEM, n2 = "mercator" === this.projection.name;
            if (void 0 !== t2.minzoom && i2 < t2.minzoom) return [];
            void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
            const a2 = this.locationCoordinate(this.center), l2 = this.center.lat, c2 = 1 << i2, h2 = [c2 * a2.x, c2 * a2.y, 0], d2 = "globe" === this.projection.name, u2 = !d2, _2 = e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u2), p2 = d2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f2 = c2 * e.cf(1, this.center.lat), m2 = this._camera.position[2] / e.cf(1, this.center.lat), g2 = [c2 * p2.x, c2 * p2.y, m2 * (u2 ? 1 : f2)], v2 = d2 || s2, y2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), x2 = this.isLODDisabled(true) ? i2 : 0;
            let b2;
            if (this._elevation && t2.isTerrainDEM) b2 = 1e4 * this._elevation.exaggeration();
            else if (this._elevation) {
              const e2 = this._elevation.getMinMaxForVisibleTiles();
              b2 = e2 ? e2.max : this._centerAltitude;
            } else b2 = this._centerAltitude;
            const w2 = t2.isTerrainDEM ? -b2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T2 = this.projection.isReprojectedInTileSpace ? e.cC(this) : 1, E2 = (t3) => {
              const i3 = 1 / 4e4, o3 = new e.ae(t3.x + i3, t3.y, t3.z), s3 = new e.ae(t3.x, t3.y + i3, t3.z), r3 = t3.toLngLat(), n3 = o3.toLngLat(), a3 = s3.toLngLat(), l3 = this.locationCoordinate(r3), c3 = this.locationCoordinate(n3), h3 = this.locationCoordinate(a3), d3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), u3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
              return Math.sqrt(d3 * u3) * T2 / i3;
            }, S2 = (t3) => {
              const i3 = b2, o3 = w2;
              return { aabb: e.cF(this, c2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
            }, I2 = [];
            let C2 = [];
            const R2 = i2, A2 = t2.reparseOverscaled ? o2 : i2, L2 = (m2 - this._centerAltitude) * f2, D2 = (e2) => {
              if (!this._elevation || !e2.tileID || !n2) return;
              const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
              t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = O2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
            }, P2 = (e2, t3) => {
              if (0.707 * t3 < e2) return 1;
              const i3 = t3 / e2;
              return i3 / (1.4144271570014144 + (Math.pow(1.1, i3 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            }, O2 = (t3) => {
              if (t3.zoom < x2) return true;
              if (t3.zoom === R2) return false;
              if (null != t3.shouldSplit) return t3.shouldSplit;
              const i3 = t3.aabb.distanceX(g2), s3 = t3.aabb.distanceY(g2);
              let a3 = L2, c3 = 1;
              if (d2) {
                a3 = t3.aabb.distanceZ(g2);
                const i4 = Math.pow(2, t3.zoom), o3 = e.a$((t3.y + 1) / i4), s4 = e.a$(t3.y / i4), r3 = Math.min(Math.max(l2, o3), s4), n3 = e.d1(r3) / e.d1(l2);
                if (c3 = r3 === l2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, n3 / this._mercatorScaleRatio), this.zoom <= e.c_ && t3.zoom === R2 - 1 && n3 >= 0.9) return true;
              } else if (r2 && (a3 = t3.aabb.distanceZ(g2) * f2), this.projection.isReprojectedInTileSpace && o2 <= 5) {
                const i4 = Math.pow(2, t3.zoom), o3 = E2(new e.ae((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
                c3 = o3 > 0.85 ? 1 : o3;
              }
              if (!n2 && !d2) {
                const e2 = Math.sqrt(i3 * i3 + s3 * s3 + a3 * a3);
                let o3 = (1 << R2 - t3.zoom) * y2 * c3;
                return o3 *= P2(Math.max(a3, L2), e2), e2 < o3;
              }
              let u3 = Number.MAX_VALUE, _3 = 0;
              const p3 = t3.aabb.getCorners(), m3 = [];
              for (const t4 of p3) {
                e.av(m3, t4, g2), d2 || (r2 ? m3[2] *= f2 : m3[2] = L2);
                const i4 = e.bJ(m3, this._camera.forward());
                i4 < u3 && (u3 = i4, _3 = Math.abs(m3[2]));
              }
              let v3 = (1 << R2 - t3.zoom) * y2 * c3;
              if (v3 *= P2(Math.max(_3, L2), u3), u3 < v3) return true;
              const b3 = t3.aabb.closestPoint(h2);
              return b3[0] === h2[0] && b3[1] === h2[1];
            };
            if (this.renderWorldCopies) for (let e2 = 1; e2 <= 3; e2++) I2.push(S2(-e2)), I2.push(S2(e2));
            for (I2.push(S2(0)); I2.length > 0; ) {
              const o3 = I2.pop(), s3 = o3.x, a3 = o3.y;
              let l3 = o3.fullyVisible;
              const u3 = () => "globe" === this.projection.name && (0 === o3.y || o3.y === (1 << o3.zoom) - 1);
              if (!l3) {
                let t3 = v2 ? o3.aabb.intersects(_2) : o3.aabb.intersectsFlat(_2);
                if (0 === t3 && u3()) {
                  const i3 = new e.cD(o3.zoom, s3, a3);
                  t3 = e.cE(this, c2, i3, true).intersects(_2);
                }
                if (0 === t3) continue;
                l3 = 2 === t3;
              }
              if (o3.zoom === R2 || !O2(o3)) {
                const r3 = o3.zoom === R2 ? A2 : o3.zoom;
                if (t2.minzoom && t2.minzoom > r3) continue;
                let n3 = 0;
                if (!l3) {
                  let i3 = v2 ? o3.aabb.intersectsPrecise(_2) : o3.aabb.intersectsPreciseFlat(_2);
                  if (0 === i3 && u3()) {
                    const t3 = new e.cD(o3.zoom, s3, a3);
                    i3 = e.cE(this, c2, t3, true).intersectsPrecise(_2);
                  }
                  if (0 === i3) continue;
                  if (t2.calculateQuadrantVisibility) if (_2.containsPoint(o3.aabb.center)) n3 = 15;
                  else for (let e2 = 0; e2 < 4; e2++) 0 !== o3.aabb.quadrant(e2).intersects(_2) && (n3 |= 1 << e2);
                }
                const d3 = h2[0] - (0.5 + s3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), p3 = h2[1] - 0.5 - a3, f3 = o3.tileID ? o3.tileID : new e.aQ(r3, o3.wrap, o3.zoom, s3, a3);
                t2.calculateQuadrantVisibility && (f3.visibleQuadrants = n3), C2.push({ tileID: f3, distanceSq: d3 * d3 + p3 * p3 });
                continue;
              }
              for (let t3 = 0; t3 < 4; t3++) {
                const i3 = (s3 << 1) + t3 % 2, h3 = (a3 << 1) + (t3 >> 1), u4 = { aabb: n2 ? o3.aabb.quadrant(t3) : e.cF(this, c2, o3.zoom + 1, i3, h3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: h3, wrap: o3.wrap, fullyVisible: l3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                r2 && !d2 && (u4.tileID = new e.aQ(o3.zoom + 1 === R2 ? A2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, h3), D2(u4)), I2.push(u4);
              }
            }
            if (this.fogCullDistSq) {
              const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
              C2 = C2.filter((s3) => {
                const r3 = [0, 0, 0, 1], n3 = [e.al, e.al, 0, 1], a3 = this.calculateFogTileMatrix(s3.tileID.toUnwrapped());
                e.aC(r3, r3, a3), e.aC(n3, n3, a3);
                const l3 = e.cG([], r3, n3), c3 = e.cH([], r3, n3), h3 = e.c$(l3, c3);
                if (0 === h3) return true;
                let d3 = false;
                const u3 = this._elevation;
                if (u3 && h3 > i3 && 0 !== o3) {
                  const i4 = this.calculateProjMatrix(s3.tileID.toUnwrapped());
                  let r4;
                  t2.isTerrainDEM || (r4 = u3.getMinMaxForTile(s3.tileID)), r4 || (r4 = { min: w2, max: b2 });
                  const n4 = e.cI(this.rotation), a4 = [n4[0] * e.al, n4[1] * e.al, r4.max];
                  e.af(a4, a4, i4), d3 = (1 - a4[1]) * this.height * 0.5 < o3;
                }
                return h3 < i3 || d3;
              });
            }
            return C2.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
          }
          resize(e2, t2) {
            this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e2) {
            return Math.pow(2, e2);
          }
          scaleZoom(e2) {
            return Math.log2(e2);
          }
          project(t2) {
            const i2 = e.aA(t2.lat, -e.cJ, e.cJ), o2 = this.projection.project(t2.lng, i2);
            return new e.P(o2.x * this.worldSize, o2.y * this.worldSize);
          }
          unproject(e2) {
            return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / e.cf(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t2, i2) {
            let o2, s2;
            const r2 = this.centerPoint;
            if ("globe" === this.projection.name) {
              const e2 = this.worldSize;
              o2 = (i2.x - r2.x) / e2, s2 = (i2.y - r2.y) / e2;
            } else {
              const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(r2);
              o2 = e2.x - t3.x, s2 = e2.y - t3.y;
            }
            const n2 = this.locationCoordinate(t2);
            this.setLocation(new e.ae(n2.x - o2, n2.y - s2));
          }
          setLocation(e2) {
            this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e2, t2) {
            return this.projection.locationPoint(this, e2, t2);
          }
          locationPoint3D(e2, t2) {
            return this.projection.locationPoint(this, e2, t2, true);
          }
          pointLocation(e2) {
            return this.coordinateLocation(this.pointCoordinate(e2));
          }
          pointLocation3D(e2, t2) {
            return this.coordinateLocation(this.pointCoordinate3D(e2, t2));
          }
          locationCoordinate(t2, i2) {
            const o2 = i2 ? e.cf(i2, t2.lat) : void 0, s2 = this.projection.project(t2.lng, t2.lat);
            return new e.ae(s2.x, s2.y, o2);
          }
          coordinateLocation(e2) {
            return this.projection.unproject(e2.x, e2.y);
          }
          pointRayIntersection(t2, i2) {
            const o2 = null != i2 ? i2 : this._centerAltitude, s2 = [t2.x, t2.y, 0, 1], r2 = [t2.x, t2.y, 1, 1];
            e.aC(s2, s2, this.pixelMatrixInverse), e.aC(r2, r2, this.pixelMatrixInverse);
            const n2 = r2[3];
            e.cK(s2, s2, 1 / s2[3]), e.cK(r2, r2, 1 / n2);
            const a2 = s2[2], l2 = r2[2];
            return { p0: s2, p1: r2, t: a2 === l2 ? 0 : (o2 - a2) / (l2 - a2) };
          }
          screenPointToMercatorRay(t2) {
            const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
            return e.aC(i2, i2, this.pixelMatrixInverse), e.aC(o2, o2, this.pixelMatrixInverse), e.cK(i2, i2, 1 / i2[3]), e.cK(o2, o2, 1 / o2[3]), i2[2] = e.cf(i2[2], this._center.lat) * this.worldSize, o2[2] = e.cf(o2[2], this._center.lat) * this.worldSize, e.cK(i2, i2, 1 / this.worldSize), e.cK(o2, o2, 1 / this.worldSize), new e.ax([i2[0], i2[1], i2[2]], e.aw([], e.av([], o2, i2)));
          }
          rayIntersectionCoordinate(t2) {
            const { p0: i2, p1: o2, t: s2 } = t2, r2 = e.cf(i2[2], this._center.lat), n2 = e.cf(o2[2], this._center.lat);
            return new e.ae(e.ak(i2[0], o2[0], s2) / this.worldSize, e.ak(i2[1], o2[1], s2) / this.worldSize, e.ak(r2, n2, s2));
          }
          pointCoordinate(e2, t2 = this._centerAltitude) {
            return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
          }
          pointCoordinate3D(t2, i2) {
            if (!this.elevation) return this.pointCoordinate(t2, i2);
            let o2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
            if (o2) return new e.ae(o2[0], o2[1], o2[2]);
            let s2 = 0, r2 = this.horizonLineFromTop();
            if (t2.y > r2) return this.pointCoordinate(t2, i2);
            const n2 = 0.02 * r2, a2 = t2.clone();
            for (let t3 = 0; t3 < 10 && r2 - s2 > n2; t3++) {
              a2.y = e.ak(s2, r2, 0.66);
              const t4 = this.projection.pointCoordinate3D(this, a2.x, a2.y);
              t4 ? (r2 = a2.y, o2 = t4) : s2 = a2.y;
            }
            return o2 ? new e.ae(o2[0], o2[1], o2[2]) : this.pointCoordinate(t2);
          }
          isPointAboveHorizon(e2) {
            return this.projection.isPointAboveHorizon(this, e2);
          }
          isPointOnSurface(t2) {
            if (t2.y < 0 || t2.y > this.height || t2.x < 0 || t2.x > this.width) return false;
            if (this.elevation || this.zoom >= e.cL) return !this.isPointAboveHorizon(t2);
            const i2 = this.pointCoordinate(t2);
            return i2.y >= 0 && i2.y <= 1;
          }
          _coordinatePoint(t2, i2) {
            const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, s2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
            return e.aC(s2, s2, this.pixelMatrix), s2[3] > 0 ? new e.P(s2[0] / s2[3], s2[1] / s2[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, s2 = this.width - this._edgeInsets.right, r2 = this.pointLocation3D(new e.P(i2, t2)), n2 = this.pointLocation3D(new e.P(s2, t2)), a2 = this.pointLocation3D(new e.P(s2, o2)), l2 = this.pointLocation3D(new e.P(i2, o2));
            let c2 = Math.min(r2.lng, n2.lng, a2.lng, l2.lng), h2 = Math.max(r2.lng, n2.lng, a2.lng, l2.lng), d2 = Math.min(r2.lat, n2.lat, a2.lat, l2.lat), u2 = Math.max(r2.lat, n2.lat, a2.lat, l2.lat);
            const _2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = "globe" === this.projection.name ? 1 : 4, f2 = (t3, i3, o3, s3, r3) => {
              const n3 = (t3 + o3) / 2, a3 = (i3 + s3) / 2, l3 = new e.P(n3, a3), { lng: m2, lat: g2 } = this.pointLocation3D(l3), v2 = Math.max(0, c2 - m2, d2 - g2, m2 - h2, g2 - u2);
              c2 = Math.min(c2, m2), h2 = Math.max(h2, m2), d2 = Math.min(d2, g2), u2 = Math.max(u2, g2), (r3 < p2 || v2 > _2) && (f2(t3, i3, n3, a3, r3 + 1), f2(n3, a3, o3, s3, r3 + 1));
            };
            if (f2(i2, t2, s2, t2, 1), f2(s2, t2, s2, o2, 1), f2(s2, o2, i2, o2, 1), f2(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
              const [t3, i3] = e.cM(this);
              t3 ? (u2 = 90, h2 = 180, c2 = -180) : i3 && (d2 = -90, h2 = 180, c2 = -180);
            }
            return new e.aI(new e.aT(c2, d2), new e.aT(h2, u2));
          }
          _getBoundsRectangular(t2, i2) {
            const { top: o2, left: s2 } = this._edgeInsets, r2 = this.height - this._edgeInsets.bottom, n2 = this.width - this._edgeInsets.right, a2 = new e.P(s2, o2), l2 = new e.P(n2, o2), c2 = new e.P(n2, r2), h2 = new e.P(s2, r2);
            let d2 = this.pointCoordinate(a2, t2), u2 = this.pointCoordinate(l2, t2);
            const _2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h2, i2), f2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
            return d2.y > 1 && u2.y >= 0 ? d2 = new e.ae((1 - p2.y) / f2(p2, d2) + p2.x, 1) : d2.y < 0 && u2.y <= 1 && (d2 = new e.ae(-p2.y / f2(p2, d2) + p2.x, 0)), u2.y > 1 && d2.y >= 0 ? u2 = new e.ae((1 - _2.y) / f2(_2, u2) + _2.x, 1) : u2.y < 0 && d2.y <= 1 && (u2 = new e.ae(-_2.y / f2(_2, u2) + _2.x, 0)), new e.aI().extend(this.coordinateLocation(d2)).extend(this.coordinateLocation(u2)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(_2));
          }
          _getBoundsRectangularTerrain() {
            const e2 = this.elevation;
            if (!e2.visibleDemTiles.length || e2.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
            const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
              if (t3.dem) {
                const i2 = t3.dem.tree;
                e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
              }
              return e3;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
          }
          getBounds() {
            return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(e2 = true) {
            const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
            return e2 ? Math.max(0, i2) : i2;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t2) {
            this.maxBounds = t2, this.minLat = -e.cJ, this.maxLat = e.cJ, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.aF(this.minLng) * this.tileSize, this.worldMaxX = e.aF(this.maxLng) * this.tileSize, this.worldMinY = e.aJ(this.maxLat) * this.tileSize, this.worldMaxY = e.aJ(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e2, t2) {
            return this.projection.createTileMatrix(this, t2, e2);
          }
          calculateDistanceTileData(t2) {
            const i2 = t2.key, o2 = this._distanceTileDataCache;
            if (o2[i2]) return o2[i2];
            const s2 = t2.canonical, r2 = 1 / this.height, n2 = this.cameraWorldSize, a2 = n2 / this.zoomScale(s2.z), l2 = (s2.x + Math.pow(2, s2.z) * t2.wrap) * a2, c2 = s2.y * a2, h2 = this.point;
            h2.x *= n2 / this.worldSize, h2.y *= n2 / this.worldSize;
            const d2 = this.angle, u2 = Math.sin(-d2), _2 = -Math.cos(-d2);
            return o2[i2] = { bearing: [u2, _2], center: [(h2.x - l2) * r2, (h2.y - c2) * r2], scale: a2 / e.al * r2 }, o2[i2];
          }
          calculateFogTileMatrix(t2) {
            const i2 = t2.key, o2 = this._fogTileMatrixCache;
            if (o2[i2]) return o2[i2];
            const s2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
            return e.aB(s2, this.worldToFogMatrix, s2), o2[i2] = new Float32Array(s2), o2[i2];
          }
          calculateProjMatrix(t2, i2 = false, o2 = false) {
            const s2 = t2.key;
            let r2;
            if (r2 = o2 ? this._expandedProjMatrixCache : i2 ? this._alignedProjMatrixCache : this._projMatrixCache, r2[s2]) return r2[s2];
            const n2 = this.calculatePosMatrix(t2, this.worldSize);
            let a2;
            return a2 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o2 ? this.expandedFarZProjMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, e.aB(n2, a2, n2), r2[s2] = new Float32Array(n2), r2[s2];
          }
          calculatePixelsToTileUnitsMatrix(t2) {
            const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
            if (o2[i2]) return o2[i2];
            const s2 = e.cN(t2, this);
            return o2[i2] = s2, o2[i2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if ("globe" === this.projection.name) {
              const t2 = 1 / this.worldSize, i2 = e.bq([], [t2, t2, t2]);
              return e.aB(i2, i2, this.globeMatrix), i2;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || "globe" === this.projection.name) return;
            const t2 = this._elevation;
            this._updateCameraState();
            const i2 = e.cf(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), s2 = this._camera.forward(), r2 = e.cf(1, this._center.lat);
            o2[2] /= r2, s2[2] /= r2, e.aw(s2, s2);
            const n2 = t2.raycast(o2, s2, t2.exaggeration());
            if (n2) {
              const t3 = e.bH([], o2, s2, n2), i3 = new e.ae(t3[0], t3[1], e.cf(t3[2], e.a$(t3[1]))), a2 = (i3.z + e.ag([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * r2])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t2 = false) {
            if (!this._elevation) return;
            const i2 = this._elevation, o2 = e.cf(1, this._center.lat) * this.worldSize, s2 = this._computeCameraPosition(o2), r2 = i2.getAtPointOrZero(new e.ae(...s2)), n2 = this.pixelsPerMeter / this.worldSize * r2, a2 = this._minimumHeightOverTerrain(), l2 = s2[2] - n2;
            if (l2 <= a2) if (l2 < 0 || t2) {
              const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [s2[0], s2[1], t3.z - s2[2]], o3 = e.ag(i3);
              i3[2] -= (a2 - l2) / this._pixelsPerMercatorPixel;
              const r3 = e.ag(i3);
              if (0 === r3) return;
              e.c5(i3, i3, o3 / r3 * this._pixelsPerMercatorPixel), this._camera.position = [s2[0], s2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
            } else this._isCameraConstrained = true;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = true;
            const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t2) {
              const i3 = this.center;
              return i3.lat = e.aA(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.aA(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
            }
            const i2 = this._unmodified, { x: o2, y: s2 } = this.point;
            let r2 = 0, n2 = o2, a2 = s2;
            const l2 = this.width / 2, c2 = this.height / 2, h2 = this.worldMinY * this.scale, d2 = this.worldMaxY * this.scale;
            if (s2 - c2 < h2 && (a2 = h2 + c2), s2 + c2 > d2 && (a2 = d2 - c2), d2 - h2 < this.height && (r2 = Math.max(r2, this.height / (d2 - h2)), a2 = (d2 + h2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
              n2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, n2 - l2 < e2 && (n2 = e2 + l2), n2 + l2 > t3 && (n2 = t3 - l2), t3 - e2 < this.width && (r2 = Math.max(r2, this.width / (t3 - e2)), n2 = (t3 + e2) / 2);
            }
            n2 === o2 && a2 === s2 || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n2, a2))), r2 && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
          }
          _minZoomForBounds() {
            let e2 = Math.max(0, this.scaleZoom(Math.max(0, this.height) / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height) return;
            const t2 = this.centerOffset, i2 = "globe" === this.projection.name, o2 = this.pixelsPerMeter;
            "globe" === this.projection.name && (this._mercatorScaleRatio = e.cf(1, this.center.lat) / e.cf(1, e.d2));
            const s2 = e.cO(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const r2 = "meters" === this.projection.zAxisUnit ? o2 : 1, n2 = this._camera.getWorldToCamera(this.worldSize, r2);
            let a2;
            const l2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            if (l2[8] = 2 * -t2.x / this.width, l2[9] = 2 * t2.y / this.height, this.isOrthographic) {
              let i3 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), o3 = i3 * this.aspect, s3 = -o3, r3 = -i3;
              o3 -= t2.x, s3 -= t2.x, i3 += t2.y, r3 += t2.y, a2 = this._camera.getCameraToClipOrthographic(s3, o3, r3, i3, this._nearZ, this._farZ), ((t3, i4, o4, s4) => {
                for (let r4 = 0; r4 < 16; r4++) t3[r4] = e.ak(i4[r4], o4[r4], s4);
              })(a2, a2, l2, e.d0(this.pitch >= ao ? 1 : this.pitch / ao));
            } else a2 = l2;
            const c2 = e.cP([], l2, n2);
            let h2 = e.cP([], a2, n2);
            if (this.projection.isReprojectedInTileSpace) {
              const t3 = this.locationCoordinate(this.center), i3 = e.bA([]);
              e.br(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.aB(i3, i3, e.cQ(this)), e.br(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.aB(h2, h2, i3), e.aB(c2, c2, i3), this.inverseAdjustmentMatrix = e.cR(this);
            } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            if (this.mercatorMatrix = e.cS([], h2, [this.worldSize, this.worldSize, this.worldSize / r2, 1]), this.projMatrix = h2, this.invProjMatrix = e.bl(new Float64Array(16), this.projMatrix), i2) {
              const i3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
              i3[8] = 2 * -t2.x / this.width, i3[9] = 2 * t2.y / this.height, this.expandedFarZProjMatrix = e.cP([], i3, n2);
            } else this.expandedFarZProjMatrix = this.projMatrix;
            const d2 = e.bl([], a2);
            this.frustumCorners = e.cT.fromInvProjectionMatrix(d2, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i2);
            const u2 = new Float32Array(16);
            e.bA(u2), e.cS(u2, u2, [1, -1, 1]), e.cU(u2, u2, this._pitch), e.bB(u2, u2, this.angle);
            const _2 = e.cd(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
            this.starsProjMatrix = e.bz(_2);
            const p2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            _2[8] = 2 * -t2.x / this.width, _2[9] = 2 * (t2.y + p2) / this.height, this.skyboxMatrix = e.aB(u2, _2, u2);
            const f2 = this.point, m2 = f2.x, g2 = f2.y, v2 = this.width % 2 / 2, y2 = this.height % 2 / 2, x2 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = m2 - Math.round(m2) + x2 * v2 + b2 * y2, T2 = g2 - Math.round(g2) + x2 * y2 + b2 * v2, E2 = new Float64Array(h2);
            if (e.br(E2, E2, [w2 > 0.5 ? w2 - 1 : w2, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = E2, h2 = e.bC(), e.cS(h2, h2, [this.width / 2, -this.height / 2, 1]), e.br(h2, h2, [1, -1, 0]), this.labelPlaneMatrix = h2, h2 = e.bC(), e.cS(h2, h2, [1, -1, 1]), e.br(h2, h2, [-1, -1, 0]), e.cS(h2, h2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h2, this.pixelMatrix = e.aB(new Float64Array(16), this.labelPlaneMatrix, c2), this._calcFogMatrices(), this._distanceTileDataCache = {}, h2 = e.bl(new Float64Array(16), this.pixelMatrix), !h2) throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = h2, "globe" === this.projection.name || this.mercatorFromTransition) {
              this.globeMatrix = e.cV(this);
              const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = e.af(t3, t3, n2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else this.globeMatrix = h2;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, s2 = 1 / this.height / this._pixelsPerMercatorPixel, r2 = [t2, t2, i2];
            e.c5(r2, r2, s2), e.c5(o2, o2, -1), e.cW(o2, o2, r2);
            const n2 = e.bC();
            e.br(n2, n2, o2), e.cS(n2, n2, r2), this.mercatorFogMatrix = n2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, s2);
          }
          _computeCameraPosition(e2) {
            const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, s2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
            return [o2.x / this.worldSize - i2[0] * s2, o2.y / this.worldSize - i2[1] * s2, e2 / this.worldSize * this._centerAltitude - i2[2] * s2];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t2) {
            const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], s2 = t2[2];
            let r2 = 1;
            this.projection.wrap && (this.center = this.center.wrap()), s2 > 0 && (r2 = Math.min((i2 - o2) / s2, 1)), this._camera.position = e.bH([], this._camera.position, t2, r2), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: s2 } = this._camera.getPitchBearing(), r2 = e.cf(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.an(this._maxPitch)), a2 = Math.max((t2[2] - r2) / Math.cos(o2), n2), l2 = this._zoomFromMercatorZ(a2);
            e.bH(t2, t2, i2, a2), this._pitch = e.aA(o2, e.an(this.minPitch), e.an(this.maxPitch)), this.angle = e.bT(s2, -Math.PI, Math.PI), this._setZoom(e.aA(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ae(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e2) {
            return Math.pow(2, e2) * this.tileSize;
          }
          _mercatorZfromZoom(e2) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
          }
          _minimumHeightOverTerrain() {
            const e2 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
            return this._mercatorZfromZoom(e2);
          }
          _zoomFromMercatorZ(e2) {
            return this.scaleZoom(this.cameraToCenterDistance / (Math.max(0, e2) * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t2) {
            let i2 = 0, o2 = e.cL, s2 = 0, r2 = 1 / 0;
            for (; o2 - i2 > 1e-6 && o2 > i2; ) {
              const e2 = i2 + 0.5 * (o2 - i2), n2 = this.tileSize * Math.pow(2, e2), a2 = this.getCameraToCenterDistance(this.projection, e2, n2), l2 = this.scaleZoom(a2 / (Math.max(0, t2) * this.tileSize)), c2 = Math.abs(e2 - l2);
              c2 < r2 && (r2 = c2, s2 = e2), e2 < l2 ? i2 = e2 : o2 = e2;
            }
            return s2;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t2, i2) {
            const o2 = Math.min(t2.x, i2.x), s2 = Math.max(t2.x, i2.x), r2 = Math.min(t2.y, i2.y), n2 = Math.max(t2.y, i2.y);
            if (r2 < this.horizonLineFromTop(false)) return true;
            if ("mercator" !== this.projection.name) return false;
            const a2 = [new e.P(o2, r2), new e.P(s2, n2), new e.P(o2, n2), new e.P(s2, r2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
            for (const e2 of a2) {
              const t3 = this.pointRayIntersection(e2);
              if (t3.t < 0) return true;
              const i3 = this.rayIntersectionCoordinate(t3);
              if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1) return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e.cX(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
          }
          zoomDeltaToMovement(t2, i2) {
            const o2 = e.ag(e.av([], this._camera.position, t2)), s2 = this._zoomFromMercatorZ(o2) + i2;
            return o2 - this._mercatorZfromZoom(s2);
          }
          getCameraPoint() {
            if ("globe" === this.projection.name) {
              const t2 = function([t3, i2, o2], s2) {
                const r2 = [t3, i2, o2, 1];
                e.aC(r2, r2, s2);
                const n2 = r2[3] = Math.max(r2[3], 1e-6);
                return r2[0] /= n2, r2[1] /= n2, r2[2] /= n2, r2;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new e.P(t2[0], t2[1]);
            }
            {
              const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new e.P(0, t2));
            }
          }
          getCameraToCenterDistance(t2, i2 = this.zoom, o2 = this.worldSize) {
            const s2 = e.cO(t2, i2, this.width, this.height, 1024), r2 = t2.pixelSpaceConversion(this.center.lat, o2, s2);
            let n2 = 0.5 / Math.tan(0.5 * this._fov) * this.height * r2;
            return this.isOrthographic && (n2 = e.ak(1, n2, e.d0(this.pitch >= ao ? 1 : this.pitch / ao))), n2;
          }
          getWorldToCameraMatrix() {
            const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
            return "globe" === this.projection.name && e.aB(t2, t2, this.globeMatrix), t2;
          }
          getFrustum(t2) {
            return e.cB.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t2, "meters" === this.projection.zAxisUnit);
          }
        }
        const co = (t2, i2) => {
          if (i2 > 0 && t2.terrain && e.w("Cutoff is currently disabled on terrain"), i2 <= 0 || t2.terrain) return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
          const o2 = t2.transform, s2 = Math.max(Math.abs(o2._zoom - (t2.minCutoffZoom - 1)), 1), r2 = o2.isLODDisabled(false) ? e.ah(60, 45, o2.pitch) : e.ah(30, 15, o2.pitch), n2 = o2._farZ - o2._nearZ, a2 = i2 * o2.height, l2 = ((1 - (c2 = r2)) * o2.cameraToCenterDistance + c2 * (o2._farZ + a2)) * s2;
          var c2;
          return { shouldRenderCutoff: r2 < 1, uniformValues: { u_cutoff_params: [o2._nearZ, o2._farZ, (l2 - o2._nearZ) / n2, (l2 - a2 - o2._nearZ) / n2] } };
        }, ho = 2048;
        class uo {
          constructor(e2, t2) {
            this.aabb = e2, this.lastCascade = t2;
          }
        }
        class _o {
          add(e2, t2) {
            const i2 = this.receivers[e2.key];
            void 0 !== i2 ? (i2.aabb.min[0] = Math.min(i2.aabb.min[0], t2.min[0]), i2.aabb.min[1] = Math.min(i2.aabb.min[1], t2.min[1]), i2.aabb.min[2] = Math.min(i2.aabb.min[2], t2.min[2]), i2.aabb.max[0] = Math.max(i2.aabb.max[0], t2.max[0]), i2.aabb.max[1] = Math.max(i2.aabb.max[1], t2.max[1]), i2.aabb.max[2] = Math.max(i2.aabb.max[2], t2.max[2])) : this.receivers[e2.key] = new uo(t2, null);
          }
          clear() {
            this.receivers = {};
          }
          get(e2) {
            return this.receivers[e2.key];
          }
          computeRequiredCascades(t2, i2, o2) {
            const s2 = e.d9.fromPoints(t2.points);
            let r2 = 0;
            for (const t3 in this.receivers) {
              const n2 = this.receivers[t3];
              if (!n2) continue;
              if (!s2.intersectsAabb(n2.aabb)) continue;
              n2.aabb.min = s2.closestPoint(n2.aabb.min), n2.aabb.max = s2.closestPoint(n2.aabb.max);
              const a2 = n2.aabb.getCorners();
              for (let t4 = 0; t4 < o2.length; t4++) {
                let s3 = true;
                for (const r3 of a2) {
                  const n3 = [r3[0] * i2, r3[1] * i2, r3[2]];
                  if (e.af(n3, n3, o2[t4].matrix), n3[0] < -1 || n3[0] > 1 || n3[1] < -1 || n3[1] > 1) {
                    s3 = false;
                    break;
                  }
                }
                if (n2.lastCascade = t4, r2 = Math.max(r2, t4), s3) break;
              }
            }
            return r2 + 1;
          }
        }
        class po {
          constructor(e2) {
            this.painter = e2, this._enabled = false, this._drawShadowAfterLayer = -1, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new _o(), this._depthMode = new $i(e2.context.gl.LEQUAL, $i.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false;
          }
          destroy() {
            for (const e2 of this._cascades) e2.texture.destroy(), e2.framebuffer.destroy();
            this._cascades = [];
          }
          updateShadowParameters(t2, i2) {
            const o2 = this.painter;
            if (this._enabled = false, this._drawShadowAfterLayer = -1, this._receivers.clear(), !i2 || !i2.properties) return;
            const s2 = i2.properties.get("shadow-intensity"), r2 = i2.properties.get("shadow-draw-before-layer");
            if (!i2.shadowsEnabled() || s2 <= 0) return;
            let n2 = -1, a2 = 0;
            for (const e2 of o2.style.order) {
              const i3 = o2.style._mergedLayers[e2];
              i3.hasShadowPass() && !i3.isHidden(t2.zoom) && (n2 = a2), r2 && r2 === e2 && (this._drawShadowAfterLayer = a2 > 0 ? a2 - 1 : 0), a2 += 1;
            }
            if (this._enabled = n2 >= 0, !this.enabled) return;
            this._drawShadowAfterLayer < 0 && (this._drawShadowAfterLayer = n2);
            const l2 = o2.context, c2 = ho, h2 = ho;
            if (0 === this._cascades.length || ho !== this._cascades[0].texture.size[0]) {
              this._cascades = [];
              for (let t3 = 0; t3 < 2; ++t3) {
                const t4 = o2._shadowMapDebug, i3 = l2.gl, s3 = l2.createFramebuffer(c2, h2, t4 ? 1 : 0, "texture"), r3 = new e.T(l2, { width: c2, height: h2, data: null }, i3.DEPTH_COMPONENT16);
                if (s3.depthAttachment.set(r3.texture), t4) {
                  const t5 = new e.T(l2, { width: c2, height: h2, data: null }, i3.RGBA8);
                  s3.colorAttachment0.set(t5.texture);
                }
                this._cascades.push({ framebuffer: s3, texture: r3, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e.cB(), scale: 0 });
              }
            }
            this.shadowDirection = mo(i2);
            let d2 = 0;
            if (t2.elevation) {
              const e2 = t2.elevation, i3 = [1e4, -1e4];
              e2.visibleDemTiles.filter((e3) => e3.dem).forEach((e3) => {
                const t3 = e3.dem.tree;
                i3[0] = Math.min(i3[0], t3.minimums[0]), i3[1] = Math.max(i3[1], t3.maximums[0]);
              }), 1e4 !== i3[0] && (d2 = (i3[1] - i3[0]) * e2.exaggeration());
            }
            const u2 = 1.5 * t2.cameraToCenterDistance, _2 = 3 * u2, p2 = new Float64Array(16);
            for (let i3 = 0; i3 < this._cascades.length; ++i3) {
              const o3 = this._cascades[i3];
              let s3 = t2.height / 50, r3 = 1;
              0 === i3 ? r3 = u2 : (s3 = u2, r3 = _2);
              const [n3, a3] = vo(t2, this.shadowDirection, s3, r3, ho, d2);
              o3.scale = t2.scale, o3.matrix = n3, o3.boundingSphereRadius = a3, e.bl(p2, o3.matrix), o3.frustum = e.cB.fromInvProjectionMatrix(p2, 1, 0, true), o3.far = r3;
            }
            const f2 = this._cascades.length - 1;
            this._uniformValues.u_fade_range = [0.75 * this._cascades[f2].far, this._cascades[f2].far], this._uniformValues.u_shadow_intensity = s2, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 48828125e-11, this._uniformValues.u_shadow_map_resolution = ho, this._uniformValues.u_shadowmap_0 = 11, this._uniformValues.u_shadowmap_1 = 12, this._groundShadowTiles = o2.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
            const m2 = o2.transform.elevation;
            for (const e2 of this._groundShadowTiles) {
              let t3 = { min: 0, max: 0 };
              if (m2) {
                const i3 = m2.getMinMaxForTile(e2);
                i3 && (t3 = i3);
              }
              this.addShadowReceiver(e2.toUnwrapped(), t3.min, t3.max);
            }
          }
          get enabled() {
            return this._enabled && !this._forceDisable;
          }
          set enabled(e2) {
            this._enabled = e2;
          }
          drawShadowPass(t2, i2) {
            if (!this.enabled) return;
            const o2 = this.painter, s2 = o2.context;
            this._numCascadesToRender = this._receivers.computeRequiredCascades(o2.transform.getFrustum(0), o2.transform.worldSize, this._cascades), s2.viewport.set([0, 0, ho, ho]);
            for (let r2 = 0; r2 < this._numCascadesToRender; ++r2) {
              o2.currentShadowCascade = r2, s2.bindFramebuffer.set(this._cascades[r2].framebuffer.framebuffer), s2.clear({ color: e.ao.white, depth: 1 });
              for (const e2 of t2.order) {
                const s3 = t2._mergedLayers[e2];
                if (!s3.hasShadowPass() || s3.isHidden(o2.transform.zoom)) continue;
                const r3 = t2.getLayerSourceCache(s3), n2 = r3 ? i2[r3.id] : void 0;
                ("model" === s3.type || n2 && n2.length) && o2.renderLayer(o2, r3, s3, n2);
              }
            }
            o2.currentShadowCascade = 0;
          }
          drawGroundShadows() {
            if (!this.enabled) return;
            const e2 = this.painter, t2 = e2.style, i2 = e2.context, o2 = i2.gl, s2 = t2.directionalLight, r2 = t2.ambientLight;
            if (!s2 || !r2) return;
            const n2 = [], a2 = co(e2, e2.longestCutoffRange);
            a2.shouldRenderCutoff && n2.push("RENDER_CUTOFF"), n2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && n2.push("NORMAL_OFFSET");
            const l2 = go(t2, s2, r2), c2 = new $i(o2.LEQUAL, $i.ReadOnly, e2.depthRangeFor3D), h2 = new Yi({ func: o2.EQUAL, mask: 255 }, 0, 255, o2.KEEP, o2.KEEP, o2.KEEP);
            for (const t3 of this._groundShadowTiles) {
              const s3 = t3.toUnwrapped(), r3 = e2.isTileAffectedByFog(t3), d2 = e2.getOrCreateProgram("groundShadow", { defines: n2, overrideFog: r3 });
              this.setupShadows(s3, d2), e2.uploadCommonUniforms(i2, d2, s3, null, a2);
              const u2 = ro(e2.transform.calculateProjMatrix(s3), l2);
              d2.draw(e2, o2.TRIANGLES, c2, h2, Wi.multiply, Qi.disabled, u2, "ground_shadow", e2.tileExtentBuffer, e2.quadTriangleIndexBuffer, e2.tileExtentSegments, null, e2.transform.zoom, null, null);
            }
          }
          getShadowPassColorMode() {
            return this.painter._shadowMapDebug ? Wi.unblended : Wi.disabled;
          }
          getShadowPassDepthMode() {
            return this._depthMode;
          }
          getGroundShadowLayerIndex() {
            return this._drawShadowAfterLayer;
          }
          calculateShadowPassMatrixFromTile(t2) {
            const i2 = this.painter.transform, o2 = i2.calculatePosMatrix(t2, i2.worldSize);
            return e.aB(o2, this._cascades[this.painter.currentShadowCascade].matrix, o2), Float32Array.from(o2);
          }
          calculateShadowPassMatrixFromMatrix(t2) {
            const i2 = e.bz(t2);
            return e.aB(i2, this._cascades[this.painter.currentShadowCascade].matrix, t2), i2;
          }
          setupShadows(t2, i2, o2) {
            if (!this.enabled) return;
            const s2 = this.painter.transform, r2 = this.painter.context, n2 = r2.gl, a2 = this._uniformValues, l2 = new Float64Array(16), c2 = s2.calculatePosMatrix(t2, s2.worldSize);
            for (let t3 = 0; t3 < this._cascades.length; t3++) e.aB(l2, this._cascades[t3].matrix, c2), a2[0 === t3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(l2), r2.activeTexture.set(n2.TEXTURE0 + 11 + t3), this._cascades[t3].texture.bindExtraParam(n2.LINEAR, n2.LINEAR, n2.CLAMP_TO_EDGE, n2.CLAMP_TO_EDGE, n2.GREATER);
            if (this.useNormalOffset = !!o2, this.useNormalOffset) {
              const i3 = e.d7(t2.canonical), r3 = 2 / s2.tileSize * e.al / ho, n3 = r3 * this._cascades[0].boundingSphereRadius, l3 = r3 * this._cascades[this._cascades.length - 1].boundingSphereRadius, c3 = ("vector-tile" === o2 ? 1 : 3) * function(t3) {
                const i4 = e.aA((t3 - 22) / -22, 0, 1);
                return 0.125 * (1 - i4) + 4 * i4;
              }(s2.zoom);
              a2.u_shadow_normal_offset = [i3, n3 * c3, l3 * c3], a2.u_shadow_bias = [1e-4, 12e-4, 0.012];
            } else a2.u_shadow_bias = [36e-5, 12e-4, 0.012];
            i2.setShadowUniformValues(r2, a2);
          }
          setupShadowsFromMatrix(t2, i2, o2 = false) {
            if (!this.enabled) return;
            const s2 = this.painter.context, r2 = s2.gl, n2 = this._uniformValues, a2 = new Float64Array(16);
            for (let i3 = 0; i3 < 2; i3++) e.aB(a2, this._cascades[i3].matrix, t2), n2[0 === i3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a2), s2.activeTexture.set(r2.TEXTURE0 + 11 + i3), this._cascades[i3].texture.bindExtraParam(r2.LINEAR, r2.LINEAR, r2.CLAMP_TO_EDGE, r2.CLAMP_TO_EDGE, r2.GREATER);
            this.useNormalOffset = o2, o2 ? (n2.u_shadow_normal_offset = [1, 3, 3], n2.u_shadow_bias = [6e-5, 12e-4, 0.012]) : n2.u_shadow_bias = [36e-5, 12e-4, 0.012], i2.setShadowUniformValues(s2, n2);
          }
          getShadowUniformValues() {
            return this._uniformValues;
          }
          getCurrentCascadeFrustum() {
            return this._cascades[this.painter.currentShadowCascade].frustum;
          }
          computeSimplifiedTileShadowVolume(t2, i2, o2, s2) {
            if (s2[2] >= 0) return {};
            const r2 = function(t3, i3, o3) {
              const s3 = o3 / (1 << t3.canonical.z);
              return new e.d9([t3.canonical.x * s3 + t3.wrap * o3, t3.canonical.y * s3 + t3.wrap * o3, 0], [(t3.canonical.x + 1) * s3 + t3.wrap * o3, (t3.canonical.y + 1) * s3 + t3.wrap * o3, i3]);
            }(t2, i2, o2).getCorners(), n2 = i2 / -s2[2];
            s2[0] < 0 ? (e.d8(r2[0], r2[0], [s2[0] * n2, 0, 0]), e.d8(r2[3], r2[3], [s2[0] * n2, 0, 0])) : s2[0] > 0 && (e.d8(r2[1], r2[1], [s2[0] * n2, 0, 0]), e.d8(r2[2], r2[2], [s2[0] * n2, 0, 0])), s2[1] < 0 ? (e.d8(r2[0], r2[0], [0, s2[1] * n2, 0]), e.d8(r2[1], r2[1], [0, s2[1] * n2, 0])) : s2[1] > 0 && (e.d8(r2[2], r2[2], [0, s2[1] * n2, 0]), e.d8(r2[3], r2[3], [0, s2[1] * n2, 0]));
            const a2 = {};
            return a2.vertices = r2, a2.planes = [fo(r2[1], r2[0], r2[4]), fo(r2[2], r2[1], r2[5]), fo(r2[3], r2[2], r2[6]), fo(r2[0], r2[3], r2[7])], a2;
          }
          addShadowReceiver(t2, i2, o2) {
            this._receivers.add(t2, e.d9.fromTileIdAndHeight(t2, i2, o2));
          }
          getMaxCascadeForTile(e2) {
            const t2 = this._receivers.get(e2);
            return t2 && t2.lastCascade ? t2.lastCascade : 0;
          }
        }
        function fo(t2, i2, o2) {
          const s2 = e.av([], o2, i2), r2 = e.av([], t2, i2), n2 = e.bI([], s2, r2), a2 = e.ag(n2);
          return 0 === a2 ? [0, 0, 1, 0] : (e.c5(n2, n2, 1 / a2), [n2[0], n2[1], n2[2], -e.bJ(n2, i2)]);
        }
        function mo(t2) {
          const i2 = t2.properties.get("direction"), o2 = e.d4(i2.x, i2.y, i2.z);
          o2[2] = e.aA(o2[2], 0, 75);
          const s2 = e.d6([o2[0], o2[1], o2[2]]);
          return e.d5(s2.x, s2.y, s2.z);
        }
        function go(t2, i2, o2) {
          const s2 = "none" === i2.properties.get("color-use-theme"), r2 = i2.properties.get("color"), n2 = i2.properties.get("intensity"), a2 = i2.properties.get("direction"), l2 = [a2.x, a2.y, a2.z], c2 = "none" === o2.properties.get("color-use-theme"), h2 = o2.properties.get("color"), d2 = o2.properties.get("intensity"), u2 = Math.max(e.bJ([0, 0, 1], l2), 0), _2 = [0, 0, 0];
          e.c5(_2, h2.toPremultipliedRenderColor(c2 ? null : t2.getLut(i2.scope)).toArray01Linear().slice(0, 3), d2);
          const p2 = [0, 0, 0];
          return e.c5(p2, r2.toPremultipliedRenderColor(s2 ? null : t2.getLut(o2.scope)).toArray01Linear().slice(0, 3), u2 * n2), e.db([_2[0] > 0 ? _2[0] / (_2[0] + p2[0]) : 0, _2[1] > 0 ? _2[1] / (_2[1] + p2[1]) : 0, _2[2] > 0 ? _2[2] / (_2[2] + p2[2]) : 0]);
        }
        function vo(t2, i2, o2, s2, r2, n2) {
          const a2 = t2.zoom, l2 = t2.scale, c2 = t2.worldSize, h2 = 1 / c2, d2 = t2.aspect, u2 = Math.sqrt(1 + d2 * d2) * Math.tan(0.5 * t2.fovX), _2 = u2 * u2, p2 = s2 - o2, f2 = s2 + o2;
          let m2, g2;
          _2 > p2 / f2 ? (m2 = s2, g2 = s2 * u2) : (m2 = 0.5 * f2 * (1 + _2), g2 = 0.5 * Math.sqrt(p2 * p2 + 2 * (s2 * s2 + o2 * o2) * _2 + f2 * f2 * _2 * _2));
          const v2 = t2.projection.pixelsPerMeter(t2.center.lat, c2), y2 = t2._camera.getCameraToWorldMercator(), x2 = [0, 0, -m2 * h2];
          e.af(x2, x2, y2);
          let b2 = g2 * h2;
          const w2 = function(i3) {
            return i3[0] /= l2, i3[1] /= l2, i3[2] = e.cf(i3[2], t2._center.lat), i3;
          }, T2 = t2._edgeInsets;
          if (!(0 === T2.left && 0 === T2.top && 0 === T2.right && 0 === T2.bottom || T2.left === T2.right && T2.top === T2.bottom)) {
            const i3 = t2._camera.getWorldToCamera(t2.worldSize, "meters" === t2.projection.zAxisUnit ? v2 : 1), r3 = t2._camera.getCameraToClipPerspective(t2._fov, t2.width / t2.height, o2, s2);
            r3[8] = 2 * -t2.centerOffset.x / t2.width, r3[9] = 2 * t2.centerOffset.y / t2.height;
            const n3 = new Float64Array(16);
            e.cP(n3, r3, i3);
            const l3 = new Float64Array(16);
            e.bl(l3, n3);
            const h3 = e.cB.fromInvProjectionMatrix(l3, c2, a2, true);
            for (const t3 of h3.points) {
              const i4 = w2(t3);
              b2 = Math.max(b2, e.c6(e.da([], x2, i4)));
            }
          }
          b2 *= r2 / (r2 - 1);
          const E2 = Math.acos(i2[2]), S2 = Math.atan2(-i2[0], -i2[1]), I2 = new so();
          I2.position = x2, I2.setPitchBearing(E2, S2);
          const C2 = I2.getWorldToCamera(c2, v2), R2 = b2 * c2, A2 = Math.min(t2._mercatorZfromZoom(17) * c2 * -2, -2 * R2), L2 = I2.getCameraToClipOrthographic(-R2, R2, -R2, R2, A2, (R2 + n2 * v2) / i2[2]), D2 = new Float64Array(16);
          e.aB(D2, L2, C2);
          const P2 = e.d5(Math.floor(1e6 * x2[0]) / 1e6 * c2, Math.floor(1e6 * x2[1]) / 1e6 * c2, 0), O2 = 0.5 * r2, z2 = [0, 0, 0];
          e.af(z2, P2, D2), e.c5(z2, z2, O2);
          const M2 = [Math.floor(z2[0]), Math.floor(z2[1]), Math.floor(z2[2])], F2 = [0, 0, 0];
          e.av(F2, z2, M2), e.c5(F2, F2, -1 / O2);
          const B2 = new Float64Array(16);
          return e.bA(B2), e.br(B2, B2, F2), e.aB(D2, B2, D2), [D2, R2];
        }
        class yo extends e.E {
          constructor(e2) {
            super(), this.requestManager = e2, this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
          }
          loadModel(t2, i2) {
            return e.dc(this.requestManager.transformRequest(i2, e.R.Model).url).then((o2) => {
              if (!o2) return;
              const s2 = e.dd(o2), r2 = new e.de(t2, i2, void 0, void 0, s2);
              return r2.computeBoundsAndApplyParent(), r2;
            }).catch((o2) => {
              if (o2 && 404 === o2.status) return null;
              this.fire(new e.y(new Error(`Could not load model ${t2} from ${i2}: ${o2.message}`)));
            });
          }
          load(t2, i2, o2 = { forceReload: false }) {
            this.models[i2] || (this.models[i2] = {});
            const s2 = Object.keys(t2), r2 = [], n2 = [];
            for (const e2 of s2) {
              const s3 = t2[e2];
              this.hasURLBeenRequested(s3) && !o2.forceReload || (this.modelByURL[s3] = { modelId: e2, scope: i2 }, r2.push(this.loadModel(e2, s3)), n2.push(e2)), this.models[i2][e2] || (this.models[i2][e2] = { model: null, numReferences: 1 });
            }
            this.numModelsLoading[i2] = (this.numModelsLoading[i2] || 0) + n2.length, Promise.allSettled(r2).then((t3) => {
              for (let e2 = 0; e2 < t3.length; e2++) {
                const { status: o3 } = t3[e2];
                if ("rejected" === o3) continue;
                const { value: s3 } = t3[e2];
                this.models[i2][n2[e2]] || (this.models[i2][n2[e2]] = { model: null, numReferences: 1 }), this.models[i2][n2[e2]].model = s3;
              }
              this.numModelsLoading[i2] -= n2.length, this.fire(new e.z("data", { dataType: "style" }));
            }).catch((t3) => {
              this.fire(new e.y(new Error(`Could not load models: ${t3.message}`)));
            });
          }
          isLoaded() {
            for (const e2 in this.numModelsLoading) if (this.numModelsLoading[e2] > 0) return false;
            return true;
          }
          hasModel(e2, t2, i2 = { exactIdMatch: false }) {
            return !!(i2.exactIdMatch ? this.getModel(e2, t2) : this.getModelByURL(this.modelUris[t2][e2]));
          }
          getModel(e2, t2) {
            return this.models[t2] || (this.models[t2] = {}), this.models[t2][e2] ? this.models[t2][e2].model : void 0;
          }
          getModelByURL(e2) {
            if (!e2) return null;
            const t2 = this.modelByURL[e2];
            return t2 ? this.models[t2.scope][t2.modelId].model : null;
          }
          hasModelBeenAdded(e2, t2) {
            return this.models[t2] && void 0 !== this.models[t2][e2];
          }
          getModelURIs(e2) {
            return this.modelUris[e2] || {};
          }
          addModel(e2, t2, i2) {
            this.models[i2] || (this.models[i2] = {}), this.modelUris[i2] || (this.modelUris[i2] = {});
            const o2 = this.requestManager.normalizeModelURL(t2);
            if ((this.hasModel(e2, i2, { exactIdMatch: true }) || this.hasModelBeenAdded(e2, i2)) && this.modelUris[i2][e2] === o2) this.models[i2][e2].numReferences++;
            else if (this.hasURLBeenRequested(o2)) {
              const { scope: e3, modelId: t3 } = this.modelByURL[o2];
              this.models[e3][t3].numReferences++;
            } else this.modelUris[i2][e2] = o2, this.load({ [e2]: this.modelUris[i2][e2] }, i2);
          }
          addModelURLs(e2, t2) {
            this.models[t2] || (this.models[t2] = {}), this.modelUris[t2] || (this.modelUris[t2] = {});
            const i2 = this.modelUris[t2];
            for (const t3 in e2) i2[t3] = this.requestManager.normalizeModelURL(e2[t3]);
          }
          reloadModels(e2) {
            this.load(this.modelUris[e2], e2, { forceReload: true });
          }
          addModelsFromBucket(t2, i2) {
            this.models[i2] || (this.models[i2] = {}), this.modelUris[i2] || (this.modelUris[i2] = {});
            const o2 = {};
            for (const s2 of t2) this.hasModel(s2, i2, { exactIdMatch: true }) || this.hasURLBeenRequested(s2) ? this.models[i2][s2].numReferences++ : this.modelUris[i2][s2] && !this.hasURLBeenRequested(s2) ? o2[s2] = this.modelUris[i2][s2] : !this.hasURLBeenRequested(s2) && e.df(s2, false) && (this.modelUris[i2][s2] = this.requestManager.normalizeModelURL(s2), o2[s2] = this.modelUris[i2][s2]);
            this.load(o2, i2);
          }
          hasURLBeenRequested(e2) {
            return void 0 !== this.modelByURL[e2];
          }
          removeModel(e2, t2, i2 = false, o2 = false) {
            if (this.models[t2] && this.models[t2][e2] && (this.models[t2][e2].numReferences--, 0 === this.models[t2][e2].numReferences || o2)) {
              const o3 = this.modelUris[t2][e2];
              i2 || delete this.modelUris[t2][e2], delete this.modelByURL[o3];
              const s2 = this.models[t2][e2].model;
              if (!s2) return;
              delete this.models[t2][e2], s2.destroy();
            }
          }
          destroy() {
            for (const e2 of Object.keys(this.models)) for (const t2 of Object.keys(this.models[e2])) {
              const i2 = this.models[e2][t2].model;
              delete this.models[e2][t2], i2 && i2.destroy();
            }
            this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
          }
          listModels(e2) {
            return this.models[e2] || (this.models[e2] = {}), Object.keys(this.models[e2]);
          }
          upload(e2, t2) {
            this.models[t2] || (this.models[t2] = {});
            for (const i2 in this.models[t2]) this.models[t2][i2].model && this.models[t2][i2].model.upload(e2.context);
          }
        }
        const xo = e.a6.colorTheme, bo = new e.a9({ data: new e.aa(xo.data) });
        function wo(t2) {
          if (!t2.metadata || !t2.metadata.content_area) return;
          const i2 = e.o.devicePixelRatio, { left: o2, top: s2, width: r2, height: n2 } = t2.metadata.content_area, a2 = o2 * i2, l2 = s2 * i2;
          return [a2, l2, a2 + r2 * i2, l2 + n2 * i2];
        }
        function To(t2) {
          if (t2) return t2.map(([t3, i2]) => [t3 * e.o.devicePixelRatio, i2 * e.o.devicePixelRatio]);
        }
        class Eo {
          constructor(e2, t2, i2) {
            this.id = e2, this.scope = t2, this.sourceCache = i2, this.pendingRequests = /* @__PURE__ */ new Set(), this.missingRequests = /* @__PURE__ */ new Set();
          }
          addPendingRequest(e2) {
            this.missingRequests.has(e2.name) || this.pendingRequests.has(e2.name) || this.pendingRequests.add(e2.name);
          }
          hasPendingRequests() {
            return this.pendingRequests.size > 0;
          }
          resolvePendingRequests() {
            const t2 = /* @__PURE__ */ new Map();
            if (!this.sourceCache.loaded()) return t2;
            const i2 = this.sourceCache.getVisibleCoordinates();
            if (0 === i2.length) return t2;
            const o2 = this.sourceCache.getSource();
            if (!(o2 instanceof pt)) return t2;
            const s2 = i2.map((e2) => this.sourceCache.getTile(e2)), r2 = o2.getImages(s2, Array.from(this.pendingRequests));
            for (const [i3, o3] of r2) t2.set(e.I.from({ name: i3, iconsetId: this.id }), o3), this.pendingRequests.delete(i3);
            for (const e2 of this.pendingRequests) this.missingRequests.add(e2);
            return this.pendingRequests.clear(), t2;
          }
        }
        class So {
          constructor() {
            e.aY(["_onIndoorUpdate"], this);
          }
          onAdd(e2) {
            return this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._map.style && this._map.style.indoorManager.on("selector-update", (e3) => this._onIndoorUpdate(e3)), this._container;
          }
          _createButton(e2, t2) {
            const i2 = l("button", e2, this._container);
            return i2.type = "button", i2.addEventListener("click", t2), i2;
          }
          _createSeparator() {
            return l("div", "mapboxgl-ctrl-separator", this._container);
          }
          _setButtonTitle(e2, t2) {
            this._map && (e2.setAttribute("aria-label", t2), e2.textContent = t2);
          }
          onRemove() {
            this._container && this._container.remove(), this._map && this._map.style && (this._map.style.indoorManager.off("selector-update", this._onIndoorUpdate), this._map = null);
          }
          getDefaultPosition() {
            return "right";
          }
          _onIndoorUpdate(e2) {
            if (!e2 || !e2.floors) return this._model = e2, void (this._container.style.display = "none");
            const t2 = this._model;
            this._model = e2, this._container.style.display = "inline-block", this._container.style.borderRadius = "8px", t2 && Array.from(this._container.children).forEach((e3) => e3.remove()), e2.floors.length > 0 && (this.addBuildingsToggleButton(), this.addCurrentFloors(e2.floors, e2.activeFloorsVisible), this._updateBuildingsButtonState());
          }
          addBuildingsToggleButton() {
            const e2 = this._createButton("mapboxgl-ctrl-buildings-toggle", () => {
              const e3 = this._map;
              this._model && e3 && e3._setIndoorActiveFloorsVisibility(!this._model.activeFloorsVisible);
            });
            l("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.classList.add("mapboxgl-ctrl-level-button", "mapboxgl-ctrl-buildings-toggle"), this._model && !this._model.activeFloorsVisible && e2.classList.add("mapboxgl-ctrl-level-button-selected"), this._container.append(e2), this._createSeparator();
          }
          _updateBuildingsButtonState() {
            const e2 = this._container.querySelector(".mapboxgl-ctrl-buildings-toggle");
            e2 && this._model && (this._model.activeFloorsVisible ? e2.classList.remove("mapboxgl-ctrl-level-button-selected") : e2.classList.add("mapboxgl-ctrl-level-button-selected"));
          }
          addCurrentFloors(e2, t2) {
            for (let i2 = 0; i2 < e2.length; i2++) {
              const o2 = e2[i2], s2 = this._createButton("mapboxgl-ctrl-level-button", () => {
                this._map._selectIndoorFloor(o2.id);
              }), r2 = (o2.name || "").trim(), n2 = o2.zIndex.toString(), a2 = r2 ? Array.from(r2).slice(0, 3).join("") : n2;
              this._setButtonTitle(s2, a2), this._model && o2.id === this._model.selectedFloorId && t2 && s2.classList.add("mapboxgl-ctrl-level-button-selected"), this._container.append(s2), i2 < e2.length - 1 && this._createSeparator();
            }
          }
        }
        class Io extends e.E {
          constructor(t2) {
            super(), this._style = t2, this._buildings = {}, this._indoorControl = null, this._activeFloors = /* @__PURE__ */ new Set(), this._activeFloorsVisible = true, this._indoorState = { selectedFloorId: null, lastActiveFloors: null, activeFloorsVisible: true }, e.aY(["_updateUI"], this), this._style.on("style.load", () => {
              this._style.isIndoorEnabled() && (this._style.map.on("load", this._updateUI), this._style.map.on("move", this._updateUI), this._style.map.on("idle", this._updateUI), this._updateUI());
            });
          }
          destroy() {
            this._buildings = {}, this._activeFloors = /* @__PURE__ */ new Set(), this._indoorState = null, this._removeIndoorControl();
          }
          selectFloor(e2) {
            e2 === this._selectedFloorId && this._activeFloorsVisible || (this._selectedFloorId = e2, this._activeFloorsVisible = true, this._updateActiveFloors());
          }
          setActiveFloorsVisibility(e2) {
            this._activeFloorsVisible = e2, this._updateActiveFloors(), this._updateIndoorSelector();
          }
          setIndoorData(e2) {
            for (const [t2, i2] of Object.entries(e2.buildings)) if (this._buildings[t2]) for (const e3 of i2.floorIds) this._buildings[t2].floors[e3] || (this._buildings[t2].floors[e3] = i2.floors[e3]);
            else this._buildings[t2] = i2;
            for (const t2 of e2.activeFloors) this._activeFloors.add(t2);
            this._updateIndoorSelector();
          }
          getIndoorTileOptions(e2, t2) {
            const i2 = this._style.getIndoorSourceLayers(e2, t2);
            return i2 && this._indoorState ? { sourceLayers: i2, indoorState: this._indoorState } : null;
          }
          _addIndoorControl() {
            this._indoorControl || (this._indoorControl = new So(), this._style.map.addControl(this._indoorControl, "right"));
          }
          _removeIndoorControl() {
            this._indoorControl && (this._indoorControl.onRemove(), this._indoorControl = null);
          }
          _updateUI() {
            const t2 = this._style.map.transform, i2 = function(t3, i3, o2, s2) {
              let r2 = null, n2 = Number.MAX_SAFE_INTEGER;
              if (s2 < 16) return null;
              for (const [s3, a2] of Object.entries(t3)) {
                const t4 = a2.center;
                if (t4) {
                  const a3 = i3.distanceTo(e.aT.convert(t4));
                  a3 < n2 && o2.contains(t4) && (n2 = a3, r2 = s3);
                }
              }
              return r2;
            }(this._buildings, t2.center, t2.getBounds(), t2.zoom);
            i2 !== this._closestBuildingId && (this._closestBuildingId = i2, this._updateIndoorSelector());
          }
          _updateIndoorSelector() {
            const t2 = this._buildings, i2 = this._closestBuildingId, o2 = i2 && t2 ? t2[i2] : void 0;
            if (!o2) return this._removeIndoorControl(), void this.fire(new e.z("selector-update", { selectedFloorId: null, activeFloorsVisible: this._activeFloorsVisible, floors: [] }));
            this._addIndoorControl();
            let s2 = null;
            for (const e2 of o2.floorIds) if (this._activeFloors && this._activeFloors.has(e2)) {
              s2 = e2;
              break;
            }
            const r2 = Array.from(o2.floorIds).map((e2) => ({ id: e2, name: o2.floors[e2].name, zIndex: o2.floors[e2].zIndex })).sort((e2, t3) => t3.zIndex - e2.zIndex).filter((e2, t3, i3) => 0 === t3 || e2.zIndex !== i3[t3 - 1].zIndex);
            this.fire(new e.z("selector-update", { selectedFloorId: s2, activeFloorsVisible: this._activeFloorsVisible, floors: r2 }));
          }
          _updateActiveFloors() {
            const e2 = this._activeFloors;
            this._activeFloors = /* @__PURE__ */ new Set(), this._indoorState = { selectedFloorId: this._selectedFloorId, lastActiveFloors: e2, activeFloorsVisible: this._activeFloorsVisible }, this._style.updateIndoorDependentLayers();
          }
        }
        const Co = (e2, t2) => Fe(e2, t2 && t2.filter((e3) => "source.canvas" !== e3.identifier)), Ro = e.aH(Gt, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setLayerProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport", "addIconset", "removeIconset"]), Ao = e.aH(Gt, ["setCenter", "setZoom", "setBearing", "setPitch"]), Lo = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), Do = { version: 8, layers: [], sources: {} }, Po = { duration: 300, delay: 0 };
        class Oo extends e.E {
          constructor(t2, i2 = {}) {
            super(), this.map = t2, this.scope = i2.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i2.importDepth || 0, this.importsCache = i2.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i2.resolvedImports || /* @__PURE__ */ new Set(), this.transition = Object.assign({}, Po), this._buildingIndex = new Ut(this), this.crossTileSymbolIndex = new qi(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedIndoor = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = false, this._hasAppearances = false, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._importedAsBasemap = false, this._changes = i2.styleChanges || new W(), this._hasDataDrivenEmissive = false, this.indoorManager = new Io(this), this.dispatcher = i2.dispatcher ? i2.dispatcher : new e.D(e.dh(), this), i2.imageManager ? this.imageManager = i2.imageManager : (this.imageManager = new X(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i2.glyphManager ? i2.glyphManager : new e.di(t2._requestManager, i2.localFontFamily ? e.dj.all : i2.localIdeographFontFamily ? e.dj.ideographs : e.dj.none, i2.localFontFamily || i2.localIdeographFontFamily), i2.modelManager ? this.modelManager = i2.modelManager : (this.modelManager = new yo(t2._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = false, this.options = i2.configOptions ? i2.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i2.configDependentLayers ? i2.configDependentLayers : /* @__PURE__ */ new Set(), this._indoorDependentLayers = i2.indoorDependentLayers ? i2.indoorDependentLayers : /* @__PURE__ */ new Set(), this._config = i2.config, this._styleColorTheme = { lut: null, lutLoading: false, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: i2.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = i2.initialConfig, this.dispatcher.broadcast("setReferrer", e.dk());
            const o2 = this;
            this._rtlTextPluginCallback = Oo.registerForPluginStateChange((t3) => {
              o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
                if (e.dl(t4), i3 && i3.every((e2) => e2)) for (const e2 in o2._sourceCaches) {
                  const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                  "vector" !== i4 && "geojson" !== i4 || t5.reload();
                }
              });
            }), this.on("data", (e2) => {
              if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType) return;
              const t3 = this.getOwnSource(e2.sourceId);
              if (t3 && t3.vectorLayerIds) for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t3.id && this._validateLayer(i3);
              }
            });
          }
          load(e2) {
            return e2 ? ("string" == typeof e2 ? this.loadURL(e2) : this.loadJSON(e2), this) : this;
          }
          _getGlobalId(t2) {
            if (!t2) return null;
            if ("string" == typeof t2) {
              if (e.h(t2)) return t2;
              const i2 = e.dm(t2);
              if (!i2.startsWith("http")) try {
                return new URL(i2, location.href).toString();
              } catch (e2) {
                return i2;
              }
              return i2;
            }
            return `json://${e.dn(JSON.stringify(t2))}`;
          }
          _diffStyle(t2, i2, o2) {
            this.globalId = this._getGlobalId(t2);
            const s2 = (e2, t3) => {
              try {
                t3(null, this.setState(e2, o2));
              } catch (e3) {
                t3(e3, false);
              }
            };
            if ("string" == typeof t2) {
              const o3 = this.map._requestManager.normalizeStyleURL(t2), r2 = this.map._requestManager.transformRequest(o3, e.R.Style);
              e.m(r2, (t3, o4) => {
                t3 ? this.fire(new e.y(t3)) : o4 && s2(o4, i2);
              });
            } else "object" == typeof t2 && s2(t2, i2);
          }
          loadURL(t2, i2 = {}) {
            this.fire(new e.z("dataloading", { dataType: "style" }));
            const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.h(t2);
            this.globalId = this._getGlobalId(t2), t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken), this.resolvedImports.add(t2);
            const s2 = this.importsCache.get(t2);
            if (s2) return this._load(s2, o2);
            const r2 = this.map._requestManager.transformRequest(t2, e.R.Style);
            this._request = e.m(r2, (i3, s3) => {
              if (this._request = null, i3) this.fire(new e.y(i3));
              else if (s3) return this.importsCache.set(t2, s3), this._load(s3, o2);
            });
          }
          loadJSON(t2, i2 = {}) {
            this.fire(new e.z("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t2), this._request = e.o.frame(() => {
              this._request = null, this._load(t2, false !== i2.validate);
            });
          }
          loadEmpty() {
            this.fire(new e.z("dataloading", { dataType: "style" })), this._load(Do, false);
          }
          _loadImports(t2, i2, o2) {
            if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
            const s2 = [];
            for (const e2 of t2) {
              const t3 = this._createFragmentStyle(e2), r2 = new Promise((e3) => {
                t3.once("style.import.load", e3), t3.once("error", e3);
              }).then(() => this.mergeAll());
              if (s2.push(r2), this.resolvedImports.has(e2.url)) {
                t3.loadEmpty();
                continue;
              }
              const n2 = e2.data || this.importsCache.get(e2.url);
              n2 ? (t3.loadJSON(n2, { validate: i2 }), this._isInternalStyle(n2) && (t3.globalId = null)) : e2.url ? t3.loadURL(e2.url, { validate: i2 }) : t3.loadEmpty();
              const a2 = { style: t3, id: e2.id, config: e2.config };
              if (o2) {
                const e3 = this.fragments.findIndex(({ id: e4 }) => e4 === o2);
                this.fragments = this.fragments.slice(0, e3).concat(a2).concat(this.fragments.slice(e3));
              } else this.fragments.push(a2);
            }
            return Promise.allSettled(s2);
          }
          getImportGlobalIds(e2 = this, t2 = /* @__PURE__ */ new Set()) {
            for (const i2 of e2.fragments) i2.style.globalId && t2.add(i2.style.globalId), this.getImportGlobalIds(i2.style, t2);
            return [...t2.values()];
          }
          _createFragmentStyle(t2) {
            const i2 = this.scope ? e.B(t2.id, this.scope) : t2.id;
            let o2;
            const s2 = this._initialConfig && this._initialConfig[i2];
            (t2.config || s2) && (o2 = Object.assign({}, t2.config, s2));
            const r2 = new Oo(this.map, { scope: i2, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o2, configOptions: this.options, colorThemeOverride: t2["color-theme"], configDependentLayers: this._configDependentLayers, indoorDependentLayers: this._indoorDependentLayers });
            return r2.setEventedParent(this.map, { style: r2 }), r2;
          }
          _reloadImports() {
            this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this._updateLayers(this._indoorDependentLayers), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
          }
          _isInternalStyle(e2) {
            return this.isRootStyle() && (e2.fragment || !!e2.schema && false !== e2.fragment);
          }
          _load(t2, i2) {
            if (this._isInternalStyle(t2)) {
              const e2 = Object.assign({}, Do, { imports: [{ id: "basemap", data: t2, url: "" }] }, t2.center ? { center: t2.center } : {}, t2.bearing ? { bearing: t2.bearing } : {}, t2.pitch ? { pitch: t2.pitch } : {}, t2.zoom ? { zoom: t2.zoom } : {}, t2.light ? { light: t2.light } : {});
              return this._importedAsBasemap = true, void this._load(e2, i2);
            }
            if (this.updateConfig(this._config, t2.schema), i2 && Co(this, we(t2))) return;
            this._loaded = true, this.stylesheet = e.dp(t2);
            const o2 = () => {
              for (const e2 in t2.sources) this.addSource(e2, t2.sources[e2], { validate: false, isInitialLoad: true });
              if (t2.iconsets) for (const e2 in t2.iconsets) this.addIconset(e2, t2.iconsets[e2]);
              t2.sprite ? this._loadIconset(t2.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), !this.glyphManager.url && t2.glyphs && this.glyphManager.setURL(t2.glyphs);
              const o3 = Vt(this.stylesheet.layers);
              if (this._order = o3.map((e2) => e2.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                const e2 = this.stylesheet.lights[0];
                this.light = new Ne(e2.properties, e2.id);
              } else this.setLights(this.stylesheet.lights);
              this.light || (this.light = new Ne(this.stylesheet.light)), this._layers = {};
              for (const t3 of o3) {
                const i3 = e.du(t3, this.scope, this._styleColorTheme.lut, this.options);
                0 !== i3.expressionDependencies.configDependencies.size && this._configDependentLayers.add(i3.fqid), i3.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(i3.fqid), this._hasAppearances = this._hasAppearances || 0 !== i3.getAppearances().length, i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3;
                const o4 = this.getOwnLayerSourceCache(i3), s4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                o4 && i3.canCastShadows() && s4 && (o4.castsShadows = true);
              }
              this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
              const s3 = this.stylesheet.terrain;
              s3 && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s3, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.z("data", { dataType: "style" }));
              const r2 = this.isRootStyle();
              t2.imports ? this._loadImports(t2.imports, i2).then(() => {
                this._reloadImports(), this.fire(new e.z(r2 ? "style.load" : "style.import.load"));
              }).catch((t3) => {
                this.fire(new e.y(new Error("Failed to load imports", t3))), this.fire(new e.z(r2 ? "style.load" : "style.import.load"));
              }) : (this._reloadImports(), this.fire(new e.z(r2 ? "style.load" : "style.import.load")));
            };
            this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
            const s2 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
            if (s2) {
              const t3 = this._evaluateColorThemeData(s2);
              this._loadColorTheme(t3).then(() => {
                o2();
              }).catch((t4) => {
                e.w(`Couldn't load color theme from the stylesheet: ${t4}`), o2();
              });
            } else this._styleColorTheme.lut = null, o2();
          }
          isRootStyle() {
            return 0 === this.importDepth;
          }
          hasAppearances() {
            return this._hasAppearances || this.fragments.some((e2) => e2.style.hasAppearances());
          }
          mergeAll() {
            let e2, t2, i2, o2, s2, r2, n2, a2, l2, c2;
            const h2 = {};
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((d2) => {
              if (d2.stylesheet) {
                if (null != d2.light && (e2 = d2.light), d2.stylesheet.lights) for (const e3 of d2.stylesheet.lights) "ambient" === e3.type && null != d2.ambientLight && (t2 = d2.ambientLight), "directional" === e3.type && null != d2.directionalLight && (i2 = d2.directionalLight);
                o2 = this._prioritizeTerrain(o2, d2.terrain, d2.stylesheet.terrain), d2.stylesheet.fog && null != d2.fog && (s2 = d2.fog), d2.stylesheet.snow && null != d2.snow && (r2 = d2.snow), d2.stylesheet.rain && null != d2.rain && (n2 = d2.rain), null != d2.stylesheet.camera && (c2 = d2.stylesheet.camera), null != d2.stylesheet.projection && (a2 = d2.stylesheet.projection), null != d2.stylesheet.transition && (l2 = d2.stylesheet.transition), h2[d2.scope] = d2._styleColorTheme;
              }
            }), this.light = e2, this.ambientLight = t2, this.directionalLight = i2, this.fog = s2, this.snow = r2, this.rain = n2, this._styleColorThemeForScope = h2, null === o2 ? delete this.terrain : this.terrain = o2, this.camera = c2 || { "camera-projection": "perspective" }, this.projection = a2 || { name: "mercator" }, this.transition = Object.assign({}, Po, l2), this.mergeSources(), this.mergeLayers(), this.mergeIndoor();
          }
          forEachFragmentStyle(e2) {
            const t2 = (i2) => {
              for (const e3 of i2.fragments) t2(e3.style);
              e2(i2);
            };
            t2(this);
          }
          _prioritizeTerrain(e2, t2, i2) {
            const o2 = e2 && 0 === e2.drapeRenderMode;
            return null === i2 ? t2 && 0 === t2.drapeRenderMode ? t2 : o2 ? e2 : null : null != t2 && (!e2 || o2 || t2 && 1 === t2.drapeRenderMode) ? t2 : e2;
          }
          mergeTerrain() {
            let e2;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t2) => {
              e2 = this._prioritizeTerrain(e2, t2.terrain, t2.stylesheet.terrain);
            }), null === e2 ? delete this.terrain : this.terrain = e2;
          }
          mergeProjection() {
            let e2;
            this.forEachFragmentStyle((t2) => {
              null != t2.stylesheet.projection && (e2 = t2.stylesheet.projection);
            }), this.projection = e2 || { name: "mercator" };
          }
          mergeSources() {
            const t2 = {}, i2 = {}, o2 = {};
            this.forEachFragmentStyle((s2) => {
              for (const i3 in s2._sourceCaches) {
                const o3 = e.B(i3, s2.scope);
                t2[o3] = s2._sourceCaches[i3];
              }
              for (const t3 in s2._otherSourceCaches) {
                const o3 = e.B(t3, s2.scope);
                i2[o3] = s2._otherSourceCaches[t3];
              }
              for (const t3 in s2._symbolSourceCaches) {
                const i3 = e.B(t3, s2.scope);
                o2[i3] = s2._symbolSourceCaches[t3];
              }
            }), this._mergedSourceCaches = t2, this._mergedOtherSourceCaches = i2, this._mergedSymbolSourceCaches = o2;
          }
          mergeIndoor() {
            this.forEachFragmentStyle((t2) => {
              if (t2.stylesheet && t2.stylesheet.indoor) for (const i2 of Object.values(t2.stylesheet.indoor)) {
                const o2 = i2, s2 = e.B(o2.sourceId, t2.scope);
                this._mergedIndoor[s2] = new Set(o2.sourceLayers || []);
              }
            });
          }
          mergeLayers() {
            const t2 = {}, i2 = [], o2 = {};
            this._mergedSlots = [], this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o3) => {
              for (const s3 of o3._order) {
                const r3 = o3._layers[s3];
                if ("slot" === r3.type) {
                  const i3 = e.dq(s3);
                  if (t2[i3]) continue;
                  t2[i3] = [];
                }
                r3.slot && t2[r3.slot] ? t2[r3.slot].push(r3) : i2.push(r3);
              }
            }), this._mergedOrder = [];
            let s2 = -1;
            const r2 = (i3 = []) => {
              for (const n2 of i3) if ("slot" === n2.type) {
                const i4 = e.dq(n2.id);
                t2[i4] && r2(t2[i4]), this._mergedSlots.push(i4);
              } else {
                const t3 = e.B(n2.id, n2.scope);
                this._mergedOrder.push(t3), o2[t3] = n2, n2.is3D(!!this.terrain) && (this._has3DLayers = true, s2 = this._mergedOrder.length - 1), "circle" === n2.type && (this._hasCircleLayers = true), "symbol" === n2.type && (this._hasSymbolLayers = true), "clip" === n2.type && (this._clipLayerPresent = true);
              }
            };
            if (r2(i2), this._has3DLayers) {
              const e2 = {};
              for (let t3 = 0; t3 < this._mergedOrder.length; ++t3) {
                const i3 = this._mergedOrder[t3];
                e2[i3] = t3 === s2 ? 1 : t3 < s2 ? o2[i3].hasOcclusionOpacityProperties ? 2 : 0 : 4;
              }
              this._mergedOrder.sort((t3, i3) => e2[t3] - e2[i3]);
            }
            this._mergedLayers = o2, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged(), this._updateDataDrivenEmissiveStrength();
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && 0 === this.terrain.drapeRenderMode;
          }
          getCamera() {
            return this.stylesheet.camera;
          }
          setCamera(e2) {
            return this.stylesheet.camera = Object.assign({}, this.stylesheet.camera, e2), this.camera = this.stylesheet.camera, this;
          }
          _evaluateColorThemeData(t2) {
            return t2.data ? function(t3, i2, o2) {
              const s2 = Object.assign({}, i2);
              for (const e2 of Object.keys(xo)) void 0 === s2[e2] && (s2[e2] = xo[e2].default);
              const r2 = new e.a8(bo, t3, new Map(o2));
              return r2.setTransitionOrValue(s2, o2), r2.untransitioned().possiblyEvaluate(new e.ac(0, { worldview: void 0 }));
            }(this.scope, t2, this.options).get("data") : null;
          }
          _loadColorTheme(t2) {
            this._styleColorTheme.lutLoading = true, this._styleColorTheme.lutLoadingCorrelationID += 1;
            const i2 = this._styleColorTheme.lutLoadingCorrelationID;
            return new Promise((o2, s2) => {
              const r2 = "data:image/png;base64,";
              if (!t2 || 0 === t2.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = false, void o2();
              let n2 = t2;
              n2.startsWith(r2) || (n2 = r2 + n2);
              const a2 = e.I.from("mapbox-reserved-lut"), l2 = new Image();
              l2.src = n2, l2.onerror = () => {
                this._styleColorTheme.lutLoading = false, s2(new Error("Failed to load image data"));
              }, l2.onload = () => {
                if (this._styleColorTheme.lutLoadingCorrelationID !== i2) return void o2();
                this._styleColorTheme.lutLoading = false;
                const { width: r3, height: n3, data: c2 } = e.o.getImageData(l2);
                if (n3 > 32) return void s2(new Error("The height of the image must be less than or equal to 32 pixels."));
                if (r3 !== n3 * n3) return void s2(new Error("The width of the image must be equal to the height squared."));
                this.getImage(a2) && this.removeImage(a2), this.addImage(a2, { data: new e.q({ width: r3, height: n3 }, c2), pixelRatio: 1, sdf: false, usvg: false, version: 0 });
                const h2 = this.imageManager.getImage(a2, this.scope);
                h2 ? (this._styleColorTheme.lut = { image: h2.data, data: t2 }, o2()) : s2(new Error("Missing LUT image."));
              };
            });
          }
          getLut(e2) {
            const t2 = this._styleColorThemeForScope[e2];
            return t2 ? t2.lut : null;
          }
          setProjection(e2) {
            e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
          }
          _updateMapProjection() {
            this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
          }
          _loadSprite(t2) {
            this._spriteRequest = function(t3, i2, o2) {
              let s2, r2, n2;
              const a2 = e.o.devicePixelRatio > 1 ? "@2x" : "";
              let l2 = e.m(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.R.SpriteJSON), (e2, t4) => {
                l2 = null, n2 || (n2 = e2, s2 = t4, h2());
              }), c2 = e.n(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.R.SpriteImage), (e2, t4) => {
                c2 = null, n2 || (n2 = e2, r2 = t4, h2());
              });
              function h2() {
                if (n2) o2(n2);
                else if (s2 && r2) {
                  const t4 = e.o.getImageData(r2), i3 = {};
                  for (const o3 in s2) {
                    const { width: r3, height: n3, x: a3, y: l3, sdf: c3, pixelRatio: h3, stretchX: d2, stretchY: u2, content: _2 } = s2[o3], p2 = new e.q({ width: r3, height: n3 });
                    e.q.copy(t4, p2, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: r3, height: n3 }, null), i3[o3] = { data: p2, pixelRatio: void 0 !== h3 ? h3 : 1, sdf: void 0 !== c3 && c3, stretchX: d2, stretchY: u2, content: _2, usvg: false, version: 0 };
                  }
                  o2(null, i3);
                }
              }
              return { cancel() {
                l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
              } };
            }(t2, this.map._requestManager, (t3, i2) => {
              if (this._spriteRequest = null, t3) this.fire(new e.y(t3));
              else if (i2) {
                const t4 = /* @__PURE__ */ new Map();
                for (const o2 in i2) t4.set(e.I.from(o2), i2[o2]);
                this.addImages(t4);
              }
              this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e.z("data", { dataType: "style" }));
            });
          }
          addIconset(t2, i2) {
            if ("sprite" === i2.type) return void this._loadSprite(i2.url);
            const o2 = this.getOwnSourceCache(i2.source);
            if (!o2) return void this.fire(new e.y(new Error(`Source "${i2.source}" as specified by iconset "${t2}" does not exist and cannot be used as an iconset source`)));
            const s2 = o2.getSource();
            if ("raster-array" !== s2.type) return void this.fire(new e.y(new Error(`Source "${i2.source}" as specified by iconset "${t2}" is not a "raster-array" source and cannot be used as an iconset source`)));
            s2.partial = false;
            const r2 = new Eo(t2, this.scope, o2);
            this.imageManager.addImageProvider(r2, this.scope);
          }
          removeIconset(e2) {
            this.imageManager.removeImageProvider(e2, this.scope);
          }
          _loadIconset(t2) {
            if (!e.h(t2) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t2);
            const i2 = "auto" === this.map._spriteFormat;
            var o2, s2;
            this._spriteRequest = (s2 = (o3, s3) => {
              if (this._spriteRequest = null, o3) i2 ? this._loadSprite(t2) : this.fire(new e.y(o3));
              else if (s3) {
                const t3 = /* @__PURE__ */ new Map();
                for (const i3 in s3) t3.set(e.I.from(i3), s3[i3]);
                this.addImages(t3);
              }
              this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e.z("data", { dataType: "style" }));
            }, e.bu((o2 = this.map._requestManager).transformRequest(o2.normalizeIconsetURL(t2), e.R.Iconset), (t3, i3) => {
              if (t3) return void s2(t3);
              const o3 = {}, r2 = e.dg(new e.bt(i3));
              for (const t4 of r2.icons) {
                const i4 = { version: 1, pixelRatio: e.o.devicePixelRatio, content: wo(t4), stretchX: t4.metadata ? To(t4.metadata.stretch_x_areas) : void 0, stretchY: t4.metadata ? To(t4.metadata.stretch_y_areas) : void 0, sdf: false, usvg: true, icon: t4 };
                o3[t4.name] = i4;
              }
              s2(null, o3);
            }));
          }
          _validateLayer(t2) {
            const i2 = this.getOwnSource(t2.source);
            if (!i2) return;
            const o2 = t2.sourceLayer;
            o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.y(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return false;
            for (const e2 in this._sourceCaches) if (!this._sourceCaches[e2].loaded()) return false;
            if (!this.imageManager.isLoaded()) return false;
            if (this.imageManager.hasPatternsInFlight()) return false;
            if (!this.modelManager.isLoaded()) return false;
            if (this._styleColorTheme.lutLoading) return false;
            for (const { style: e2 } of this.fragments) if (!e2.loaded()) return false;
            return true;
          }
          _serializeImports() {
            if (this.stylesheet.imports) return this.stylesheet.imports.map((e2, t2) => {
              const i2 = this.fragments[t2];
              return i2 && i2.style && (e2.data = i2.style.serialize()), e2;
            });
          }
          _serializeSources() {
            const e2 = {};
            for (const t2 in this._sourceCaches) {
              const i2 = this._sourceCaches[t2].getSource();
              e2[i2.id] || (e2[i2.id] = i2.serialize());
            }
            return e2;
          }
          _serializeLayers(e2) {
            const t2 = [];
            for (const i2 of e2) {
              const e3 = this._layers[i2];
              e3 && "custom" !== e3.type && t2.push(e3.serialize());
            }
            return t2;
          }
          hasLightTransitions() {
            return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
          }
          hasFogTransition() {
            return !!this.fog && this.fog.hasTransition();
          }
          hasSnowTransition() {
            return !!this.snow && this.snow.hasTransition();
          }
          hasRainTransition() {
            return !!this.rain && this.rain.hasTransition();
          }
          hasTransitions() {
            if (this.hasLightTransitions()) return true;
            if (this.hasFogTransition()) return true;
            if (this.hasSnowTransition()) return true;
            if (this.hasRainTransition()) return true;
            for (const e2 in this._sourceCaches) if (this._sourceCaches[e2].hasTransition()) return true;
            for (const e2 in this._layers) if (this._layers[e2].hasTransition()) return true;
            return false;
          }
          _updateDataDrivenEmissiveStrength() {
            for (const e2 in this._mergedLayers) {
              const t2 = this._mergedLayers[e2];
              if (t2._transitionablePaint && t2._transitionablePaint._values) {
                const e3 = t2._transitionablePaint._values["line-emissive-strength"];
                if (e3 && e3.value && e3.value.isDataDriven()) return void (this._hasDataDrivenEmissive = true);
              }
            }
            this._hasDataDrivenEmissive = false;
          }
          hasDataDrivenEmissiveStrength() {
            return this._hasDataDrivenEmissive;
          }
          get order() {
            return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
          }
          _getOrder(e2) {
            return e2 ? this.order : this._mergedOrder;
          }
          isLayerDraped(e2) {
            return !!this.terrain && e2.isDraped(this.getLayerSourceCache(e2));
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading");
          }
          _checkLayer(t2) {
            const i2 = this.getOwnLayer(t2);
            if (i2) return i2;
            this.fire(new e.y(new Error(`The layer '${t2}' does not exist in the map's style.`)));
          }
          _checkSource(t2) {
            const i2 = this.getOwnSource(t2);
            if (i2) return i2;
            this.fire(new e.y(new Error(`The source '${t2}' does not exist in the map's style.`)));
          }
          precompilePrograms(e2, t2) {
            const i2 = this.map.painter;
            if (i2) for (let o2 = e2.minzoom || 0; o2 < (e2.maxzoom || 25.5); o2++) {
              const o3 = e2.getProgramIds();
              if (o3) for (const s2 of o3) {
                const o4 = e2.getDefaultProgramParams(s2, t2.zoom, this._styleColorTheme.lut);
                o4 && (i2.style = this, this.fog && (i2._fogVisible = true, o4.overrideFog = true, i2.getOrCreateProgram(s2, o4)), i2._fogVisible = false, o4.overrideFog = false, i2.getOrCreateProgram(s2, o4), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o4.overrideRtt = true, i2.getOrCreateProgram(s2, o4)));
              }
            }
          }
          update(t2) {
            if (!this._loaded) return;
            this.ambientLight && this.ambientLight.recalculate(t2), this.directionalLight && this.directionalLight.recalculate(t2);
            const i2 = this.calculateLightsBrightness();
            t2.brightness = i2 || 0, i2 !== this._brightness && (this._brightness = i2, this.dispatcher.broadcast("setBrightness", i2)), t2.worldview !== this._worldview && (this._worldview = t2.worldview, this.dispatcher.broadcast("setWorldview", this._worldview));
            const o2 = this._changes.isDirty();
            let s2 = false;
            if (this._changes.isDirty()) {
              const e2 = this._changes.getLayerUpdatesByScope();
              for (const t3 in e2) {
                const { updatedIds: i3, removedIds: o3 } = e2[t3];
                (i3 || o3) && (this._updateWorkerLayers(t3, i3, o3), s2 = true);
              }
              this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t2), this.light && this.light.updateTransitions(t2), this.ambientLight && this.ambientLight.updateTransitions(t2), this.directionalLight && this.directionalLight.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this.snow && this.snow.updateTransitions(t2), this.rain && this.rain.updateTransitions(t2), this._changes.reset();
            }
            const r2 = {};
            for (const e2 in this._mergedSourceCaches) {
              const t3 = this._mergedSourceCaches[e2];
              r2[e2] = t3.used, t3.used = false, t3.tileCoverLift = 0;
            }
            for (const e2 of this._mergedOrder) {
              const i3 = this._mergedLayers[e2];
              if ("none" !== i3.visibility && i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
                const e3 = this.getLayerSourceCache(i3);
                e3 && (e3.used = true, e3.tileCoverLift = Math.max(e3.tileCoverLift, i3.tileCoverLift()));
              }
              !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
                this.precompilePrograms(i3, t2);
              }) : this.precompilePrograms(i3, t2));
            }
            this._shouldPrecompile && (this._precompileDone = true), this.terrain && s2 && this.mergeLayers();
            const n2 = this.imageManager.getPendingImageProviders();
            for (const e2 of n2) e2.sourceCache.used = true;
            for (const t3 in r2) {
              const i3 = this._mergedSourceCaches[t3];
              r2[t3] !== i3.used && i3.getSource().fire(new e.z("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
            }
            this.light && this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.snow && this.snow.recalculate(t2), this.rain && this.rain.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), this.imageManager.clearUpdatedImages(this.scope), o2 && this.fire(new e.z("data", { dataType: "style" }));
          }
          updateImageProviders() {
            const e2 = this.imageManager.getPendingImageProviders();
            for (const t2 of e2) {
              const e3 = t2.resolvePendingRequests(), i2 = this.getFragmentStyle(t2.scope);
              i2 && i2.addImages(e3);
            }
          }
          _updateTilesForChangedImages() {
            const e2 = {};
            for (const t2 in this._mergedSourceCaches) {
              const i2 = this._mergedSourceCaches[t2].getSource().scope;
              e2[i2] = e2[i2] || this._changes.getUpdatedImages(i2), 0 !== e2[i2].length && this._mergedSourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2[i2]);
            }
            for (const t2 in e2) this._changes.resetUpdatedImages(t2);
          }
          _updateWorkerLayers(e2, t2, i2) {
            const o2 = this.getFragmentStyle(e2);
            o2 && this.dispatcher.broadcast("updateLayers", { layers: t2 ? o2._serializeLayers(t2) : [], scope: e2, removedIds: i2 || [], options: o2.options });
          }
          setState(t2, i2) {
            if (this._checkLoaded(), Co(this, we(t2))) return false;
            (t2 = e.dp(t2)).layers = Vt(t2.layers);
            const o2 = function(t3, i3) {
              if (!t3) return [{ command: Gt.setStyle, args: [i3] }];
              let o3 = [];
              try {
                if (!e.by(t3.version, i3.version)) return [{ command: Gt.setStyle, args: [i3] }];
                if (e.by(t3.center, i3.center) || o3.push({ command: Gt.setCenter, args: [i3.center] }), e.by(t3.zoom, i3.zoom) || o3.push({ command: Gt.setZoom, args: [i3.zoom] }), e.by(t3.bearing, i3.bearing) || o3.push({ command: Gt.setBearing, args: [i3.bearing] }), e.by(t3.pitch, i3.pitch) || o3.push({ command: Gt.setPitch, args: [i3.pitch] }), e.by(t3.sprite, i3.sprite) || o3.push({ command: Gt.setSprite, args: [i3.sprite] }), e.by(t3.glyphs, i3.glyphs) || o3.push({ command: Gt.setGlyphs, args: [i3.glyphs] }), e.by(t3.imports, i3.imports) || function(t4 = [], i4 = [], o4) {
                  i4 = i4 || [];
                  const s4 = (t4 = t4 || []).map(Xt), r4 = i4.map(Xt), n3 = t4.reduce(Yt, {}), a3 = i4.reduce(Yt, {}), l2 = s4.slice();
                  let c2, h2, d2, u2;
                  for (c2 = 0, h2 = 0; c2 < s4.length; c2++) d2 = s4[c2], a3.hasOwnProperty(d2) ? h2++ : (o4.push({ command: Gt.removeImport, args: [d2] }), l2.splice(l2.indexOf(d2, h2), 1));
                  for (c2 = 0, h2 = 0; c2 < r4.length; c2++) d2 = r4[r4.length - 1 - c2], l2[l2.length - 1 - c2] !== d2 && (n3.hasOwnProperty(d2) ? (o4.push({ command: Gt.removeImport, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - h2), 1)) : h2++, u2 = l2[l2.length - c2], o4.push({ command: Gt.addImport, args: [a3[d2], u2] }), l2.splice(l2.length - c2, 0, d2));
                  for (const t5 of i4) {
                    const i5 = n3[t5.id];
                    i5 && (delete i5.data, e.by(i5, t5) || o4.push({ command: Gt.updateImport, args: [t5.id, t5] }));
                  }
                }(t3.imports, i3.imports, o3), e.by(t3.transition, i3.transition) || o3.push({ command: Gt.setTransition, args: [i3.transition] }), e.by(t3.light, i3.light) || o3.push({ command: Gt.setLight, args: [i3.light] }), e.by(t3.fog, i3.fog) || o3.push({ command: Gt.setFog, args: [i3.fog] }), e.by(t3.snow, i3.snow) || o3.push({ command: Gt.setSnow, args: [i3.snow] }), e.by(t3.rain, i3.rain) || o3.push({ command: Gt.setRain, args: [i3.rain] }), e.by(t3.projection, i3.projection) || o3.push({ command: Gt.setProjection, args: [i3.projection] }), e.by(t3.lights, i3.lights) || o3.push({ command: Gt.setLights, args: [i3.lights] }), e.by(t3.camera, i3.camera) || o3.push({ command: Gt.setCamera, args: [i3.camera] }), e.by(t3.iconsets, i3.iconsets) || function(t4, i4, o4) {
                  let s4;
                  for (s4 in i4 = i4 || {}, t4 = t4 || {}) t4.hasOwnProperty(s4) && (i4.hasOwnProperty(s4) || o4.push({ command: Gt.removeIconset, args: [s4] }));
                  for (s4 in i4) {
                    if (!i4.hasOwnProperty(s4)) continue;
                    const r4 = i4[s4];
                    t4.hasOwnProperty(s4) ? e.by(t4[s4], r4) || (o4.push({ command: Gt.removeIconset, args: [s4] }), o4.push({ command: Gt.addIconset, args: [s4, r4] })) : o4.push({ command: Gt.addIconset, args: [s4, r4] });
                  }
                }(t3.iconsets, i3.iconsets, o3), !e.by(t3["color-theme"], i3["color-theme"])) return [{ command: Gt.setStyle, args: [i3] }];
                const s3 = {}, r3 = [];
                !function(t4, i4, o4, s4) {
                  let r4;
                  for (r4 in i4 = i4 || {}, t4 = t4 || {}) t4.hasOwnProperty(r4) && (i4.hasOwnProperty(r4) || qt(r4, o4, s4));
                  for (r4 in i4) {
                    if (!i4.hasOwnProperty(r4)) continue;
                    const n3 = i4[r4];
                    t4.hasOwnProperty(r4) ? e.by(t4[r4], n3) || ("geojson" === t4[r4].type && "geojson" === n3.type && Wt(t4, i4, r4) ? o4.push({ command: Gt.setGeoJSONSourceData, args: [r4, n3.data] }) : Zt(r4, i4, o4, s4)) : Ht(r4, i4, o4);
                  }
                }(t3.sources, i3.sources, r3, s3);
                const n2 = [];
                t3.layers && t3.layers.forEach((e2) => {
                  e2.source && s3[e2.source] ? o3.push({ command: Gt.removeLayer, args: [e2.id] }) : n2.push(e2);
                });
                let a2 = t3.terrain;
                a2 && s3[a2.source] && (o3.push({ command: Gt.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(r3), e.by(a2, i3.terrain) || o3.push({ command: Gt.setTerrain, args: [i3.terrain] }), function(t4, i4, o4) {
                  i4 = i4 || [];
                  const s4 = (t4 = t4 || []).map(Xt), r4 = i4.map(Xt), n3 = t4.reduce(Yt, {}), a3 = i4.reduce(Yt, {}), l2 = s4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                  let h2, d2, u2, _2, p2, f2, m2;
                  for (h2 = 0, d2 = 0; h2 < s4.length; h2++) u2 = s4[h2], a3.hasOwnProperty(u2) ? d2++ : (o4.push({ command: Gt.removeLayer, args: [u2] }), l2.splice(l2.indexOf(u2, d2), 1));
                  for (h2 = 0, d2 = 0; h2 < r4.length; h2++) u2 = r4[r4.length - 1 - h2], l2[l2.length - 1 - h2] !== u2 && (n3.hasOwnProperty(u2) ? (o4.push({ command: Gt.removeLayer, args: [u2] }), l2.splice(l2.lastIndexOf(u2, l2.length - d2), 1)) : d2++, f2 = l2[l2.length - h2], o4.push({ command: Gt.addLayer, args: [a3[u2], f2] }), l2.splice(l2.length - h2, 0, u2), c2[u2] = true);
                  for (h2 = 0; h2 < r4.length; h2++) if (u2 = r4[h2], _2 = n3[u2], p2 = a3[u2], !c2[u2] && !e.by(_2, p2)) if (e.by(_2.source, p2.source) && e.by(_2["source-layer"], p2["source-layer"]) && e.by(_2.type, p2.type)) {
                    for (m2 in $t(_2.layout, p2.layout, o4, u2, null, Gt.setLayoutProperty), $t(_2.paint, p2.paint, o4, u2, null, Gt.setPaintProperty), e.by(_2.slot, p2.slot) || o4.push({ command: Gt.setSlot, args: [u2, p2.slot] }), e.by(_2.filter, p2.filter) || o4.push({ command: Gt.setFilter, args: [u2, p2.filter] }), e.by(_2.minzoom, p2.minzoom) && e.by(_2.maxzoom, p2.maxzoom) || o4.push({ command: Gt.setLayerZoomRange, args: [u2, p2.minzoom, p2.maxzoom] }), _2) _2.hasOwnProperty(m2) && "layout" !== m2 && "paint" !== m2 && "filter" !== m2 && "metadata" !== m2 && "minzoom" !== m2 && "maxzoom" !== m2 && "slot" !== m2 && (0 === m2.indexOf("paint.") ? $t(_2[m2], p2[m2], o4, u2, m2.slice(6), Gt.setPaintProperty) : e.by(_2[m2], p2[m2]) || o4.push({ command: Gt.setLayerProperty, args: [u2, m2, p2[m2]] }));
                    for (m2 in p2) p2.hasOwnProperty(m2) && !_2.hasOwnProperty(m2) && "layout" !== m2 && "paint" !== m2 && "filter" !== m2 && "metadata" !== m2 && "minzoom" !== m2 && "maxzoom" !== m2 && "slot" !== m2 && (0 === m2.indexOf("paint.") ? $t(_2[m2], p2[m2], o4, u2, m2.slice(6), Gt.setPaintProperty) : e.by(_2[m2], p2[m2]) || o4.push({ command: Gt.setLayerProperty, args: [u2, m2, p2[m2]] }));
                  } else o4.push({ command: Gt.removeLayer, args: [u2] }), f2 = l2[l2.lastIndexOf(u2) + 1], o4.push({ command: Gt.addLayer, args: [p2, f2] });
                }(n2, i3.layers, o3);
              } catch (e2) {
                console.warn("Unable to compute style diff:", e2), o3 = [{ command: Gt.setStyle, args: [i3] }];
              }
              return o3;
            }(this.serialize(), t2).filter((e2) => !(e2.command in Ao));
            if (0 === o2.length) return false;
            const s2 = o2.filter((e2) => !(e2.command in Ro));
            if (s2.length > 0) throw new Error(`Unimplemented: ${s2.map((e2) => e2.command).join(", ")}.`);
            const r2 = [];
            return o2.forEach((e2) => {
              r2.push(this[e2.command](...e2.args));
            }), i2 && Promise.all(r2).then(i2).catch(i2), this.stylesheet = t2, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
          }
          _updateWorkerImages() {
            this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages });
          }
          _updateWorkerModels() {
            this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", { scope: this.scope, models: this._availableModels });
          }
          addImages(t2) {
            if (0 === t2.size) return this;
            for (const [i2, o2] of t2.entries()) {
              if (this.getImage(i2)) return this.fire(new e.y(new Error(`An image with the name "${i2.name}" already exists.`)));
              this.imageManager.addImage(i2, this.scope, o2), this._changes.updateImage(i2, this.scope);
            }
            return this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })), this;
          }
          addImage(t2, i2) {
            return this.getImage(t2) ? this.fire(new e.y(new Error(`An image with the name "${t2.name}" already exists.`))) : (this.imageManager.addImage(t2, this.scope, i2), this._changes.updateImage(t2, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })), this);
          }
          updateImage(t2, i2, o2 = false) {
            this.imageManager.updateImage(t2, this.scope, i2), o2 && (this._changes.updateImage(t2, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })));
          }
          getImage(e2) {
            return this.imageManager.getImage(e2, this.scope);
          }
          removeImage(t2) {
            return this.getImage(t2) ? (this.imageManager.removeImage(t2, this.scope), this._changes.updateImage(t2, this.scope), this._updateWorkerImages(), this.fire(new e.z("data", { dataType: "style" })), this) : this.fire(new e.y(new Error("No image with this name exists.")));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          getActualScope() {
            return this._importedAsBasemap ? "basemap" : this.scope;
          }
          addModelURLs(t2) {
            return this.modelManager.addModelURLs(t2, this.getActualScope()), this._updateWorkerModels(), this.fire(new e.z("data", { dataType: "style" })), this;
          }
          addModel(t2, i2, o2 = {}) {
            return this._checkLoaded(), this._validate(ze, `models.${t2}`, i2, null, o2) || (this.modelManager.addModel(t2, i2, this.getActualScope()), this.fire(new e.z("data", { dataType: "style" }))), this;
          }
          hasModel(e2) {
            return this.modelManager.hasModel(e2, this.getActualScope());
          }
          removeModel(t2) {
            return this.hasModel(t2) ? (this.modelManager.removeModel(t2, this.getActualScope(), false, true), this.fire(new e.z("data", { dataType: "style" })), this) : this.fire(new e.y(new Error("No model with this ID exists.")));
          }
          listModels() {
            return this._checkLoaded(), this.modelManager.listModels(this.getActualScope());
          }
          addSource(t2, i2, o2 = {}) {
            if (this._checkLoaded(), void 0 !== this.getOwnSource(t2)) throw new Error(`There is already a source with ID "${t2}".`);
            if (!i2.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(Te, `sources.${t2}`, i2, null, o2)) return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const s2 = mt(t2, i2, this.dispatcher, this);
            s2.scope = this.scope, s2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(s2.id), source: s2.serialize(), sourceId: s2.id }));
            const r2 = (t3) => {
              const i3 = (t3 ? "symbol:" : "other:") + s2.id, o3 = e.B(i3, this.scope), r3 = this._sourceCaches[i3] = new Ft(o3, s2, t3);
              (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[s2.id] = r3, r3.onAdd(this.map);
            };
            r2(false), "vector" !== i2.type && "geojson" !== i2.type || r2(true), s2.onAdd && s2.onAdd(this.map), o2.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
          }
          removeSource(t2) {
            this._checkLoaded();
            const i2 = this.getOwnSource(t2);
            if (!i2) throw new Error("There is no source with this ID");
            for (const i3 in this._layers) if (this._layers[i3].source === t2) return this.fire(new e.y(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
            if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t2) return this.fire(new e.y(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
            if (this.stylesheet.iconsets) {
              const i3 = Object.entries(this.stylesheet.iconsets).find(([e2, i4]) => "source" === i4.type && i4.source === t2);
              if (i3) return this.fire(new e.y(new Error(`Source "${t2}" cannot be removed while iconset "${i3[0]}" is using it.`)));
            }
            const o2 = this.getOwnSourceCaches(t2);
            for (const t3 of o2) {
              const i3 = e.dq(t3.id);
              delete this._sourceCaches[i3], this._changes.discardSourceCacheUpdate(t3.id), t3.fire(new e.z("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
            }
            return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], this.mergeSources(), i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changes.setDirty(), this;
          }
          setGeoJSONSourceData(e2, t2) {
            this._checkLoaded(), this.getOwnSource(e2).setData(t2), this._changes.setDirty();
          }
          getOwnSource(e2) {
            const t2 = this.getOwnSourceCache(e2);
            return t2 && t2.getSource();
          }
          getOwnSources() {
            const e2 = [];
            for (const t2 in this._otherSourceCaches) {
              const i2 = this.getOwnSourceCache(t2);
              i2 && e2.push(i2.getSource());
            }
            return e2;
          }
          areTilesLoaded() {
            const e2 = this._mergedSourceCaches;
            for (const t2 in e2) {
              const i2 = e2[t2]._tiles;
              for (const e3 in i2) {
                const t3 = i2[e3];
                if ("loaded" !== t3.state && "errored" !== t3.state) return false;
              }
            }
            return true;
          }
          setLights(t2) {
            if (this._checkLoaded(), !t2) return delete this.ambientLight, void delete this.directionalLight;
            const i2 = this._getTransitionParameters();
            for (const e2 of t2) {
              if (this._validate(Se, "lights", e2)) return;
              switch (e2.type) {
                case "ambient":
                  if (this.ambientLight) {
                    const t3 = this.ambientLight;
                    t3.set(e2), t3.updateTransitions(i2);
                  } else this.ambientLight = new et(e2, tt(), this.scope, this.options);
                  break;
                case "directional":
                  if (this.directionalLight) {
                    const t3 = this.directionalLight;
                    t3.set(e2), t3.updateTransitions(i2);
                  } else this.directionalLight = new et(e2, ot(), this.scope, this.options);
              }
            }
            const o2 = Object.assign(i2, { worldview: this.map.getWorldview() }), s2 = new e.ac(this.z || 0, o2);
            this.ambientLight && this.ambientLight.recalculate(s2), this.directionalLight && this.directionalLight.recalculate(s2), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
          }
          calculateLightsBrightness() {
            const t2 = this.directionalLight, i2 = this.ambientLight;
            if (!t2 || !i2) return;
            const o2 = (e2) => 0.2126 * (e2[0] <= 0.03928 ? e2[0] / 12.92 : Math.pow((e2[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e2[1] <= 0.03928 ? e2[1] / 12.92 : Math.pow((e2[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e2[2] <= 0.03928 ? e2[2] / 12.92 : Math.pow((e2[2] + 0.055) / 1.055, 2.4)), s2 = t2.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), r2 = t2.properties.get("intensity"), n2 = t2.properties.get("direction"), a2 = 1 - e.d4(n2.x, n2.y, n2.z)[2] / 90, l2 = o2(s2) * r2 * a2, c2 = i2.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(), h2 = i2.properties.get("intensity"), d2 = o2(c2) * h2;
            return Number(((l2 + d2) / 2).toFixed(6));
          }
          getBrightness() {
            return this._brightness;
          }
          getLights() {
            if (!this.enable3dLights()) return null;
            const e2 = [];
            return this.directionalLight && e2.push(this.directionalLight.get()), this.ambientLight && e2.push(this.ambientLight.get()), e2;
          }
          enable3dLights() {
            return !!this.ambientLight && !!this.directionalLight;
          }
          getFragmentStyle(t2) {
            if (null == t2 || "" === t2 && this.isRootStyle()) return this;
            if (e.dr(t2)) {
              const i2 = e.ds(t2), o2 = this.fragments.find(({ id: e2 }) => e2 === i2);
              if (!o2) return;
              const s2 = e.dq(t2);
              return o2.style.getFragmentStyle(s2);
            }
            {
              const e2 = this.fragments.find(({ id: e3 }) => e3 === t2);
              return e2 ? e2.style : void 0;
            }
          }
          setFeaturesetSelectors(t2) {
            if (!t2) return;
            const i2 = {}, o2 = (e2, t3 = "") => `${e2}::${t3}`;
            this._featuresetSelectors = {};
            for (const s2 in t2) {
              const r2 = this._featuresetSelectors[s2] = [];
              for (const n2 of t2[s2].selectors) {
                if (n2.featureNamespace) {
                  const t4 = this.getOwnLayer(n2.layer);
                  if (!t4) {
                    e.w(`Layer is undefined for selector: ${n2.layer}`);
                    continue;
                  }
                  const r3 = o2(t4.source, t4.sourceLayer);
                  if (r3 in i2 && i2[r3] !== n2.featureNamespace) {
                    e.w(`"featureNamespace ${n2.featureNamespace} of featureset ${s2}'s selector is not associated to the same source, skip this selector`);
                    continue;
                  }
                  i2[r3] = n2.featureNamespace;
                }
                let t3;
                if (n2.properties) for (const i3 in n2.properties) {
                  const o3 = e.U(n2.properties[i3]);
                  "success" === o3.result && (t3 = t3 || {}, t3[i3] = o3.value);
                }
                r2.push({ layerId: n2.layer, namespace: n2.featureNamespace, properties: t3, uniqueFeatureID: n2._uniqueFeatureID });
              }
            }
          }
          getFeaturesetDescriptors(e2) {
            const t2 = this.getFragmentStyle(e2);
            if (!t2 || !t2.stylesheet.featuresets) return [];
            const i2 = [];
            for (const e3 in t2.stylesheet.featuresets) i2.push({ featuresetId: e3, importId: t2.scope ? t2.scope : void 0 });
            return i2;
          }
          getFeaturesetLayers(t2, i2) {
            const o2 = this.getFragmentStyle(i2), s2 = o2.stylesheet.featuresets;
            if (!s2 || !s2[t2]) return this.fire(new e.y(new Error(`The featureset '${t2}' does not exist in the map's style and cannot be queried.`))), [];
            const r2 = [];
            for (const e2 of s2[t2].selectors) {
              const t3 = o2.getOwnLayer(e2.layer);
              t3 && r2.push(t3);
            }
            return r2;
          }
          getConfigProperty(t2, i2) {
            const o2 = this.getFragmentStyle(t2);
            if (!o2) return null;
            const s2 = e.B(i2, o2.scope), r2 = o2.options.get(s2), n2 = r2 ? r2.value || r2.default : null;
            return n2 ? n2.serialize() : null;
          }
          isIndoorEnabled() {
            return Object.keys(this._mergedIndoor).length > 0;
          }
          getIndoorSourceLayers(t2, i2) {
            const o2 = e.B(t2, i2);
            return this._mergedIndoor[o2];
          }
          setIndoorData(e2, t2) {
            this.indoorManager.setIndoorData(t2);
          }
          updateIndoorDependentLayers() {
            this._updateLayers(this._indoorDependentLayers), this.map._styleDirty = true, this.map.triggerRepaint();
          }
          setConfigProperty(t2, i2, o2) {
            const s2 = this.getFragmentStyle(t2);
            if (!s2) return;
            const r2 = s2.stylesheet.schema;
            if (!r2 || !r2[i2]) return;
            const n2 = e.U(o2);
            if ("success" !== n2.result) return void Co(this, n2.value);
            const a2 = n2.value.expression, l2 = e.B(i2, s2.scope), c2 = s2.options.get(l2);
            if (!c2) return;
            let h2;
            const { minValue: d2, maxValue: u2, stepValue: _2, type: p2, values: f2 } = r2[i2], m2 = e.U(r2[i2].default);
            "success" === m2.result && (h2 = m2.value.expression), h2 ? (this.options.set(l2, Object.assign({}, c2, { value: a2, default: h2, minValue: d2, maxValue: u2, stepValue: _2, type: p2, values: f2 })), this.updateConfigDependencies(i2)) : this.fire(new e.y(new Error(`No schema defined for the config option "${i2}" in the "${t2}" fragment.`)));
          }
          getConfig(t2) {
            const i2 = this.getFragmentStyle(t2);
            if (!i2) return null;
            const o2 = i2.stylesheet.schema;
            if (!o2) return null;
            const s2 = {};
            for (const t3 in o2) {
              const o3 = e.B(t3, i2.scope), r2 = i2.options.get(o3), n2 = r2 ? r2.value || r2.default : null;
              s2[t3] = n2 ? n2.serialize() : null;
            }
            return s2;
          }
          setConfig(e2, t2) {
            const i2 = this.getFragmentStyle(e2);
            i2 && (i2.updateConfig(t2, i2.stylesheet.schema), this.updateConfigDependencies());
          }
          getSchema(e2) {
            const t2 = this.getFragmentStyle(e2);
            return t2 ? t2.stylesheet.schema : null;
          }
          setSchema(e2, t2) {
            const i2 = this.getFragmentStyle(e2);
            i2 && (i2.stylesheet.schema = t2, i2.updateConfig(i2._config, t2), this.updateConfigDependencies());
          }
          updateConfig(t2, i2) {
            if (this._config = t2, t2 || i2) if (i2) for (const o2 in i2) {
              let s2, r2;
              const n2 = e.U(i2[o2].default);
              if ("success" === n2.result && (s2 = n2.value.expression), t2 && void 0 !== t2[o2]) {
                const i3 = e.U(t2[o2]);
                "success" === i3.result && (r2 = i3.value.expression);
              }
              const { minValue: a2, maxValue: l2, stepValue: c2, type: h2, values: d2 } = i2[o2];
              if (s2) {
                const t3 = e.B(o2, this.scope);
                this.options.set(t3, { default: s2, value: r2, minValue: a2, maxValue: l2, stepValue: c2, type: h2, values: d2 });
              } else this.fire(new e.y(new Error(`No schema defined for config option "${o2}".`)));
            }
            else this.fire(new e.y(new Error("Attempting to set config for a style without schema.")));
          }
          _updateLayers(e2, t2 = () => true) {
            for (const i2 of e2) {
              const e3 = this.getLayer(i2);
              e3 && t2(e3) && (e3.possiblyEvaluateVisibility(), this._updateLayer(e3), this._changes.setDirty());
            }
          }
          updateConfigDependencies(e2) {
            this._updateLayers(this._configDependentLayers, (t2) => !e2 || t2.expressionDependencies.configDependencies.has(e2)), this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((e3) => {
              const t2 = e3._styleColorTheme.colorThemeOverride ? e3._styleColorTheme.colorThemeOverride : e3._styleColorTheme.colorTheme;
              if (t2) {
                const i2 = e3._evaluateColorThemeData(t2);
                (!e3._styleColorTheme.lut && "" !== i2 || e3._styleColorTheme.lut && i2 !== e3._styleColorTheme.lut.data) && e3.setColorTheme(t2);
              }
            }), this._changes.setDirty();
          }
          addLayer(t2, i2, o2 = {}) {
            this._checkLoaded();
            const s2 = t2.id;
            if (this._layers[s2]) return void this.fire(new e.y(new Error(`Layer with id "${s2}" already exists on this map`)));
            let r2;
            if ("custom" === t2.type) {
              if (Co(this, e.dt(t2))) return;
              r2 = e.du(t2, this.scope, this._styleColorTheme.lut, this.options);
            } else {
              if ("object" == typeof t2.source && (this.addSource(s2, t2.source), t2 = e.dp(t2), t2 = Object.assign(t2, { source: s2 })), this._validate(Le, `layers.${s2}`, t2, { arrayIndex: -1 }, o2)) return;
              r2 = e.du(t2, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r2), r2.setEventedParent(this, { layer: { id: s2 } });
            }
            const n2 = e.B(r2.source, r2.scope);
            0 !== r2.expressionDependencies.configDependencies.size && this._configDependentLayers.add(n2), r2.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(n2);
            let a2 = this._order.length;
            if (i2) {
              const t3 = this._order.indexOf(i2);
              if (-1 === t3) return void this.fire(new e.y(new Error(`Layer with id "${i2}" does not exist on this map.`)));
              r2.slot && r2.slot !== this._layers[i2].slot ? e.w(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`) : a2 = t3;
            }
            this._order.splice(a2, 0, s2), this._handleLayerOrderChange(), this._layers[s2] = r2;
            const l2 = this.getOwnLayerSourceCache(r2), c2 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            l2 && r2.canCastShadows() && c2 && (l2.castsShadows = true);
            const h2 = this._changes.getRemovedLayer(r2);
            if (h2 && r2.source && l2 && "custom" !== r2.type) {
              this._changes.discardLayerRemoval(r2);
              const t3 = e.B(r2.source, r2.scope);
              h2.type !== r2.type ? this._changes.updateSourceCache(t3, "clear") : (this._changes.updateSourceCache(t3, "reload"), l2.pause());
            }
            this._updateLayer(r2), r2.onAdd && r2.onAdd(this.map), r2.scope = this.scope, this.mergeLayers();
          }
          moveLayer(t2, i2) {
            this._checkLoaded();
            const o2 = this._checkLayer(t2);
            if (!o2) return;
            if (t2 === i2) return;
            const s2 = this._order.indexOf(t2);
            this._order.splice(s2, 1);
            let r2 = this._order.length;
            if (i2) {
              const t3 = this._order.indexOf(i2);
              if (-1 === t3) return void this.fire(new e.y(new Error(`Layer with id "${i2}" does not exist on this map.`)));
              o2.slot && o2.slot !== this._layers[i2].slot ? e.w(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`) : r2 = t3;
            }
            this._order.splice(r2, 0, t2), this._changes.setDirty(), this._handleLayerOrderChange(), this.mergeLayers();
          }
          removeLayer(e2) {
            this._checkLoaded();
            const t2 = this._checkLayer(e2);
            if (!t2) return;
            t2.setEventedParent(null);
            const i2 = this._order.indexOf(e2);
            this._order.splice(i2, 1), delete this._layers[e2], this._changes.setDirty(), this._handleLayerOrderChange(), this._configDependentLayers.delete(t2.fqid), this._indoorDependentLayers.delete(t2.fqid), this._changes.removeLayer(t2);
            const o2 = this.getOwnLayerSourceCache(t2);
            if (o2 && o2.castsShadows) {
              let e3 = false;
              for (const i3 in this._layers) if (this._layers[i3].source === t2.source && this._layers[i3].canCastShadows()) {
                e3 = true;
                break;
              }
              o2.castsShadows = e3;
            }
            t2.onRemove && t2.onRemove(this.map), this.mergeLayers();
          }
          getOwnLayer(e2) {
            return this._layers[e2];
          }
          hasLayer(e2) {
            return e2 in this._mergedLayers;
          }
          hasLayerType(e2) {
            for (const t2 in this._layers) if (this._layers[t2].type === e2) return true;
            return false;
          }
          setLayerZoomRange(e2, t2, i2) {
            this._checkLoaded();
            const o2 = this._checkLayer(e2);
            o2 && (o2.minzoom === t2 && o2.maxzoom === i2 || (null != t2 && (o2.minzoom = t2), null != i2 && (o2.maxzoom = i2), this._updateLayer(o2)));
          }
          getSlots() {
            return this._checkLoaded(), this._mergedSlots;
          }
          setSlot(e2, t2) {
            this._checkLoaded();
            const i2 = this._checkLayer(e2);
            i2 && i2.slot !== t2 && (i2.slot = t2, this._updateLayer(i2));
          }
          setFilter(t2, i2, o2 = {}) {
            this._checkLoaded();
            const s2 = this._checkLayer(t2);
            if (s2 && !e.by(s2.filter, i2)) return null == i2 ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(De, `layers.${s2.id}.filter`, i2, { layerType: s2.type }, o2) || (s2.filter = e.dp(i2), this._updateLayer(s2)));
          }
          getFilter(t2) {
            const i2 = this._checkLayer(t2);
            if (i2) return e.dp(i2.filter);
          }
          setLayoutProperty(t2, i2, o2, s2 = {}) {
            this._checkLoaded();
            const r2 = this._checkLayer(t2);
            if (r2 && !e.by(r2.getLayoutProperty(i2), o2)) {
              if (null != o2 && (!s2 || false !== s2.validate) && Co(r2, Oe.call(we, { key: `layers.${t2}.layout.${i2}`, layerType: r2.type, objectKey: i2, value: o2, styleSpec: e.a6, style: { glyphs: true, sprite: true } }))) return;
              r2.setLayoutProperty(i2, o2), 0 !== r2.expressionDependencies.configDependencies.size && this._configDependentLayers.add(r2.fqid), r2.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(r2.fqid), this._updateLayer(r2);
            }
          }
          setLayerProperty(e2, t2, i2, o2 = {}) {
            this._checkLoaded();
            const s2 = this._checkLayer(e2);
            s2 && ("appearances" === t2 ? (s2.setAppearances(i2), this._changes.setDirty()) : s2.isPaintProperty(t2) ? this.setPaintProperty(e2, t2, i2, o2) : this.setLayoutProperty(e2, t2, i2, o2));
          }
          getLayoutProperty(e2, t2) {
            const i2 = this._checkLayer(e2);
            if (i2) return i2.getLayoutProperty(t2);
          }
          setPaintProperty(t2, i2, o2, s2 = {}) {
            this._checkLoaded();
            const r2 = this._checkLayer(t2);
            if (!r2) return;
            if (e.by(r2.getPaintProperty(i2), o2)) return;
            if (null != o2 && (!s2 || false !== s2.validate) && Co(r2, Pe.call(we, { key: `layers.${t2}.paint.${i2}`, layerType: r2.type, objectKey: i2, value: o2, styleSpec: e.a6 }))) return;
            const n2 = r2.setPaintProperty(i2, o2);
            0 !== r2.expressionDependencies.configDependencies.size && this._configDependentLayers.add(r2.fqid), r2.expressionDependencies.isIndoorDependent && this._indoorDependentLayers.add(r2.fqid), n2 && this._updateLayer(r2), this._changes.updatePaintProperties(r2);
          }
          getPaintProperty(e2, t2) {
            const i2 = this._checkLayer(e2);
            if (i2) return i2.getPaintProperty(t2);
          }
          setFeatureState(t2, i2) {
            if (this._checkLoaded(), "target" in t2) {
              if ("featuresetId" in t2.target) {
                const { featuresetId: e2, importId: o3 } = t2.target, s3 = this.getFragmentStyle(o3), r3 = s3.getFeaturesetLayers(e2);
                for (const { source: e3, sourceLayer: o4 } of r3) s3.setFeatureState({ id: t2.id, source: e3, sourceLayer: o4 }, i2);
              } else if ("layerId" in t2.target) {
                const { layerId: e2 } = t2.target, o3 = this.getLayer(e2);
                this.setFeatureState({ id: t2.id, source: o3.source, sourceLayer: o3.sourceLayer }, i2);
              }
              return;
            }
            const o2 = t2.source, s2 = t2.sourceLayer, r2 = this._checkSource(o2);
            if (!r2) return;
            const n2 = r2.type;
            if ("geojson" === n2 && s2) return void this.fire(new e.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if ("vector" === n2 && !s2) return void this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            void 0 === t2.id && this.fire(new e.y(new Error("The feature id parameter must be provided.")));
            const a2 = this.getOwnSourceCaches(o2);
            for (const e2 of a2) e2.setFeatureState(s2, t2.id, i2);
          }
          removeFeatureState(t2, i2) {
            if (this._checkLoaded(), "target" in t2) {
              if ("featuresetId" in t2.target) {
                const { featuresetId: e2, importId: o3 } = t2.target, s3 = this.getFragmentStyle(o3), r3 = s3.getFeaturesetLayers(e2);
                for (const { source: e3, sourceLayer: o4 } of r3) s3.removeFeatureState({ id: t2.id, source: e3, sourceLayer: o4 }, i2);
              } else if ("layerId" in t2.target) {
                const { layerId: e2 } = t2.target, o3 = this.getLayer(e2);
                this.removeFeatureState({ id: t2.id, source: o3.source, sourceLayer: o3.sourceLayer }, i2);
              }
              return;
            }
            const o2 = t2.source, s2 = this._checkSource(o2);
            if (!s2) return;
            const r2 = s2.type, n2 = "vector" === r2 ? t2.sourceLayer : void 0;
            if ("vector" === r2 && !n2) return void this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i2 && "string" != typeof t2.id && "number" != typeof t2.id) return void this.fire(new e.y(new Error("A feature id is required to remove its specific state property.")));
            const a2 = this.getOwnSourceCaches(o2);
            for (const e2 of a2) e2.removeFeatureState(n2, t2.id, i2);
          }
          getFeatureState(t2) {
            if (this._checkLoaded(), "target" in t2) {
              let i3;
              if ("featuresetId" in t2.target) {
                const { featuresetId: o3, importId: s3 } = t2.target, r2 = this.getFragmentStyle(s3), n2 = r2.getFeaturesetLayers(o3);
                for (const { source: o4, sourceLayer: s4 } of n2) {
                  const n3 = r2.getFeatureState({ id: t2.id, source: o4, sourceLayer: s4 });
                  if (n3 && !i3) i3 = n3;
                  else if (!e.by(i3, n3)) return void this.fire(new e.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                }
              } else if ("layerId" in t2.target) {
                const { layerId: e2 } = t2.target, o3 = this.getLayer(e2);
                i3 = this.getFeatureState({ id: t2.id, source: o3.source, sourceLayer: o3.sourceLayer });
              }
              return i3;
            }
            const i2 = t2.source, o2 = t2.sourceLayer, s2 = this._checkSource(i2);
            if (s2) {
              if ("vector" !== s2.type || o2) return void 0 === t2.id && this.fire(new e.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i2)[0].getFeatureState(o2, t2.id);
              this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
          }
          setTransition(e2) {
            return this.stylesheet.transition = Object.assign({}, this.stylesheet.transition, e2), this.transition = this.stylesheet.transition, this;
          }
          getTransition() {
            return Object.assign({}, this.stylesheet.transition);
          }
          serialize() {
            this._checkLoaded();
            const t2 = this.getTerrain(), i2 = t2 && this.terrain && this.terrain.scope === this.scope ? t2 : this.stylesheet.terrain;
            return e.dv({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, iconsets: this.stylesheet.iconsets, featuresets: this.stylesheet.featuresets, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i2, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, indoor: this.stylesheet.indoor, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
          }
          _updateFilteredLayers(e2) {
            for (const t2 of Object.values(this._mergedLayers)) e2(t2) && this._updateLayer(t2);
          }
          _updateLayer(t2) {
            this._changes.updateLayer(t2);
            const i2 = this.getLayerSourceCache(t2), o2 = e.B(t2.source, t2.scope), s2 = this._changes.getUpdatedSourceCaches();
            t2.source && !s2[o2] && i2 && "raster" !== i2.getSource().type && (this._changes.updateSourceCache(o2, "reload"), i2.pause()), t2.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e2) {
            const t2 = (e3) => this._mergedLayers[e3].is3D(!!this.terrain), i2 = this.order, o2 = {}, s2 = [];
            for (let r3 = i2.length - 1; r3 >= 0; r3--) {
              const n2 = i2[r3];
              if (t2(n2)) {
                o2[n2] = r3;
                for (const t3 of e2) {
                  const e3 = t3[n2];
                  if (e3) for (const t4 of e3) s2.push(t4);
                }
              }
            }
            s2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
            const r2 = [];
            for (let n2 = i2.length - 1; n2 >= 0; n2--) {
              const a2 = i2[n2];
              if (t2(a2)) for (let e3 = s2.length - 1; e3 >= 0; e3--) {
                const t3 = s2[e3].feature;
                if (t3.layer && o2[t3.layer.id] < n2) break;
                r2.push(t3), s2.pop();
              }
              else for (const t3 of e2) {
                const e3 = t3[a2];
                if (e3) for (const t4 of e3) r2.push(t4.feature);
              }
            }
            return r2;
          }
          queryRasterValue(t2, i2, o2) {
            const s2 = this.getOwnSource(t2);
            return s2 ? "raster-array" !== s2.type ? (this.fire(new e.y(new Error('queryRasterValue support only "raster-array" sources.'))), Promise.resolve(null)) : s2.queryRasterArrayValue(i2, o2) : (this.fire(new e.y(new Error(`Source with id "${t2}" does not exist in the style.`))), Promise.resolve(null));
          }
          queryRenderedFeatures(t2, i2, o2) {
            let s2;
            i2 && !Array.isArray(i2) && i2.filter && (this._validate(De, "queryRenderedFeatures.filter", i2.filter, null, i2), s2 = e.b6(i2.filter));
            const r2 = {}, n2 = (e2) => {
              if (Lo.has(e2.type)) return;
              const t3 = this.getOwnLayerSourceCache(e2), i3 = r2[t3.id] = r2[t3.id] || { sourceCache: t3, layers: {}, has3DLayers: false };
              e2.is3D(!!this.terrain) && (i3.has3DLayers = true), i3.layers[e2.fqid] = i3.layers[e2.fqid] || { styleLayer: e2, targets: [] }, i3.layers[e2.fqid].targets.push({ filter: s2 });
            };
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers)) return this.fire(new e.y(new Error("parameters.layers must be an Array."))), [];
              for (const t3 of i2.layers) {
                const i3 = this._layers[t3];
                if (!i3) return this.fire(new e.y(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                n2(i3);
              }
            } else for (const e2 in this._layers) n2(this._layers[e2]);
            const a2 = this._queryRenderedFeatures(t2, r2, o2), l2 = this._flattenAndSortRenderedFeatures(a2), c2 = [];
            for (const t3 of l2) e.dw(t3.layer.id) === this.scope && c2.push(t3);
            return c2;
          }
          queryRenderedFeatureset(t2, i2, o2) {
            let s2;
            i2 && !Array.isArray(i2) && i2.filter && (this._validate(De, "queryRenderedFeatures.filter", i2.filter, null, i2), s2 = e.b6(i2.filter));
            const r2 = "mock", n2 = [];
            if (i2 && i2.target) n2.push(Object.assign({}, i2, { targetId: r2, filter: s2 }));
            else {
              const e2 = this.getFeaturesetDescriptors();
              for (const t3 of e2) n2.push({ targetId: r2, filter: s2, target: t3 });
              for (const { style: e3 } of this.fragments) {
                const t3 = e3.getFeaturesetDescriptors();
                for (const e4 of t3) n2.push({ targetId: r2, filter: s2, target: e4 });
              }
            }
            const a2 = this.queryRenderedTargets(t2, n2, o2), l2 = [], c2 = /* @__PURE__ */ new Set();
            for (const t3 of a2) for (const i3 of t3.variants[r2]) vt(i3, t3, c2) || l2.push(new e.dx(t3, i3));
            return l2;
          }
          queryRenderedTargets(t2, i2, o2) {
            const s2 = {}, r2 = (e2, t3, i3, o3) => {
              const r3 = s2[t3.id] = s2[t3.id] || { sourceCache: t3, layers: {}, has3DLayers: false };
              if (r3.layers[e2.fqid] = r3.layers[e2.fqid] || { styleLayer: e2, targets: [] }, e2.is3D(!!this.terrain) && (r3.has3DLayers = true), !o3) return i3.uniqueFeatureID = false, void r3.layers[e2.fqid].targets.push(i3);
              r3.layers[e2.fqid].targets.push(Object.assign({}, i3, { namespace: o3.namespace, properties: o3.properties, uniqueFeatureID: o3.uniqueFeatureID }));
            };
            for (const t3 of i2) if ("featuresetId" in t3.target) {
              const { featuresetId: i3, importId: o3 } = t3.target, s3 = this.getFragmentStyle(o3);
              if (!s3 || !s3._featuresetSelectors) continue;
              const n3 = s3._featuresetSelectors[i3];
              if (!n3) {
                this.fire(new e.y(new Error(`The featureset '${i3}' does not exist in the map's style and cannot be queried for features.`)));
                continue;
              }
              for (const e2 of n3) {
                const i4 = s3.getOwnLayer(e2.layerId);
                i4 && !Lo.has(i4.type) && r2(i4, s3.getOwnLayerSourceCache(i4), t3, e2);
              }
            } else if ("layerId" in t3.target) {
              const { layerId: e2 } = t3.target, i3 = this.getLayer(e2);
              if (!i3 || Lo.has(i3.type)) continue;
              r2(i3, this.getLayerSourceCache(i3), t3);
            }
            const n2 = this._queryRenderedFeatures(t2, s2, o2);
            return this._flattenAndSortRenderedFeatures(n2);
          }
          _queryRenderedFeatures(e2, t2, i2) {
            const o2 = [], s2 = !!this.map._showQueryGeometry, r2 = st.createFromScreenPoints(e2, i2);
            for (const e3 in t2) {
              const n2 = yt(r2, t2[e3], this._availableImages, i2, s2, this.getActualScope());
              Object.keys(n2).length && o2.push(n2);
            }
            if (this.placement) for (const e3 in t2) {
              if (!t2[e3].sourceCache._onlySymbols) continue;
              const i3 = xt(r2.screenGeometry, t2[e3], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData, this.map.getWorldview());
              Object.keys(i3).length && o2.push(i3);
            }
            return o2;
          }
          querySourceFeatures(e2, t2) {
            const i2 = t2 && t2.filter;
            i2 && this._validate(De, "querySourceFeatures.filter", i2, null, t2);
            let o2 = [];
            const s2 = this.getOwnSourceCaches(e2);
            for (const e3 of s2) o2 = o2.concat(bt(e3, t2));
            return o2;
          }
          addSourceType(e2, t2, i2) {
            return Oo.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Oo.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
          }
          getFlatLight() {
            return this.light.getLight();
          }
          setFlatLight(t2, i2, o2 = {}) {
            this._checkLoaded();
            const s2 = this.light.getLight();
            let r2 = false;
            for (const i3 in t2) if (!e.by(t2[i3], s2[i3])) {
              r2 = true;
              break;
            }
            if (!r2) return;
            const n2 = this._getTransitionParameters();
            this.light.setLight(t2, i2, o2), this.light.updateTransitions(n2);
          }
          getTerrain() {
            return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          checkCanvasFingerprintNoise() {
            void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.o.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
          }
          setTerrain(t2, i2 = 1) {
            if (this._checkLoaded(), !t2) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i2 && delete this.terrain, null === t2 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            this.checkCanvasFingerprintNoise();
            let o2 = t2;
            const s2 = !("source" in t2) || null == t2.source;
            if (1 === i2) {
              if (this.disableElevatedTerrain) return;
              if ("source" in o2 && "object" == typeof o2.source) {
                const t4 = "terrain-dem-src";
                this.addSource(t4, o2.source), o2 = e.dp(o2), o2 = Object.assign(o2, { source: t4 });
              }
              const t3 = Object.assign({}, o2), i3 = {};
              if (this.terrain && s2) {
                t3.source = this.terrain.get().source;
                const e2 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                e2 && (i3.style = e2.serialize());
              }
              if (this._validate(Ie, "terrain", t3, i3)) return;
            }
            if (!this.terrain || this.terrain.scope !== this.scope && !s2 || this.terrain && i2 !== this.terrain.drapeRenderMode) {
              if (!o2) return;
              this._createTerrain(o2, i2), this.fire(new e.z("data", { dataType: "style" }));
            } else {
              const i3 = this.terrain, s3 = i3.get();
              for (const t3 of Object.keys(e.a6.terrain)) !o2.hasOwnProperty(t3) && e.a6.terrain[t3].default && (o2[t3] = e.a6.terrain[t3].default);
              for (const o3 in t2) if (!e.by(t2[o3], s3[o3])) {
                i3.set(t2, this.options), this.stylesheet.terrain = t2;
                const o4 = this._getTransitionParameters({ duration: 0 });
                i3.updateTransitions(o4), this.fire(new e.z("data", { dataType: "style" }));
                break;
              }
            }
            this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(e2) {
            const t2 = this.fog = new $e(e2, this.map.transform, this.scope, this.options);
            this.stylesheet.fog = t2.get();
            const i2 = this._getTransitionParameters({ duration: 0 });
            t2.updateTransitions(i2);
          }
          _createSnow(e2) {
            const t2 = this.snow = new Je(e2, this.map.transform, this.scope, this.options);
            this.stylesheet.snow = t2.get();
            const i2 = this._getTransitionParameters({ duration: 0 });
            t2.updateTransitions(i2);
          }
          _createRain(e2) {
            const t2 = this.rain = new Qe(e2, this.map.transform, this.scope, this.options);
            this.stylesheet.rain = t2.get();
            const i2 = this._getTransitionParameters({ duration: 0 });
            t2.updateTransitions(i2);
          }
          _updateMarkersOpacity() {
            0 !== this.map._markers.length && this.map._requestDomTask(() => {
              for (const e2 of this.map._markers) e2._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(t2) {
            if (this._checkLoaded(), !t2) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i2 = this.fog;
              if (!e.by(i2.get(), t2)) {
                i2.set(t2, this.options), this.stylesheet.fog = i2.get();
                const e2 = this._getTransitionParameters({ duration: 0 });
                i2.updateTransitions(e2);
              }
            } else this._createFog(t2);
            this._markersNeedUpdate = true;
          }
          getSnow() {
            return this.snow ? this.snow.get() : null;
          }
          setSnow(t2) {
            if (this._checkLoaded(), !t2) return delete this.snow, void delete this.stylesheet.snow;
            if (this.snow) {
              const i2 = this.snow;
              if (!e.by(i2.get(), t2)) {
                i2.set(t2, this.options), this.stylesheet.snow = i2.get();
                const e2 = this._getTransitionParameters({ duration: 0 });
                i2.updateTransitions(e2);
              }
            } else this._createSnow(t2);
            this._markersNeedUpdate = true;
          }
          getRain() {
            return this.rain ? this.rain.get() : null;
          }
          setRain(t2) {
            if (this._checkLoaded(), !t2) return delete this.rain, void delete this.stylesheet.rain;
            if (this.rain) {
              const i2 = this.rain;
              if (!e.by(i2.get(), t2)) {
                i2.set(t2, this.options), this.stylesheet.rain = i2.get();
                const e2 = this._getTransitionParameters({ duration: 0 });
                i2.updateTransitions(e2);
              }
            } else this._createRain(t2);
            this._markersNeedUpdate = true;
          }
          _reloadColorTheme() {
            const t2 = () => {
              for (const e2 in this._layers) this._layers[e2].lut = this._styleColorTheme.lut;
              for (const e2 in this._sourceCaches) this._sourceCaches[e2].clearTiles();
            }, i2 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
            if (!i2) return this._styleColorTheme.lut = null, void t2();
            const o2 = this._evaluateColorThemeData(i2);
            this._loadColorTheme(o2).then(() => {
              this.fire(new e.z("colorthemeset")), t2();
            }).catch((t3) => {
              e.w(`Couldn't set color theme: ${t3}`);
            });
          }
          setColorTheme(t2) {
            this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t2, this._reloadColorTheme();
          }
          setImportColorTheme(e2, t2) {
            const i2 = this.getFragmentStyle(e2);
            i2 && (i2._styleColorTheme.colorThemeOverride = t2, i2._reloadColorTheme());
          }
          _getTransitionParameters(t2) {
            return { now: e.o.now(), transition: Object.assign(this.transition, t2) };
          }
          updateDrapeFirstLayers() {
            if (!this.terrain) return;
            const e2 = [], t2 = [];
            for (const i2 of this._mergedOrder) this.isLayerDraped(this._mergedLayers[i2]) ? e2.push(i2) : t2.push(i2);
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
          }
          _createTerrain(e2, t2) {
            const i2 = this.terrain = new je(e2, t2, this.scope, this.options, this.map.getWorldview());
            1 === t2 && (this.stylesheet.terrain = e2), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
            const o2 = this._getTransitionParameters({ duration: 0 });
            i2.updateTransitions(o2);
          }
          _force3DLayerUpdate() {
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              "fill-extrusion" === t2.type && this._updateLayer(t2);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              "symbol" === t2.type && this._updateLayer(t2);
            }
          }
          _validate(t2, i2, o2, s2, r2 = {}) {
            if (r2 && false === r2.validate) return false;
            const n2 = Object.assign({}, this.serialize());
            return Co(this, t2.call(we, Object.assign({ key: i2, style: n2, value: o2, styleSpec: e.a6 }, s2)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.dy.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e2 in this._mergedLayers) this._mergedLayers[e2].setEventedParent(null);
            for (const e2 in this._mergedSourceCaches) this._mergedSourceCaches[e2].clearTiles(), this._mergedSourceCaches[e2].setEventedParent(null);
            this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.indoorManager.destroy(), this.isRootStyle() && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());
          }
          clearSource(e2) {
            const t2 = this.getSourceCaches(e2);
            for (const e3 of t2) e3.clearTiles();
          }
          clearSources() {
            for (const e2 in this._mergedSourceCaches) this._mergedSourceCaches[e2].clearTiles();
          }
          clearLayers() {
            for (const e2 in this._mergedLayers) {
              const t2 = this._mergedLayers[e2];
              t2._clear && t2._clear();
            }
          }
          reloadSource(e2) {
            const t2 = this.getSourceCaches(e2);
            for (const e3 of t2) e3.resume(), e3.reload();
          }
          reloadSources() {
            for (const e2 of this.getSources()) e2.reload && e2.reload();
          }
          reloadModels() {
            this.modelManager.reloadModels(""), this.forEachFragmentStyle((e2) => {
              e2.modelManager.reloadModels(e2.scope);
            });
          }
          updateSources(e2) {
            let t2;
            this.directionalLight && (t2 = mo(this.directionalLight));
            const i2 = /* @__PURE__ */ new Set(), o2 = /* @__PURE__ */ new Set();
            for (const e3 in this._mergedLayers) {
              const t3 = this._mergedLayers[e3];
              "building" === t3.type && i2.add(t3.source), t3.hasElevation() && !o2.has(t3.source) && o2.add(t3.source);
            }
            for (const s2 in this._mergedSourceCaches) {
              const r2 = this._mergedSourceCaches[s2], n2 = o2.has(r2._source.id);
              i2.has(r2._source.id) && (r2._source.reparseOverscaled = false), r2.update(e2, void 0, void 0, t2, n2);
            }
          }
          _generateCollisionBoxes() {
            for (const e2 in this._sourceCaches) {
              const t2 = this._sourceCaches[e2];
              t2.resume(), t2.reload();
            }
          }
          _handleLayerOrderChange() {
            this._requestFullLabelPlacement(), this.fire(new e.z("neworder"));
          }
          _requestFullLabelPlacement() {
            this.pauseablePlacement || (this.pauseablePlacement = new Ui()), this.pauseablePlacement.requestFullPlacement();
          }
          _setLabelPlacementStale() {
            this.placement && this.placement.setStale();
          }
          _updatePlacement(t2, i2, o2, s2, r2) {
            this.pauseablePlacement || (this.pauseablePlacement = new Ui());
            let n2 = false, a2 = false;
            const l2 = {}, c2 = {};
            for (const i3 of this._mergedOrder) {
              const o3 = this._mergedLayers[i3];
              if ("symbol" !== o3.type) continue;
              const s3 = e.B(o3.source, o3.scope);
              let r3 = l2[s3];
              if (!r3) {
                const e2 = this.getLayerSourceCache(o3);
                if (!e2) continue;
                const t3 = e2.getRenderableIds(true).map((t4) => e2.getTileByID(t4));
                c2[s3] = t3.slice(), r3 = l2[s3] = t3.sort((e3, t4) => t4.tileID.overscaledZ - e3.tileID.overscaledZ || (e3.tileID.isLessThan(t4.tileID) ? -1 : 1));
              }
              const a3 = this.crossTileSymbolIndex.addLayer(o3, r3, t2.center.lng, t2.projection);
              n2 = n2 || a3;
            }
            this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder);
            const h2 = Boolean(this.placement && !t2.equals(this.placement.transform)), d2 = Boolean(this.placement && (0 !== this.placement.lastReplacementSourceUpdateTime && !r2 || this.placement.lastReplacementSourceUpdateTime !== r2.updateTime)), u2 = h2 || d2 || n2, _2 = (u2 || this.pauseablePlacement.isStale()) && 0 === o2, p2 = this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.o.now(), t2.zoom) && 0 !== o2;
            if ((this.pauseablePlacement.isFullPlacementRequested() || !this.pauseablePlacement.placement || _2 || p2) && (this.pauseablePlacement = this.pauseablePlacement.startNewPlacement(t2, this._mergedOrder, i2, o2, s2, this.placement, this.fog && t2.projection.supportsFog ? this.fog.state : null, this._buildingIndex)), this.pauseablePlacement.isDone() ? u2 && 0 !== o2 && this.pauseablePlacement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l2, c2, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.o.now()), a2 = true), n2 && this.pauseablePlacement.setStale()), a2 || n2) {
              this._buildingIndex.onNewFrame(t2.zoom);
              for (let t3 = 0; t3 < this._mergedOrder.length; t3++) {
                const i3 = this._mergedLayers[this._mergedOrder[t3]];
                if ("symbol" !== i3.type) continue;
                if ("none" === i3.visibility) continue;
                const o3 = this.isLayerClipped(i3);
                this.placement.updateLayerOpacities(i3, l2[e.B(i3.source, i3.scope)], t3, o3 ? r2 : null);
              }
            }
            return !this.pauseablePlacement.isDone() || this.placement.isStale() || this.placement.hasTransitions(e.o.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e2 in this._sourceCaches) this._sourceCaches[e2].releaseSymbolFadeTiles();
          }
          addImport(t2, i2) {
            this._checkLoaded();
            const o2 = this.stylesheet.imports = this.stylesheet.imports || [];
            if (-1 !== o2.findIndex(({ id: e2 }) => e2 === t2.id)) return void this.fire(new e.y(new Error(`Import with id '${t2.id}' already exists in the map's style.`)));
            if (!i2) return o2.push(t2), this._loadImports([t2], true);
            const s2 = o2.findIndex(({ id: e2 }) => e2 === i2);
            return -1 === s2 && this.fire(new e.y(new Error(`Import with id "${i2}" does not exist on this map.`))), this.stylesheet.imports = o2.slice(0, s2).concat(t2).concat(o2.slice(s2)), this._loadImports([t2], true, i2);
          }
          updateImport(t2, i2) {
            this._checkLoaded();
            const o2 = this.stylesheet.imports || [], s2 = this.getImportIndex(t2);
            return -1 === s2 ? this : "string" == typeof i2 ? (this.setImportUrl(t2, i2), this) : (i2.url && i2.url !== o2[s2].url && this.setImportUrl(t2, i2.url), e.by(i2.config, o2[s2].config) || this.setImportConfig(t2, i2.config, i2.data.schema), e.by(i2.data, o2[s2].data) || this.setImportData(t2, i2.data), this);
          }
          moveImport(e2, t2) {
            this._checkLoaded();
            let i2 = this.stylesheet.imports || [];
            const o2 = this.getImportIndex(e2);
            if (-1 === o2) return this;
            const s2 = this.getImportIndex(t2);
            if (-1 === s2) return this;
            const r2 = i2[o2], n2 = this.fragments[o2];
            return i2 = i2.filter(({ id: t3 }) => t3 !== e2), this.fragments = this.fragments.filter(({ id: t3 }) => t3 !== e2), this.stylesheet.imports = i2.slice(0, s2).concat(r2).concat(i2.slice(s2)), this.fragments = this.fragments.slice(0, s2).concat(n2).concat(this.fragments.slice(s2)), this.mergeLayers(), this;
          }
          setImportUrl(e2, t2) {
            this._checkLoaded();
            const i2 = this.stylesheet.imports || [], o2 = this.getImportIndex(e2);
            if (-1 === o2) return this;
            i2[o2].url = t2;
            const s2 = this.fragments[o2];
            return s2.style = this._createFragmentStyle(i2[o2]), s2.style.on("style.import.load", () => this.mergeAll()), s2.style.loadURL(t2), this;
          }
          setImportData(e2, t2) {
            this._checkLoaded();
            const i2 = this.getImportIndex(e2), o2 = this.stylesheet.imports || [];
            return -1 === i2 ? this : t2 ? (this.fragments[i2].style.setState(t2), this._reloadImports(), this) : (delete o2[i2].data, this.setImportUrl(e2, o2[i2].url));
          }
          setImportConfig(e2, t2, i2) {
            this._checkLoaded();
            const o2 = this.getImportIndex(e2), s2 = this.stylesheet.imports || [];
            if (-1 === o2) return this;
            t2 ? s2[o2].config = t2 : delete s2[o2].config;
            const r2 = this.fragments[o2];
            i2 && r2.style.stylesheet && (r2.style.stylesheet.schema = i2);
            const n2 = r2.style.stylesheet && r2.style.stylesheet.schema;
            return r2.config = t2, r2.style.updateConfig(t2, n2), this.updateConfigDependencies(), this;
          }
          removeImport(e2) {
            this._checkLoaded();
            const t2 = this.stylesheet.imports || [], i2 = this.getImportIndex(e2);
            -1 !== i2 && (t2.splice(i2, 1), this.fragments[i2].style._remove(), this.fragments.splice(i2, 1), this._reloadImports());
          }
          getImportIndex(t2) {
            const i2 = (this.stylesheet.imports || []).findIndex((e2) => e2.id === t2);
            return -1 === i2 && this.fire(new e.y(new Error(`Import '${t2}' does not exist in the map's style and cannot be updated.`))), i2;
          }
          getLayer(e2) {
            return this._mergedLayers[e2];
          }
          getSources() {
            const e2 = [];
            for (const t2 in this._mergedOtherSourceCaches) {
              const i2 = this._mergedOtherSourceCaches[t2];
              i2 && e2.push(i2.getSource());
            }
            return e2;
          }
          getSource(e2, t2) {
            const i2 = this.getSourceCache(e2, t2);
            return i2 && i2.getSource();
          }
          getLayerSource(e2) {
            const t2 = this.getLayerSourceCache(e2);
            return t2 && t2.getSource();
          }
          getSourceCache(t2, i2) {
            const o2 = e.B(t2, i2);
            return this._mergedOtherSourceCaches[o2];
          }
          getLayerSourceCache(t2) {
            const i2 = e.B(t2.source, t2.scope);
            return "symbol" === t2.type ? this._mergedSymbolSourceCaches[i2] : this._mergedOtherSourceCaches[i2];
          }
          getSourceCaches(e2) {
            if (null == e2) return Object.values(this._mergedSourceCaches);
            const t2 = [];
            return this._mergedOtherSourceCaches[e2] && t2.push(this._mergedOtherSourceCaches[e2]), this._mergedSymbolSourceCaches[e2] && t2.push(this._mergedSymbolSourceCaches[e2]), t2;
          }
          updateSourceCaches() {
            const e2 = this._changes.getUpdatedSourceCaches();
            for (const t2 in e2) {
              const i2 = e2[t2];
              "reload" === i2 ? this.reloadSource(t2) : "clear" === i2 && this.clearSource(t2);
            }
          }
          updateLayers(e2) {
            const t2 = this._changes.getUpdatedPaintProperties();
            for (const i2 of t2) {
              const t3 = this.getLayer(i2);
              t3 && t3.updateTransitions(e2);
            }
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs;
          }
          setGlyphsUrl(e2) {
            this.stylesheet.glyphs = e2, this.glyphManager.setURL(e2);
          }
          getImages(t2, i2, o2) {
            this.imageManager.getImages(i2.images, i2.scope, o2), this._updateTilesForChangedImages();
            const s2 = (t3) => {
              if (t3) {
                const o3 = i2.images.map((t4) => e.I.toString(t4));
                t3.setDependencies(i2.tileID.key, i2.type, o3);
              }
            }, r2 = e.B(i2.source, i2.scope);
            s2(this._mergedOtherSourceCaches[r2]), s2(this._mergedSymbolSourceCaches[r2]), i2.images.some((e2) => e2.iconsetId) && this.fire(new e.z("data", { dataType: "style" }));
          }
          rasterizeImages(e2, t2, i2) {
            this.imageManager.rasterizeImages(t2, i2);
          }
          getGlyphs(e2, t2, i2) {
            this.glyphManager.getGlyphs(t2.stacks, i2);
          }
          getResource(t2, i2, o2) {
            return e.dz(i2, o2);
          }
          getOwnSourceCache(e2) {
            return this._otherSourceCaches[e2];
          }
          getOwnLayerSourceCache(e2) {
            return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
          }
          getOwnSourceCaches(e2) {
            const t2 = [];
            return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
          }
          _isSourceCacheLoaded(t2) {
            const i2 = this.getOwnSourceCaches(t2);
            return 0 === i2.length ? (this.fire(new e.y(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
          }
          has3DLayers() {
            return this._has3DLayers;
          }
          hasSymbolLayers() {
            return this._hasSymbolLayers;
          }
          hasCircleLayers() {
            return this._hasCircleLayers;
          }
          isLayerClipped(e2, t2) {
            if (!this._clipLayerPresent && "fill-extrusion" !== e2.type && "building" !== e2.type) return false;
            const i2 = "fill-extrusion" === e2.type && ("building" === e2.sourceLayer || "procedural_buildings" === e2.sourceLayer), o2 = "building" === e2.type;
            if (e2.is3D(!!this.terrain)) {
              if (i2 || o2 || t2 && "batched-model" === t2.type) return true;
              if ("model" === e2.type) return true;
            } else if ("symbol" === e2.type) return true;
            return false;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.fragments.forEach((e2) => {
              e2.style._remove();
            }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Oo.getSourceType = function(e2) {
          return ft[e2];
        }, Oo.setSourceType = function(e2, t2) {
          ft[e2] = t2;
        }, Oo.registerForPluginStateChange = e.dA;
        var zo = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Mo = "\n#ifdef DUAL_SOURCE_BLENDING\nlayout(location=0,index=0) out vec4 glFragColor;layout(location=0,index=1) out vec4 glFragColorSrc1;\n#else\nlayout(location=0) out vec4 glFragColor;\n#endif\n#ifdef USE_MRT1\nlayout(location=1) out vec4 out_Target1;\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb*col.a,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Fo = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifndef HAS_SHADER_STORAGE_BLOCK_material_buffer\n#define GET_ATTRIBUTE_float(attrib,matInfo,attrib_id) attrib\n#define GET_ATTRIBUTE_vec4(attrib,matInfo,attrib_id) attrib\n#define GET_ATTRIBUTE_vec2(attrib,matInfo,attrib_id) attrib\n#define DECLARE_MATERIAL_TABLE_INFO\n#endif", Bo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ko = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\nint NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;\n#ifdef CLIP_ZERO_TO_ONE\ncoord.z=-1.0+2.0*coord.z; \n#endif\nhighp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif", No = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Uo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", jo = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", Vo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Go = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif", Ho = "#ifdef RENDER_SHADOWS\nprecision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {\n#ifdef CLIP_ZERO_TO_ONE\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z-bias);\n#else\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);\n#endif\nreturn texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;\n#ifdef SHADOWS_SINGLE_CASCADE\nvec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);\n#else\nlight_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const qo = /#include\s+"([^"]+)"/g, Zo = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g, Wo = /\b[A-Za-z_][A-Za-z0-9_]*\b/g, $o = /* @__PURE__ */ new Set(["ifdef", "ifndef", "elif", "if", "defined"]), Xo = /* @__PURE__ */ new Set();
        os(zo, Xo), os(Fo, Xo), os(Mo, Xo);
        const Yo = { "_prelude_fog.vertex.glsl": No, "_prelude_terrain.vertex.glsl": ko, "_prelude_shadow.vertex.glsl": Go, "_prelude_material_table.vertex.glsl": "#ifdef HAS_SHADER_STORAGE_BLOCK_material_buffer\n#define MATERIAL_TABLE_DEBUG 0\nuniform int u_material_offset;uniform int u_vertex_offset;layout(std140,binding=0)readonly buffer material_buffer{uvec4 material_data[];};struct MaterialInfo{uint dataOffset;\n#if MATERIAL_TABLE_DEBUG\nvec4 colorDebug;\n#endif\n};uint read_buf_no_offset(uint iDword) {return material_data[iDword/4u][iDword % 4u];}uint read_buf(uint iDword) {iDword+=uint(u_material_offset/4);return read_buf_no_offset(iDword);}float read_buf_float(uint iDword){return uintBitsToFloat(read_buf(iDword));}uint read_buf_uint8(uint iDword,uint iUint8){uint dwordOffset=iDword+(iUint8/4u);uint byteOffset=iUint8 & 3u;uint bitOffset=8u*byteOffset;uint mask=0xffu << bitOffset;uint dwordVal=read_buf(dwordOffset);return (dwordVal & mask) >> bitOffset;}uint read_buf_uint16(uint iDword,uint iUint16){uint dwordOffset=iDword+(iUint16 >> 1u);uint bitOffset=(iUint16 & 1u)*16u;uint mask=0xffffu << bitOffset;uint dwordVal=read_buf(dwordOffset);return (dwordVal & mask) >> bitOffset;}uint nrDwordsForVertexIdEntries(uint nrMaterialLookupEntries) {return nrMaterialLookupEntries;}uint nrDwordsForMaterialIdEntries(uint nrMaterialLookupEntries) {return (nrMaterialLookupEntries*2u+3u)/4u;}uint findRangeBinarySearch(uint vertexId,uint numRanges,uint dwordOffset) {uint left=0u;uint right=numRanges-1u;for (uint i=0u; i < 16u; i++) { \nif (left > right) {break;}uint mid=(left+right)/2u;uint start=read_buf(dwordOffset+mid);uint nextStart=(mid+1u < numRanges) ? read_buf(dwordOffset+mid+1u) : 0xffffffffu;if (vertexId >=start && vertexId < nextStart) {return mid;} else if (vertexId < start) {if (mid==0u) {break;}right=mid-1u;} else {left=mid+1u;}}return 0u; \n}uint readVertexId(uint dwordOffset,uint iMaterialLookupEntry) {return read_buf(dwordOffset+iMaterialLookupEntry);}uint findRange(uint vertexId,uint numRanges,uint dwordOffset) {uint iRange;if(numRanges <=64u){uint vertexBegin;for(iRange=0u; iRange < numRanges;++iRange) {vertexBegin=readVertexId(dwordOffset,iRange);if(vertexBegin > vertexId) {break;}}iRange=iRange==0u? 0u : iRange-1u;} else { \niRange=findRangeBinarySearch(vertexId,numRanges,dwordOffset);}return iRange;}MaterialInfo read_material_info(uint vertex_id) {MaterialInfo info;\n#if MATERIAL_TABLE_DEBUG\nconst vec4 red=vec4(1.0,0.0,0.0,1.0);const vec4 orange=vec4(1.0,0.5,0.0,1.0);const vec4 yellow=vec4(1.0,1.0,0.0,1.0);const vec4 green=vec4(0.0,1.0,0.0,1.0);const vec4 indigo=vec4(0.294,0.0,0.510,1.0);const vec4 blue=vec4(0.0,0.0,1.0,1.0);const vec4 purple=vec4(0.5,0.0,0.5,1.0);const vec4 pink=vec4(1.0,0.0,1.0,1.0);info.colorDebug=green;\n#endif\nuint offset=0u;\n#if MATERIAL_TABLE_DEBUG\nbool keepFinding=true;uint magic=read_buf(offset);if(magic !=0xCAFEBABEu) {info.colorDebug=red;keepFinding=false;return info;}\n#endif\noffset++;\n#if MATERIAL_TABLE_DEBUG\nuint nrMaterials=read_buf(offset);uint nrVertices=read_buf(offset+1u);if(keepFinding && vertex_id >=nrVertices) {info.colorDebug=red;keepFinding=false;}\n#endif\noffset+=2u;uint nrMaterialLookupEntries=read_buf(offset++);uint perMaterialEntrySizeDwords=read_buf(offset++);\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding && perMaterialEntrySizeDwords !=1u) {info.colorDebug=red;keepFinding=false;}\n#endif\nuint iMaterialLookup=findRange(vertex_id,nrMaterialLookupEntries,offset);\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding)\n{uint vertexBeginCheck=readVertexId(offset,iMaterialLookup);if(vertexBeginCheck > vertex_id) {info.colorDebug=red;keepFinding=false;}if(iMaterialLookup < nrMaterialLookupEntries-1u) {uint vertexEndCheck=readVertexId(offset,iMaterialLookup+1u);if(vertexEndCheck <=vertex_id) {info.colorDebug=red;keepFinding=false;}}}\n#endif\noffset+=nrDwordsForVertexIdEntries(nrMaterialLookupEntries);uint materialId=iMaterialLookup;\n#if MATERIAL_TABLE_DEBUG\nif(keepFinding) {if(materialId >=nrMaterialLookupEntries) {info.colorDebug=red;}}\n#endif\ninfo.dataOffset=offset+materialId*perMaterialEntrySizeDwords;return info;}uint get_data_location(const MaterialInfo matInfo,uint attribOffsetBytes)\n{uint attribFieldOffsetDwords=attribOffsetBytes/4u;return matInfo.dataOffset+attribFieldOffsetDwords;}vec4 read_material_vec4(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return vec4(read_buf_float(loc),read_buf_float(loc+1u),read_buf_float(loc+2u),read_buf_float(loc+3u));}vec2 read_material_vec2(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return vec2(read_buf_float(loc),read_buf_float(loc+1u));}float read_material_float(const MaterialInfo matInfo,uint attribOffsetBytes){uint loc=get_data_location(matInfo,attribOffsetBytes);return read_buf_float(loc);}\n#define GET_ATTRIBUTE_float(attrib,matInfo,attrib_offset) read_material_float(matInfo,attrib_offset)\n#define GET_ATTRIBUTE_vec4(attrib,matInfo,attrib_offset) read_material_vec4(matInfo,attrib_offset)\n#define GET_ATTRIBUTE_vec2(attrib,matInfo,attrib_offset) read_material_vec2(matInfo,attrib_offset)\n#define DECLARE_MATERIAL_TABLE_INFO MaterialInfo materialInfo=read_material_info(uint(gl_VertexID));\n#define DECLARE_MATERIAL_TABLE_INFO_DEBUG(dbgColor) MaterialInfo materialInfo=read_material_info(uint(gl_VertexID)); dbgColor=materialInfo.colorDebug;\n#endif", "_prelude_fog.fragment.glsl": Uo, "_prelude_shadow.fragment.glsl": Ho, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif", "_prelude_raster_array.glsl": jo, "_prelude_raster_particle.glsl": Vo }, Ko = {};
        ss("", ko), ss(Uo, No), ss(Ho, Go), ss(jo, ""), ss(Vo, "");
        const Jo = ss(Mo, Fo), Qo = zo, es = ["\n#if defined(GL_EXT_blend_func_extended) && defined(DUAL_SOURCE_BLENDING)\n#extension GL_EXT_blend_func_extended : require\n#endif", "precision mediump float;", Qo, Jo.fragmentSource].join("\n"), ts = ["precision highp float;", Qo, Jo.vertexSource].join("\n");
        var is = { background: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;uniform mediump float u_emissive_strength;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform mediump float u_emissive_strength;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), building: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nconst float window_depth=0.5;const float ao_radius=0.2;in vec4 v_color;in highp vec3 v_normal;in highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nin lowp float v_faux_facade;in highp float v_faux_facade_ed;in highp vec2 v_faux_facade_window;in highp vec2 v_faux_facade_floor;in highp vec2 v_faux_facade_range;in highp float v_aspect;in highp vec3 v_tbn_0;in highp vec3 v_tbn_1;in highp vec3 v_tbn_2;in highp vec4 v_faux_color_emissive;uniform float u_faux_facade_ao_intensity;\n#endif\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\n#ifdef FLOOD_LIGHT\nin highp float v_flood_radius;in float v_has_flood_light;\n#endif\nuniform lowp float u_opacity;uniform vec3 u_camera_pos;uniform highp float u_tile_to_meter;uniform float u_facade_emissive_chance;uniform vec3 u_flood_light_color;uniform float u_flood_light_intensity;vec3 linearTosRGB(in vec3 color) {return pow(color,vec3(1./2.2));}\n#ifdef BUILDING_FAUX_FACADE\nfloat hash12(in vec2 p) {vec3 p3 =fract(vec3(p.xyx)*0.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float min3(in vec3 v) {return min(min(v.x,v.y),v.z);}vec2 get_uv_mask_id(in vec2 q,out float mask,out vec2 id) {vec2 p=q;mask=step(v_faux_facade_range.x,p.y)*step(p.y,v_faux_facade_range.y);p.y=p.y-v_faux_facade_range.x;vec2 uv=modf(p/v_faux_facade_floor,id);vec4 d=(v_faux_facade_floor.xyxy+vec4(-v_faux_facade_window,v_faux_facade_window))*0.5;vec4 edge=d/v_faux_facade_floor.xyxy;vec2 m=step(edge.xy,uv)*step(uv,edge.zw);mask*=m.x*m.y;uv-=vec2(0.5);uv*=vec2(0.5)/(vec2(0.5)-edge.xy);uv+=vec2(0.5);return uv;}float ray_unit_box(in vec3 ray_o,in vec3 ray_d,in vec3 bmin,in vec3 bmax) {vec3 planes=mix(bmin,bmax,step(0.0,ray_d));vec3 t=(planes-ray_o)/ray_d;return min3(t);}float get_emissive(in vec2 id) {if (u_facade_emissive_chance > 0.0) {return (step(hash12(id),u_facade_emissive_chance)+0.05)*v_faux_color_emissive.a;}return 0.0;}vec3 get_shade_info(in vec3 v,in vec3 v_normalized,in vec3 color,in vec2 id,in mat3 tbn,inout vec3 out_normal,inout float out_emissive) {vec3 out_color=color;vec3 abs_v=abs(v_normalized);bool x_major=abs_v.x >=abs_v.y && abs_v.x >=abs_v.z;bool y_major=abs_v.y >=abs_v.x && abs_v.y >=abs_v.z;bool z_major=abs_v.z >=abs_v.x && abs_v.z >=abs_v.y;\n#if 0\nif (x_major) {out_color=v.x > 0.0 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,1.0);} else if (y_major) {out_color=v.y > 0.0 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,1.0);} else if (z_major) {out_color=v.z > 0.0 ? vec3(0.0,0.0,1.0) : vec3(1.0,1.0,0.0);}out_emissive=1.0;\n#else\nif (x_major) {out_normal=sign(v.x)*tbn[0];} else if (y_major) {out_normal=vec3(0.0,0.0,-sign(v.y));} else if (z_major) {out_color=v_faux_color_emissive.rgb;out_emissive=v.z <=0.0 ? get_emissive(id) : out_emissive;}float ao=1.0;if (u_faux_facade_ao_intensity > 0.0) {vec4 ao_range=v_faux_facade_window.xxyy*0.5-vec4(0,ao_radius,0,ao_radius);vec2 ao_range_z=vec2(window_depth*0.5)-vec2(0.0,ao_radius);if (x_major || y_major) {ao*=smoothstep(-ao_range_z.x,-ao_range_z.y,v.z);} else if (z_major) {ao*=smoothstep(-ao_range.x,-ao_range.y,v.x)*(1.0-smoothstep(ao_range.y,ao_range.x,v.x));ao*=smoothstep(-ao_range.z,-ao_range.w,v.y)*(1.0-smoothstep(ao_range.w,ao_range.z,v.y));}ao=mix(1.0,min(1.0,ao+0.25),u_faux_facade_ao_intensity);}out_color*=ao;\n#endif\nreturn out_color;}\n#endif\nvec3 apply_lighting_linear(in vec3 color,in vec3 normal,in float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec3 normal=normalize(v_normal);vec3 base_color=v_color.rgb;float emissive=v_color.a;\n#ifdef BUILDING_FAUX_FACADE\nif (v_faux_facade > 0.0) {mat3 tbn=mat3(v_tbn_0,v_tbn_1,v_tbn_2);vec3 v=vec3(v_pos.xy,v_pos.z/u_tile_to_meter)-u_camera_pos;vec3 view_tangent=transpose(tbn)*v;vec2 q=vec2(v_faux_facade_ed,v_pos.z);float mask=0.0;vec2 id=vec2(0.0);vec2 uv=get_uv_mask_id(q,mask,id);uv*=v_faux_facade_window;vec3 bmin=vec3(0.0,0.0,-window_depth);vec3 bmax=bmin+vec3(v_faux_facade_window,window_depth);vec3 ray_o=vec3(uv,0.0);vec3 ray_d=normalize(view_tangent);float t_min=ray_unit_box(ray_o,ray_d,bmin,bmax);vec3 hit=ray_o+t_min*ray_d;vec3 r=vec3(v_faux_facade_window,-window_depth);hit-=r*0.5;vec3 normalized=hit/r;vec3 out_normal=normal;float out_emissive=emissive;vec3 room_color=get_shade_info(hit,normalized,base_color,id,tbn,out_normal,out_emissive);base_color=mix(base_color,room_color,mask);normal=mix(normal,out_normal,mask);emissive=mix(emissive,out_emissive,mask);}\n#endif\nvec4 color=vec4(base_color,1.0);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\n#ifdef RENDER_SHADOWS\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\n#else\nshadowed_lighting_factor=dot(xy_flipped_normal,u_lighting_directional_dir);\n#endif\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=linearTosRGB(color.rgb);\n#ifdef FLOOD_LIGHT\nfloat flood_radiance=(1.0-min(v_pos.z/v_flood_radius,1.0))*u_flood_light_intensity*v_has_flood_light;color.rgb=mix(color.rgb,u_flood_light_color,flood_radiance);\n#endif\ncolor.rgb=mix(color.rgb,linearTosRGB(base_color.rgb),emissive);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_pos.z));\n#endif\ncolor*=u_opacity;\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_pos.z);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color; \n#ifdef DEBUG_SHOW_NORMALS\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;in vec3 a_normal_3;in vec3 a_centroid_3;in float a_flood_light_wall_radius_1i16;in vec4 a_faux_facade_data;in vec2 a_faux_facade_vertical_range;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;uniform highp float u_tile_to_meter;out vec4 v_color;out vec3 v_normal;out highp vec3 v_pos;\n#ifdef BUILDING_FAUX_FACADE\nout lowp float v_faux_facade;out highp float v_faux_facade_ed;out highp vec2 v_faux_facade_window;out highp vec2 v_faux_facade_floor;out highp vec2 v_faux_facade_range;out highp float v_aspect;out highp vec3 v_tbn_0;out highp vec3 v_tbn_1;out highp vec3 v_tbn_2;out highp vec4 v_faux_color_emissive;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#ifdef FLOOD_LIGHT\nout highp float v_flood_radius;out float v_has_flood_light;\n#endif\nconst float MAX_UINT_16=65535.0;const float MAX_INT_16=32767.0;const float MAX_UINT_8=255.0;const float TWO_POW_8=256.0;const float FLOOD_LIGHT_MAX_RADIUS_METER=2048.0;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#ifdef BUILDING_FAUX_FACADE\nmat3 get_tbn(in vec3 normal) {const vec3 bitangent=vec3(0.0,0.0,1.0);vec3 tangent=normalize(vec3(normal.y,-normal.x,0.0));return mat3(tangent,bitangent,normal);}\n#endif\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 faux_facade_color_emissive\nvoid main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute-custom highp vec2 faux_facade_color_emissive\n#ifdef FLOOD_LIGHT\nv_flood_radius=(a_flood_light_wall_radius_1i16/MAX_INT_16*FLOOD_LIGHT_MAX_RADIUS_METER);v_has_flood_light=step(0.0,v_flood_radius);\n#endif\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);vec3 a_normal_3f=a_normal_3/MAX_INT_16;v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));float hidden=0.0;float depth_offset=0.0;\n#ifdef BUILDING_FAUX_FACADE\nv_faux_facade=a_faux_facade_data.x;if (v_faux_facade > 0.0) {v_faux_facade_ed=a_faux_facade_data.x *u_tile_to_meter;float window_x_perc=floor(a_faux_facade_data.y/TWO_POW_8);float window_y_perc=a_faux_facade_data.y-TWO_POW_8*window_x_perc;vec2 window_perc=vec2(window_x_perc,window_y_perc)/MAX_UINT_8;v_faux_facade_floor=(a_faux_facade_data.zw/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_faux_facade_window=window_perc*v_faux_facade_floor;v_faux_facade_range=(a_faux_facade_vertical_range/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_aspect=v_faux_facade_window.x/v_faux_facade_window.y;mat3 tbn=get_tbn(normalize(v_normal));v_tbn_0=tbn[0];v_tbn_1=tbn[1];v_tbn_2=tbn[2];v_faux_color_emissive=decode_color(faux_facade_color_emissive);v_faux_color_emissive.rgb=sRGBToLinear(v_faux_color_emissive.rgb);float height=a_centroid_3.z;depth_offset=min(1000.0,height)*0.0000002;}\n#endif\nv_pos=a_pos_3f;\n#ifdef RENDER_CUTOFF\nvec4 ground=u_matrix*vec4(a_centroid_3,1.0);v_cutoff_opacity=cutoff_opacity(u_cutoff_params,ground.z);hidden=float(v_cutoff_opacity==0.0);v_pos.z*=v_cutoff_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=v_pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(v_pos);\n#endif\ngl_Position=mix(u_matrix*vec4(v_pos,1),AWAY,hidden);gl_Position.z-=depth_offset*gl_Position.w;}'), buildingBloom: ss("in vec4 v_color_emissive;\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\nfloat saturate(float val) {return clamp(val,0.0,1.0);}void main() {float emission=v_color_emissive.a;float opacity=1.0;\n#ifdef HAS_ATTRIBUTE_a_bloom_attenuation\nfloat distance=length(vec2(1.3*max(0.0,abs(bloom_attenuation.x)-bloom_attenuation.z),bloom_attenuation.y));distance+= mix(0.5,0.0,clamp(emission-1.0,0.0,1.0));opacity*=saturate(1.0-distance*distance);\n#endif\n#ifdef RENDER_CUTOFF\nopacity*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(v_color_emissive.rgb,1.0)*opacity;}", "in vec3 a_pos_3f;\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\nout vec4 v_color_emissive;uniform mat4 u_matrix;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\n#ifdef HAS_ATTRIBUTE_a_part_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);float part_emissive=color_emissive.a*5.0;v_color_emissive=vec4(sRGBToLinear(color_emissive.rgb),part_emissive);\n#else\nv_color_emissive=vec4(1.0);\n#endif\ngl_Position=u_matrix*vec4(a_pos_3f,1.0);\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}"), buildingDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"), circle: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\n#ifdef ELEVATED_ROADS\nin float a_circle_z_offset;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\n#ifdef ELEVATED_ROADS\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: ss("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ss('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: ss("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: ss("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform float u_zoom_transition;\n#endif\nout float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec3 proj_pos=a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation);\n#ifdef PROJECTION_GLOBE_VIEW\n#ifndef PROJECTED_POS_ON_VIEWPORT\nvec3 globe_pos=proj_pos;vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,a_anchor_pos,u_tile_id,u_merc_center);proj_pos=mix_globe_mercator(globe_pos,mercator_pos,u_zoom_transition);\n#endif\n#endif\nvec4 projectedPoint=u_matrix*vec4(proj_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: ss("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ss("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), elevatedStructuresDepth: ss("void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=vec4(0.);\n#endif\n}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"), elevatedStructuresDepthReconstruct: ss("#ifdef DEPTH_RECONSTRUCTION\nin float v_height;\n#endif\nvoid main() {\n#ifdef DEPTH_RECONSTRUCTION\nif (v_height >=0.0)\ndiscard;\n#else\n#ifdef FEATURE_CUTOUT\napply_feature_cutout(vec4(0.0,0.0,0.0,1.0),gl_FragCoord);\n#endif\n#endif\nglFragColor=vec4(1.0,0.0,0.0,1.0);}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\n#ifdef DEPTH_RECONSTRUCTION\nout float v_height;\n#endif\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\n#ifdef DEPTH_RECONSTRUCTION\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\n#endif\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}"), elevatedStructures: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin vec3 v_normal;in float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)\n{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nvec3 color=structure_color.xyz;\n#ifdef LIGHTING_3D_MODE\nvec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);\n#ifdef RENDER_SHADOWS\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);\n#else\ncolor=apply_lighting(color,transformed_normal);\n#endif\ncolor=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\n#endif\n#ifdef FOG\ncolor=fog_apply(color,v_fog_pos);\n#endif\nvec4 out_color=vec4(color,1.0);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_height);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#pragma mapbox: define highp vec4 structure_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 structure_color\nv_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fill: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'), fillOutline: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef FLIP_Y\nv_pos=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nuniform float u_emissive_strength;\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FLIP_Y\nv_pos_world=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\n#else\nv_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;out highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\n#ifdef FEATURE_CUTOUT\ncolor=apply_feature_cutout(color,gl_FragCoord);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_material_table.vertex.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);\n#ifdef CLIP_ZERO_TO_ONE\ncutoff=cutoff_opacity(u_cutoff_params,ground.z*2.0-ground.w);\n#else\ncutoff=cutoff_opacity(u_cutoff_params,ground.z);\n#endif\nif (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_material_table.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_material_table.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {DECLARE_MATERIAL_TABLE_INFO\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: ss('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: ss("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(1.0-texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size)).a,0.0,0.0,0.0);\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: ss("precision highp float;uniform highp sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform highp vec2 u_trim_gradient_mix_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef VARIABLE_LINE_WIDTH\nin float stub_side;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float side_z_offset\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\n#pragma mapbox: define lowp float emissive_strength\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float side_z_offset\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\n#pragma mapbox: initialize lowp float emissive_strength\nfloat dist=length(v_normal)*v_width2.s;\n#ifdef VARIABLE_LINE_WIDTH\nblur=mix(blur,0.0,stub_side);\n#endif\nfloat blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef VARIABLE_LINE_WIDTH\nalpha=mix(alpha,1.0,stub_side);\n#endif\nalpha=side_z_offset > 0.0 ? 1.0-alpha : alpha;\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);highp float gradient_trim_color_mix_factor=0.0;\n#ifdef RENDER_LINE_GRADIENT\ngradient_trim_color_mix_factor=smoothstep(u_trim_gradient_mix_range.x,u_trim_gradient_mix_range.y,line_progress);\n#endif\nhighp vec4 trim_color=mix(u_trim_color,out_color,gradient_trim_color_mix_factor);out_color=mix(u_trim_gradient_mix_range.x < 1.0 ? color : out_color,trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\n#ifndef VARIABLE_LINE_WIDTH\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef DUAL_SOURCE_BLENDING\nglFragColorSrc1=vec4(vec3(0.0),emissive_strength);\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec3 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec3 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef VARIABLE_LINE_WIDTH\nout float stub_side;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float side_z_offset\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float side_z_offset\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\n#pragma mapbox: initialize lowp float emissive_strength\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;offset=-1.0*offset*u_width_scale;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nbool left=normal.y==1.0;float left_width=a_z_offset_width.y;float right_width=a_z_offset_width.z;halfwidth=(u_width_scale*(left ? left_width : right_width))/2.0;a_z_offset+=left ? side_z_offset : 0.0;v_normal=side_z_offset > 0.0 && left ? vec2(0.0) : v_normal;offset=border_width > 0.0 ? (left_width+right_width)*u_width_scale*0.5 : offset;halfwidth=border_width > 0.0 ? border_width*u_width_scale*0.5 : halfwidth;bool zero_right_width=border_width==0.0 && right_width==0.0;stub_side=zero_right_width ?-normal.y : 0.0;v_normal=!left && zero_right_width ? vec2(0.0) : v_normal;ANTIALIASING=!left && zero_right_width ? 0.0 : ANTIALIASING;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\nfloat inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\n#else\nv_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'), linePattern: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef LINE_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\n#ifdef LINE_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef DUAL_SOURCE_BLENDING\nglFragColorSrc1=vec4(vec3(0.0),emissive_strength);\n#else\n#ifdef USE_MRT1\nout_Target1=vec4(emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec3 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize lowp float emissive_strength\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'), raster: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n#ifdef USE_MRT1\nout_Target1=vec4(u_emissive_strength*glFragColor.a,0.0,0.0,glFragColor.a);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),1.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: ss("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: ss("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: ss('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: ss('#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nin highp float v_z_offset;\n#endif\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nout_color=applyLUT(u_lutTexture,out_color);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef TERRAIN\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#else\nout_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\n#ifdef FEATURE_CUTOUT\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#define USING_APPEARANCE 1.0\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef ELEVATED_ROADS\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#else\n#ifdef RENDER_SHADOWS\nout highp float v_z_offset;\n#endif\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float a_size_max= floor(a_size[1]*0.5);float a_apperance=a_size[1]-2.0*a_size_max;vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (a_apperance==USING_APPEARANCE) {size=a_size_max/128.0;} else if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size_max,u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\n#ifdef PROJECTED_POS_ON_VIEWPORT\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\n#else\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \n#endif\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\n#else\nz+=u_pitch_with_map ? z_offset : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\n#ifdef Z_TEST_OCCLUSION\nout_fade_opacity*=occlusion_opacity;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\n#ifdef ELEVATED_ROADS\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\n#endif\n#endif\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#else\n#ifdef RENDER_SHADOWS\nv_z_offset=e;\n#endif\n#endif\n}'), terrainRaster: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nuniform sampler2D u_image1;uniform float u_emissive_texture_available;\n#endif\nin vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : image_color.a;vec3 unlit_base=image_color.rgb*(1.0-emissive_strength);vec3 emissive_base=image_color.rgb*emissive_strength;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : image_color.a;color.rgb=mix(color.rgb,image_color.rgb,emissive_strength);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: ss("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: ss('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Bo), skyboxGradient: ss('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Bo), skyboxCapture: ss("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nuniform sampler2D u_image1;uniform float u_emissive_texture_available;\n#endif\nuniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;\n#ifdef FLIP_Y\nuv.y=1.0-uv.y;\n#endif\nhighp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : raster.a;raster=apply_lighting_with_emission_ground(raster,emissive_strength);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nfloat emissive_strength=u_emissive_texture_available > 0.5 ? texture(u_image1,v_pos0).r : color.a;color=apply_lighting_with_emission_ground(color,emissive_strength);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: ss('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_atmosphere_fog_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_atmosphere_fog_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_atmosphere_fog_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: ss('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;\n#ifdef DITHERED_DISCARD\nuniform float u_dithered_discard_threshold;\n#endif\nuniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef FLIP_Y\ncoord.y=1.0-coord.y;\n#endif\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;\n#ifdef FLIP_Y\nT=-T;B=-B;\n#endif\nhighp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));\n#ifdef FLIP_Y\nn=normalize(cross(fdx,fdy));\n#else\nn=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef DITHERED_DISCARD\nif (abs(u_dithered_discard_threshold) < 1.0) {float ditherValue=fract(52.9829189*fract(0.06711056*gl_FragCoord.x+0.00583715*gl_FragCoord.y));float compareValue=mix(1.0-ditherValue,ditherValue,step(0.0,u_dithered_discard_threshold));if (abs(u_dithered_discard_threshold) < compareValue) {discard;}}\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\n#ifdef FEATURE_CUTOUT\nfinalColor=apply_feature_cutout(finalColor,gl_FragCoord);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#ifdef CLIP_ZERO_TO_ONE\nv_depth=-1.0+2.0*v_depth; \n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: ss("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: ss("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"), snowParticle: ss("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"), rainParticle: ss("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"), vignette: ss("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: ss("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}') };
        function os(e2, t2) {
          const i2 = e2.split("\n");
          for (let e3 of i2) {
            if (e3 = e3.trimStart(), "#" !== e3[0]) continue;
            if (!e3.includes("if")) continue;
            if (e3.startsWith("#endif")) continue;
            const i3 = e3.match(Wo);
            if (i3) for (const e4 of i3) $o.has(e4) || t2.add(e4);
          }
        }
        function ss(e2, t2) {
          const i2 = /* @__PURE__ */ new Set(), o2 = [], s2 = [];
          e2 = e2.replace(qo, (e3, t3) => (s2.push(t3), "")), t2 = t2.replace(qo, (e3, t3) => (o2.push(t3), ""));
          let r2 = new Set(Xo);
          os(e2, r2), os(t2, r2);
          for (const e3 of [...o2, ...s2]) Ko[e3] || (Ko[e3] = /* @__PURE__ */ new Set(), os(Yo[e3], Ko[e3])), r2 = /* @__PURE__ */ new Set([...r2, ...Ko[e3]]);
          return { fragmentSource: e2 = e2.replace(Zo, (e3, t3, o3, s3, r3) => (i2.add(r3), "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
in ${o3} ${s3} ${r3};
#else
uniform ${o3} ${s3} u_${r3};
#endif
` : "initialize" === t3 ? `
#ifdef HAS_UNIFORM_u_${r3}
    ${o3} ${s3} ${r3} = u_${r3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    in ${o3} ${s3} ${r3};
#endif
` : "initialize-attribute" === t3 ? "" : void 0)), vertexSource: t2 = t2.replace(Zo, (e3, t3, o3, s3, r3) => {
            const n2 = `MATERIAL_ATTRIBUTE_OFFSET_${r3}`, a2 = "float" === s3 ? "vec2" : s3, l2 = `GET_ATTRIBUTE_${a2}(a_${r3}, materialInfo, ${n2})`, c2 = r3.match(/color/) ? "color" : a2;
            return "define-attribute-vertex-shader-only" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
in ${o3} ${s3} a_${r3};
#endif
` : i2.has(r3) ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
    #if !defined(${n2})
        in ${o3} ${a2} a_${r3};
    #endif
out ${o3} ${s3} ${r3};
#else
uniform ${o3} ${s3} u_${r3};
#endif
` : "initialize" === t3 ? "vec4" === c2 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = a_${r3};
#else
    ${o3} ${s3} ${r3} = u_${r3};
#endif
` : `
#if !defined(HAS_UNIFORM_u_${r3})
    #ifdef ${n2}
        ${r3} = unpack_mix_${c2}(${l2}, u_${r3}_t);
    #else
        ${r3} = unpack_mix_${c2}(a_${r3}, u_${r3}_t);
    #endif
#else
    ${o3} ${s3} ${r3} = u_${r3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    in ${o3} ${s3} a_${r3};
    out ${o3} ${s3} ${r3};
#endif
` : "initialize-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    ${r3} = a_${r3};
#endif
` : void 0 : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
    #if !defined(${n2})
        in ${o3} ${a2} a_${r3};
    #endif
#else
uniform ${o3} ${s3} u_${r3};
#endif
` : "define-instanced" === t3 ? "mat4" === c2 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${r3}0;
in vec4 a_${r3}1;
in vec4 a_${r3}2;
in vec4 a_${r3}3;
#else
uniform ${o3} ${s3} u_${r3};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${o3} ${a2} a_${r3};
#else
uniform ${o3} ${s3} u_${r3};
#endif
` : "initialize-attribute-custom" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    ${o3} ${s3} ${r3} = a_${r3};
#endif
` : "vec4" === c2 ? `
#ifndef HAS_UNIFORM_u_${r3}
    #ifdef ${n2}
        ${o3} ${s3} ${r3} = ${l2};
    #else
        ${o3} ${s3} ${r3} = a_${r3};
    #endif
#else
    ${o3} ${s3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    #ifdef ${n2}
        ${o3} ${s3} ${r3} = unpack_mix_${c2}(${l2}, u_${r3}_t);
    #else
        ${o3} ${s3} ${r3} = unpack_mix_${c2}(a_${r3}, u_${r3}_t);
    #endif
#else
    ${o3} ${s3} ${r3} = u_${r3};
#endif
`;
          }), usedDefines: r2, vertexIncludes: o2, fragmentIncludes: s2 };
        }
        class rs {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(e2, t2, i2, o2, s2, r2, n2, a2) {
            this.context = e2;
            let l2 = this.boundPaintVertexBuffers.length !== o2.length;
            for (let e3 = 0; !l2 && e3 < o2.length; e3++) this.boundPaintVertexBuffers[e3] !== o2[e3] && (l2 = true);
            let c2 = this.boundDynamicVertexBuffers.length !== n2.length;
            for (let e3 = 0; !c2 && e3 < n2.length; e3++) this.boundDynamicVertexBuffers[e3] !== n2[e3] && (c2 = true);
            if (!this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || l2 || c2 || this.boundIndexBuffer !== s2 || this.boundVertexOffset !== r2) this.freshBind(t2, i2, o2, s2, r2, n2, a2);
            else {
              e2.bindVertexArrayOES.set(this.vao);
              for (const i3 of n2) i3 && (i3.bind(), a2 && i3.instanceCount && i3.setVertexAttribDivisor(e2.gl, t2, a2));
              s2 && s2.dynamicDraw && s2.bind();
            }
          }
          freshBind(e2, t2, i2, o2, s2, r2, n2) {
            const a2 = this.context, l2 = a2.gl;
            this.vao && this.destroy(), this.vao = a2.gl.createVertexArray(), a2.bindVertexArrayOES.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = s2, this.boundDynamicVertexBuffers = r2, t2.enableAttributes(l2, e2), t2.bind(), t2.setVertexAttribPointers(l2, e2, s2);
            for (const t3 of i2) t3.enableAttributes(l2, e2), t3.bind(), t3.setVertexAttribPointers(l2, e2, s2);
            for (const t3 of r2) t3 && (t3.enableAttributes(l2, e2), t3.bind(), t3.setVertexAttribPointers(l2, e2, s2), n2 && t3.instanceCount && t3.setVertexAttribDivisor(l2, e2, n2));
            o2 && o2.bind();
          }
          destroy() {
            this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function ns(t2, i2) {
          const o2 = Math.pow(2, i2.canonical.z), s2 = i2.canonical.y;
          return [new e.ae(0, s2 / o2).toLngLat().lat, new e.ae(0, (s2 + 1) / o2).toLngLat().lat];
        }
        function as(t2, i2, o2, s2, r2, n2, a2) {
          const l2 = t2.context, c2 = l2.gl, h2 = o2.hillshadeFBO;
          if (!h2) return;
          t2.prepareDrawTile();
          const d2 = t2.isTileAffectedByFog(i2), u2 = [];
          t2.terrain && t2.terrain.renderingToTexture && "mrt-fallback" === t2.emissiveMode && u2.push("USE_MRT1");
          const _2 = t2.getOrCreateProgram("hillshade", { overrideFog: d2, defines: u2 });
          l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment0.get());
          const p2 = ((t3, i3, o3, s3) => {
            const r3 = o3.paint.get("hillshade-shadow-color"), n3 = "none" === o3.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), a3 = o3.paint.get("hillshade-highlight-color"), l3 = "none" === o3.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c3 = o3.paint.get("hillshade-accent-color"), h3 = "none" === o3.paint.get("hillshade-accent-color-use-theme").constantOr("default"), d3 = o3.paint.get("hillshade-emissive-strength");
            let u3 = e.an(o3.paint.get("hillshade-illumination-direction"));
            if ("viewport" === o3.paint.get("hillshade-illumination-anchor")) u3 -= t3.transform.angle;
            else if (t3.style && t3.style.enable3dLights() && t3.style.directionalLight) {
              const i4 = t3.style.directionalLight.properties.get("direction"), o4 = e.d4(i4.x, i4.y, i4.z);
              u3 = e.an(o4[1]);
            }
            const _3 = !t3.options.moving;
            return { u_matrix: s3 || t3.transform.calculateProjMatrix(i3.tileID.toUnwrapped(), _3), u_image: 0, u_latrange: ns(0, i3.tileID), u_light: [o3.paint.get("hillshade-exaggeration"), u3], u_shadow: r3.toPremultipliedRenderColor(n3 ? null : o3.lut), u_highlight: a3.toPremultipliedRenderColor(l3 ? null : o3.lut), u_emissive_strength: d3, u_accent: c3.toPremultipliedRenderColor(h3 ? null : o3.lut) };
          })(t2, o2, s2, t2.terrain ? i2.projMatrix : null);
          t2.uploadCommonUniforms(l2, _2, i2.toUnwrapped());
          const { tileBoundsBuffer: f2, tileBoundsIndexBuffer: m2, tileBoundsSegments: g2 } = t2.getTileBoundsBuffers(o2);
          _2.draw(t2, c2.TRIANGLES, r2, n2, a2, Qi.disabled, p2, s2.id, f2, m2, g2);
        }
        function ls(t2, i2, o2) {
          if (!i2.needsDEMTextureUpload) return;
          const s2 = t2.context, r2 = s2.gl;
          s2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
          const n2 = o2.getPixels();
          i2.demTexture ? i2.demTexture.update(n2, { premultiply: false }) : i2.demTexture = new e.T(s2, n2, r2.R32F, { premultiply: false }), i2.needsDEMTextureUpload = false;
        }
        function cs(t2, i2, o2) {
          const s2 = t2.context, r2 = s2.gl;
          if (!i2.dem) return;
          const n2 = i2.dem;
          if (s2.activeTexture.set(r2.TEXTURE1), ls(t2, i2, n2), !i2.demTexture) return;
          i2.demTexture.bind(r2.NEAREST, r2.CLAMP_TO_EDGE);
          const a2 = n2.dim;
          s2.activeTexture.set(r2.TEXTURE0);
          let l2 = i2.hillshadeFBO;
          if (!l2) {
            const t3 = new e.T(s2, { width: a2, height: a2, data: null }, r2.RGBA8);
            t3.bind(r2.LINEAR, r2.CLAMP_TO_EDGE), l2 = i2.hillshadeFBO = s2.createFramebuffer(a2, a2, 1, "renderbuffer"), l2.colorAttachment0.set(t3.texture);
          }
          s2.bindFramebuffer.set(l2.framebuffer), s2.viewport.set([0, 0, a2, a2]);
          const { tileBoundsBuffer: c2, tileBoundsIndexBuffer: h2, tileBoundsSegments: d2 } = t2.getMercatorTileBoundsBuffers(), u2 = [];
          t2.linearFloatFilteringSupported() && u2.push("TERRAIN_DEM_FLOAT_FORMAT"), t2.terrain && t2.terrain.renderingToTexture && "mrt-fallback" === t2.emissiveMode && u2.push("USE_MRT1"), t2.getOrCreateProgram("hillshadePrepare", { defines: u2 }).draw(t2, r2.TRIANGLES, $i.disabled, Yi.disabled, Wi.unblended, Qi.disabled, ((t3, i3) => {
            const o3 = i3.stride, s3 = e.bC();
            return e.ce(s3, 0, e.al, -e.al, 0, 0, 1), e.br(s3, s3, [0, -e.al, 0]), { u_matrix: s3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ };
          })(i2.tileID, n2), o2.id, c2, h2, d2), i2.needsHillshadePrepare = false;
        }
        class hs {
          constructor(e2) {
            this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class ds extends hs {
          getDefault() {
            return e.ao.transparent.toNonPremultipliedRenderColor(null);
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class us extends hs {
          getDefault() {
            return 1;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
          }
        }
        class _s extends hs {
          getDefault() {
            return 0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
          }
        }
        class ps extends hs {
          getDefault() {
            return [true, true, true, true];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class fs extends hs {
          getDefault() {
            return true;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class ms extends hs {
          getDefault() {
            return 255;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class gs extends hs {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e2) {
            const t2 = this.current;
            (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
          }
        }
        class vs extends hs {
          getDefault() {
            const e2 = this.gl;
            return [e2.KEEP, e2.KEEP, e2.KEEP];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
          }
        }
        class ys extends hs {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
          }
        }
        class xs extends hs {
          getDefault() {
            return [0, 1];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class bs extends hs {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
          }
        }
        class ws extends hs {
          getDefault() {
            return this.gl.LESS;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ts extends hs {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
          }
        }
        class Es extends hs {
          getDefault() {
            const e2 = this.gl;
            return [e2.ONE, e2.ZERO, e2.ONE, e2.ZERO];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class Ss extends hs {
          getDefault() {
            return e.ao.transparent.toNonPremultipliedRenderColor(null);
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class Is extends hs {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e2, e2), this.current = e2, this.dirty = false);
          }
        }
        class Cs extends hs {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
          }
        }
        class Rs extends hs {
          getDefault() {
            return this.gl.BACK;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
          }
        }
        class As extends hs {
          getDefault() {
            return this.gl.CCW;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
          }
        }
        let Ls = class extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
          }
        };
        class Ds extends hs {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ps extends hs {
          getDefault() {
            const e2 = this.gl;
            return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class Os extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class zs extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class Ms extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
          }
        }
        class Fs extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class Bs extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            const t2 = this.gl;
            t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class ks extends hs {
          getDefault() {
            return null;
          }
          set(e2) {
            this.gl && (e2 !== this.current || this.dirty) && (this.gl.bindVertexArray(e2), this.current = e2, this.dirty = false);
          }
        }
        class Ns extends hs {
          getDefault() {
            return 4;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
          }
        }
        class Us extends hs {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class js extends hs {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class Vs extends hs {
          constructor(e2, t2) {
            super(e2), this.context = e2, this.parent = t2;
          }
          getDefault() {
            return null;
          }
        }
        class Gs extends Vs {
          constructor(e2, t2, i2 = 0) {
            super(e2, t2), this.attachmentPoint = e2.gl.COLOR_ATTACHMENT0 + i2;
          }
          setDirty() {
            this.dirty = true;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferTexture2D(t2.FRAMEBUFFER, this.attachmentPoint, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
          }
        }
        class Hs extends Vs {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class qs extends Vs {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferTexture2D(t2.FRAMEBUFFER, this.attachment(), t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
          }
        }
        class Zs extends Hs {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        const Ws = (e2, t2, i2, o2) => ({ u_matrix: e2, u_image0: 0, u_image1: 1, u_skirt_height: t2, u_ground_shadow_factor: i2, u_emissive_texture_available: o2 }), $s = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: s2, u_merc_center: r2, u_image0: 0, u_image1: 1, u_frustum_tl: n2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h2, u_globe_radius: d2, u_viewport: u2, u_grid_matrix: m2 ? Float32Array.from(m2) : new Float32Array(9), u_skirt_height: _2, u_far_z_cutoff: p2, u_emissive_texture_available: f2 });
        function Xs(e2, t2) {
          return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
        }
        const Ys = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e2, t2, i2, o2, s2) {
            if (e2 in this.operations) {
              const t3 = this.operations[e2];
              t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
            } else this.operations[e2] = { startTime: o2, phase: 0, duration: s2, from: t2, to: i2, queued: null };
          }
          getMorphValuesForProxy(e2) {
            if (!(e2 in this.operations)) return null;
            const t2 = this.operations[e2];
            return { from: t2.from, to: t2.to, phase: t2.phase };
          }
          update(e2) {
            for (const t2 in this.operations) {
              const i2 = this.operations[t2];
              for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); ) if (!this._nextOp(i2, e2)) {
                delete this.operations[t2];
                break;
              }
            }
          }
          _nextOp(e2, t2) {
            return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
          }
          _validOp(e2) {
            return e2.from.hasData() && e2.to.hasData();
          }
        }(), Ks = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
        function Js(e2, t2, i2) {
          if (0 === t2) return 0;
          const o2 = t2 < 1 && 514 === i2 ? 0.25 / t2 : 1;
          return 6 * Math.pow(1.5, 22 - e2) * Math.max(t2, 1) * o2;
        }
        function Qs(e2, t2) {
          const i2 = 1 << e2.z;
          return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
        }
        function er(e2, t2) {
          if (!e2.style || !e2.style.enable3dLights()) return;
          const i2 = e2.context, o2 = i2.gl;
          i2.activeTexture.set(o2.TEXTURE1), t2 ? t2.bind(o2.LINEAR, o2.CLAMP_TO_EDGE) : e2.emptyTexture.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
        }
        const tr = (e2) => ({ u_matrix: e2 });
        function ir(t2, i2, o2, s2, r2) {
          if (r2 > 0) {
            const n2 = e.o.now(), a2 = (n2 - t2.timeAdded) / r2, l2 = i2 ? (n2 - i2.timeAdded) / r2 : -1, c2 = o2.getSource(), h2 = s2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(t2.tileID.overscaledZ - h2), u2 = d2 && t2.refreshedUponExpiration ? 1 : e.aA(d2 ? a2 : 1 - l2, 0, 1);
            return i2 ? { opacity: 1, mix: 1 - u2, isFading: a2 < 1 } : { opacity: u2, mix: 0, isFading: a2 < 1 };
          }
          return { opacity: 1, mix: 0, isFading: false };
        }
        class or extends Ft {
          constructor(e2) {
            const t2 = mt("mock-dem", { type: "raster-dem", maxzoom: e2.transform.maxZoom }, e2.style.dispatcher, e2.style);
            super("mock-dem", t2, false), t2.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e2, t2) {
            e2.state = "loaded", t2(null);
          }
        }
        class sr extends Ft {
          constructor(e2) {
            const t2 = mt("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, e2.style.dispatcher, e2.style);
            super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(e2, t2, i2) {
            if (e2.freezeTileCoverage) return;
            this.transform = e2;
            const o2 = e2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t3, i3) => {
              if (t3[i3.key] = "", !this._tiles[i3.key]) {
                const t4 = new Pt(i3, this._source.tileSize * i3.overscaleFactor(), e2.tileZoom, void 0, void 0, this._source.worldview);
                t4.state = "loaded", this._tiles[i3.key] = t4;
              }
              return t3;
            }, {});
            for (const e3 in this._tiles) e3 in o2 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
          }
          freeFBO(e2) {
            const t2 = this.proxyCachedFBO[e2];
            if (void 0 !== t2) {
              const i2 = Object.values(t2);
              this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class rr extends e.aQ {
          constructor(e2, t2, i2) {
            super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
          }
        }
        class nr extends e.bV {
          constructor(t2, i2) {
            super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o2, s2, r2] = function() {
              const t3 = new e.bd(), i3 = new e.b0(), o3 = 131;
              t3.reserve(17161), i3.reserve(33800);
              const s3 = e.al / 128, r3 = e.al + s3 / 2, n3 = r3 + s3;
              for (let i4 = -s3; i4 < n3; i4 += s3) for (let o4 = -s3; o4 < n3; o4 += s3) {
                const s4 = o4 < 0 || o4 > r3 || i4 < 0 || i4 > r3 ? 24575 : 0, n4 = e.aA(Math.round(o4), 0, e.al), a4 = e.aA(Math.round(i4), 0, e.al);
                t3.emplaceBack(n4 + s4, a4);
              }
              const a3 = (e2, t4) => {
                const s4 = t4 * o3 + e2;
                i3.emplaceBack(s4 + 1, s4, s4 + o3), i3.emplaceBack(s4 + o3, s4 + o3 + 1, s4 + 1);
              };
              for (let e2 = 1; e2 < 129; e2++) for (let t4 = 1; t4 < 129; t4++) a3(t4, e2);
              return [0, 129].forEach((e2) => {
                for (let t4 = 0; t4 < 130; t4++) a3(t4, e2), a3(e2, t4);
              }), [t3, i3, 32768];
            }(), n2 = t2.context;
            this.gridBuffer = n2.createVertexBuffer(o2, e.bf.members), this.gridIndexBuffer = n2.createIndexBuffer(s2), this.gridSegments = e.bg.simpleSegment(0, 0, o2.length, s2.length), this.gridNoSkirtSegments = e.bg.simpleSegment(0, 0, o2.length, r2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new sr(i2.map), this.orthoMatrix = e.bC(), e.ce(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.al, 0, e.al, 0, 1);
            const a2 = n2.gl;
            this._overlapStencilMode = new Yi({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new or(i2.map), this._pendingGroundEffectLayers = [], this._emissiveTexture = false;
          }
          set style(e2) {
            e2.on("data", this._onStyleDataEvent.bind(this)), this._style = e2, this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t2, i2, o2) {
            if (t2 && t2.terrain) {
              this._style !== t2 && (this.style = t2, this._evaluationZoom = void 0);
              const s2 = t2.terrain.properties, r2 = 0 === t2.terrain.drapeRenderMode, n2 = t2.terrain.isZoomDependent();
              this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.o.now();
              const a2 = t2.terrain && t2.terrain.scope, l2 = s2.get("source"), c2 = r2 ? this._mockSourceCache : t2.getSourceCache(l2, a2);
              if (!c2) return void e.w(`Couldn't find terrain source "${l2}".`);
              if (this.sourceCache = c2, this._attenuationRange = t2.terrain.getAttenuationRange(), this._exaggeration = n2 ? this.calculateExaggeration(i2) : s2.get("exaggeration"), !i2.projection.requiresDraping && n2 && 0 === this._exaggeration) return void this._disable();
              this.enabled = true;
              const h2 = () => {
                this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t3 = this.getScaledDemTileSize();
                this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h2(), this._initializing = true), h2(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true, this._previousZoom = i2.zoom;
            } else this._disable();
          }
          calculateExaggeration(t2) {
            if (this._attenuationRange && t2.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t2.zoom);
            const i2 = this._previousCameraAltitude, o2 = t2.getFreeCameraOptions().position.z / t2.pixelsPerMeter * t2.worldSize;
            this._previousCameraAltitude = o2;
            const s2 = null != i2 ? o2 - i2 : Number.MAX_VALUE;
            if (Math.abs(s2) < 2) return this._exaggeration;
            const r2 = t2.zoom, n2 = this._style.terrain;
            if (!this._previousUpdateTimestamp) return n2.getExaggeration(r2);
            let a2 = r2 - this._previousZoom;
            const l2 = this._previousUpdateTimestamp;
            let c2 = r2;
            null != this._evaluationZoom && (c2 = this._evaluationZoom, Math.abs(r2 - c2) > 0.5 && (a2 = 0.5 * (r2 - c2 + a2)), a2 * s2 < 0 && (c2 += a2)), this._evaluationZoom = c2;
            const h2 = n2.getExaggeration(c2), d2 = h2 === n2.getExaggeration(Math.max(0, c2 - 0.1));
            if (d2 && Math.abs(h2 - this._exaggeration) < 0.01) return h2;
            let u2 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l2));
            return (d2 || h2 < 0.1 || Math.abs(a2) < 1e-4) && (u2 = Math.min(0.2, 4 * u2)), e.ak(this._exaggeration, h2, u2);
          }
          resetTileLookupCache(e2) {
            this._findCoveringTileCache[e2] = {};
          }
          attenuationRange() {
            return this._attenuationRange;
          }
          getDemUpscale() {
            return this.proxySourceCache.getSource().tileSize / 128;
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _onStyleDataEvent(e2) {
            "source" === e2.dataType && e2.coord ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._emptyDEMTextureDirty = true, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e2 in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e2].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this.enabled ? this._exaggeration : 0;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e2 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e2, e2];
          }
          set useVertexMorphing(e2) {
            this._useVertexMorphing = e2;
          }
          updateTileBinding(t2) {
            if (!this.enabled) return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i2 = this.proxySourceCache, o2 = this.painter.transform;
            this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.ae.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
            const s2 = this.proxyCoords = i2.getIds().map((e2) => {
              const t3 = i2.getTileByID(e2).tileID;
              return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
            });
            !function(t3, i3) {
              const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), s3 = new e.P(o3.x, o3.y);
              t3.sort((t4, i4) => {
                if (i4.overscaledZ - t4.overscaledZ) return i4.overscaledZ - t4.overscaledZ;
                const o4 = new e.P(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), r3 = new e.P(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), n3 = s3.mult(1 << t4.canonical.z);
                return n3.x -= 0.5, n3.y -= 0.5, n3.distSqr(o4) - n3.distSqr(r3);
              });
            }(s2, this.painter);
            const r2 = this.proxyToSource || {};
            this.proxyToSource = {}, s2.forEach((e2) => {
              this.proxyToSource[e2.key] = {};
            }), this.terrainTileForTile = {};
            const n2 = this._style._mergedSourceCaches;
            for (const e2 in n2) {
              const i3 = n2[e2];
              if (!i3.used) continue;
              if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], r2), i3.usedForTerrain) continue;
              const o3 = t2[e2];
              i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
            }
            this.proxiedCoords[i2.id] = s2.map((e2) => new rr(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(s2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r2), this.renderingToTexture = false;
            const a2 = {};
            this._visibleDemTiles = [];
            for (const e2 of this.proxyCoords) {
              const t3 = this.terrainTileForTile[e2.key];
              if (!t3) continue;
              const i3 = t3.tileID.key;
              i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
            }
          }
          _assignTerrainTiles(e2) {
            this._initializing || e2.forEach((e3) => {
              if (this.terrainTileForTile[e3.key]) return;
              const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
              t2 && (this.terrainTileForTile[e3.key] = t2);
            });
          }
          _prepareDEMTextures() {
            const e2 = this.painter.context, t2 = e2.gl;
            for (const i2 in this.terrainTileForTile) {
              const o2 = this.terrainTileForTile[i2], s2 = o2.dem;
              !s2 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), ls(this.painter, o2, s2));
            }
          }
          _prepareDemTileUniforms(e2, t2, i2, o2) {
            if (!t2 || null == t2.demTexture) return false;
            const s2 = e2.tileID.canonical, r2 = Math.pow(2, t2.tileID.canonical.z - s2.z), n2 = o2 || "";
            return i2[`u_dem_tl${n2}`] = [s2.x * r2 % 1, s2.y * r2 % 1], i2[`u_dem_scale${n2}`] = r2, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          _getLoadedAreaMinimum() {
            if (!this.enabled) return 0;
            let e2 = 0;
            const t2 = this._visibleDemTiles.reduce((t3, i2) => {
              if (!i2.dem) return t3;
              const o2 = i2.dem.tree.minimums[0];
              return o2 > 0 && e2++, t3 + o2;
            }, 0);
            return e2 ? t2 / e2 : 0;
          }
          _updateEmptyDEMTexture() {
            const t2 = this.painter.context, i2 = t2.gl;
            t2.activeTexture.set(i2.TEXTURE2);
            const o2 = this._getLoadedAreaMinimum(), s2 = new e.dL({ width: 1, height: 1 }, new Float32Array([o2]));
            this._emptyDEMTextureDirty = false;
            let r2 = this._emptyDEMTexture;
            return r2 ? r2.update(s2, { premultiply: false }) : r2 = this._emptyDEMTexture = new e.T(t2, s2, i2.R32F, { premultiply: false }), r2;
          }
          setupElevationDraw(t2, i2, o2) {
            const s2 = this.painter.context, r2 = s2.gl, n2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
            n2.u_exaggeration = this.exaggeration();
            let a2 = null, l2 = null, c2 = 1;
            if (o2 && o2.morphing && this._useVertexMorphing) {
              const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
              c2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, n2, "_prev") && (l2 = e2), this._prepareDemTileUniforms(t2, i3, n2) && (a2 = i3));
            }
            const h2 = (e2) => e2 && e2.demTexture && this.painter.linearFloatFilteringSupported() ? r2.LINEAR : r2.NEAREST;
            let d2 = null;
            var u2;
            if (this.enabled ? l2 && a2 ? (d2 = a2.demTexture, s2.activeTexture.set(r2.TEXTURE4), l2.demTexture.bind(h2(l2), r2.CLAMP_TO_EDGE), n2.u_dem_lerp = c2) : (a2 = this.terrainTileForTile[t2.tileID.key], d2 = this._prepareDemTileUniforms(t2, a2, n2) ? a2.demTexture : this.emptyDEMTexture) : d2 = this.emptyDEMTexture, s2.activeTexture.set(r2.TEXTURE2), d2 && (n2.u_dem_size = 1 === (u2 = d2).size[0] ? 1 : u2.size[0] - 2, d2.bind(h2(a2), r2.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o2 && o2.useDepthForOcclusion, i2, n2), o2 && o2.useMeterToDem && a2) {
              const t3 = (1 << a2.tileID.canonical.z) * e.cf(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              n2.u_meter_to_dem = t3;
            }
            if (o2 && o2.labelPlaneMatrixInv && (n2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(s2, n2), "globe" === this.painter.transform.projection.name) {
              const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
              i2.setGlobeUniformValues(s2, e2);
            }
          }
          globeUniformValues(t2, i2, o2) {
            const s2 = t2.projection;
            return { u_tile_tl_up: s2.upVector(i2, 0, 0), u_tile_tr_up: s2.upVector(i2, e.al, 0), u_tile_br_up: s2.upVector(i2, e.al, e.al), u_tile_bl_up: s2.upVector(i2, 0, e.al), u_tile_up_scale: o2 ? e.dM(1) : s2.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
          }
          renderToBackBuffer(t2) {
            const i2 = this.painter, o2 = this.painter.context;
            0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, s2, r2) {
              if ("globe" === t3.transform.projection.name) !function(t4, i4, o4, s3, r3) {
                const n2 = t4.context, a2 = n2.gl;
                let l2, c2;
                const h2 = t4.transform, d2 = e.dE(t4, n2, h2), u2 = (e2, i5) => {
                  if (c2 === i5) return;
                  const o5 = [Ks[i5], "PROJECTION_GLOBE_VIEW"];
                  d2 && o5.push("CUSTOM_ANTIALIASING");
                  const s4 = t4.isTileAffectedByFog(e2);
                  l2 = t4.getOrCreateProgram("globeRaster", { defines: o5, overrideFog: s4 }), c2 = i5;
                }, _2 = t4.colorModeForRenderPass(), p2 = new $i(a2.LEQUAL, $i.ReadWrite, t4.depthRangeFor3D);
                Ys.update(r3);
                const f2 = e.dF(h2), m2 = [e.aF(h2.center.lng), e.aJ(h2.center.lat)], g2 = t4.globeSharedBuffers, v2 = [h2.width * e.o.devicePixelRatio, h2.height * e.o.devicePixelRatio], y2 = Float32Array.from(h2.globeMatrix), x2 = { useDenormalizedUpVectorScale: true };
                {
                  const h3 = t4.transform, d3 = Js(h3.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                  c2 = -1;
                  const b2 = a2.TRIANGLES;
                  for (const c3 of s3) {
                    const s4 = o4.getTile(c3), w2 = Yi.disabled, T2 = i4.prevTerrainTileForTile[c3.key], E2 = i4.terrainTileForTile[c3.key];
                    Xs(T2, E2) && Ys.newMorphing(c3.key, T2, E2, r3, 250), er(t4, s4.emissiveTexture), n2.activeTexture.set(a2.TEXTURE0), s4.texture && s4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                    const S2 = Ys.getMorphValuesForProxy(c3.key), I2 = S2 ? 1 : 0;
                    S2 && Object.assign(x2, { morphing: { srcDemTile: S2.from, dstDemTile: S2.to, phase: e.dD(S2.phase) } });
                    const C2 = e.dG(c3.canonical), R2 = e.dH(C2.getCenter().lat), A2 = e.dI(c3.canonical, C2, R2, h3.worldSize / h3._pixelsPerMercatorPixel), L2 = e.bk(e.dJ(c3.canonical)), D2 = "mrt-fallback" === t4.emissiveMode ? 1 : 0, P2 = $s(h3.expandedFarZProjMatrix, y2, f2, L2, e.aj(h3.zoom), m2, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v2, d3, h3._farZ, D2, A2);
                    if (u2(c3, I2), l2 && (i4.setupElevationDraw(s4, l2, x2), t4.uploadCommonUniforms(n2, l2, c3.toUnwrapped()), g2)) {
                      const [e2, i5, o5] = g2.getGridBuffers(R2, 0 !== d3);
                      l2.draw(t4, b2, p2, w2, _2, Qi.backCCW, P2, "globe_raster", e2, i5, o5);
                    }
                  }
                }
                if (g2 && (t4.renderDefaultNorthPole || t4.renderDefaultSouthPole)) {
                  const r4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  d2 && r4.push("CUSTOM_ANTIALIASING"), l2 = t4.getOrCreateProgram("globeRaster", { defines: r4 });
                  for (const r5 of s3) {
                    const { x: s4, y: c3, z: d3 } = r5.canonical, u3 = 0 === c3, f3 = c3 === (1 << d3) - 1, [y3, b2, w2, T2] = g2.getPoleBuffers(d3, false);
                    if (T2 && (u3 || f3)) {
                      const c4 = o4.getTile(r5);
                      er(t4, c4.emissiveTexture), n2.activeTexture.set(a2.TEXTURE0), c4.texture && c4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      let g3 = e.dK(d3, s4, h2);
                      const E2 = e.bk(e.dJ(r5.canonical)), S2 = "mrt-fallback" === t4.emissiveMode ? 1 : 0, I2 = (e2, i5) => e2.draw(t4, a2.TRIANGLES, p2, Yi.disabled, _2, Qi.disabled, $s(h2.expandedFarZProjMatrix, g3, g3, E2, 0, m2, h2.frustumCorners.TL, h2.frustumCorners.TR, h2.frustumCorners.BR, h2.frustumCorners.BL, h2.globeCenterInViewSpace, h2.globeRadius, v2, 0, h2._farZ, S2), "globe_pole_raster", i5, w2, T2);
                      i4.setupElevationDraw(c4, l2, x2), t4.uploadCommonUniforms(n2, l2, r5.toUnwrapped()), u3 && t4.renderDefaultNorthPole && I2(l2, y3), f3 && t4.renderDefaultSouthPole && (g3 = e.cS(e.bC(), g3, [1, -1, 1]), I2(l2, b2));
                    }
                  }
                }
              }(t3, i3, o3, s2, r2);
              else {
                const n2 = t3.context, a2 = n2.gl;
                let l2, c2;
                const h2 = t3.shadowRenderer, d2 = co(t3, t3.longestCutoffRange), u2 = (e2) => {
                  if (c2 === e2) return;
                  const i4 = [];
                  i4.push(Ks[e2]), d2.shouldRenderCutoff && i4.push("RENDER_CUTOFF"), h2 && (i4.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h2.useNormalOffset && i4.push("NORMAL_OFFSET")), l2 = t3.getOrCreateProgram("terrainRaster", { defines: i4 }), c2 = e2;
                }, _2 = t3.colorModeForRenderPass(), p2 = new $i(a2.LEQUAL, $i.ReadWrite, t3.depthRangeFor3D);
                Ys.update(r2);
                const f2 = t3.transform, m2 = Js(f2.zoom, i3.exaggeration(), i3.sourceCache._source.tileSize);
                let g2 = [0, 0, 0];
                if (h2) {
                  const e2 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                  e2 && i4 && (g2 = go(t3.style, e2, i4));
                }
                {
                  c2 = -1;
                  const v2 = a2.TRIANGLES, [y2, x2] = [i3.gridIndexBuffer, i3.gridSegments];
                  for (const c3 of s2) {
                    const s3 = o3.getTile(c3), b2 = Yi.disabled, w2 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                    Xs(w2, T2) && Ys.newMorphing(c3.key, w2, T2, r2, 250), er(t3, s3.emissiveTexture), n2.activeTexture.set(a2.TEXTURE0), s3.texture && s3.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                    const E2 = Ys.getMorphValuesForProxy(c3.key), S2 = E2 ? 1 : 0;
                    let I2;
                    E2 && (I2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: e.dD(E2.phase) } });
                    const C2 = "mrt-fallback" === t3.emissiveMode ? 1 : 0, R2 = Ws(c3.projMatrix, Qs(c3.canonical, f2.renderWorldCopies) ? m2 / 10 : m2, g2, C2);
                    if (u2(S2), !l2) continue;
                    i3.setupElevationDraw(s3, l2, I2);
                    const A2 = c3.toUnwrapped();
                    h2 && h2.setupShadows(A2, l2), t3.uploadCommonUniforms(n2, l2, A2, null, d2), l2.draw(t3, v2, p2, b2, _2, Qi.backCCW, R2, "terrain_raster", i3.gridBuffer, y2, x2);
                  }
                }
              }
            }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
          }
          renderBatch(t2) {
            if (0 === this._drapedRenderBatches.length) return t2 + 1;
            this.renderingToTexture = true;
            const i2 = this.painter, o2 = this.painter.context, s2 = this.proxySourceCache, r2 = this.proxiedCoords[s2.id], n2 = this._drapedRenderBatches.shift(), a2 = i2.style.order, l2 = [];
            this._updateFBOs("mrt-fallback" === i2.emissiveMode);
            let c2 = 0;
            for (const h2 of r2) {
              const r3 = s2.getTileByID(h2.proxyTileKey), d2 = s2.proxyCachedFBO[h2.key] ? s2.proxyCachedFBO[h2.key][t2] : void 0, u2 = void 0 !== d2 ? s2.renderCache[d2] : this.pool[c2++], _2 = void 0 !== d2;
              if (r3.texture = u2.tex, r3.emissiveTexture = u2.emissiveTex, _2 && !u2.dirty) {
                l2.push(r3.tileID);
                continue;
              }
              o2.bindFramebuffer.set(u2.fb.framebuffer);
              const p2 = o2.gl;
              let f2;
              p2.drawBuffers("mrt-fallback" === i2.emissiveMode ? [p2.COLOR_ATTACHMENT0, p2.COLOR_ATTACHMENT1] : [p2.COLOR_ATTACHMENT0]), this.renderedToTile = false, u2.dirty && (o2.clear({ color: e.ao.transparent, stencil: 0 }), u2.dirty = false);
              for (let e2 = n2.start; e2 <= n2.end; ++e2) {
                const t3 = i2.style._mergedLayers[a2[e2]];
                if (t3.isHidden(i2.transform.zoom)) continue;
                const s3 = i2.style.getLayerSourceCache(t3), r4 = s3 ? this.proxyToSource[h2.key][s3.id] : [h2];
                if (!r4) continue;
                const n3 = r4;
                o2.viewport.set([0, 0, u2.fb.width, u2.fb.height]), f2 !== (s3 ? s3.id : null) && (this._setupStencil(u2, r4, t3, s3), f2 = s3 ? s3.id : null), i2.renderLayer(i2, s3, t3, n3);
              }
              if (p2.drawBuffers([p2.COLOR_ATTACHMENT0]), 0 === this._drapedRenderBatches.length) for (const e2 of this._pendingGroundEffectLayers) {
                const t3 = i2.style._mergedLayers[a2[e2]];
                if (t3.isHidden(i2.transform.zoom)) continue;
                const s3 = i2.style.getLayerSourceCache(t3), r4 = s3 ? this.proxyToSource[h2.key][s3.id] : [h2];
                if (!r4) continue;
                const n3 = r4;
                o2.viewport.set([0, 0, u2.fb.width, u2.fb.height]), f2 !== (s3 ? s3.id : null) && (this._setupStencil(u2, r4, t3, s3), f2 = s3 ? s3.id : null), i2.renderLayer(i2, s3, t3, n3);
              }
              this.renderedToTile ? (u2.dirty = true, l2.push(r3.tileID)) : _2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(l2));
            }
            return this.renderToBackBuffer(l2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), n2.end + 1;
          }
          postRender() {
          }
          isLayerOrderingCorrect(e2) {
            const t2 = e2.order.length;
            let i2 = -1, o2 = t2;
            for (let s2 = 0; s2 < t2; ++s2) this._style.isLayerDraped(e2._mergedLayers[e2.order[s2]]) ? i2 = Math.max(i2, s2) : o2 = Math.min(o2, s2);
            return o2 > i2;
          }
          getMinElevationBelowMSL() {
            let e2 = 0;
            return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
              e2 = Math.min(e2, t2.dem.tree.minimums[0]);
            }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
          }
          raycast(e2, t2, i2) {
            if (!this._visibleDemTiles) return null;
            const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
              const s2 = o3.tileID, r2 = 1 << s2.overscaledZ, { x: n2, y: a2 } = s2.canonical, l2 = n2 / r2, c2 = (n2 + 1) / r2, h2 = a2 / r2, d2 = (a2 + 1) / r2;
              return { minx: l2, miny: h2, maxx: c2, maxy: d2, t: o3.dem.tree.raycastRoot(l2, h2, c2, d2, e2, t2, i2), tile: o3 };
            });
            o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
            for (const s2 of o2) {
              if (null == s2.t) return null;
              const o3 = s2.tile.dem.tree.raycast(s2.minx, s2.miny, s2.maxx, s2.maxy, e2, t2, i2);
              if (null != o3) return o3;
            }
            return null;
          }
          _createFBO() {
            const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
            t2.activeTexture.set(i2.TEXTURE0);
            const s2 = new e.T(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA8);
            s2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
            const r2 = t2.createFramebuffer(o2[0], o2[1], 1, null);
            let n2;
            return r2.colorAttachment0.set(s2.texture), this._emissiveTexture && (n2 = new e.T(t2, { width: o2[0], height: o2[1], data: null }, i2.R8), n2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), r2.createColorAttachment(t2, 1), r2.colorAttachment1.set(n2.texture)), r2.depthAttachment = new Zs(t2, r2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, r2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : r2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: r2, tex: s2, emissiveTex: n2, dirty: false };
          }
          _updateFBOs(e2) {
            if (this._emissiveTexture !== e2) {
              for (const t2 of this.pool) this._updateFBO(t2, e2);
              for (const t2 of this.proxySourceCache.renderCache) this._updateFBO(t2, e2);
              this._emissiveTexture = e2;
            }
          }
          _updateFBO(t2, i2) {
            const o2 = t2.fb, s2 = this.painter.context, r2 = s2.gl, n2 = this.drapeBufferSize;
            if (i2) {
              const i3 = new e.T(s2, { width: n2[0], height: n2[1], data: null }, r2.R8);
              i3.bind(r2.LINEAR, r2.CLAMP_TO_EDGE), t2.emissiveTex = i3, o2.createColorAttachment(s2, 1), o2.colorAttachment1.set(i3.texture);
            } else t2.emissiveTex = void 0, o2.removeColorAttachment(s2, 1);
            t2.dirty = true;
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._debugParams.disableRenderCache) return true;
            if (this._style.hasLightTransitions()) return true;
            for (const e2 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e2].hasTransition()) return true;
            return this._style.order.some((e2) => {
              const t2 = this._style._mergedLayers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
              return "hillshade" === t2.type || "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t2 = false;
            for (const e2 of this._style.getSources()) if (e2 instanceof dt) {
              t2 = true;
              break;
            }
            if (!t2) return;
            const i2 = {};
            for (let t3 = 0; t3 < this._style.order.length; ++t3) {
              const o2 = this._style._mergedLayers[this._style.order[t3]], s2 = this._style.getLayerSourceCache(o2);
              if (!s2 || i2[s2.id]) continue;
              if (o2.isHidden(this.painter.transform.zoom) || "line" !== o2.type) continue;
              const r2 = o2.widthExpression(), n2 = o2.emissiveStrengthExpression();
              if (r2 instanceof e.ad || n2 instanceof e.ad) {
                i2[s2.id] = true;
                for (const e2 of this.proxyCoords) {
                  const t4 = this.proxyToSource[e2.key][s2.id];
                  if (t4) for (const e3 of t4) this._clearRenderCacheForTile(s2.id, e3);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let e2 = false;
            for (const t3 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t3]._source instanceof ut) {
              e2 = true;
              break;
            }
            if (!e2) return;
            const t2 = {};
            for (let e3 = 0; e3 < this._style.order.length; ++e3) {
              const i2 = this._style._mergedLayers[this._style.order[e3]], o2 = this._style.getLayerSourceCache(i2);
              if (!o2 || t2[o2.id]) continue;
              if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type) continue;
              const s2 = i2.paint.get("raster-fade-duration");
              for (const e4 of this.proxyCoords) {
                const t3 = this.proxyToSource[e4.key][o2.id];
                if (t3) for (const e5 of t3) {
                  const t4 = ir(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, s2);
                  (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                }
              }
            }
          }
          _setupDrapedRenderBatches() {
            this._style.updateDrapeFirstLayers();
            const t2 = this._style.order, i2 = t2.length;
            if (0 === i2) return;
            const o2 = [];
            this._pendingGroundEffectLayers = [];
            let s2, r2 = 0, n2 = this._style._mergedLayers[t2[r2]];
            for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r2 < i2; ) n2 = this._style._mergedLayers[t2[r2]];
            for (; r2 < i2; ++r2) {
              const e2 = this._style._mergedLayers[t2[r2]];
              e2.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e2) ? void 0 === s2 && (s2 = r2) : ("fill-extrusion" === e2.type && this._pendingGroundEffectLayers.push(r2), void 0 !== s2 && (o2.push({ start: s2, end: r2 - 1 }), s2 = void 0)));
            }
            if (void 0 !== s2 && o2.push({ start: s2, end: r2 - 1 }), 0 !== o2.length) {
              const t3 = o2[o2.length - 1];
              this._pendingGroundEffectLayers.every((e2) => e2 > t3.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
            }
            this._drapedRenderBatches = o2;
          }
          _setupRenderCache(e2) {
            const t2 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
              if (this.invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
                const e3 = Object.values(t2.proxyCachedFBO);
                t2.proxyCachedFBO = {};
                for (let i3 = 0; i3 < e3.length; ++i3) {
                  const o3 = Object.values(e3[i3]);
                  t2.renderCachePool.push(...o3);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const i2 = this.proxyCoords, o2 = this._tilesDirty;
            for (let s3 = i2.length - 1; s3 >= 0; s3--) {
              const r2 = i2[s3];
              if (t2.getTileByID(r2.key), void 0 !== t2.proxyCachedFBO[r2.key]) {
                const i3 = e2[r2.key], s4 = this.proxyToSource[r2.key];
                let n2 = 0;
                for (const e3 in s4) {
                  const t3 = s4[e3], r3 = i3[e3];
                  if (!r3 || r3.length !== t3.length || t3.some((t4, i4) => t4 !== r3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                    n2 = -1;
                    break;
                  }
                  ++n2;
                }
                for (const e3 in t2.proxyCachedFBO[r2.key]) t2.renderCache[t2.proxyCachedFBO[r2.key][e3]].dirty = n2 < 0 || n2 !== Object.values(i3).length;
              }
            }
            const s2 = [...this._drapedRenderBatches];
            s2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
            for (const e3 of s2) for (const o3 of i2) {
              if (t2.proxyCachedFBO[o3.key]) continue;
              let i3 = t2.renderCachePool.pop();
              void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
            }
            this._tilesDirty = {};
          }
          _setupStencil(e2, t2, i2, o2) {
            if (!o2 || !this._sourceTilesOverlap[o2.id]) return void (this._overlapStencilType && (this._overlapStencilType = false));
            const s2 = this.painter.context, r2 = s2.gl;
            if (t2.length <= 1) return void (this._overlapStencilType = false);
            let n2;
            if (i2.isTileClipped()) n2 = t2.length, this._overlapStencilMode.test = { func: r2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ)) return void (this._overlapStencilType = false);
              n2 = 1, this._overlapStencilMode.test = { func: r2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + n2 > 255 && (s2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
          }
          stencilModeForRTTOverlap(e2) {
            return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e2.key]), this._overlapStencilMode) : Yi.disabled;
          }
          _renderTileClippingMasks(e2, t2) {
            const i2 = this.painter, o2 = this.painter.context, s2 = o2.gl;
            i2._tileClippingMaskIDs = {}, o2.setColorMode(Wi.disabled), o2.setDepthMode($i.disabled);
            const r2 = i2.getOrCreateProgram("clippingMask");
            for (const o3 of e2) {
              const e3 = i2._tileClippingMaskIDs[o3.key] = --t2;
              r2.draw(i2, s2.TRIANGLES, $i.disabled, new Yi({ func: s2.ALWAYS, mask: 0 }, e3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), Wi.disabled, Qi.disabled, tr(o3.projMatrix), "$clipping", i2.tileExtentBuffer, i2.quadTriangleIndexBuffer, i2.tileExtentSegments);
            }
          }
          pointCoordinate(t2) {
            const i2 = this.painter.transform;
            if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height) return null;
            const o2 = [t2.x, t2.y, 1, 1];
            e.aC(o2, o2, i2.pixelMatrixInverse), e.cK(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
            const s2 = i2._camera.position, r2 = e.cf(1, i2.center.lat), n2 = [s2[0], s2[1], s2[2] / r2, 0], a2 = e.da([], o2.slice(0, 3), n2);
            e.aw(a2, a2);
            const l2 = this.raycast(n2, a2, this._exaggeration);
            return null !== l2 && l2 ? (e.bH(n2, n2, a2, l2), n2[3] = n2[2], n2[2] *= r2, n2) : null;
          }
          _setupProxiedCoordsForOrtho(t2, i2, o2) {
            if (t2.getSource() instanceof e.aU) return this._setupProxiedCoordsForImageSource(t2, i2, o2);
            this._findCoveringTileCache[t2.id] = this._findCoveringTileCache[t2.id] || {};
            const s2 = this.proxiedCoords[t2.id] = [], r2 = this.proxyCoords;
            for (let e2 = 0; e2 < r2.length; e2++) {
              const i3 = r2[e2], n3 = this._findTileCoveringTileID(i3, t2);
              if (n3) {
                const e3 = this._createProxiedId(i3, n3, o2[i3.key] && o2[i3.key][t2.id]);
                s2.push(e3), this.proxyToSource[i3.key][t2.id] = [e3];
              }
            }
            let n2 = false;
            const a2 = /* @__PURE__ */ new Set();
            for (let e2 = 0; e2 < i2.length; e2++) {
              const r3 = t2.getTile(i2[e2]);
              if (!r3 || !r3.hasData()) continue;
              const l2 = this._findTileCoveringTileID(r3.tileID, this.proxySourceCache);
              if (l2 && l2.tileID.canonical.z !== r3.tileID.canonical.z) {
                const e3 = this.proxyToSource[l2.tileID.key][t2.id], i3 = this._createProxiedId(l2.tileID, r3, o2[l2.tileID.key] && o2[l2.tileID.key][t2.id]);
                e3 ? e3.splice(e3.length - 1, 0, i3) : this.proxyToSource[l2.tileID.key][t2.id] = [i3];
                const c2 = this.proxyToSource[l2.tileID.key][t2.id];
                a2.has(c2) || a2.add(c2), s2.push(i3), n2 = true;
              }
            }
            if (this._sourceTilesOverlap[t2.id] = n2, n2 && this._debugParams.sortTilesHiZFirst) for (const e2 of a2) e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ);
          }
          _setupProxiedCoordsForImageSource(t2, i2, o2) {
            if (!t2.getSource().loaded()) return;
            const s2 = this.proxiedCoords[t2.id] = [], r2 = this.proxyCoords, n2 = t2.getSource(), a2 = n2.tileID;
            if (!a2) return;
            const l2 = new e.P(a2.x, a2.y)._div(1 << a2.z), c2 = n2.coordinates.map(e.ae.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - l2.x), e2.min.y = Math.min(e2.min.y, t3.y - l2.y), e2.max.x = Math.max(e2.max.x, t3.x - l2.x), e2.max.y = Math.max(e2.max.y, t3.y - l2.y), e2), { min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h2 = (t3, i3) => {
              const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), s3 = t3.canonical.y / (1 << t3.canonical.z), r3 = e.al / (1 << t3.canonical.z), n3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
              return o3 + r3 < n3 + c2.min.x || o3 > n3 + c2.max.x || s3 + r3 < a3 + c2.min.y || s3 > a3 + c2.max.y;
            };
            for (let e2 = 0; e2 < r2.length; e2++) {
              const n3 = r2[e2];
              for (let e3 = 0; e3 < i2.length; e3++) {
                const r3 = t2.getTile(i2[e3]);
                if (!r3 || !r3.hasData()) continue;
                if (h2(n3, r3.tileID)) continue;
                const a3 = this._createProxiedId(n3, r3, o2[n3.key] && o2[n3.key][t2.id]), l3 = this.proxyToSource[n3.key][t2.id];
                l3 ? l3.push(a3) : this.proxyToSource[n3.key][t2.id] = [a3], s2.push(a3);
              }
            }
          }
          _createProxiedId(t2, i2, o2) {
            let s2 = this.orthoMatrix;
            if (o2) {
              const e2 = o2.find((e3) => e3.key === i2.tileID.key);
              if (e2) return e2;
            }
            if (i2.tileID.key !== t2.key) {
              const o3 = t2.canonical.z - i2.tileID.canonical.z;
              let r2, n2, a2;
              s2 = e.bC();
              const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
              o3 > 0 ? (r2 = e.al >> o3, n2 = r2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), a2 = r2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (r2 = e.al << -o3, n2 = e.al * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), a2 = e.al * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.ce(s2, 0, r2, 0, r2, 0, 1), e.br(s2, s2, [n2, a2, 0]);
            }
            return new rr(i2.tileID, t2.key, s2);
          }
          _findTileCoveringTileID(t2, i2) {
            let o2 = i2.getTile(t2);
            if (o2 && o2.hasData()) return o2;
            const s2 = this._findCoveringTileCache[i2.id], r2 = s2[t2.key];
            if (o2 = r2 ? i2.getTileByID(r2) : null, o2 && o2.hasData() || null === r2) return o2;
            let n2 = o2 ? o2.tileID : t2, a2 = n2.overscaledZ;
            const l2 = i2.getSource().minzoom, c2 = [];
            if (!r2) {
              const s3 = i2.getSource().maxzoom;
              if (t2.canonical.z >= s3) {
                const o3 = t2.canonical.z - s3;
                i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), n2 = new e.aQ(a2, t2.wrap, s3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (a2 = s3, n2 = new e.aQ(a2, t2.wrap, s3, t2.canonical.x >> o3, t2.canonical.y >> o3));
              }
              n2.key !== t2.key && (c2.push(n2.key), o2 = i2.getTile(n2));
            }
            const h2 = (e2) => {
              c2.forEach((t3) => {
                s2[t3] = e2;
              }), c2.length = 0;
            };
            for (a2 -= 1; a2 >= l2 && (!o2 || !o2.hasData()); a2--) {
              o2 && h2(o2.tileID.key);
              const e2 = n2.calculateScaledKey(a2);
              if (o2 = i2.getTileByID(e2), o2 && o2.hasData()) break;
              const t3 = s2[e2];
              if (null === t3) break;
              void 0 === t3 ? c2.push(e2) : o2 = i2.getTileByID(t3);
            }
            return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
          }
          findDEMTileFor(e2) {
            return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e2, t2) {
            let i2 = this._tilesDirty[e2];
            i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
          }
        }
        function ar(t2, i2, o2) {
          const s2 = function(t3, i3, o3) {
            const s3 = e.bJ(i3, t3), r3 = e.bJ(o3, [0.2126, 0.7152, 0.0722]), n3 = (e2, t4, i4) => (1 - i4) * e2 + i4 * t4, a3 = n3(1 - 0.3 * Math.min(r3, 1), 1, Math.min(s3 + 1, 1));
            return n3(0.92, 1, Math.asin(e.aA(i3[2], -1, 1)) / Math.PI + 0.5) * a3;
          }(t2, [0, 0, 1], i2), r2 = [0, 0, 0];
          e.c5(r2, o2.slice(0, 3), s2);
          const n2 = [0, 0, 0];
          e.c5(n2, i2.slice(0, 3), t2[2]);
          const a2 = [0, 0, 0];
          return e.d8(a2, r2, n2), e.db(a2);
        }
        const lr = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], cr = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "building", "buildingBloom", "elevatedStructures", "model", "symbol"];
        class hr {
          static cacheKey(e2, t2, i2, o2) {
            const s2 = [t2];
            o2 && s2.push(o2.cacheKey);
            for (const t3 of i2) e2.usedDefines.has(t3) && s2.push(t3);
            return s2.join("/");
          }
          constructor(t2, i2, o2, s2, r2, n2) {
            const a2 = t2.gl;
            this.program = a2.createProgram(), this.configuration = s2, this.name = i2, this.fixedDefines = [...n2];
            const l2 = `#version 300 es
${(s2 ? s2.defines() : []).concat(n2.map((e2) => `#define ${e2}`)).join("\n")}`, c2 = [l2, es];
            for (const e2 of o2.fragmentIncludes) c2.push(Yo[e2]);
            c2.push(o2.fragmentSource);
            const h2 = c2.join("\n"), d2 = [l2, ts];
            for (const e2 of o2.vertexIncludes) d2.push(Yo[e2]);
            this.forceManualRenderingForInstanceIDShaders = t2.forceManualRenderingForInstanceIDShaders && o2.vertexSource.includes("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && d2.push("uniform int u_instanceID;"), d2.push(o2.vertexSource);
            let u2 = d2.join("\n");
            this.forceManualRenderingForInstanceIDShaders && (u2 = u2.replaceAll("gl_InstanceID", "u_instanceID"));
            const _2 = a2.createShader(a2.FRAGMENT_SHADER);
            if (a2.isContextLost()) return void (this.failedToCreate = true);
            a2.shaderSource(_2, h2), a2.compileShader(_2), a2.attachShader(this.program, _2);
            const p2 = a2.createShader(a2.VERTEX_SHADER);
            a2.isContextLost() ? this.failedToCreate = true : (a2.shaderSource(p2, u2), a2.compileShader(p2), a2.attachShader(this.program, p2), this.attributes = {}, a2.linkProgram(this.program), a2.deleteShader(p2), a2.deleteShader(_2), this.fixedUniforms = r2(t2), this.fixedUniformsEntries = Object.entries(this.fixedUniforms), this.binderUniforms = s2 ? s2.getUniforms(t2) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t3) => ({ u_instanceID: new e.ch(t3) }))(t2)), (n2.includes("TERRAIN") || i2.includes("symbol") || i2.includes("circle")) && (this.terrainUniforms = ((t3) => ({ u_dem: new e.ch(t3), u_dem_prev: new e.ch(t3), u_dem_tl: new e.ck(t3), u_dem_scale: new e.cj(t3), u_dem_tl_prev: new e.ck(t3), u_dem_scale_prev: new e.cj(t3), u_dem_size: new e.cj(t3), u_dem_lerp: new e.cj(t3), u_exaggeration: new e.cj(t3), u_depth: new e.ch(t3), u_depth_size_inv: new e.ck(t3), u_depth_range_unpack: new e.ck(t3), u_occluder_half_size: new e.cj(t3), u_occlusion_depth_offset: new e.cj(t3), u_meter_to_dem: new e.cj(t3), u_label_plane_matrix_inv: new e.cl(t3) }))(t2)), n2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.ci(t3), u_tile_tr_up: new e.ci(t3), u_tile_br_up: new e.ci(t3), u_tile_bl_up: new e.ci(t3), u_tile_up_scale: new e.cj(t3) }))(t2)), n2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.cl(t3), u_fog_range: new e.ck(t3), u_fog_color: new e.d3(t3), u_fog_horizon_blend: new e.cj(t3), u_fog_vertical_limit: new e.ck(t3), u_fog_temporal_offset: new e.cj(t3), u_frustum_tl: new e.ci(t3), u_frustum_tr: new e.ci(t3), u_frustum_br: new e.ci(t3), u_frustum_bl: new e.ci(t3), u_globe_pos: new e.ci(t3), u_globe_radius: new e.cj(t3), u_globe_transition: new e.cj(t3), u_is_globe: new e.ch(t3), u_viewport: new e.ck(t3) }))(t2)), n2.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t3) => ({ u_cutoff_params: new e.d3(t3) }))(t2)), n2.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t3) => ({ u_lighting_ambient_color: new e.ci(t3), u_lighting_directional_dir: new e.ci(t3), u_lighting_directional_color: new e.ci(t3), u_ground_radiance: new e.ci(t3) }))(t2)), n2.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t3) => ({ u_light_matrix_0: new e.cl(t3), u_light_matrix_1: new e.cl(t3), u_fade_range: new e.ck(t3), u_shadow_normal_offset: new e.ci(t3), u_shadow_intensity: new e.cj(t3), u_shadow_texel_size: new e.cj(t3), u_shadow_map_resolution: new e.cj(t3), u_shadow_direction: new e.ci(t3), u_shadow_bias: new e.ci(t3), u_shadowmap_0: new e.ch(t3), u_shadowmap_1: new e.ch(t3) }))(t2)));
          }
          getAttributeLocation(e2, t2) {
            let i2 = this.attributes[t2];
            return void 0 === i2 && (i2 = this.attributes[t2] = e2.getAttribLocation(this.program, t2)), i2;
          }
          setTerrainUniformValues(e2, t2) {
            if (!this.terrainUniforms) return;
            const i2 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setGlobeUniformValues(e2, t2) {
            if (!this.globeUniforms) return;
            const i2 = this.globeUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setFogUniformValues(e2, t2) {
            if (!this.fogUniforms) return;
            const i2 = this.fogUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setCutoffUniformValues(e2, t2) {
            if (!this.cutoffUniforms) return;
            const i2 = this.cutoffUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setLightsUniformValues(e2, t2) {
            if (!this.lightsUniforms) return;
            const i2 = this.lightsUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setShadowUniformValues(e2, t2) {
            if (this.failedToCreate || !this.shadowUniforms) return;
            const i2 = this.shadowUniforms;
            e2.program.set(this.program);
            for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
          }
          _drawDebugWireframe(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2) {
            const d2 = t2.options.wireframe;
            if (false === d2.terrain && false === d2.layers2D && false === d2.layers3D) return;
            const u2 = t2.context;
            if (!(() => !(!d2.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!d2.layers2D || t2._terrain && t2._terrain.renderingToTexture || !lr.includes(this.name)) || !(!d2.layers3D || !cr.includes(this.name)))()) return;
            const _2 = u2.gl, p2 = t2.wireframeDebugCache.getLinesFromTrianglesBuffer(t2.frameCounter, r2, u2);
            if (!p2) return;
            const f2 = [...this.fixedDefines, "DEBUG_WIREFRAME"], m2 = t2.getOrCreateProgram(this.name, { config: this.configuration, defines: f2 });
            u2.program.set(m2.program);
            const g2 = (e2, t3, i3) => {
              if (t3[e2] && i3[e2]) for (const o3 in t3[e2]) i3[e2][o3] && i3[e2][o3].set(i3.program, o3, t3[e2][o3].current);
            };
            c2 && c2.setUniforms(m2.program, u2, m2.binderUniforms, a2, { zoom: l2 }), g2("fixedUniforms", this, m2), g2("terrainUniforms", this, m2), g2("globeUniforms", this, m2), g2("fogUniforms", this, m2), g2("lightsUniforms", this, m2), g2("shadowUniforms", this, m2), p2.bind(), u2.setColorMode(new Wi([_2.ONE, _2.ONE_MINUS_SRC_ALPHA, _2.ZERO, _2.ONE], e.ao.transparent, [true, true, true, false])), u2.setDepthMode(new $i(i2.func === _2.LESS ? _2.LEQUAL : i2.func, $i.ReadOnly, i2.range)), u2.setStencilMode(Yi.disabled);
            const v2 = 3 * n2.primitiveLength * 2, y2 = 3 * n2.primitiveOffset * 2 * 2;
            if (this.forceManualRenderingForInstanceIDShaders) {
              const e2 = h2 || 1;
              for (let t3 = 0; t3 < e2; ++t3) m2.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t3), _2.drawElements(_2.LINES, v2, _2.UNSIGNED_SHORT, y2);
            } else h2 && h2 > 1 ? _2.drawElementsInstanced(_2.LINES, v2, _2.UNSIGNED_SHORT, y2, h2) : _2.drawElements(_2.LINES, v2, _2.UNSIGNED_SHORT, y2);
            r2.bind(), u2.program.set(this.program), u2.setDepthMode(i2), u2.setStencilMode(o2), u2.setColorMode(s2);
          }
          checkUniforms(e2, t2, i2) {
            if (this.fixedDefines.includes(t2)) {
              for (const o2 of Object.keys(i2)) if (!i2[o2].initialized) throw new Error(`Program '${this.name}', from draw '${e2}': uniform ${o2} not set but required by ${t2} being defined`);
            }
          }
          draw(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2) {
            const m2 = e2.context, g2 = m2.gl;
            if (this.failedToCreate) return;
            m2.program.set(this.program), m2.setDepthMode(i2), m2.setStencilMode(o2), m2.setColorMode(s2), m2.setCullFace(r2);
            for (const [e3, t3] of this.fixedUniformsEntries) t3.set(this.program, e3, n2[e3]);
            _2 && _2.setUniforms(this.program, m2, this.binderUniforms, d2, { zoom: u2 });
            const v2 = { [g2.POINTS]: 1, [g2.LINES]: 2, [g2.TRIANGLES]: 3, [g2.LINE_STRIP]: 1 }[t2];
            this.checkUniforms(a2, "RENDER_SHADOWS", this.shadowUniforms);
            const y2 = p2 || [], x2 = _2 ? _2.getPaintVertexBuffers() : [], b2 = t2 === g2.TRIANGLES && c2, w2 = f2 && f2 > 0 ? 1 : void 0;
            for (const r3 of h2.get()) {
              const n3 = r3.vaos || (r3.vaos = {});
              if ((n3[a2] || (n3[a2] = new rs())).bind(m2, this, l2, x2, c2, r3.vertexOffset, y2, w2), this.forceManualRenderingForInstanceIDShaders) {
                const e3 = f2 || 1;
                for (let i3 = 0; i3 < e3; ++i3) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i3), c2 ? g2.drawElements(t2, r3.primitiveLength * v2, g2.UNSIGNED_SHORT, r3.primitiveOffset * v2 * 2) : g2.drawArrays(t2, r3.vertexOffset, r3.vertexLength);
              } else f2 && f2 > 1 ? g2.drawElementsInstanced(t2, r3.primitiveLength * v2, g2.UNSIGNED_SHORT, r3.primitiveOffset * v2 * 2, f2) : c2 ? g2.drawElements(t2, r3.primitiveLength * v2, g2.UNSIGNED_SHORT, r3.primitiveOffset * v2 * 2) : g2.drawArrays(t2, r3.vertexOffset, r3.vertexLength);
              b2 && this._drawDebugWireframe(e2, i2, o2, s2, c2, r3, d2, u2, _2, f2);
            }
          }
        }
        function dr(t2, i2, o2 = 0) {
          const s2 = Math.pow(2, i2.tileID.overscaledZ), r2 = i2.tileSize * Math.pow(2, t2.transform.tileZoom) / s2, n2 = r2 * (i2.tileID.canonical.x + i2.tileID.wrap * s2), a2 = r2 * i2.tileID.canonical.y;
          return { u_image: 0, u_texsize: i2.imageAtlasTexture ? i2.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e.ay(i2, 1, t2.transform.tileZoom), u_pixel_coord_upper: [n2 >> 16, a2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & a2], u_pattern_transition: o2 };
        }
        const ur = { terrain: 0, flat: 1 }, _r = e.bC(), pr = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2) => {
          const y2 = i2.style.light, x2 = y2.properties.get("position"), b2 = [x2.x, x2.y, x2.z], w2 = e.dO();
          "viewport" === y2.properties.get("anchor") && (e.dP(w2, -i2.transform.angle), e.dQ(b2, b2, w2));
          const T2 = y2.properties.get("color").toPremultipliedRenderColor(null), E2 = i2.transform, S2 = { u_matrix: t2, u_lightpos: b2, u_lightintensity: y2.properties.get("intensity"), u_lightcolor: [T2.r, T2.g, T2.b], u_vertical_gradient: +o2, u_opacity: s2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: _r, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: ur[h2], u_base_type: ur[d2], u_ao: r2, u_edge_radius: n2, u_width_scale: a2, u_flood_light_color: f2, u_vertical_scale: m2, u_flood_light_intensity: g2, u_ground_shadow_factor: v2 };
          return "globe" === E2.projection.name && (S2.u_tile_id = [l2.canonical.x, l2.canonical.y, 1 << l2.canonical.z], S2.u_zoom_transition = u2, S2.u_inv_rot_matrix = p2, S2.u_merc_center = _2, S2.u_up_dir = E2.projection.upVector(new e.cD(0, 0, 0), _2[0] * e.al, _2[1] * e.al), S2.u_height_lift = c2), S2;
        }, fr = (e2, t2, i2, o2, s2, r2) => ({ u_matrix: e2, u_edge_radius: t2, u_width_scale: i2, u_vertical_scale: o2, u_height_type: ur[s2], u_base_type: ur[r2] }), mr = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2) => {
          const v2 = pr(e2, t2, i2, o2, s2, r2, n2, a2, c2, h2, d2, u2, _2, p2, f2, m2, 1, [0, 0, 0]), y2 = { u_height_factor: -Math.pow(2, a2.overscaledZ) / l2.tileSize / 8 };
          return Object.assign(v2, dr(t2, l2, g2), y2);
        }, gr = (e2, t2, i2) => ({ u_matrix: e2, u_emissive_strength: t2, u_ground_shadow_factor: i2 }), vr = (e2, t2, i2, o2, s2, r2 = 0) => Object.assign(gr(e2, t2, s2), dr(i2, o2, r2)), yr = (e2, t2, i2, o2) => ({ u_matrix: e2, u_world: i2, u_emissive_strength: t2, u_ground_shadow_factor: o2 }), xr = (e2, t2, i2, o2, s2, r2, n2 = 0) => Object.assign(vr(e2, t2, i2, o2, r2, n2), { u_world: s2 }), br = (e2, t2) => ({ u_matrix: e2, u_depth_bias: t2 }), wr = (e2, t2) => ({ u_matrix: e2, u_ground_shadow_factor: t2 }), Tr = (e2, t2, i2, o2, s2) => ({ u_matrix: e2, u_camera_pos: [t2[0], t2[1], t2[2]], u_depth_bias: i2, u_height_scale: o2, u_reset_depth: s2 }), Er = (e2, t2, i2, o2, s2, r2, n2, a2, l2) => ({ u_matrix: e2, u_normal_matrix: t2, u_opacity: i2, u_faux_facade_ao_intensity: o2, u_camera_pos: s2, u_tile_to_meter: r2, u_facade_emissive_chance: n2, u_flood_light_color: a2, u_flood_light_intensity: l2 }), Sr = (e2) => ({ u_matrix: e2 }), Ir = (e2) => ({ u_matrix: e2 }), Cr = (t2, i2, o2, s2, r2, n2, a2, l2) => {
          const c2 = e.al / n2.tileSize;
          return { u_matrix: t2, u_inv_rot_matrix: i2, u_camera_to_center_distance: o2.getCameraToCenterDistance(l2), u_extrude_scale: [o2.pixelsToGLUnits[0] / c2, o2.pixelsToGLUnits[1] / c2], u_zoom_transition: s2, u_tile_id: a2, u_merc_center: r2 };
        }, Rr = (e2, t2, i2, o2) => ({ u_matrix: e2, u_inv_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(o2), u_viewport_size: [i2.width, i2.height] }), Ar = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), Lr = e.bC(), Dr = (t2, i2, o2, s2, r2, n2, a2) => {
          const l2 = t2.transform, c2 = "globe" === l2.projection.name, h2 = c2 ? e.dR(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : e.ay(o2, 1, n2), d2 = { u_matrix: i2.projMatrix, u_extrude_scale: h2, u_intensity: a2, u_inv_rot_matrix: Lr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (c2) {
            d2.u_inv_rot_matrix = s2, d2.u_merc_center = r2, d2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], d2.u_zoom_transition = e.aj(l2.zoom);
            const t3 = r2[0] * e.al, o3 = r2[1] * e.al;
            d2.u_up_dir = l2.projection.upVector(new e.cD(0, 0, 0), t3, o3);
          }
          return d2;
        };
        function Pr(e2, [t2, i2, o2, s2], [r2, n2]) {
          if (r2 === n2) return [0, 0, 0, 0];
          const a2 = 255 * (e2 - 1) / (e2 * (n2 - r2));
          return [t2 * a2, i2 * a2, o2 * a2, s2 * a2];
        }
        function Or(e2, t2, [i2, o2]) {
          return i2 === o2 ? 0 : 0.5 / e2 + (t2 - i2) * (e2 - 1) / (e2 * (o2 - i2));
        }
        const zr = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2, y2, x2, b2) => ({ u_matrix: t2, u_normalize_matrix: i2, u_globe_matrix: o2, u_merc_matrix: s2, u_grid_matrix: r2, u_tl_parent: n2, u_scale_parent: h2, u_fade_t: d2.mix, u_opacity: d2.opacity * u2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: u2.paint.get("raster-brightness-min"), u_brightness_high: u2.paint.get("raster-brightness-max"), u_saturation_factor: e.dT(u2.paint.get("raster-saturation")), u_contrast_factor: e.dS(u2.paint.get("raster-contrast")), u_spin_weights: Mr(u2.paint.get("raster-hue-rotate")), u_perspective_transform: _2, u_raster_elevation: p2, u_zoom_transition: a2, u_merc_center: l2, u_cutoff_params: c2, u_colorization_mix: Pr(e.dU, m2, v2), u_colorization_offset: Or(e.dU, g2, v2), u_color_ramp: f2, u_texture_offset: [x2 / (y2 + 2 * x2), y2 / (y2 + 2 * x2)], u_texture_res: [y2 + 2 * x2, y2 + 2 * x2], u_emissive_strength: b2 });
        function Mr(e2) {
          e2 *= Math.PI / 180;
          const t2 = Math.sin(e2), i2 = Math.cos(e2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
        }
        const Fr = 0.05, Br = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2) => ({ u_matrix: e2, u_normalize_matrix: t2, u_globe_matrix: i2, u_merc_matrix: o2, u_grid_matrix: s2, u_tl_parent: r2, u_scale_parent: c2, u_fade_t: h2.mix, u_opacity: h2.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: d2, u_zoom_transition: n2, u_merc_center: a2, u_cutoff_params: l2 }), kr = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2) => ({ u_particle_texture: e2, u_particle_texture_side_len: t2, u_tile_offset: i2, u_velocity: o2, u_color_ramp: r2, u_velocity_res: s2, u_max_speed: n2, u_uv_offset: a2, u_data_scale: [255 * l2[0], 255 * l2[1]], u_data_offset: c2, u_particle_pos_scale: 1.1, u_particle_pos_offset: [Fr, Fr] }), Nr = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2) => ({ u_particle_texture: e2, u_particle_texture_side_len: t2, u_velocity: i2, u_velocity_res: o2, u_max_speed: s2, u_speed_factor: r2, u_reset_rate: n2, u_rand_seed: Math.random(), u_uv_offset: a2, u_data_scale: [255 * l2[0], 255 * l2[1]], u_data_offset: c2, u_particle_pos_scale: 1.1, u_particle_pos_offset: [Fr, Fr] }), Ur = e.bC(), jr = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2, y2, x2, b2, w2, T2, E2) => {
          const S2 = r2.transform, I2 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: S2.getCameraToCenterDistance(y2), u_rotate_symbol: +o2, u_aspect_ratio: S2.width / S2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: a2, u_coord_matrix: l2, u_is_text: +h2, u_elevation_from_sea: c2 ? 1 : 0, u_pitch_with_map: +s2, u_texsize: d2, u_texsize_icon: u2, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Ur, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: Ur, u_up_vector: [0, -1, 0], u_color_adj_mat: w2, u_icon_transition: T2 || 0, u_gamma_scale: s2 ? r2.transform.getCameraToCenterDistance(y2) * Math.cos(r2.terrain ? 0 : r2.transform._pitch) : 1, u_device_pixel_ratio: e.o.devicePixelRatio, u_is_halo: 1, u_scale_factor: E2 || 1, u_ground_shadow_factor: x2, u_inv_matrix: e.bl(e.bC(), a2), u_normal_scale: b2, u_lutTexture: 10 };
          return "globe" === y2.name && (I2.u_tile_id = [p2.canonical.x, p2.canonical.y, 1 << p2.canonical.z], I2.u_zoom_transition = f2, I2.u_inv_rot_matrix = g2, I2.u_merc_center = m2, I2.u_camera_forward = S2._camera.forward(), I2.u_ecef_origin = e.dV(S2.globeMatrix, p2.toUnwrapped()), I2.u_tile_matrix = Float32Array.from(S2.globeMatrix), I2.u_up_vector = v2), I2;
        }, Vr = (e2, t2, i2, o2) => ({ u_matrix: e2, u_emissive_strength: t2, u_opacity: i2, u_color: o2 }), Gr = (t2, i2, o2, s2, r2, n2, a2, l2, c2) => Object.assign(function(t3, i3, o3, s3, r3, n3) {
          const { width: a3, height: l3 } = s3.imageManager.getPixelSize(i3), c3 = Math.pow(2, n3.tileID.overscaledZ), h2 = n3.tileSize * Math.pow(2, s3.transform.tileZoom) / c3, d2 = h2 * (n3.tileID.canonical.x + n3.tileID.wrap * c3), u2 = h2 * n3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [a3, l3], u_pattern_size: o3.displaySize, u_pattern_units_to_pixels: r3 ? [s3.transform.width, -1 * s3.transform.height] : [1 / e.ay(n3, 1, s3.transform.tileZoom), 1 / e.ay(n3, 1, s3.transform.tileZoom)], u_pixel_coord_upper: [d2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & d2, 65535 & u2] };
        }(0, n2, a2, s2, l2, c2), { u_matrix: t2, u_emissive_strength: i2, u_opacity: o2 }), Hr = new Float32Array(e.bA([])), qr = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2 = [0, 0, 0], f2, m2, g2) => {
          const v2 = r2.style.light, y2 = v2.properties.get("position"), x2 = [-y2.x, -y2.y, y2.z], b2 = e.dO();
          "viewport" === v2.properties.get("anchor") && (e.dP(b2, -r2.transform.angle), e.dQ(x2, x2, b2));
          const w2 = "MASK" === d2.alphaMode, T2 = v2.properties.get("color").toNonPremultipliedRenderColor(null), E2 = _2.paint.get("model-ambient-occlusion-intensity"), S2 = _2.paint.get("model-color").constantOr(e.ao.white).toNonPremultipliedRenderColor(null);
          return S2.a = _2.paint.get("model-color-mix-intensity").constantOr(0), g2 && (S2.r = g2[0], S2.g = g2[1], S2.b = g2[2], S2.a = g2[3]), m2 && (S2.r = m2.color.r, S2.g = m2.color.g, S2.b = m2.color.b, S2.a = m2.colorMix, u2 = m2.emissionStrength, n2 *= m2.opacity), { u_matrix: t2, u_lighting_matrix: i2, u_normal_matrix: o2, u_node_matrix: s2 || Hr, u_lightpos: x2, u_lightintensity: v2.properties.get("intensity"), u_lightcolor: [T2.r, T2.g, T2.b], u_camera_pos: p2, u_opacity: n2, u_baseTextureIsAlpha: 0, u_alphaMask: +w2, u_alphaCutoff: d2.alphaCutoff, u_baseColorFactor: a2.toNonPremultipliedRenderColor(null).toArray01(), u_emissiveFactor: l2.toNonPremultipliedRenderColor(null).toArray01(), u_metallicFactor: c2, u_roughnessFactor: h2, u_baseColorTexture: 5, u_metallicRoughnessTexture: 6, u_normalTexture: 7, u_occlusionTexture: 8, u_emissionTexture: 9, u_lutTexture: 10, u_color_mix: S2.toArray01(), u_aoIntensity: E2, u_emissive_strength: u2, u_occlusionTextureTransform: f2 || [0, 0, 0, 0] };
        }, Zr = (e2, t2 = Hr, i2 = Hr) => ({ u_matrix: e2, u_instance: t2, u_node_matrix: i2 }), Wr = { fillExtrusion: (t2) => ({ u_matrix: new e.cl(t2), u_lightpos: new e.ci(t2), u_lightintensity: new e.cj(t2), u_lightcolor: new e.ci(t2), u_vertical_gradient: new e.cj(t2), u_opacity: new e.cj(t2), u_edge_radius: new e.cj(t2), u_width_scale: new e.cj(t2), u_ao: new e.ck(t2), u_height_type: new e.ch(t2), u_base_type: new e.ch(t2), u_tile_id: new e.ci(t2), u_zoom_transition: new e.cj(t2), u_inv_rot_matrix: new e.cl(t2), u_merc_center: new e.ck(t2), u_up_dir: new e.ci(t2), u_height_lift: new e.cj(t2), u_flood_light_color: new e.ci(t2), u_vertical_scale: new e.cj(t2), u_flood_light_intensity: new e.cj(t2), u_ground_shadow_factor: new e.ci(t2) }), fillExtrusionDepth: (t2) => ({ u_matrix: new e.cl(t2), u_edge_radius: new e.cj(t2), u_width_scale: new e.cj(t2), u_vertical_scale: new e.cj(t2), u_height_type: new e.ch(t2), u_base_type: new e.ch(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.cl(t2), u_lightpos: new e.ci(t2), u_lightintensity: new e.cj(t2), u_lightcolor: new e.ci(t2), u_vertical_gradient: new e.cj(t2), u_height_factor: new e.cj(t2), u_edge_radius: new e.cj(t2), u_width_scale: new e.cj(t2), u_ao: new e.ck(t2), u_height_type: new e.ch(t2), u_base_type: new e.ch(t2), u_tile_id: new e.ci(t2), u_zoom_transition: new e.cj(t2), u_inv_rot_matrix: new e.cl(t2), u_merc_center: new e.ck(t2), u_up_dir: new e.ci(t2), u_height_lift: new e.cj(t2), u_image: new e.ch(t2), u_texsize: new e.ck(t2), u_pixel_coord_upper: new e.ck(t2), u_pixel_coord_lower: new e.ck(t2), u_tile_units_to_pixels: new e.cj(t2), u_opacity: new e.cj(t2), u_pattern_transition: new e.cj(t2) }), fillExtrusionGroundEffect: (t2) => ({ u_matrix: new e.cl(t2), u_opacity: new e.cj(t2), u_ao_pass: new e.cj(t2), u_meter_to_tile: new e.cj(t2), u_ao: new e.ck(t2), u_flood_light_intensity: new e.cj(t2), u_flood_light_color: new e.ci(t2), u_attenuation: new e.cj(t2), u_edge_radius: new e.cj(t2), u_fb: new e.ch(t2), u_fb_size: new e.cj(t2), u_dynamic_offset: new e.cj(t2) }), fill: (t2) => ({ u_matrix: new e.cl(t2), u_emissive_strength: new e.cj(t2), u_ground_shadow_factor: new e.ci(t2) }), fillPattern: (t2) => ({ u_matrix: new e.cl(t2), u_emissive_strength: new e.cj(t2), u_image: new e.ch(t2), u_texsize: new e.ck(t2), u_pixel_coord_upper: new e.ck(t2), u_pixel_coord_lower: new e.ck(t2), u_tile_units_to_pixels: new e.cj(t2), u_ground_shadow_factor: new e.ci(t2), u_pattern_transition: new e.cj(t2) }), fillOutline: (t2) => ({ u_matrix: new e.cl(t2), u_emissive_strength: new e.cj(t2), u_world: new e.ck(t2), u_ground_shadow_factor: new e.ci(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.cl(t2), u_emissive_strength: new e.cj(t2), u_world: new e.ck(t2), u_image: new e.ch(t2), u_texsize: new e.ck(t2), u_pixel_coord_upper: new e.ck(t2), u_pixel_coord_lower: new e.ck(t2), u_tile_units_to_pixels: new e.cj(t2), u_ground_shadow_factor: new e.ci(t2), u_pattern_transition: new e.cj(t2) }), building: (t2) => ({ u_matrix: new e.cl(t2), u_normal_matrix: new e.cl(t2), u_opacity: new e.cj(t2), u_faux_facade_ao_intensity: new e.cj(t2), u_camera_pos: new e.ci(t2), u_tile_to_meter: new e.cj(t2), u_facade_emissive_chance: new e.cj(t2), u_flood_light_color: new e.ci(t2), u_flood_light_intensity: new e.cj(t2) }), buildingBloom: (t2) => ({ u_matrix: new e.cl(t2) }), buildingDepth: (t2) => ({ u_matrix: new e.cl(t2) }), elevatedStructuresDepth: (t2) => ({ u_matrix: new e.cl(t2), u_depth_bias: new e.cj(t2) }), elevatedStructures: (t2) => ({ u_matrix: new e.cl(t2), u_ground_shadow_factor: new e.ci(t2) }), elevatedStructuresDepthReconstruct: (t2) => ({ u_matrix: new e.cl(t2), u_camera_pos: new e.ci(t2), u_depth_bias: new e.cj(t2), u_height_scale: new e.cj(t2), u_reset_depth: new e.cj(t2) }), circle: e.dY, collisionBox: (t2) => ({ u_matrix: new e.cl(t2), u_inv_rot_matrix: new e.cl(t2), u_camera_to_center_distance: new e.cj(t2), u_extrude_scale: new e.ck(t2), u_zoom_transition: new e.cj(t2), u_merc_center: new e.ck(t2), u_tile_id: new e.ci(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.cl(t2), u_inv_matrix: new e.cl(t2), u_camera_to_center_distance: new e.cj(t2), u_viewport_size: new e.ck(t2) }), debug: (t2) => ({ u_color: new e.dB(t2), u_matrix: new e.cl(t2), u_overlay: new e.ch(t2), u_overlay_scale: new e.cj(t2) }), clippingMask: (t2) => ({ u_matrix: new e.cl(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.cj(t2), u_intensity: new e.cj(t2), u_matrix: new e.cl(t2), u_inv_rot_matrix: new e.cl(t2), u_merc_center: new e.ck(t2), u_tile_id: new e.ci(t2), u_zoom_transition: new e.cj(t2), u_up_dir: new e.ci(t2) }), heatmapTexture: (t2) => ({ u_image: new e.ch(t2), u_color_ramp: new e.ch(t2), u_opacity: new e.cj(t2) }), hillshade: (t2) => ({ u_matrix: new e.cl(t2), u_image: new e.ch(t2), u_latrange: new e.ck(t2), u_light: new e.ck(t2), u_shadow: new e.dB(t2), u_highlight: new e.dB(t2), u_emissive_strength: new e.cj(t2), u_accent: new e.dB(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.cl(t2), u_image: new e.ch(t2), u_dimension: new e.ck(t2), u_zoom: new e.cj(t2) }), line: e.dX, linePattern: e.dW, raster: (t2) => ({ u_matrix: new e.cl(t2), u_normalize_matrix: new e.cl(t2), u_globe_matrix: new e.cl(t2), u_merc_matrix: new e.cl(t2), u_grid_matrix: new e.dC(t2), u_tl_parent: new e.ck(t2), u_scale_parent: new e.cj(t2), u_fade_t: new e.cj(t2), u_opacity: new e.cj(t2), u_image0: new e.ch(t2), u_image1: new e.ch(t2), u_brightness_low: new e.cj(t2), u_brightness_high: new e.cj(t2), u_saturation_factor: new e.cj(t2), u_contrast_factor: new e.cj(t2), u_spin_weights: new e.ci(t2), u_perspective_transform: new e.ck(t2), u_raster_elevation: new e.cj(t2), u_zoom_transition: new e.cj(t2), u_merc_center: new e.ck(t2), u_cutoff_params: new e.d3(t2), u_colorization_mix: new e.d3(t2), u_colorization_offset: new e.cj(t2), u_color_ramp: new e.ch(t2), u_texture_offset: new e.ck(t2), u_texture_res: new e.ck(t2), u_emissive_strength: new e.cj(t2) }), rasterParticle: (t2) => ({ u_matrix: new e.cl(t2), u_normalize_matrix: new e.cl(t2), u_globe_matrix: new e.cl(t2), u_merc_matrix: new e.cl(t2), u_grid_matrix: new e.dC(t2), u_tl_parent: new e.ck(t2), u_scale_parent: new e.cj(t2), u_fade_t: new e.cj(t2), u_opacity: new e.cj(t2), u_image0: new e.ch(t2), u_image1: new e.ch(t2), u_raster_elevation: new e.cj(t2), u_zoom_transition: new e.cj(t2), u_merc_center: new e.ck(t2), u_cutoff_params: new e.d3(t2) }), rasterParticleTexture: (t2) => ({ u_texture: new e.ch(t2), u_opacity: new e.cj(t2) }), rasterParticleDraw: (t2) => ({ u_particle_texture: new e.ch(t2), u_particle_texture_side_len: new e.cj(t2), u_tile_offset: new e.ck(t2), u_velocity: new e.ch(t2), u_color_ramp: new e.ch(t2), u_velocity_res: new e.ck(t2), u_max_speed: new e.cj(t2), u_uv_offset: new e.ck(t2), u_data_scale: new e.ck(t2), u_data_offset: new e.cj(t2), u_particle_pos_scale: new e.cj(t2), u_particle_pos_offset: new e.ck(t2) }), rasterParticleUpdate: (t2) => ({ u_particle_texture: new e.ch(t2), u_particle_texture_side_len: new e.cj(t2), u_velocity: new e.ch(t2), u_velocity_res: new e.ck(t2), u_max_speed: new e.cj(t2), u_speed_factor: new e.cj(t2), u_reset_rate: new e.cj(t2), u_rand_seed: new e.cj(t2), u_uv_offset: new e.ck(t2), u_data_scale: new e.ck(t2), u_data_offset: new e.cj(t2), u_particle_pos_scale: new e.cj(t2), u_particle_pos_offset: new e.ck(t2) }), symbol: (t2) => ({ u_is_size_zoom_constant: new e.ch(t2), u_is_size_feature_constant: new e.ch(t2), u_size_t: new e.cj(t2), u_size: new e.cj(t2), u_camera_to_center_distance: new e.cj(t2), u_rotate_symbol: new e.ch(t2), u_aspect_ratio: new e.cj(t2), u_fade_change: new e.cj(t2), u_matrix: new e.cl(t2), u_label_plane_matrix: new e.cl(t2), u_coord_matrix: new e.cl(t2), u_is_text: new e.ch(t2), u_elevation_from_sea: new e.ch(t2), u_pitch_with_map: new e.ch(t2), u_texsize: new e.ck(t2), u_texsize_icon: new e.ck(t2), u_texture: new e.ch(t2), u_texture_icon: new e.ch(t2), u_gamma_scale: new e.cj(t2), u_device_pixel_ratio: new e.cj(t2), u_tile_id: new e.ci(t2), u_zoom_transition: new e.cj(t2), u_inv_rot_matrix: new e.cl(t2), u_merc_center: new e.ck(t2), u_camera_forward: new e.ci(t2), u_tile_matrix: new e.cl(t2), u_up_vector: new e.ci(t2), u_ecef_origin: new e.ci(t2), u_is_halo: new e.ch(t2), u_icon_transition: new e.cj(t2), u_color_adj_mat: new e.cl(t2), u_scale_factor: new e.cj(t2), u_ground_shadow_factor: new e.ci(t2), u_inv_matrix: new e.cl(t2), u_normal_scale: new e.cj(t2), u_lutTexture: new e.ch(t2) }), background: (t2) => ({ u_matrix: new e.cl(t2), u_emissive_strength: new e.cj(t2), u_opacity: new e.cj(t2), u_color: new e.dB(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.cl(t2), u_emissive_strength: new e.cj(t2), u_opacity: new e.cj(t2), u_image: new e.ch(t2), u_pattern_tl: new e.ck(t2), u_pattern_br: new e.ck(t2), u_texsize: new e.ck(t2), u_pattern_size: new e.ck(t2), u_pixel_coord_upper: new e.ck(t2), u_pixel_coord_lower: new e.ck(t2), u_pattern_units_to_pixels: new e.ck(t2) }), terrainRaster: (t2) => ({ u_matrix: new e.cl(t2), u_image0: new e.ch(t2), u_image1: new e.ch(t2), u_skirt_height: new e.cj(t2), u_ground_shadow_factor: new e.ci(t2), u_emissive_texture_available: new e.cj(t2) }), skybox: (t2) => ({ u_matrix: new e.cl(t2), u_sun_direction: new e.ci(t2), u_cubemap: new e.ch(t2), u_opacity: new e.cj(t2), u_temporal_offset: new e.cj(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.cl(t2), u_color_ramp: new e.ch(t2), u_center_direction: new e.ci(t2), u_radius: new e.cj(t2), u_opacity: new e.cj(t2), u_temporal_offset: new e.cj(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.dC(t2), u_sun_direction: new e.ci(t2), u_sun_intensity: new e.cj(t2), u_color_tint_r: new e.d3(t2), u_color_tint_m: new e.d3(t2), u_luminance: new e.cj(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.cl(t2), u_globe_matrix: new e.cl(t2), u_normalize_matrix: new e.cl(t2), u_merc_matrix: new e.cl(t2), u_zoom_transition: new e.cj(t2), u_merc_center: new e.ck(t2), u_image0: new e.ch(t2), u_image1: new e.ch(t2), u_grid_matrix: new e.dC(t2), u_skirt_height: new e.cj(t2), u_far_z_cutoff: new e.cj(t2), u_frustum_tl: new e.ci(t2), u_frustum_tr: new e.ci(t2), u_frustum_br: new e.ci(t2), u_frustum_bl: new e.ci(t2), u_globe_pos: new e.ci(t2), u_globe_radius: new e.cj(t2), u_viewport: new e.ck(t2), u_emissive_texture_available: new e.cj(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.ci(t2), u_frustum_tr: new e.ci(t2), u_frustum_br: new e.ci(t2), u_frustum_bl: new e.ci(t2), u_horizon: new e.cj(t2), u_transition: new e.cj(t2), u_fadeout_range: new e.cj(t2), u_atmosphere_fog_color: new e.d3(t2), u_high_color: new e.d3(t2), u_space_color: new e.d3(t2), u_temporal_offset: new e.cj(t2), u_horizon_angle: new e.cj(t2) }), model: (t2) => ({ u_matrix: new e.cl(t2), u_lighting_matrix: new e.cl(t2), u_normal_matrix: new e.cl(t2), u_node_matrix: new e.cl(t2), u_lightpos: new e.ci(t2), u_lightintensity: new e.cj(t2), u_lightcolor: new e.ci(t2), u_camera_pos: new e.ci(t2), u_opacity: new e.cj(t2), u_baseColorFactor: new e.d3(t2), u_emissiveFactor: new e.d3(t2), u_metallicFactor: new e.cj(t2), u_roughnessFactor: new e.cj(t2), u_baseTextureIsAlpha: new e.ch(t2), u_alphaMask: new e.ch(t2), u_alphaCutoff: new e.cj(t2), u_baseColorTexture: new e.ch(t2), u_metallicRoughnessTexture: new e.ch(t2), u_normalTexture: new e.ch(t2), u_occlusionTexture: new e.ch(t2), u_emissionTexture: new e.ch(t2), u_lutTexture: new e.ch(t2), u_color_mix: new e.d3(t2), u_aoIntensity: new e.cj(t2), u_emissive_strength: new e.cj(t2), u_occlusionTextureTransform: new e.d3(t2) }), modelDepth: (t2) => ({ u_matrix: new e.cl(t2), u_instance: new e.cl(t2), u_node_matrix: new e.cl(t2) }), groundShadow: (t2) => ({ u_matrix: new e.cl(t2), u_ground_shadow_factor: new e.ci(t2) }), stars: (t2) => ({ u_matrix: new e.cl(t2), u_up: new e.ci(t2), u_right: new e.ci(t2), u_intensity_multiplier: new e.cj(t2) }), snowParticle: (t2) => ({ u_modelview: new e.cl(t2), u_projection: new e.cl(t2), u_time: new e.cj(t2), u_cam_pos: new e.ci(t2), u_velocityConeAperture: new e.cj(t2), u_velocity: new e.cj(t2), u_horizontalOscillationRadius: new e.cj(t2), u_horizontalOscillationRate: new e.cj(t2), u_boxSize: new e.cj(t2), u_billboardSize: new e.cj(t2), u_simpleShapeParameters: new e.ck(t2), u_screenSize: new e.ck(t2), u_thinningCenterPos: new e.ck(t2), u_thinningShape: new e.ci(t2), u_thinningAffectedRatio: new e.cj(t2), u_thinningParticleOffset: new e.cj(t2), u_particleColor: new e.d3(t2), u_direction: new e.ci(t2) }), rainParticle: (t2) => ({ u_modelview: new e.cl(t2), u_projection: new e.cl(t2), u_time: new e.cj(t2), u_cam_pos: new e.ci(t2), u_texScreen: new e.ch(t2), u_velocityConeAperture: new e.cj(t2), u_velocity: new e.cj(t2), u_boxSize: new e.cj(t2), u_rainDropletSize: new e.ck(t2), u_distortionStrength: new e.cj(t2), u_rainDirection: new e.ci(t2), u_color: new e.d3(t2), u_screenSize: new e.ck(t2), u_thinningCenterPos: new e.ck(t2), u_thinningShape: new e.ci(t2), u_thinningAffectedRatio: new e.cj(t2), u_thinningParticleOffset: new e.cj(t2), u_shapeDirectionalPower: new e.cj(t2), u_shapeNormalPower: new e.cj(t2), u_mode: new e.cj(t2) }), vignette: (t2) => ({ u_vignetteShape: new e.ci(t2), u_vignetteColor: new e.d3(t2) }), occlusion: (t2) => ({ u_matrix: new e.cl(t2), u_anchorPos: new e.ci(t2), u_screenSizePx: new e.ck(t2), u_occluderSizePx: new e.ck(t2), u_color: new e.d3(t2) }) };
        class $r {
          constructor(e2, t2, i2, o2) {
            this.id = $r.uniqueIdxCounter, $r.uniqueIdxCounter++, this.context = e2;
            const s2 = e2.gl;
            this.buffer = s2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || o2 || t2.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e2) {
            this.id = $r.uniqueIdxCounter, $r.uniqueIdxCounter++;
            const t2 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        $r.uniqueIdxCounter = 0;
        const Xr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Yr {
          constructor(e2, t2, i2, o2, s2, r2) {
            this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.instanceCount = r2, this.context = e2;
            const n2 = e2.gl;
            this.buffer = n2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), n2.bufferData(n2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? n2.DYNAMIC_DRAW : n2.STATIC_DRAW), this.dynamicDraw || s2 || t2.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e2) {
            const t2 = this.context.gl;
            this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          enableAttributes(e2, t2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const o2 = t2.getAttributeLocation(e2, this.attributes[i2].name);
              -1 !== o2 && e2.enableVertexAttribArray(o2);
            }
          }
          setVertexAttribPointers(e2, t2, i2) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              const s2 = this.attributes[o2], r2 = t2.getAttributeLocation(e2, s2.name);
              -1 !== r2 && e2.vertexAttribPointer(r2, s2.components, e2[Xr[s2.type]], false, this.itemSize, s2.offset + this.itemSize * (i2 || 0));
            }
          }
          setVertexAttribDivisor(e2, t2, i2) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              const s2 = t2.getAttributeLocation(e2, this.attributes[o2].name);
              -1 !== s2 && this.instanceCount && this.instanceCount > 0 && e2.vertexAttribDivisor(s2, i2);
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Kr {
          constructor(e2, t2, i2, o2, s2) {
            this.context = e2, this.width = t2, this.height = i2;
            const r2 = this.framebuffer = e2.gl.createFramebuffer();
            o2 > 0 && (this.colorAttachment0 = new Gs(e2, r2, 0)), o2 > 1 && (this.colorAttachment1 = new Gs(e2, r2, 1)), s2 && (this.depthAttachmentType = s2, this.depthAttachment = "renderbuffer" === s2 ? new Hs(e2, r2) : new qs(e2, r2));
          }
          createColorAttachment(e2, t2) {
            0 === t2 ? this.colorAttachment0 = new Gs(e2, this.framebuffer, 0) : 1 === t2 && (this.colorAttachment1 = new Gs(e2, this.framebuffer, 1));
          }
          removeColorAttachment(e2, t2) {
            const i2 = this.context.gl;
            let o2;
            0 === t2 ? (o2 = this.colorAttachment0.get(), this.colorAttachment0 = void 0) : 1 === t2 && (o2 = this.colorAttachment1.get(), this.colorAttachment1 = void 0), o2 && i2.deleteTexture(o2);
          }
          destroy() {
            const e2 = this.context.gl;
            if (this.colorAttachment0) {
              const t2 = this.colorAttachment0.get();
              t2 && e2.deleteTexture(t2);
            }
            if (this.colorAttachment1) {
              const t2 = this.colorAttachment1.get();
              t2 && e2.deleteTexture(t2);
            }
            if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
              const t2 = this.depthAttachment.get();
              t2 && e2.deleteRenderbuffer(t2);
            } else {
              const t2 = this.depthAttachment.get();
              t2 && e2.deleteTexture(t2);
            }
            e2.deleteFramebuffer(this.framebuffer);
          }
        }
        class Jr {
          constructor(e2, t2) {
            this.gl = e2, this.clearColor = new ds(this), this.clearDepth = new us(this), this.clearStencil = new _s(this), this.colorMask = new ps(this), this.depthMask = new fs(this), this.stencilMask = new ms(this), this.stencilFunc = new gs(this), this.stencilOp = new vs(this), this.stencilTest = new ys(this), this.depthRange = new xs(this), this.depthTest = new bs(this), this.depthFunc = new ws(this), this.blend = new Ts(this), this.blendFunc = new Es(this), this.blendColor = new Ss(this), this.blendEquation = new Is(this), this.cullFace = new Cs(this), this.cullFaceSide = new Rs(this), this.frontFace = new As(this), this.program = new Ls(this), this.activeTexture = new Ds(this), this.viewport = new Ps(this), this.bindFramebuffer = new Os(this), this.bindRenderbuffer = new zs(this), this.bindTexture = new Ms(this), this.bindVertexBuffer = new Fs(this), this.bindElementBuffer = new Bs(this), this.bindVertexArrayOES = new ks(this), this.pixelStoreUnpack = new Ns(this), this.pixelStoreUnpackPremultiplyAlpha = new Us(this), this.pixelStoreUnpackFlipY = new js(this), this.options = t2 ? Object.assign({}, t2) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t2 && !!t2.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e2.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.extBlendFuncExtended = e2.getExtension("WEBGL_blend_func_extended");
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e2, t2, i2) {
            return new $r(this, e2, t2, i2);
          }
          createVertexBuffer(e2, t2, i2, o2, s2) {
            return new Yr(this, e2, t2, i2, o2, s2);
          }
          createRenderbuffer(e2, t2, i2) {
            const o2 = this.gl, s2 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(s2), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), s2;
          }
          createFramebuffer(e2, t2, i2, o2) {
            return new Kr(this, e2, t2, i2, o2);
          }
          clear({ color: e2, depth: t2, stencil: i2, colorMask: o2 }) {
            const s2 = this.gl;
            let r2 = 0;
            e2 && (r2 |= s2.COLOR_BUFFER_BIT, this.clearColor.set(e2.toNonPremultipliedRenderColor(null)), this.colorMask.set(o2 || [true, true, true, true])), void 0 !== t2 && (r2 |= s2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= s2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), s2.clear(r2);
          }
          setCullFace(e2) {
            false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
          }
          setDepthMode(e2) {
            e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
          }
          setStencilMode(e2) {
            e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t2) {
            e.by(t2.blendFunction, Wi.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor), t2.blendEquation ? this.blendEquation.set(t2.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t2.mask);
          }
          unbindVAO() {
            this.bindVertexArrayOES.set(null);
          }
        }
        let Qr;
        function en(t2, i2, o2, s2, r2, n2, a2) {
          const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, d2 = [e.aF(h2.center.lng), e.aJ(h2.center.lat)], u2 = o2.layout.get("symbol-placement"), _2 = o2.layout.get("text-variable-anchor"), p2 = "map" === o2.layout.get("icon-rotation-alignment"), f2 = "map" === o2.layout.get("text-rotation-alignment"), m2 = "point" !== u2, g2 = [];
          let v2 = 0, y2 = 0;
          for (let l3 = 0; l3 < s2.length; l3++) {
            const u3 = s2[l3], x3 = i2.getTile(u3), b3 = x3.getBucket(o2);
            if (!b3) continue;
            const w3 = b3.getProjection().createInversionMatrix(h2, u3.canonical), T3 = [], E3 = Jt(u3, b3, h2), S2 = !a2 && p2 && m2, I2 = a2 && f2 && m2, C2 = _2 && b3.hasTextData(), R2 = b3.hasIconTextFit() && C2 && b3.hasIconData(), A2 = S2 || I2 || a2 && C2 || R2, L2 = "globe" === b3.projection.name, D2 = L2 ? e.aj(h2.zoom) : 0;
            L2 && (T3.push("PROJECTION_GLOBE_VIEW"), A2 && T3.push("PROJECTED_POS_ON_VIEWPORT"));
            const P2 = t2.getOrCreateProgram("collisionBox", { defines: T3 });
            let O2 = E3;
            0 === r2[0] && 0 === r2[1] || (O2 = t2.translatePosMatrix(E3, x3, r2, n2));
            const z2 = a2 ? b3.textCollisionBox : b3.iconCollisionBox, M2 = b3.collisionCircleArray;
            if (M2.length > 0) {
              const t3 = e.bC(), i3 = O2;
              e.cP(t3, b3.placementInvProjMatrix, h2.glCoordMatrix), e.cP(t3, t3, b3.placementViewportMatrix), g2.push({ circleArray: M2, circleOffset: y2, transform: i3, invTransform: t3, projection: b3.getProjection() }), v2 += M2.length / 4, y2 = v2;
            }
            if (!z2) continue;
            t2.terrain && t2.terrain.setupElevationDraw(x3, P2);
            const F2 = L2 ? [u3.canonical.x, u3.canonical.y, 1 << u3.canonical.z] : [0, 0, 0];
            P2.draw(t2, c2.LINES, $i.disabled, Yi.disabled, t2.colorModeForRenderPass(), Qi.disabled, Cr(O2, w3, h2, D2, d2, x3, F2, b3.getProjection()), o2.id, z2.layoutVertexBuffer, z2.indexBuffer, z2.segments, null, h2.zoom, null, [z2.collisionVertexBuffer, z2.collisionVertexBufferExt]);
          }
          if (!a2 || !g2.length) return;
          const x2 = t2.getOrCreateProgram("collisionCircle"), b2 = new e.dZ();
          b2.resize(4 * v2), b2._trim();
          let w2 = 0;
          for (const e2 of g2) for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], s3 = e2.circleArray[i3 + 1], r3 = e2.circleArray[i3 + 2], n3 = e2.circleArray[i3 + 3];
            b2.emplace(w2++, o3, s3, r3, n3, 0), b2.emplace(w2++, o3, s3, r3, n3, 1), b2.emplace(w2++, o3, s3, r3, n3, 2), b2.emplace(w2++, o3, s3, r3, n3, 3);
          }
          (!Qr || Qr.length < 2 * v2) && (Qr = function(t3) {
            const i3 = 2 * t3, o3 = new e.b0();
            o3.resize(i3), o3._trim();
            for (let e2 = 0; e2 < i3; e2++) {
              const t4 = 6 * e2;
              o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
            }
            return o3;
          }(v2));
          const T2 = l2.createIndexBuffer(Qr, true), E2 = l2.createVertexBuffer(b2, e.d_.members, true);
          for (const i3 of g2) {
            const s3 = Rr(i3.transform, i3.invTransform, h2, i3.projection);
            x2.draw(t2, c2.TRIANGLES, $i.disabled, Yi.disabled, t2.colorModeForRenderPass(), Qi.disabled, s3, o2.id, E2, T2, e.bg.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h2.zoom);
          }
          E2.destroy(), T2.destroy();
        }
        const tn = e.bC();
        function on(t2) {
          const i2 = t2._camera.getWorldToCamera(t2.worldSize, 1), o2 = e.aB([], i2, t2.globeMatrix);
          e.bl(o2, o2);
          const s2 = [0, 0, 0], r2 = [0, 1, 0, 0];
          return e.aC(r2, r2, o2), s2[0] = r2[0], s2[1] = r2[1], s2[2] = r2[2], e.aw(s2, s2), s2;
        }
        function sn({ width: t2, height: i2, anchor: o2, textOffset: s2, textScale: r2 }, n2) {
          const { horizontalAlign: a2, verticalAlign: l2 } = e.c1(o2), c2 = -(a2 - 0.5) * t2, h2 = -(l2 - 0.5) * i2, d2 = e.c2(o2, s2);
          return new e.P((c2 / r2 + d2[0]) * n2, (h2 / r2 + d2[1]) * n2);
        }
        function rn(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2) {
          const d2 = t2.text.placedSymbolArray, u2 = t2.text.dynamicLayoutVertexArray, _2 = t2.icon.dynamicLayoutVertexArray, p2 = {}, f2 = t2.getProjection(), m2 = Qt(a2, f2, r2), g2 = r2.elevation, v2 = f2.upVectorScale(a2.canonical, r2.center.lat, r2.worldSize).metersToTile;
          u2.clear();
          for (let _3 = 0; _3 < d2.length; _3++) {
            const y2 = d2.get(_3), { tileAnchorX: x2, tileAnchorY: b2, numGlyphs: w2 } = y2, T2 = y2.hidden || !y2.crossTileID || t2.allowVerticalPlacement && !y2.placedOrientation ? null : s2[y2.crossTileID];
            if (T2) {
              let s3 = 0, d3 = 0, E2 = 0;
              const S2 = "road" === t2.elevationType;
              if (g2 || S2) {
                const i3 = S2 ? t2.getElevationFeatureForText(_3) : null, o3 = e.bV.getAtTileOffset(a2, new e.P(x2, b2), g2, i3), [r3, n3, l3] = f2.upVector(a2.canonical, x2, b2);
                s3 = o3 * r3 * v2, d3 = o3 * n3 * v2, E2 = o3 * l3 * v2;
              }
              let [I2, C2, R2, A2] = ni(y2.projectedAnchorX + s3, y2.projectedAnchorY + d3, y2.projectedAnchorZ + E2, o2 ? m2 : n2);
              const L2 = ai(r2.getCameraToCenterDistance(f2), A2);
              let D2 = e.bM(t2.textSizeData, c2, y2) * L2 / e.bY;
              o2 && (D2 *= t2.tilePixelRatio / l2);
              const P2 = sn(T2, D2);
              o2 ? ({ x: I2, y: C2, z: R2 } = f2.projectTilePoint(x2 + P2.x, b2 + P2.y, a2.canonical), [I2, C2, R2] = ni(I2 + s3, C2 + d3, R2 + E2, n2)) : (i2 && P2._rotate(-r2.angle), I2 += P2.x, C2 += P2.y, R2 = 0);
              const O2 = t2.allowVerticalPlacement && y2.placedOrientation === e.bL.vertical ? Math.PI / 2 : 0;
              for (let t3 = 0; t3 < w2; t3++) e.bO(u2, I2, C2, R2, O2);
              h2 && y2.associatedIconIndex >= 0 && (p2[y2.associatedIconIndex] = { x: I2, y: C2, z: R2, angle: O2 });
            } else mi(w2, u2);
          }
          if (h2) {
            _2.clear();
            const i3 = t2.icon.placedSymbolArray;
            for (let t3 = 0; t3 < i3.length; t3++) {
              const o3 = i3.get(t3), { numGlyphs: s3 } = o3, r3 = p2[t3];
              if (o3.hidden || !r3) mi(s3, _2);
              else {
                const { x: t4, y: i4, z: o4, angle: n3 } = r3;
                for (let r4 = 0; r4 < s3; r4++) e.bO(_2, t4, i4, o4, n3);
              }
            }
            t2.icon.dynamicLayoutVertexBuffer.updateData(_2);
          }
          t2.text.dynamicLayoutVertexBuffer.updateData(u2);
        }
        function nn(t2, i2, o2, s2, r2, n2, a2 = {}) {
          const l2 = o2.paint.get("icon-translate"), c2 = o2.paint.get("text-translate"), h2 = o2.paint.get("icon-translate-anchor"), d2 = o2.paint.get("text-translate-anchor"), u2 = o2.layout.get("icon-rotation-alignment"), _2 = o2.layout.get("text-rotation-alignment"), p2 = o2.layout.get("icon-pitch-alignment"), f2 = o2.layout.get("text-pitch-alignment"), m2 = o2.layout.get("icon-keep-upright"), g2 = o2.layout.get("text-keep-upright"), v2 = o2.paint.get("icon-color-saturation"), y2 = o2.paint.get("icon-color-contrast"), x2 = o2.paint.get("icon-color-brightness-min"), b2 = o2.paint.get("icon-color-brightness-max"), w2 = "sea" === o2.layout.get("symbol-elevation-reference"), T2 = "none" === o2.layout.get("icon-image-use-theme"), E2 = t2.context, S2 = E2.gl, I2 = t2.transform, C2 = "map" === u2, R2 = "map" === _2, A2 = "map" === p2, L2 = "map" === f2, D2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
          let P2 = false;
          const O2 = t2.depthModeForSublayer(0, $i.ReadOnly), z2 = new $i(t2.context.gl.LEQUAL, $i.ReadOnly, t2.depthRangeFor3D), M2 = [e.aF(I2.center.lng), e.aJ(I2.center.lat)], F2 = o2.layout.get("text-variable-anchor"), B2 = "globe" === I2.projection.name, k2 = [], N2 = [0, -1, 0];
          for (const r3 of s2) {
            const s3 = i2.getTile(r3), n3 = s3.getBucket(o2);
            if (!n3) continue;
            if ("mercator" === n3.projection.name && B2) continue;
            if (n3.fullyClipped) continue;
            const u3 = "globe" === n3.projection.name, _3 = u3 ? e.aj(I2.zoom) : 0, p3 = Qt(r3, n3.getProjection(), I2), f3 = I2.calculatePixelsToTileUnitsMatrix(s3), U2 = F2 && n3.hasTextData(), j2 = n3.hasIconTextFit() && U2 && n3.hasIconData(), V2 = n3.getProjection().createInversionMatrix(I2, r3.canonical), G2 = (1 << s3.tileID.canonical.z) * e.al / t2.transform.worldSize, H2 = (e2) => {
              let i3 = [0, 0, 0];
              if (e2) {
                const e3 = t2.style.directionalLight, o3 = t2.style.ambientLight;
                e3 && o3 && (i3 = go(t2.style, e3, o3));
              }
              return i3;
            }, q2 = (e2) => {
              I2.depthOcclusionForSymbolsAndCircles && (o2.hasOcclusionOpacityProperties || t2.terrain) && (e2.push("DEPTH_D24"), e2.push("DEPTH_OCCLUSION"));
            }, Z2 = (i3) => {
              o2.lut && !T2 && (o2.lut.texture || (o2.lut.texture = new e.d$(t2.context, o2.lut.image, [o2.lut.image.height, o2.lut.image.height, o2.lut.image.height], E2.gl.RGBA8)), E2.activeTexture.set(E2.gl.TEXTURE0 + 10), o2.lut.texture && o2.lut.texture.bind(E2.gl.LINEAR, E2.gl.CLAMP_TO_EDGE), i3.push("APPLY_LUT_ON_GPU"));
            }, W2 = () => {
              const i3 = C2 && "point" !== o2.layout.get("symbol-placement"), a3 = [];
              q2(a3), Z2(a3);
              const c3 = i3 || j2, d3 = "road" === n3.elevationType, g3 = t2.shadowRenderer, T3 = d3 && A2 && !!g3 && g3.enabled, E3 = H2(T3), R3 = d3 && A2 && !t2.terrain ? z2 : O2, L3 = o2.paint.get("icon-image-cross-fade");
              t2.terrainRenderModeElevated() && A2 && a3.push("PITCH_WITH_MAP_TERRAIN"), u3 && (a3.push("PROJECTION_GLOBE_VIEW"), c3 && a3.push("PROJECTED_POS_ON_VIEWPORT")), L3 > 0 && n3.hasAnySecondaryIcon && a3.push("ICON_TRANSITION"), !n3.icon.zOffsetVertexBuffer || d3 && t2.terrain || a3.push("Z_OFFSET"), 0 === v2 && 0 === y2 && 0 === x2 && 1 === b2 || a3.push("COLOR_ADJUSTMENT"), n3.sdfIcons && a3.push("RENDER_SDF"), T3 && a3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), d3 && A2 && !t2.terrain && n3.icon.orientationVertexBuffer && a3.push("ELEVATED_ROADS");
              const D3 = n3.icon.programConfigurations.get(o2.id), P3 = t2.getOrCreateProgram("symbol", { config: D3, defines: a3 }), F3 = s3.imageAtlasTexture ? s3.imageAtlasTexture.size : [0, 0], k3 = n3.iconSizeData, U3 = e.bK(k3, I2.zoom), W3 = A2 || !I2.isOrthographic, $3 = oi(p3, s3.tileID.canonical, A2, C2, I2, n3.getProjection(), f3), X3 = ri(p3, s3.tileID.canonical, A2, C2, I2, n3.getProjection(), f3), Y3 = t2.translatePosMatrix(X3, s3, l2, h2, true), K3 = t2.translatePosMatrix(p3, s3, l2, h2), J3 = c3 ? tn : $3, Q3 = C2 && !A2 && !i3;
              let ee3 = N2;
              !B2 && !I2.mercatorFromTransition || C2 || (ee3 = on(I2));
              const te2 = u3 ? ee3 : N2, ie2 = o2.getColorAdjustmentMatrix(v2, y2, x2, b2), oe2 = jr(k3.kind, U3, Q3, A2, t2, K3, J3, Y3, w2, false, F3, [0, 0], 0, r3, _3, M2, V2, te2, n3.getProjection(), E3, G2, ie2, L3, null), se2 = s3.imageAtlasTexture ? s3.imageAtlasTexture : null, re2 = 1 !== o2.layout.get("icon-size").constantOr(0) || n3.iconsNeedLinear, ne2 = n3.sdfIcons || t2.options.rotating || t2.options.zooming || re2 || W3 ? S2.LINEAR : S2.NEAREST, ae2 = n3.sdfIcons && 0 !== o2.paint.get("icon-halo-width").constantOr(1), le2 = t2.terrain && A2 && i3 ? e.bl(e.bC(), $3) : tn;
              if (i3 && n3.icon) {
                const i4 = e.bV.getAtTileOffsetFunc(r3, I2.center.lat, I2.worldSize, n3.getProjection()), a4 = si(p3, s3.tileID.canonical, A2, C2, I2, n3.getProjection(), f3), l3 = o2.layout.get("icon-size-scale-range"), c4 = e.aA(t2.scaleFactor, l3[0], l3[1]);
                ci(n3, p3, t2, false, a4, X3, A2, m2, i4, r3, c4);
              }
              return { program: P3, buffers: n3.icon, uniformValues: oe2, atlasTexture: se2, atlasTextureIcon: null, atlasInterpolation: ne2, atlasInterpolationIcon: null, isSDF: n3.sdfIcons, hasHalo: ae2, depthMode: R3, tile: s3, renderWithShadows: T3, labelPlaneMatrixInv: le2 };
            }, $2 = () => {
              const i3 = R2 && "point" !== o2.layout.get("symbol-placement"), a3 = [], l3 = i3 || F2 || j2, h3 = "road" === n3.elevationType, m3 = t2.shadowRenderer, v3 = h3 && L2 && !!m3 && m3.enabled, y3 = H2(v3), x3 = h3 && L2 && !t2.terrain ? z2 : O2;
              t2.terrainRenderModeElevated() && L2 && a3.push("PITCH_WITH_MAP_TERRAIN"), u3 && (a3.push("PROJECTION_GLOBE_VIEW"), l3 && a3.push("PROJECTED_POS_ON_VIEWPORT")), !n3.text.zOffsetVertexBuffer || h3 && t2.terrain || a3.push("Z_OFFSET"), n3.iconsInText && a3.push("RENDER_TEXT_AND_SYMBOL"), a3.push("RENDER_SDF"), v3 && a3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), h3 && L2 && !t2.terrain && n3.text.orientationVertexBuffer && a3.push("ELEVATED_ROADS"), q2(a3);
              const b3 = n3.text.programConfigurations.get(o2.id), T3 = t2.getOrCreateProgram("symbol", { config: b3, defines: a3 });
              let E3, C3 = [0, 0], A3 = null;
              const D3 = n3.textSizeData;
              n3.iconsInText && (C3 = s3.imageAtlasTexture ? s3.imageAtlasTexture.size : [0, 0], A3 = s3.imageAtlasTexture ? s3.imageAtlasTexture : null, E3 = L2 || !I2.isOrthographic || t2.options.rotating || t2.options.zooming || "composite" === D3.kind || "camera" === D3.kind ? S2.LINEAR : S2.NEAREST);
              const P3 = s3.glyphAtlasTexture ? s3.glyphAtlasTexture.size : [0, 0], k3 = o2.layout.get("text-size-scale-range"), U3 = e.aA(t2.scaleFactor, k3[0], k3[1]), Z3 = e.bK(D3, I2.zoom, U3), W3 = oi(p3, s3.tileID.canonical, L2, R2, I2, n3.getProjection(), f3), $3 = ri(p3, s3.tileID.canonical, L2, R2, I2, n3.getProjection(), f3), X3 = t2.translatePosMatrix($3, s3, c2, d2, true), Y3 = t2.translatePosMatrix(p3, s3, c2, d2), K3 = l3 ? tn : W3, J3 = R2 && !L2 && !i3;
              let Q3 = N2;
              !B2 && !I2.mercatorFromTransition || R2 || (Q3 = on(I2));
              const ee3 = jr(D3.kind, Z3, J3, L2, t2, Y3, K3, X3, w2, true, P3, C3, 0, r3, _3, M2, V2, u3 ? Q3 : N2, n3.getProjection(), y3, G2, null, null, U3), te2 = s3.glyphAtlasTexture ? s3.glyphAtlasTexture : null, ie2 = S2.LINEAR, oe2 = 0 !== o2.paint.get("text-halo-width").constantOr(1), se2 = t2.terrain && L2 && i3 ? e.bl(e.bC(), W3) : tn;
              if (i3 && n3.text) {
                const i4 = e.bV.getAtTileOffsetFunc(r3, I2.center.lat, I2.worldSize, n3.getProjection()), o3 = si(p3, s3.tileID.canonical, L2, R2, I2, n3.getProjection(), f3);
                ci(n3, p3, t2, true, o3, $3, L2, g2, i4, r3, U3);
              }
              return { program: T3, buffers: n3.text, uniformValues: ee3, atlasTexture: te2, atlasTextureIcon: A3, atlasInterpolation: ie2, atlasInterpolationIcon: E3, isSDF: true, hasHalo: oe2, depthMode: x3, tile: s3, renderWithShadows: v3, labelPlaneMatrixInv: se2 };
            }, X2 = n3.icon.segments.get().length, Y2 = n3.text.segments.get().length, K2 = X2 && !a2.onlyText ? W2() : null, J2 = Y2 && !a2.onlyIcons ? $2() : null, Q2 = o2.paint.get("icon-opacity").constantOr(1), ee2 = o2.paint.get("text-opacity").constantOr(1);
            if (D2 && n3.canOverlap) {
              P2 = true;
              const t3 = Q2 && !a2.onlyText ? n3.icon.segments.get() : [], i3 = ee2 && !a2.onlyIcons ? n3.text.segments.get() : [];
              for (const i4 of t3) k2.push({ segments: new e.bg([i4]), sortKey: i4.sortKey, state: K2 });
              for (const t4 of i3) k2.push({ segments: new e.bg([t4]), sortKey: t4.sortKey, state: J2 });
            } else a2.onlyText || k2.push({ segments: Q2 ? n3.icon.segments : new e.bg([]), sortKey: 0, state: K2 }), a2.onlyIcons || k2.push({ segments: ee2 ? n3.text.segments : new e.bg([]), sortKey: 0, state: J2 });
          }
          P2 && k2.sort((e2, t3) => e2.sortKey - t3.sortKey);
          for (const e2 of k2) {
            const i3 = e2.state;
            if (i3) if (t2.terrain ? t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: I2.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }) : t2.setupDepthForOcclusion(I2.depthOcclusionForSymbolsAndCircles, i3.program), E2.activeTexture.set(S2.TEXTURE0), i3.atlasTexture && i3.atlasTexture.bind(i3.atlasInterpolation, S2.CLAMP_TO_EDGE, true), i3.atlasTextureIcon && (E2.activeTexture.set(S2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, S2.CLAMP_TO_EDGE, true)), i3.renderWithShadows && t2.shadowRenderer.setupShadows(i3.tile.tileID.toUnwrapped(), i3.program, "vector-tile"), t2.uploadCommonLightUniforms(t2.context, i3.program), i3.hasHalo) {
              const s3 = i3.uniformValues;
              s3.u_is_halo = 1, an(i3.buffers, e2.segments, o2, t2, i3.program, i3.depthMode, r2, n2, s3, 2), s3.u_is_halo = 0;
            } else {
              if (i3.isSDF) {
                const s3 = i3.uniformValues;
                i3.hasHalo && (s3.u_is_halo = 1, an(i3.buffers, e2.segments, o2, t2, i3.program, i3.depthMode, r2, n2, s3, 1)), s3.u_is_halo = 0;
              }
              an(i3.buffers, e2.segments, o2, t2, i3.program, i3.depthMode, r2, n2, i3.uniformValues, 1);
            }
          }
        }
        function an(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2) {
          const h2 = [e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer, e2.iconTransitioningVertexBuffer, e2.globeExtVertexBuffer, e2.zOffsetVertexBuffer, e2.orientationVertexBuffer];
          s2.draw(o2, o2.context.gl.TRIANGLES, r2, n2, a2, Qi.disabled, l2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, o2.transform.zoom, e2.programConfigurations.get(i2.id), h2, c2);
        }
        function ln(t2, i2) {
          const o2 = 1 << t2.canonical.z, s2 = (i2.x * o2 - t2.canonical.x - t2.wrap * o2) * e.al, r2 = (i2.y * o2 - t2.canonical.y) * e.al, n2 = e.e8(i2.z, i2.y);
          return e.d5(s2, r2, n2);
        }
        function cn(t2, i2, o2, s2, r2) {
          if (!o2.layout || "none" === o2.layout.get("fill-elevation-reference") || 0 === o2.paint.get("fill-opacity").constantOr(1)) return;
          const n2 = t2.context.gl, a2 = new $i(t2.context.gl.LEQUAL, $i.ReadWrite, t2.depthRangeFor3D), l2 = new $i(t2.context.gl.GREATER, $i.ReadWrite, t2.depthRangeFor3D), c2 = function(t3) {
            let i3 = 0.01;
            return t3.isOrthographic && (i3 = e.ak(1e-4, i3, e.d0(t3.pitch >= ao ? 1 : t3.pitch / ao))), 2 * i3;
          }(t2.transform), h2 = t2.transform.getFreeCameraOptions().position, d2 = "elevatedStructuresDepthReconstruct", u2 = t2.getOrCreateProgram(d2, { defines: ["DEPTH_RECONSTRUCTION"] }), _2 = t2.getOrCreateProgram(d2);
          for (const e2 of s2) {
            const s3 = i2.getTile(e2), d3 = s3.getBucket(o2);
            if (!d3) continue;
            const p2 = d3.elevatedStructures;
            if (!p2) continue;
            const f2 = d3.elevationBufferData.heightRange, m2 = ln(e2.toUnwrapped(), h2), g2 = t2.translatePosMatrix(e2.projMatrix, s3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
            let v2, y2, x2, b2;
            if ("initialize" === r2) {
              if (!f2 || f2.min >= 1 || 0 === p2.depthSegments.segments[0].primitiveLength) continue;
              v2 = Tr(g2, m2, c2, 1, 0), y2 = a2, x2 = p2.depthSegments, b2 = u2;
            } else if ("reset" === r2) {
              if (!f2 || f2.min >= 0 || 0 === p2.maskSegments.segments[0].primitiveLength) continue;
              v2 = Tr(g2, m2, 0, 0, 1), y2 = l2, x2 = p2.maskSegments, b2 = u2;
            } else if ("geometry" === r2) {
              if (0 === p2.depthSegments.segments[0].primitiveLength) continue;
              v2 = Tr(g2, m2, c2, 1, 0), y2 = a2, x2 = p2.depthSegments, b2 = _2;
            }
            b2.draw(t2, n2.TRIANGLES, y2, Yi.disabled, Wi.disabled, Qi.disabled, v2, o2.id, p2.vertexBuffer, p2.indexBuffer, x2, o2.paint, t2.transform.zoom);
          }
        }
        function hn(t2, i2, o2, s2) {
          const { painter: r2, sourceCache: n2, layer: a2, coords: l2, colorMode: c2, elevationType: h2, terrainEnabled: d2, pass: u2 } = t2, _2 = r2.context.gl, p2 = a2.paint.get("fill-pattern"), f2 = a2.paint.get("fill-pattern-cross-fade"), m2 = p2.constantOr(null);
          let g2 = h2;
          "road" !== h2 || i2 && !d2 || (g2 = "none");
          const v2 = "road" === g2, y2 = t2.painter.shadowRenderer, x2 = v2 && !!y2 && y2.enabled, b2 = new $i(r2.context.gl.LEQUAL, $i.ReadOnly, r2.depthRangeFor3D);
          let w2 = [0, 0, 0];
          if (x2) {
            const e2 = r2.style.directionalLight, t3 = r2.style.ambientLight;
            e2 && t3 && (w2 = go(r2.style, e2, t3));
          }
          const T2 = p2 && p2.constantOr(1), E2 = r2.terrain && r2.terrain.renderingToTexture, S2 = (t3, u3) => {
            let p3, g3, S3, I2, C2;
            u3 ? (p3 = T2 && !a2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", S3 = _2.LINES) : (p3 = T2 ? "fillPattern" : "fill", S3 = _2.TRIANGLES);
            for (const R2 of l2) {
              const l3 = n2.getTile(R2);
              if (T2 && !l3.patternsLoaded()) continue;
              const A2 = l3.getBucket(a2);
              if (!A2) continue;
              const L2 = i2 ? A2.elevationBufferData : A2.bufferData;
              if (L2.isEmpty()) continue;
              r2.prepareDrawTile();
              const D2 = L2.programConfigurations.get(a2.id), P2 = r2.isTileAffectedByFog(R2), O2 = [], z2 = [];
              v2 && (O2.push("ELEVATED_ROADS"), z2.push(L2.elevatedLayoutVertexBuffer)), x2 && O2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), E2 && o2 && O2.push("USE_MRT1"), T2 && (r2.context.activeTexture.set(_2.TEXTURE0), l3.imageAtlasTexture && l3.imageAtlasTexture.bind(_2.LINEAR, _2.CLAMP_TO_EDGE), D2.updatePaintBuffers());
              let M2 = false;
              if (m2 && l3.imageAtlas) {
                const t4 = l3.imageAtlas, i3 = e.e3.from(m2), o3 = i3.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(), s3 = i3.getSecondary(), r3 = t4.patternPositions.get(o3), n3 = s3 ? t4.patternPositions.get(s3.scaleSelf(e.o.devicePixelRatio).toString()) : null;
                M2 = !!r3 && !!n3, r3 && D2.setConstantPatternPositions(r3, n3);
              }
              f2 > 0 && (M2 || D2.getPatternTransitionVertexBuffer("fill-pattern")) && O2.push("FILL_PATTERN_TRANSITION");
              const F2 = r2.getOrCreateProgram(p3, { config: D2, overrideFog: P2, defines: O2 }), B2 = r2.translatePosMatrix(R2.projMatrix, l3, a2.paint.get("fill-translate"), a2.paint.get("fill-translate-anchor"));
              x2 && y2.setupShadows(l3.tileID.toUnwrapped(), F2, "vector-tile");
              const k2 = a2.paint.get("fill-emissive-strength");
              if (u3) {
                I2 = L2.lineIndexBuffer, C2 = L2.lineSegments;
                const e2 = r2.terrain && r2.terrain.renderingToTexture ? r2.terrain.drapeBufferSize : [_2.drawingBufferWidth, _2.drawingBufferHeight];
                g3 = "fillOutlinePattern" === p3 && T2 ? xr(B2, k2, r2, l3, e2, w2, f2) : yr(B2, k2, e2, w2);
              } else I2 = L2.indexBuffer, C2 = L2.triangleSegments, g3 = T2 ? vr(B2, k2, r2, l3, w2, f2) : gr(B2, k2, w2);
              r2.uploadCommonUniforms(r2.context, F2, R2.toUnwrapped());
              let N2 = t3;
              ("road" === h2 && !d2 || "offset" === h2) && (N2 = b2), F2.draw(r2, S3, N2, s2 || r2.stencilModeForClipping(R2), c2, Qi.disabled, g3, a2.id, L2.layoutVertexBuffer, I2, C2, a2.paint, r2.transform.zoom, D2, z2);
            }
          };
          r2.renderPass === u2 && S2(r2.depthModeForSublayer(1, "opaque" === r2.renderPass ? $i.ReadWrite : $i.ReadOnly), false), "none" === g2 && "translucent" === r2.renderPass && a2.paint.get("fill-antialias") && S2(r2.depthModeForSublayer(a2.getPaintProperty("fill-outline-color") ? 2 : 0, $i.ReadOnly), true);
        }
        function dn(t2, i2, o2, s2, r2, n2, a2, l2) {
          o2.resetLayerRenderingStats(t2);
          const c2 = t2.context, h2 = c2.gl, d2 = t2.transform, u2 = o2.paint.get("fill-extrusion-pattern"), _2 = o2.paint.get("fill-extrusion-pattern-cross-fade"), p2 = u2.constantOr(null), f2 = u2.constantOr(1), m2 = o2.paint.get("fill-extrusion-opacity"), g2 = t2.style.enable3dLights(), v2 = o2.paint.get(g2 && !f2 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), y2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), v2], x2 = o2.layout.get("fill-extrusion-edge-radius"), b2 = x2 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), w2 = b2 ? 0 : x2, T2 = "globe" === d2.projection.name ? e.eb() : 0, E2 = "globe" === d2.projection.name, S2 = E2 ? e.aj(d2.zoom) : 0, I2 = [e.aF(d2.center.lng), e.aJ(d2.center.lat)], C2 = "none" === o2.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), R2 = o2.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(C2 ? null : o2.lut).toArray01().slice(0, 3), A2 = o2.paint.get("fill-extrusion-flood-light-intensity"), L2 = o2.paint.get("fill-extrusion-vertical-scale"), D2 = 0 !== o2.paint.get("fill-extrusion-line-width").constantOr(1), P2 = o2.paint.get("fill-extrusion-height-alignment"), O2 = o2.paint.get("fill-extrusion-base-alignment"), z2 = co(t2, o2.paint.get("fill-extrusion-cutoff-fade-range")), M2 = [];
          let F2;
          E2 && M2.push("PROJECTION_GLOBE_VIEW"), y2[0] > 0 && M2.push("FAUX_AO"), b2 && M2.push("ZERO_ROOF_RADIUS"), l2 && M2.push("HAS_CENTROID"), A2 > 0 && M2.push("FLOOD_LIGHT"), z2.shouldRenderCutoff && M2.push("RENDER_CUTOFF"), D2 && M2.push("RENDER_WALL_MODE");
          const B2 = "shadow" === t2.renderPass, k2 = t2.shadowRenderer, N2 = B2 && !!k2, U2 = B2 ? Qi.disabled : Qi.backCCW;
          t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = true);
          let j2 = [0, 0, 0];
          if (k2) {
            const e2 = t2.style.directionalLight, i3 = t2.style.ambientLight;
            e2 && i3 && (j2 = go(t2.style, e2, i3)), B2 || (M2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), k2.useNormalOffset && M2.push("NORMAL_OFFSET")), F2 = M2.concat(["SHADOWS_SINGLE_CASCADE"]);
          }
          const V2 = N2 ? "fillExtrusionDepth" : f2 ? "fillExtrusionPattern" : "fillExtrusion", G2 = o2.getLayerRenderingStats();
          for (const u3 of s2) {
            const s3 = i2.getTile(u3), g3 = s3.getBucket(o2);
            if (!g3 || g3.projection.name !== d2.projection.name) continue;
            let v3 = false;
            k2 && (v3 = 0 === k2.getMaxCascadeForTile(u3.toUnwrapped()));
            const x3 = t2.isTileAffectedByFog(u3), b3 = g3.programConfigurations.get(o2.id);
            let C3 = false;
            if (p2 && s3.imageAtlas) {
              const t3 = s3.imageAtlas, i3 = e.e3.from(p2), o3 = i3.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(), r3 = i3.getSecondary(), n3 = t3.patternPositions.get(o3), a3 = r3 ? t3.patternPositions.get(r3.scaleSelf(e.o.devicePixelRatio).toString()) : null;
              C3 = !!n3 && !!a3, n3 && b3.setConstantPatternPositions(n3, a3);
            }
            _2 > 0 && (C3 || b3.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && M2.push("FILL_EXTRUSION_PATTERN_TRANSITION");
            const N3 = t2.getOrCreateProgram(V2, { config: b3, defines: v3 ? F2 : M2, overrideFog: x3 });
            if (t2.terrain && t2.terrain.setupElevationDraw(s3, N3, { useMeterToDem: true }), !g3.centroidVertexBuffer) {
              const e2 = N3.getAttributeLocation(h2, "a_centroid_pos");
              -1 !== e2 && h2.vertexAttrib2f(e2, 0, 0);
            }
            !B2 && k2 && k2.setupShadows(s3.tileID.toUnwrapped(), N3, "vector-tile"), f2 && (t2.context.activeTexture.set(h2.TEXTURE0), s3.imageAtlasTexture && s3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), b3.updatePaintBuffers());
            const H2 = o2.paint.get("fill-extrusion-vertical-gradient"), q2 = 1 / g3.tileToMeter;
            let Z2;
            if (B2 && k2) {
              if (vn(s3.tileID, g3.maxHeight, t2)) continue;
              const e2 = k2.calculateShadowPassMatrixFromTile(s3.tileID.toUnwrapped());
              Z2 = fr(e2, w2, q2, L2, P2, O2);
            } else {
              const e2 = t2.translatePosMatrix(u3.expandedProjMatrix, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = d2.projection.createInversionMatrix(d2, u3.canonical);
              Z2 = f2 ? mr(e2, t2, H2, m2, y2, w2, q2, u3, s3, T2, P2, O2, S2, I2, i3, R2, L2, _2) : pr(e2, t2, H2, m2, y2, w2, q2, u3, T2, P2, O2, S2, I2, i3, R2, L2, A2, j2);
            }
            t2.uploadCommonUniforms(c2, N3, u3.toUnwrapped(), null, z2);
            let W2 = g3.segments;
            if ("mercator" === d2.projection.name && !B2 && (W2 = g3.getVisibleSegments(s3.tileID, t2.terrain, t2.transform.getFrustum(0)), !W2.get().length)) continue;
            if (G2) if (B2) for (const e2 of W2.get()) G2.numRenderedVerticesInShadowPass += e2.primitiveLength;
            else for (const e2 of W2.get()) G2.numRenderedVerticesInTransparentPass += e2.primitiveLength;
            const $2 = [];
            (t2.terrain || l2) && $2.push(g3.centroidVertexBuffer), E2 && $2.push(g3.layoutVertexExtBuffer), D2 && $2.push(g3.wallVertexBuffer), N3.draw(t2, c2.gl.TRIANGLES, r2, n2, a2, U2, Z2, o2.id, g3.layoutVertexBuffer, g3.indexBuffer, W2, o2.paint, t2.transform.zoom, b3, $2);
          }
          t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = false);
        }
        class un {
          constructor() {
            this.translate = [0, 0], this.translateAnchor = "map", this.edgeRadius = 0, this.cutoffFadeRange = 0;
          }
        }
        function _n(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2, p2, f2, m2, g2, v2, y2, x2) {
          const b2 = i2.context, w2 = b2.gl, T2 = i2.transform, E2 = i2.transform.zoom, S2 = [], I2 = t2.translate, C2 = t2.translateAnchor, R2 = t2.edgeRadius, A2 = co(i2, t2.cutoffFadeRange);
          "clear" === d2 ? (S2.push("CLEAR_SUBPASS"), x2 && (S2.push("CLEAR_FROM_TEXTURE"), b2.activeTexture.set(w2.TEXTURE0), x2.bind(w2.LINEAR, w2.CLAMP_TO_EDGE))) : "sdf" === d2 ? S2.push("SDF_SUBPASS") : "emissive" === d2 && (S2.push("USE_MRT1"), b2.activeTexture.set(w2.TEXTURE0), x2.bind(w2.LINEAR, w2.CLAMP_TO_EDGE)), v2 && S2.push("HAS_CENTROID"), A2.shouldRenderCutoff && S2.push("RENDER_CUTOFF");
          const L2 = (e2, t3, o3, r3, d3) => {
            let y3 = S2;
            null != t3.groundRadiusBuffer && (y3 = S2.concat("HAS_ATTRIBUTE_a_flood_light_ground_radius"));
            const w3 = t3.programConfigurations.get(s2.id), T3 = i2.isTileAffectedByFog(e2), I3 = i2.getOrCreateProgram("fillExtrusionGroundEffect", { config: w3, defines: y3, overrideFog: T3 }), C3 = /* @__PURE__ */ ((e3, t4, i3, o4, s3, r4, n3, a3, l3, c3, h3) => ({ u_matrix: t4, u_opacity: i3, u_ao_pass: o4 ? 1 : 0, u_meter_to_tile: s3, u_ao: r4, u_flood_light_intensity: n3, u_flood_light_color: a3, u_attenuation: l3, u_edge_radius: c3, u_fb: 0, u_fb_size: h3, u_dynamic_offset: 1 }))(0, r3, u2, h2, d3, [_2, p2 * d3], f2, m2, g2, E2 >= 17 ? 0 : R2 * d3, x2 ? x2.size[0] : 0), L3 = [];
            v2 && L3.push(t3.hiddenByLandmarkVertexBuffer), null != t3.groundRadiusBuffer && L3.push(t3.groundRadiusBuffer), i2.uploadCommonUniforms(b2, I3, e2.toUnwrapped(), null, A2), I3.draw(i2, b2.gl.TRIANGLES, n2, a2, l2, c2, C3, s2.id, t3.vertexBuffer, t3.indexBuffer, o3, s2.paint, E2, w3, L3);
          };
          for (const t3 of r2) {
            const r3 = o2.getTile(t3), n3 = r3.getBucket(s2);
            if (!n3 || n3.projection.name !== T2.projection.name || !n3.groundEffect || n3.groundEffect && !n3.groundEffect.hasData()) continue;
            const a3 = n3.groundEffect, l3 = 1 / n3.tileToMeter;
            {
              const e2 = i2.translatePosMatrix(t3.projMatrix, r3, I2, C2), o3 = a3.getDefaultSegment();
              L2(t3, a3, o3, e2, l3);
            }
            if (y2) for (let n4 = 0; n4 < 4; n4++) {
              const a4 = e.e9[n4](t3), c3 = o2.getTile(a4);
              if (!c3) continue;
              const h3 = c3.getBucket(s2);
              if (!h3 || h3.projection.name !== T2.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData()) continue;
              const d3 = h3.groundEffect;
              let u3, _3;
              0 === n4 ? (u3 = [-e.al, 0, 0], _3 = 1) : 1 === n4 ? (u3 = [e.al, 0, 0], _3 = 0) : 2 === n4 ? (u3 = [0, -e.al, 0], _3 = 3) : (u3 = [0, e.al, 0], _3 = 2);
              const p3 = d3.regionSegments[_3];
              if (!p3) continue;
              const f3 = new Float32Array(16);
              e.br(f3, t3.projMatrix, u3), L2(t3, d3, p3, i2.translatePosMatrix(f3, r3, I2, C2), l3);
            }
          }
        }
        function pn(t2, i2, o2, s2, r2, n2, a2) {
          0 === s2.centroidVertexArray.length && s2.createCentroidsBuffer();
          const l2 = n2 ? n2.findDEMTileFor(o2) : null;
          if (!(l2 && l2.dem || a2)) return;
          n2 && l2 && l2.dem && s2.selfDEMTileTimestamp !== l2.dem._timestamp && (s2.borderDoneWithNeighborZ = [-1, -1, -1, -1], s2.selfDEMTileTimestamp = l2.dem._timestamp);
          const c2 = (t3, i3) => {
            (t3.flags | i3.flags) & e.ec ? (t3.flags |= e.ec, i3.flags |= e.ec) : (t3.flags &= ~e.ec, i3.flags &= ~e.ec);
          }, h2 = (t3) => new e.P(Math.ceil((t3 + e.ed) * e.ee), 0), d2 = (e2) => {
            const t3 = i2.getSource().minzoom, o3 = (e3) => {
              const t4 = i2.getTileByID(e3);
              if (t4 && t4.hasData()) return t4.getBucket(r2);
            }, s3 = [0, -1, 1];
            for (const i3 of s3) {
              if (e2.overscaledZ + i3 < t3) continue;
              const s4 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
              if (s4) return s4;
            }
          }, u2 = [0, 0, 0], _2 = (t3, i3) => (u2[0] = Math.min(t3.min.y, i3.min.y), u2[1] = Math.max(t3.max.y, i3.max.y), u2[2] = e.al - i3.min.x > t3.max.x ? i3.min.x - e.al : t3.max.x, u2), p2 = (t3, i3) => (u2[0] = Math.min(t3.min.x, i3.min.x), u2[1] = Math.max(t3.max.x, i3.max.x), u2[2] = e.al - i3.min.y > t3.max.y ? i3.min.y - e.al : t3.max.y, u2), f2 = [(e2, t3) => _2(e2, t3), (e2, t3) => _2(t3, e2), (e2, t3) => p2(e2, t3), (e2, t3) => p2(t3, e2)], m2 = (t3, i3, s3, r3, a3, c3, h3) => {
            if (!n2) return 0;
            const d3 = [[c3 ? s3 : t3, c3 ? t3 : s3, 0], [c3 ? s3 : i3, c3 ? i3 : s3, 0]], u3 = h3 < 0 ? e.al + h3 : h3, _3 = [c3 ? u3 : (t3 + i3) / 2, c3 ? (t3 + i3) / 2 : u3, 0];
            return 0 === s3 && h3 < 0 || 0 !== s3 && h3 > 0 ? n2.getForTilePoints(a3, [_3], true, r3) : d3.push(_3), n2.getForTilePoints(o2, d3, true, l2), Math.max(d3[0][2], d3[1][2], _3[2]) / n2.exaggeration();
          };
          for (let t3 = 0; t3 < 4; t3++) {
            const i3 = s2.borderFeatureIndices[t3];
            if (0 === i3.length) continue;
            const r3 = e.e9[t3](o2), l3 = d2(r3);
            if (!(l3 && l3 instanceof e.ea)) continue;
            const u3 = n2 ? n2.findDEMTileFor(r3) : null;
            if (!(u3 && u3.dem || a2)) continue;
            if (n2 && u3 && u3.dem && s2.borderDEMTileTimestamp[t3] !== u3.dem._timestamp && (s2.borderDoneWithNeighborZ[t3] = -1, s2.borderDEMTileTimestamp[t3] = u3.dem._timestamp), s2.borderDoneWithNeighborZ[t3] === l3.canonical.z) continue;
            0 === l3.centroidVertexArray.length && l3.createCentroidsBuffer();
            const _3 = (t3 < 2 ? 1 : 5) - t3, p3 = l3.borderDoneWithNeighborZ[_3] !== s2.canonical.z, g2 = l3.borderFeatureIndices[_3];
            let v2 = 0;
            if (s2.canonical.z !== l3.canonical.z) {
              for (const e2 of i3) s2.showCentroid(s2.featuresOnBorder[e2]);
              if (p3) for (const e2 of g2) l3.showCentroid(l3.featuresOnBorder[e2]);
              s2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[_3] = s2.canonical.z;
            }
            for (const o3 of i3) {
              const i4 = s2.featuresOnBorder[o3], n3 = s2.centroidData[i4.centroidDataIndex], d3 = i4.borders[t3];
              let p4;
              for (; v2 < g2.length; ) {
                p4 = l3.featuresOnBorder[g2[v2]];
                const e2 = p4.borders[_3];
                if (e2[1] > d3[0] + 3 || e2[0] > d3[0] - 3) break;
                l3.showCentroid(p4), v2++;
              }
              if (p4 && v2 < g2.length) {
                const o4 = v2;
                let y2 = 0;
                for (; !(p4.borders[_3][0] > d3[1] - 3) && (y2++, ++v2 !== g2.length); ) p4 = l3.featuresOnBorder[g2[v2]];
                p4 = l3.featuresOnBorder[g2[o4]];
                let x2 = false;
                if (y2 >= 1) {
                  const e2 = p4.borders[_3];
                  Math.abs(d3[0] - e2[0]) < 3 && Math.abs(d3[1] - e2[1]) < 3 && (y2 = 1, x2 = true, v2 = o4 + 1);
                } else if (0 === y2) {
                  s2.showCentroid(i4);
                  continue;
                }
                const b2 = l3.centroidData[p4.centroidDataIndex];
                a2 && x2 && c2(n3, b2);
                const w2 = i4.intersectsCount() > 1 || p4.intersectsCount() > 1;
                if (y2 > 1) v2 = o4, n3.centroidXY = b2.centroidXY = new e.P(0, 0);
                else if (u3 && u3.dem && !w2) {
                  const i5 = f2[t3](n3, b2), o5 = t3 % 2 ? e.al - 1 : 0, s3 = m2(i5[0], Math.min(e.al - 1, i5[1]), o5, u3, r3, t3 < 2, i5[2]);
                  n3.centroidXY = b2.centroidXY = h2(s3);
                } else w2 ? n3.centroidXY = b2.centroidXY = new e.P(0, 0) : (n3.centroidXY = s2.encodeBorderCentroid(i4), b2.centroidXY = l3.encodeBorderCentroid(p4));
                s2.writeCentroidToBuffer(n3), l3.writeCentroidToBuffer(b2);
              } else s2.showCentroid(i4);
            }
            s2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[_3] = s2.canonical.z;
          }
          (s2.needsCentroidUpdate || !s2.centroidVertexBuffer && 0 !== s2.centroidVertexArray.length) && s2.uploadCentroid(t2);
        }
        const fn = [1, 0, 0], mn = [0, 1, 0], gn = [0, 0, 1];
        function vn(t2, i2, o2) {
          const s2 = o2.transform, r2 = o2.shadowRenderer;
          if (!r2) return true;
          const n2 = t2.toUnwrapped(), a2 = s2.tileSize * r2._cascades[o2.currentShadowCascade].scale;
          let l2 = i2;
          if (s2.elevation) {
            const e2 = s2.elevation.getMinMaxForTile(t2);
            e2 && (l2 += e2.max);
          }
          const c2 = [...r2.shadowDirection];
          c2[2] = -c2[2];
          const h2 = r2.computeSimplifiedTileShadowVolume(n2, l2, a2, c2);
          if (!h2) return false;
          const d2 = [fn, mn, gn, c2, [c2[0], 0, c2[2]], [0, c2[1], c2[2]]], u2 = "globe" === s2.projection.name, _2 = s2.scaleZoom(a2), p2 = e.cB.fromInvProjectionMatrix(s2.invProjMatrix, s2.worldSize, _2, !u2), f2 = r2.getCurrentCascadeFrustum();
          return 0 === p2.intersectsPrecise(h2.vertices, h2.planes, d2) || 0 === f2.intersectsPrecise(h2.vertices, h2.planes, d2);
        }
        function yn(t2) {
          const { painter: i2, source: o2, layer: s2, coords: r2 } = t2;
          let n2 = t2.defines;
          const a2 = i2.context, l2 = "shadow" === i2.renderPass, c2 = "light-beam" === i2.renderPass, h2 = i2.shadowRenderer, d2 = e.ef(i2.transform.center.lat, i2.transform.zoom), u2 = co(i2, s2.paint.get("building-cutoff-fade-range"));
          u2.shouldRenderCutoff && (n2 = n2.concat("RENDER_CUTOFF")), t2.floodLightIntensity > 0 && (n2 = n2.concat("FLOOD_LIGHT"));
          for (const _2 of r2) {
            const r3 = o2.getTile(_2), p2 = r3.getBucket(s2);
            if (!p2) continue;
            h2 && 0 === h2.getMaxCascadeForTile(_2.toUnwrapped()) && (n2 = n2.concat("SHADOWS_SINGLE_CASCADE"));
            const f2 = p2.programConfigurations.get(s2.id);
            let m2, g2, v2, y2 = i2.translatePosMatrix(_2.expandedProjMatrix, r3, [0, 0], "map");
            if (y2 = e.cS(e.bC(), y2, [1, 1, t2.verticalScale]), l2 && h2) {
              if (vn(r3.tileID, p2.maxHeight * d2, i2)) continue;
              let o3 = h2.calculateShadowPassMatrixFromTile(r3.tileID.toUnwrapped());
              o3 = e.cS(e.bC(), o3, [1, 1, t2.verticalScale]), v2 = Ir(o3), m2 = g2 = i2.getOrCreateProgram("buildingDepth", { config: f2, defines: n2, overrideFog: false });
            } else if (c2) m2 = g2 = i2.getOrCreateProgram("buildingBloom", { config: f2, defines: n2, overrideFog: false }), v2 = Sr(y2);
            else {
              const o3 = i2.transform.calculatePosMatrix(_2.toUnwrapped(), i2.transform.worldSize);
              e.cS(o3, o3, [1, 1, t2.verticalScale]);
              const s3 = e.bC();
              e.cS(s3, o3, [1, -1, 1 / d2]), e.bl(s3, s3), e.eg(s3, s3);
              const r4 = i2.transform.getFreeCameraOptions().position, a3 = 1 << _2.canonical.z;
              if (v2 = Er(y2, s3, t2.opacity, t2.facadeAOIntensity, [((r4.x - _2.wrap) * a3 - _2.canonical.x) * e.al, (r4.y * a3 - _2.canonical.y) * e.al, r4.z * a3 * e.al], p2.tileToMeter, t2.facadeEmissiveChance, t2.floodLightColor, t2.floodLightIntensity), g2 = i2.getOrCreateProgram("building", { config: f2, defines: n2, overrideFog: false }), true === t2.depthOnly) m2 = g2;
              else {
                const e2 = n2.concat(["BUILDING_FAUX_FACADE", "HAS_ATTRIBUTE_a_faux_facade_color_emissive"]);
                m2 = i2.getOrCreateProgram("building", { config: f2, defines: e2, overrideFog: false });
              }
              h2 && (h2.setupShadowsFromMatrix(o3, g2, true), m2 !== g2 && h2.setupShadowsFromMatrix(o3, m2, true));
            }
            const x2 = (e2, o3) => {
              if (c2) {
                const r4 = e2.entranceBloom;
                o3.draw(i2, a2.gl.TRIANGLES, t2.depthMode, Yi.disabled, t2.blendMode, Qi.disabled, v2, s2.id, r4.layoutVertexBuffer, r4.indexBuffer, r4.segmentsBucket, s2.paint, i2.transform.zoom, f2, [r4.layoutAttenuationBuffer, r4.layoutColorBuffer]);
              } else {
                const r4 = e2.segmentsBucket;
                let n3 = [e2.layoutNormalBuffer, e2.layoutCentroidBuffer, e2.layoutColorBuffer, e2.layoutFloodLightDataBuffer];
                e2.layoutFacadePaintBuffer && (n3 = n3.concat([e2.layoutFacadeDataBuffer, e2.layoutFacadeVerticalRangeBuffer, e2.layoutFacadePaintBuffer])), o3.draw(i2, a2.gl.TRIANGLES, t2.depthMode, Yi.disabled, t2.blendMode, l2 ? Qi.disabled : Qi.backCW, v2, s2.id, e2.layoutVertexBuffer, e2.indexBuffer, r4, s2.paint, i2.transform.zoom, f2, n3);
              }
            };
            i2.uploadCommonUniforms(a2, g2, _2.toUnwrapped(), null, u2), p2.buildingWithoutFacade && x2(p2.buildingWithoutFacade, g2), p2.buildingWithFacade && (m2 !== g2 && i2.uploadCommonUniforms(a2, m2, _2.toUnwrapped(), null, u2), x2(p2.buildingWithFacade, m2));
          }
        }
        function xn(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u2, _2) {
          const p2 = t2.context.gl, f2 = t2.depthModeForSublayer(1, $i.ReadOnly, p2.LEQUAL, true), m2 = 0.1 * (1 - (g2 = d2)) + 3 * g2;
          var g2;
          const v2 = t2._showOverdrawInspector, y2 = u2, x2 = new un();
          v2 || _n(x2, t2, i2, o2, s2, f2, new Yi({ func: p2.ALWAYS, mask: 255 }, 255, 255, p2.KEEP, p2.KEEP, p2.REPLACE), new Wi([p2.ONE, p2.ONE, p2.ONE, p2.ONE], e.ao.transparent, [false, false, false, true], p2.MIN), Qi.disabled, r2, "sdf", n2, a2, l2, c2, h2, m2, y2, false);
          {
            const d3 = v2 ? Yi.disabled : new Yi({ func: p2.EQUAL, mask: 255 }, 255, 255, p2.KEEP, p2.DECR, p2.DECR), u3 = v2 ? t2.colorModeForRenderPass() : new Wi([p2.ONE_MINUS_DST_ALPHA, p2.DST_ALPHA, p2.ONE, p2.ONE], e.ao.transparent, [true, true, true, true]);
            _n(x2, t2, i2, o2, s2, f2, d3, u3, Qi.disabled, r2, "color", n2, a2, l2, c2, h2, m2, y2, false);
          }
        }
        function bn(t2) {
          return [t2[0] * e.eh, t2[1] * e.eh, t2[2] * e.eh, 0];
        }
        function wn(t2, i2, o2, s2, r2, n2, a2, l2, c2) {
          const h2 = s2.getSource(), d2 = o2.globeSharedBuffers;
          if (!d2) return;
          let u2, _2, p2;
          if (i2 && (u2 = s2.getTile(i2)), h2 instanceof e.aU ? (_2 = h2.texture, p2 = e.dK(0, 0, o2.transform)) : u2 && i2 && (_2 = u2.texture, p2 = e.dK(i2.canonical.z, i2.canonical.x, o2.transform)), !_2 || !p2) return;
          t2 || (p2 = e.cS(e.bC(), p2, [1, -1, 1]));
          const f2 = o2.context, m2 = f2.gl, g2 = "nearest" === r2.paint.get("raster-resampling") ? m2.NEAREST : m2.LINEAR, v2 = o2.colorModeForDrapableLayerRenderPass(n2), y2 = a2.defines;
          y2.push("GLOBE_POLES");
          const x2 = new $i(m2.LEQUAL, $i.ReadWrite, o2.depthRangeFor3D), b2 = Float32Array.from(o2.transform.expandedFarZProjMatrix), w2 = Float32Array.from(e.bk(e.dJ(new e.cD(0, 0, 0))));
          o2.terrain && o2.terrain.prepareDrawTile(), f2.activeTexture.set(m2.TEXTURE0), _2.bind(g2, m2.CLAMP_TO_EDGE), f2.activeTexture.set(m2.TEXTURE1), _2.bind(g2, m2.CLAMP_TO_EDGE), "useMipmap" in _2 && f2.extTextureFilterAnisotropic && o2.transform.pitch > 20 && m2.texParameterf(m2.TEXTURE_2D, f2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f2.extTextureFilterAnisotropicMax);
          const [T2, E2, S2, I2] = i2 ? d2.getPoleBuffers(i2.canonical.z, false) : d2.getPoleBuffers(0, true), C2 = r2.paint.get("raster-elevation");
          let R2;
          t2 ? (R2 = T2, o2.renderDefaultNorthPole = 0 !== C2) : (R2 = E2, o2.renderDefaultSouthPole = 0 !== C2);
          const A2 = bn(a2.mix), L2 = ((e2, t3, i3, o3, s3, r3, n3, a3, l3, c3, h3, d3, u3) => zr(e2, t3, i3, new Float32Array(16), new Float32Array(9), [0, 0], o3, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, r3, [0, 0], a3, 2, c3, h3, d3, 1, 0, u3))(b2, w2, p2, e.aj(o2.transform.zoom), 0, r2, 0, C2, 0, A2, a2.offset, a2.range, n2), D2 = o2.getOrCreateProgram("raster", { defines: y2 });
          o2.uploadCommonUniforms(f2, D2, null), D2.draw(o2, m2.TRIANGLES, x2, c2, v2, l2, L2, r2.id, R2, S2, I2);
        }
        function Tn(e2) {
          if (e2.isOrthographic) return [0, 0, 0, 0];
          const t2 = e2._nearZ, i2 = e2.projection.farthestPixelDistance(e2), o2 = i2 - t2, s2 = 0.2 * e2.height, r2 = t2 + s2;
          return [t2, i2, (r2 - s2 - t2) / o2, (r2 - t2) / o2];
        }
        function En(e2, t2, i2, o2) {
          if (e2) return t2 instanceof pt && e2 instanceof Ot ? t2.getTextureDescriptor(e2, i2, true) : { texture: e2.texture, mix: bn(o2.mix), offset: o2.offset, buffer: 0, tileSize: 1 };
        }
        var Sn = e.ei([{ name: "a_index", type: "Int16", components: 1 }]);
        class In {
          constructor(t2, i2, o2, s2) {
            const r2 = { width: o2[0], height: o2[1], data: null }, n2 = t2.gl;
            this.targetColorTexture = new e.T(t2, r2, n2.RGBA8, { useMipmap: false }), this.backgroundColorTexture = new e.T(t2, r2, n2.RGBA8, { useMipmap: false }), this.context = t2, this.updateParticleTexture(i2, s2), this.lastInvalidatedAt = 0;
          }
          updateParticleTexture(t2, i2) {
            if (this.particleTextureDimension === i2.width) return;
            (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
            const o2 = this.context.gl, s2 = i2.width * i2.height;
            this.particleTexture0 = new e.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false });
            const r2 = new e.ej();
            r2.reserve(s2);
            for (let e2 = 0; e2 < s2; e2++) r2.emplaceBack(e2);
            this.particleIndexBuffer = this.context.createVertexBuffer(r2, Sn.members, true), this.particleSegment = e.bg.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i2.width;
          }
          update(t2) {
            return !(this.lastInvalidatedAt < t2 && (this.lastInvalidatedAt = e.o.now(), 1));
          }
          destroy() {
            this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
          }
        }
        function Cn(t2, i2, o2) {
          if (!t2) return null;
          const s2 = i2.getTextureDescriptor(t2, o2, true);
          if (!s2) return null;
          let { texture: r2, mix: n2, offset: a2, tileSize: l2, buffer: c2, format: h2 } = s2;
          if (!r2 || !h2) return null;
          let d2 = false;
          return "uint32" === h2 && (d2 = true, n2[3] = 0, n2 = Pr(e.ek, n2, [0, o2.paint.get("raster-particle-max-speed")]), a2 = Or(e.ek, a2, [0, o2.paint.get("raster-particle-max-speed")])), { texture: r2, textureOffset: [c2 / (l2 + 2 * c2), l2 / (l2 + 2 * c2)], tileSize: l2, scalarData: d2, scale: n2, offset: a2, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h2]] };
        }
        function Rn(e2) {
          const t2 = e2._nearZ, i2 = e2.projection.farthestPixelDistance(e2), o2 = i2 - t2, s2 = 0.2 * e2.height, r2 = t2 + s2;
          return [t2, i2, (r2 - s2 - t2) / o2, (r2 - t2) / o2];
        }
        const An = new e.ao(1, 0, 0, 1), Ln = new e.ao(0, 1, 0, 1), Dn = new e.ao(0, 0, 1, 1), Pn = new e.ao(1, 0, 1, 1), On = new e.ao(0, 1, 1, 1);
        function zn(t2, i2, o2, s2, r2, n2) {
          for (let a2 = 0; a2 < o2.length; a2++) if (r2) {
            const r3 = 1, l2 = 0.8, c2 = new e.ao(s2.r * l2, s2.g * l2, s2.b * l2, 1);
            Mn(t2, i2, o2[a2], s2, -r3, -r3, n2), Mn(t2, i2, o2[a2], s2, -r3, r3, n2), Mn(t2, i2, o2[a2], s2, r3, r3, n2), Mn(t2, i2, o2[a2], s2, r3, -r3, n2), Mn(t2, i2, o2[a2], c2, 0, 0, n2);
          } else Mn(t2, i2, o2[a2], s2, 0, 0, n2);
        }
        function Mn(t2, i2, o2, s2, r2, n2, a2) {
          const l2 = t2.context, c2 = t2.transform, h2 = l2.gl, d2 = "globe" === c2.projection.name, u2 = d2 ? ["PROJECTION_GLOBE_VIEW"] : [];
          let _2 = e.bz(o2.projMatrix);
          if (d2 && e.aj(c2.zoom) > 0) {
            const t3 = e.bj(o2.canonical, c2), i3 = e.el(t3);
            _2 = e.aB(new Float32Array(16), c2.globeMatrix, i3), e.aB(_2, c2.projMatrix, _2);
          }
          const p2 = e.bC();
          p2[12] += 2 * r2 / (e.o.devicePixelRatio * c2.width), p2[13] += 2 * n2 / (e.o.devicePixelRatio * c2.height), e.aB(_2, p2, _2);
          const f2 = t2.getOrCreateProgram("debug", { defines: u2 }), m2 = i2.getTileByID(o2.key);
          t2.terrain && t2.terrain.setupElevationDraw(m2, f2);
          const g2 = $i.disabled, v2 = Yi.disabled, y2 = t2.colorModeForRenderPass(), x2 = "$debug";
          l2.activeTexture.set(h2.TEXTURE0), t2.emptyTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), d2 ? m2._makeGlobeTileDebugBuffers(t2.context, c2) : m2._makeDebugTileBoundsBuffers(t2.context, c2.projection);
          const b2 = m2._tileDebugBuffer || t2.debugBuffer, w2 = m2._tileDebugIndexBuffer || t2.debugIndexBuffer, T2 = m2._tileDebugSegments || t2.debugSegments;
          if (f2.draw(t2, h2.LINE_STRIP, g2, v2, y2, Qi.disabled, Ar(_2, s2.toPremultipliedRenderColor(null)), x2, b2, w2, T2, null, null, null, [m2._globeTileDebugBorderBuffer]), a2) {
            const e2 = m2.latestRawTileData, i3 = Math.floor((e2 && e2.byteLength || 0) / 1024);
            let s3 = o2.canonical.toString();
            o2.overscaledZ !== o2.canonical.z && (s3 += ` => ${o2.overscaledZ}`), s3 += ` ${m2.state}`, s3 += ` ${i3}kb`, function(e3, t3) {
              e3.initDebugOverlayCanvas();
              const i4 = e3.debugOverlayCanvas, o3 = e3.context.gl, s4 = e3.debugOverlayCanvas.getContext("2d");
              s4.clearRect(0, 0, i4.width, i4.height), s4.shadowColor = "white", s4.shadowBlur = 2, s4.lineWidth = 1.5, s4.strokeStyle = "white", s4.textBaseline = "top", s4.font = "bold 36px Open Sans, sans-serif", s4.fillText(t3, 5, 5), s4.strokeText(t3, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
            }(t2, s3);
          }
          const E2 = i2.getTile(o2).tileSize, S2 = 512 / Math.min(E2, 512) * (o2.overscaledZ / c2.zoom) * 0.5, I2 = m2._tileDebugTextBuffer || t2.debugBuffer, C2 = m2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, R2 = m2._tileDebugTextSegments || t2.debugSegments;
          f2.draw(t2, h2.TRIANGLES, g2, v2, Wi.alphaBlended, Qi.disabled, Ar(_2, e.ao.transparent.toPremultipliedRenderColor(null), S2), x2, I2, C2, R2, null, null, null, [m2._globeTileDebugTextBuffer]);
        }
        function Fn(e2, t2, i2, o2) {
          kn(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
        }
        function Bn(e2, t2, i2, o2) {
          kn(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
        }
        function kn(t2, i2, o2, s2, r2, n2) {
          const a2 = t2.context, l2 = a2.gl;
          l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.o.devicePixelRatio, o2 * e.o.devicePixelRatio, s2 * e.o.devicePixelRatio, r2 * e.o.devicePixelRatio), a2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
        }
        const Nn = e.ei([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Un } = Nn;
        function jn(e2, t2, i2, o2) {
          e2.emplaceBack(t2, i2, o2);
        }
        class Vn {
          constructor(t2) {
            this.vertexArray = new e.em(), this.indices = new e.b0(), jn(this.vertexArray, -1, -1, 1), jn(this.vertexArray, 1, -1, 1), jn(this.vertexArray, -1, 1, 1), jn(this.vertexArray, 1, 1, 1), jn(this.vertexArray, -1, -1, -1), jn(this.vertexArray, 1, -1, -1), jn(this.vertexArray, -1, 1, -1), jn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Un), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.bg.simpleSegment(0, 0, 36, 12);
          }
        }
        function Gn(t2, i2, o2, s2, r2, n2) {
          const a2 = t2.context.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), d2 = ((e2, t3, i3, o3, s3) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [s3.r, s3.g, s3.b, s3.a], u_luminance: 5e-5 }))(e.eo(e.dO(), s2), r2, h2, l2.toPremultipliedRenderColor(null), c2.toPremultipliedRenderColor(null));
          a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + n2, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, $i.disabled, Yi.disabled, Wi.unblended, Qi.frontCW, d2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
        }
        const Hn = e.ei([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class qn {
          constructor(t2) {
            const i2 = new e.ep();
            i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
            const o2 = new e.b0();
            o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, Hn.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.bg.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const Zn = e.ei([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
        class Wn {
          constructor() {
            this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
          }
        }
        class $n {
          constructor(t2) {
            this.colorModeAlphaBlendedWriteRGB = new Wi([1, Zi, 1, Zi], e.ao.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new Wi([1, 0, 1, 0], e.ao.transparent, [false, false, false, true]), this.params = new Wn(), this.updateNeeded = true;
          }
          update(t2) {
            const i2 = t2.context;
            if (!this.atmosphereBuffer || this.updateNeeded) {
              this.updateNeeded = false, this.atmosphereBuffer = new qn(i2);
              const t3 = this.params.sizeRange, o2 = this.params.intensityRange, s2 = function(t4) {
                const i3 = e.eq(30), o3 = [];
                for (let s3 = 0; s3 < t4; ++s3) {
                  const t5 = 2 * Math.PI * i3(), s4 = Math.acos(1 - 2 * i3()) - 0.5 * Math.PI;
                  o3.push(e.d5(Math.cos(s4) * Math.cos(t5), Math.cos(s4) * Math.sin(t5), Math.sin(s4)));
                }
                return o3;
              }(this.params.starsCount), r2 = e.eq(300), n2 = new e.er(), a2 = new e.b0();
              let l2 = 0;
              for (let i3 = 0; i3 < s2.length; ++i3) {
                const c2 = e.c5([], s2[i3], 200), h2 = Math.max(0, 1 + 0.01 * t3 * (1 * r2() - 0.5)), d2 = Math.max(0, 1 + 0.01 * o2 * (1 * r2() - 0.5));
                n2.emplaceBack(c2[0], c2[1], c2[2], -1, -1, h2, d2), n2.emplaceBack(c2[0], c2[1], c2[2], 1, -1, h2, d2), n2.emplaceBack(c2[0], c2[1], c2[2], 1, 1, h2, d2), n2.emplaceBack(c2[0], c2[1], c2[2], -1, 1, h2, d2), a2.emplaceBack(l2 + 0, l2 + 1, l2 + 2), a2.emplaceBack(l2 + 0, l2 + 2, l2 + 3), l2 += 4;
              }
              this.starsVx = i2.createVertexBuffer(n2, Zn.members), this.starsIdx = i2.createIndexBuffer(a2), this.starsSegments = e.bg.simpleSegment(0, 0, n2.length, a2.length);
            }
          }
          destroy() {
            this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
          }
          drawAtmosphereGlow(t2, i2) {
            const o2 = t2.context, s2 = o2.gl, r2 = t2.transform, n2 = new $i(s2.LEQUAL, $i.ReadOnly, [0, 1]), a2 = e.aj(r2.zoom), l2 = t2.style.getLut(i2.scope), c2 = "none" === i2.properties.get("color-use-theme"), h2 = i2.properties.get("color").toNonPremultipliedRenderColor(c2 ? null : l2), d2 = "none" === i2.properties.get("high-color-use-theme"), u2 = i2.properties.get("high-color").toNonPremultipliedRenderColor(d2 ? null : l2), _2 = "none" === i2.properties.get("space-color-use-theme"), p2 = i2.properties.get("space-color").toNonPremultipliedRenderColor(_2 ? null : l2), f2 = 5e-4, m2 = e.es(i2.properties.get("horizon-blend"), 0, 1, f2, 0.25), g2 = e.dE(t2, o2, r2) && m2 === f2 ? r2.worldSize / (2 * Math.PI * 1.025) - 1 : r2.globeRadius, v2 = t2.frameCounter / 1e3 % 1, y2 = e.ag(r2.globeCenterInViewSpace), x2 = Math.sqrt(Math.pow(y2, 2) - Math.pow(g2, 2)), b2 = Math.acos(x2 / y2), w2 = (e2) => {
              const i3 = "globe" === r2.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
              e2 && i3.push("ALPHA_PASS");
              const l3 = t2.getOrCreateProgram("globeAtmosphere", { defines: i3 }), c3 = ((e3, t3, i4, o3, s3, r3, n3, a3, l4, c4, h3, d4) => ({ u_frustum_tl: e3, u_frustum_tr: t3, u_frustum_br: i4, u_frustum_bl: o3, u_horizon: s3, u_transition: r3, u_fadeout_range: n3, u_atmosphere_fog_color: a3.toArray01(), u_high_color: l4.toArray01(), u_space_color: c4.toArray01(), u_temporal_offset: h3, u_horizon_angle: d4 }))(r2.frustumCorners.TL, r2.frustumCorners.TR, r2.frustumCorners.BR, r2.frustumCorners.BL, r2.frustumCorners.horizon, a2, m2, h2, u2, p2, v2, b2);
              t2.uploadCommonUniforms(o2, l3);
              const d3 = this.atmosphereBuffer;
              d3 && l3.draw(t2, s2.TRIANGLES, n2, Yi.disabled, e2 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Qi.backCW, c3, e2 ? "atmosphere_glow_alpha" : "atmosphere_glow", d3.vertexBuffer, d3.indexBuffer, d3.segments);
            };
            w2(false), w2(true);
          }
          drawStars(t2, i2) {
            const o2 = e.aA(i2.properties.get("star-intensity"), 0, 1);
            if (0 === o2) return;
            const s2 = t2.context, r2 = s2.gl, n2 = t2.transform, a2 = t2.getOrCreateProgram("stars"), l2 = e.c7([]);
            e.c9(l2, l2, -n2._pitch), e.c8(l2, l2, -n2.angle), e.c9(l2, l2, e.an(n2._center.lat)), e.et(l2, l2, -e.an(n2._center.lng));
            const c2 = e.cc(new Float32Array(16), l2), h2 = e.aB([], n2.starsProjMatrix, c2), d2 = e.eo([], c2), u2 = e.eu([], d2), _2 = [0, 1, 0];
            e.dQ(_2, _2, u2), e.c5(_2, _2, this.params.sizeMultiplier);
            const p2 = [1, 0, 0];
            e.dQ(p2, p2, u2), e.c5(p2, p2, this.params.sizeMultiplier);
            const f2 = (m2 = _2, g2 = p2, v2 = o2, { u_matrix: Float32Array.from(h2), u_up: m2, u_right: g2, u_intensity_multiplier: v2 });
            var m2, g2, v2;
            t2.uploadCommonUniforms(s2, a2), this.starsVx && this.starsIdx && a2.draw(t2, r2.TRIANGLES, $i.disabled, Yi.disabled, this.colorModeAlphaBlendedWriteRGB, Qi.disabled, f2, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
          }
        }
        class Xn {
          constructor() {
            this.visibleTiles = [];
          }
          updateBorders(t2, i2) {
            const o2 = [], s2 = [], r2 = t2._getRenderableCoordinates(false, true);
            for (const e2 of r2) {
              const r3 = t2.getTile(e2);
              if (!r3.hasData()) continue;
              const n3 = r3.getBucket(i2);
              n3 && (n3.isEmpty() || (o2.push(e2.key), s2.push({ bucket: n3, tileID: e2.canonical })));
            }
            let n2 = o2.length !== this.visibleTiles.length;
            if (!n2) {
              o2.sort();
              for (let e2 = 0; e2 < o2.length; e2++) if (o2[e2] !== this.visibleTiles[e2]) {
                n2 = true;
                break;
              }
            }
            if (!n2) return;
            const a2 = /* @__PURE__ */ new Set();
            this.visibleTiles = o2, s2.sort((e2, t3) => e2.tileID.z - t3.tileID.z || e2.tileID.x - t3.tileID.x || e2.tileID.y - t3.tileID.y);
            for (const t3 of s2) {
              const i3 = new Array(), o3 = new Array(), s3 = t3.bucket;
              for (const e2 of s3.featuresOnBorder) a2.has(e2.featureId) ? o3.push(e2.footprintIndex) : (a2.add(e2.featureId), i3.push(e2.footprintIndex));
              s3.updateFootprintHiddenFlags(i3, e.ev, false), s3.updateFootprintHiddenFlags(o3, e.ev, true);
            }
          }
        }
        function Yn(t2, i2) {
          const o2 = [...t2], s2 = i2.cameraWorldSizeForFog / i2.worldSize, r2 = e.bA([]);
          return e.cS(r2, r2, [s2, s2, 1]), e.aB(o2, r2, o2), e.aB(o2, i2.worldToFogMatrix, o2), o2;
        }
        function Kn(t2, i2, o2, s2, r2) {
          const n2 = o2.material, a2 = s2.context, { baseColorTexture: l2, metallicRoughnessTexture: c2 } = n2.pbrMetallicRoughness, { normalTexture: h2, occlusionTexture: d2, emissionTexture: u2 } = n2;
          function _2(e2, i3, o3) {
            if (e2 && (t2.push(i3), a2.activeTexture.set(a2.gl.TEXTURE0 + o3), e2.gfxTexture)) {
              const { minFilter: t3, magFilter: i4, wrapS: o4, wrapT: s3 } = e2.sampler;
              e2.gfxTexture.bindExtraParam(t3, i4, o4, s3);
            }
          }
          _2(l2, "HAS_TEXTURE_u_baseColorTexture", 5), _2(c2, "HAS_TEXTURE_u_metallicRoughnessTexture", 6), _2(h2, "HAS_TEXTURE_u_normalTexture", 7), _2(d2, "HAS_TEXTURE_u_occlusionTexture", 8), _2(u2, "HAS_TEXTURE_u_emissionTexture", 9), r2 && (r2.texture || (r2.texture = new e.d$(s2.context, r2.image, [r2.image.height, r2.image.height, r2.image.height], a2.gl.RGBA8)), a2.activeTexture.set(a2.gl.TEXTURE0 + 10), r2.texture && r2.texture.bind(a2.gl.LINEAR, a2.gl.CLAMP_TO_EDGE), t2.push("APPLY_LUT_ON_GPU")), o2.texcoordBuffer && (t2.push("HAS_ATTRIBUTE_a_uv_2f"), i2.push(o2.texcoordBuffer)), o2.colorBuffer && (t2.push(12 === o2.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i2.push(o2.colorBuffer)), o2.normalBuffer && (t2.push("HAS_ATTRIBUTE_a_normal_3f"), i2.push(o2.normalBuffer)), o2.pbrBuffer && (t2.push("HAS_ATTRIBUTE_a_pbr"), t2.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i2.push(o2.pbrBuffer)), "OPAQUE" !== n2.alphaMode && "MASK" !== n2.alphaMode || t2.push("UNPREMULT_TEXTURE_IN_SHADER"), n2.defined || t2.push("DIFFUSE_SHADED");
          const p2 = s2.shadowRenderer;
          p2 && (t2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p2.useNormalOffset && t2.push("NORMAL_OFFSET"));
        }
        function Jn(t2, i2, o2, s2, r2, n2) {
          const a2 = t2.modelOpacity, l2 = i2.context, c2 = new $i(i2.context.gl.LEQUAL, t2.isLightMesh ? $i.ReadOnly : $i.ReadWrite, i2.depthRangeFor3D), h2 = i2.transform, d2 = t2.mesh, u2 = d2.material, _2 = u2.pbrMetallicRoughness, p2 = i2.style.fog;
          let f2;
          f2 = "pixels" === i2.transform.projection.zAxisUnit ? [...t2.nodeModelMatrix] : e.aB([], s2.zScaleMatrix, t2.nodeModelMatrix), e.aB(f2, s2.negCameraPosMatrix, f2);
          const m2 = e.bl([], f2);
          e.eg(m2, m2);
          const g2 = "none" === o2.paint.get("model-color-use-theme").constantOr("default"), v2 = o2.paint.get("model-emissive-strength").constantOr(0), y2 = qr(new Float32Array(t2.worldViewProjection), new Float32Array(f2), new Float32Array(m2), null, i2, a2, _2.baseColorFactor, u2.emissiveFactor, _2.metallicFactor, _2.roughnessFactor, u2, v2, o2, void 0, void 0, t2.materialOverride, t2.modelColor), x2 = { defines: [] }, b2 = [], w2 = i2.shadowRenderer;
          w2 && (w2.useNormalOffset = false), Kn(x2.defines, b2, d2, i2, g2 ? null : o2.lut);
          let T2 = null;
          if (p2) {
            const e2 = Yn(t2.nodeModelMatrix, i2.transform);
            if (T2 = new Float32Array(e2), "globe" !== h2.projection.name) {
              const t3 = d2.aabb.min, i3 = d2.aabb.max, [o3, s3] = p2.getOpacityForBounds(e2, t3[0], t3[1], i3[0], i3[1]);
              x2.overrideFog = o3 >= Ve || s3 >= Ve;
            }
          }
          const E2 = co(i2, o2.paint.get("model-cutoff-fade-range"));
          E2.shouldRenderCutoff && x2.defines.push("RENDER_CUTOFF");
          const S2 = i2.getOrCreateProgram("model", x2);
          i2.uploadCommonUniforms(l2, S2, null, T2, E2), "shadow" !== i2.renderPass && w2 && w2.setupShadowsFromMatrix(t2.nodeModelMatrix, S2), S2.draw(i2, l2.gl.TRIANGLES, c2, r2, n2, d2.material.doubleSided ? Qi.disabled : Qi.backCCW, y2, o2.id, d2.vertexBuffer, d2.indexBuffer, d2.segments, o2.paint, i2.transform.zoom, void 0, b2);
        }
        function Qn(e2, t2) {
          return e2.style._importedAsBasemap ? "basemap" : t2.scope;
        }
        function ea(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2) {
          const d2 = t2.transform, u2 = !!i2.isGeometryBloom && i2.isGeometryBloom;
          if (u2 && "shadow" === t2.renderPass) return;
          const _2 = "globe" === d2.projection.name ? e.eD(o2, d2) : [...o2];
          e.aB(_2, _2, i2.globalMatrix);
          const p2 = e.aB([], s2, _2);
          if (i2.meshes) for (const t3 of i2.meshes) {
            const i3 = l2.get(t3.material.name);
            if (i3 && i3.opacity <= 0) continue;
            if ("BLEND" !== t3.material.alphaMode) {
              a2.push({ mesh: t3, depth: 0, modelIndex: r2, worldViewProjection: p2, nodeModelMatrix: _2, isLightMesh: u2, materialOverride: i3, modelOpacity: c2, modelColor: h2 });
              continue;
            }
            const o3 = e.af([], t3.centroid, p2);
            !d2.isOrthographic && o3[2] <= 0 || n2.push({ mesh: t3, depth: o3[2], modelIndex: r2, worldViewProjection: p2, nodeModelMatrix: _2, isLightMesh: u2, materialOverride: i3, modelOpacity: c2, modelColor: h2 });
          }
          if (i2.children) for (const e2 of i2.children) ea(t2, e2, o2, s2, r2, n2, a2, l2, c2, h2);
        }
        function ta(e2, t2, i2, o2) {
          const s2 = i2.shadowRenderer;
          if (!s2) return;
          const r2 = s2.getShadowPassDepthMode(), n2 = s2.getShadowPassColorMode(), a2 = s2.calculateShadowPassMatrixFromMatrix(t2), l2 = Zr(a2);
          i2.getOrCreateProgram("modelDepth", { defines: i2._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i2, i2.context.gl.TRIANGLES, r2, Yi.disabled, n2, Qi.disabled, l2, o2.id, e2.vertexBuffer, e2.indexBuffer, e2.segments, o2.paint, i2.transform.zoom, void 0, void 0);
        }
        function ia(e2, t2, i2, o2, s2, r2) {
          for (const n2 of s2) {
            const s3 = Object.assign({}, o2);
            s3.part = n2;
            const a2 = { type: "Unknown", id: t2, properties: s3 }, l2 = { orientation: e2.paint.get("model-rotation").evaluate(a2, i2) };
            r2.set(n2, l2);
          }
        }
        function oa(e2, t2, i2, o2, s2, r2) {
          for (const n2 of s2) {
            const s3 = Object.assign({}, o2);
            s3.part = n2;
            const a2 = { type: "Unknown", id: t2, properties: s3 }, l2 = { color: e2.paint.get("model-color").evaluate(a2, i2), colorMix: e2.paint.get("model-color-mix-intensity").evaluate(a2, i2), opacity: e2.paint.get("model-opacity").evaluate(a2, i2), emissionStrength: e2.paint.get("model-emissive-strength").evaluate(a2, i2) };
            r2.set(n2, l2);
          }
        }
        function sa(e2, t2, i2, o2, s2) {
          let r2 = false;
          for (const i3 of o2) 1 !== i3.modelOpacity && (Jn(i3, e2, t2, s2[i3.modelIndex], Yi.disabled, Wi.disabled), r2 = true);
          for (const i3 of o2) Jn(i3, e2, t2, s2[i3.modelIndex], 1 !== i3.modelOpacity ? e2.stencilModeFor3D() : Yi.disabled, e2.colorModeForRenderPass());
          r2 && e2.resetStencilClippingMasks();
          const n2 = Wi.additive;
          for (const o3 of i2) Jn(o3, e2, t2, s2[o3.modelIndex], Yi.disabled, o3.isLightMesh ? n2 : e2.colorModeForRenderPass());
        }
        function ra(t2, i2, o2) {
          const s2 = i2.updateZoomBasedPaintProperties(), r2 = function(t3, i3, o3) {
            let s3, r3, n2, a2 = t3.terrain ? t3.terrain.exaggeration() : 0;
            if (t3.terrain && a2 > 0) {
              const i4 = t3.terrain, r4 = i4.findDEMTileFor(o3);
              r4 && r4.dem ? s3 = e.eF.create(i4, o3, r4) : a2 = 0;
            }
            if (0 === a2 && (i3.terrainElevationMin = 0, i3.terrainElevationMax = 0), a2 === i3.validForExaggeration && (0 === a2 || s3 && s3._demTile && s3._demTile.tileID === i3.validForDEMTile.id && s3._dem._timestamp === i3.validForDEMTile.timestamp)) return false;
            for (const e2 in i3.instancesPerModel) {
              const t4 = i3.instancesPerModel[e2];
              for (let e3 = 0; e3 < t4.instancedDataArray.length; ++e3) {
                const o4 = (s3 ? a2 * s3.getElevationAt(0 | t4.instancedDataArray.float32[16 * e3], 0 | t4.instancedDataArray.float32[16 * e3 + 1], true, true) : 0) + t4.instancesEvaluatedElevation[e3];
                t4.instancedDataArray.float32[16 * e3 + 6] = o4, r3 = r3 ? Math.min(i3.terrainElevationMin, o4) : o4, n2 = n2 ? Math.max(i3.terrainElevationMax, o4) : o4;
              }
            }
            return i3.terrainElevationMin = r3 || 0, i3.terrainElevationMax = n2 || 0, i3.validForExaggeration = a2, i3.validForDEMTile = s3 && s3._demTile ? { id: s3._demTile.tileID, timestamp: s3._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
          }(t2, i2, o2);
          (s2 || r2) && (i2.uploaded = false, i2.upload(t2.context));
        }
        const na = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e.d9([0, 0, 0], [e.al, e.al, 0]) };
        function aa(t2, i2) {
          const o2 = 1 << t2.canonical.z, s2 = i2.getFreeCameraOptions().position, r2 = i2.elevation, n2 = t2.canonical.x / o2, a2 = (t2.canonical.x + 1) / o2, l2 = t2.canonical.y / o2, c2 = (t2.canonical.y + 1) / o2;
          let h2 = i2._centerAltitude;
          if (r2) {
            const e2 = r2.getMinMaxForTile(t2);
            e2 && e2.max > h2 && (h2 = e2.max);
          }
          const d2 = e.aA(s2.x, n2, a2) - s2.x, u2 = e.aA(s2.y, l2, c2) - s2.y, _2 = e.cf(h2, i2.center.lat) - s2.z;
          return i2._zoomFromMercatorZ(Math.sqrt(d2 * d2 + u2 * u2 + _2 * _2));
        }
        function la(e2, t2, i2, o2, s2, r2, n2) {
          const a2 = e2.context, l2 = "shadow" === e2.renderPass, c2 = e2.shadowRenderer, h2 = l2 && c2 ? c2.getShadowPassDepthMode() : new $i(a2.gl.LEQUAL, $i.ReadWrite, e2.depthRangeFor3D), d2 = e2.isTileAffectedByFog(r2), u2 = "globe" === e2.transform.projection.name;
          if (i2.meshes) for (const _2 of i2.meshes) {
            const p2 = u2 ? [] : ["MODEL_POSITION_ON_GPU"], f2 = [];
            let m2, g2, v2;
            const y2 = !u2 && o2.instancedDataArray.length > 20;
            y2 && p2.push("INSTANCED_ARRAYS");
            const x2 = co(e2, t2.paint.get("model-cutoff-fade-range"));
            if (x2.shouldRenderCutoff && p2.push("RENDER_CUTOFF"), l2 && c2) m2 = e2.getOrCreateProgram("modelDepth", { defines: p2 }), g2 = Zr(n2.shadowTileMatrix, n2.shadowTileMatrix, Float32Array.from(i2.globalMatrix)), v2 = c2.getShadowPassColorMode();
            else {
              Kn(p2, f2, _2, e2, "none" === t2.paint.get("model-color-use-theme").constantOr("default") ? null : t2.lut), m2 = e2.getOrCreateProgram("model", { defines: p2, overrideFog: d2 });
              const o3 = _2.material, l3 = o3.pbrMetallicRoughness, h3 = t2.paint.get("model-opacity").constantOr(1), u3 = t2.paint.get("model-emissive-strength").constantOr(0);
              g2 = qr(r2.expandedProjMatrix, Float32Array.from(i2.globalMatrix), new Float32Array(16), null, e2, h3, l3.baseColorFactor, o3.emissiveFactor, l3.metallicFactor, l3.roughnessFactor, o3, u3, t2, s2), c2 && (n2.shadowUniformsInitialized ? m2.setShadowUniformValues(a2, c2.getShadowUniformValues()) : (c2.setupShadows(r2.toUnwrapped(), m2, "model-tile"), n2.shadowUniformsInitialized = true)), v2 = x2.shouldRenderCutoff || h3 < 1 || "OPAQUE" !== o3.alphaMode ? Wi.alphaBlended : Wi.unblended;
            }
            e2.uploadCommonUniforms(a2, m2, r2.toUnwrapped(), null, x2);
            const b2 = _2.material.doubleSided ? Qi.disabled : Qi.backCCW;
            if (y2) f2.push(o2.instancedDataBuffer), m2.draw(e2, a2.gl.TRIANGLES, h2, Yi.disabled, v2, b2, g2, t2.id, _2.vertexBuffer, _2.indexBuffer, _2.segments, t2.paint, e2.transform.zoom, void 0, f2, o2.instancedDataArray.length);
            else {
              const i3 = l2 ? "u_instance" : "u_normal_matrix";
              for (let s3 = 0; s3 < o2.instancedDataArray.length; ++s3) g2[i3] = new Float32Array(o2.instancedDataArray.arrayBuffer, 64 * s3, 16), m2.draw(e2, a2.gl.TRIANGLES, h2, Yi.disabled, v2, b2, g2, t2.id, _2.vertexBuffer, _2.indexBuffer, _2.segments, t2.paint, e2.transform.zoom, void 0, f2);
            }
          }
          if (i2.children) for (const a3 of i2.children) la(e2, t2, a3, o2, s2, r2, n2);
        }
        const ca = [1, -1, 1];
        function ha(t2, i2, o2, s2) {
          if (!o2.modelManager) return true;
          const r2 = o2.modelManager;
          if (!o2.shadowRenderer) return true;
          const n2 = o2.shadowRenderer, a2 = i2.aabb;
          let l2 = true, c2 = t2.maxHeight;
          if (0 === c2) {
            let e2 = 0;
            for (const i3 in t2.instancesPerModel) {
              const t3 = r2.getModel(i3, s2);
              t3 ? e2 = Math.max(e2, Math.max(Math.max(t3.aabb.max[0], t3.aabb.max[1]), t3.aabb.max[2])) : l2 = false;
            }
            c2 = t2.maxScale * e2 * 1.41 + t2.maxVerticalOffset, l2 && (t2.maxHeight = c2);
          }
          a2.max[2] = c2, a2.min[2] += t2.terrainElevationMin, a2.max[2] += t2.terrainElevationMax, e.af(a2.min, a2.min, i2.tileMatrix), e.af(a2.max, a2.max, i2.tileMatrix);
          const h2 = a2.intersects(n2.getCurrentCascadeFrustum());
          return 0 === o2.currentShadowCascade && (t2.isInsideFirstShadowMapFrustum = 2 === h2), 0 === h2;
        }
        function da(t2, i2) {
          const o2 = t2.uniformValues.u_cutoff_params[0], s2 = t2.uniformValues.u_cutoff_params[1], r2 = t2.uniformValues.u_cutoff_params[2], n2 = t2.uniformValues.u_cutoff_params[3];
          return s2 === o2 || n2 === r2 ? 1 : e.aA(((i2 - o2) / (s2 - o2) - r2) / (n2 - r2), 0, 1);
        }
        function ua(t2, i2, o2, s2) {
          if (i2.pitch < 20) return 1;
          const r2 = i2.getWorldToCameraMatrix();
          e.aB(r2, r2, t2);
          const n2 = e.bU(o2.min[0], o2.min[1], o2.min[2], 1);
          let a2 = e.aC(e.eG(), n2, r2), l2 = a2, c2 = a2;
          n2[1] = o2.max[1], a2 = e.aC(e.eG(), n2, r2), l2 = a2[1] < l2[1] ? a2 : l2, c2 = a2[1] > c2[1] ? a2 : c2, n2[0] = o2.max[0], a2 = e.aC(e.eG(), n2, r2), l2 = a2[1] < l2[1] ? a2 : l2, c2 = a2[1] > c2[1] ? a2 : c2, n2[1] = o2.min[1], a2 = e.aC(e.eG(), n2, r2), l2 = a2[1] < l2[1] ? a2 : l2, c2 = a2[1] > c2[1] ? a2 : c2;
          const h2 = e.aA(s2[0], 0, 1), d2 = 100 * i2.pixelsPerMeter * e.aA(s2[1], 0, 1), u2 = e.aA(s2[2], 0, 1), _2 = e.eH(e.eG(), l2, c2, h2), p2 = Math.tan(0.5 * i2.fovX), f2 = -_2[2] * p2;
          if (0 === d2) return _2[1] < -Math.abs(f2) ? u2 : 1;
          const m2 = (-Math.abs(f2) - _2[1]) / d2, g2 = (e2, t3, i3) => (1 - i3) * e2 + i3 * t3, v2 = e.aA(g2(1, u2, m2), u2, 1);
          return g2(1, v2, e.aA((i2.pitch - 20) / 20, 0, 1));
        }
        class _a {
        }
        class pa {
          constructor() {
            this._storage = /* @__PURE__ */ new Map();
          }
          getLinesFromTrianglesBuffer(t2, i2, o2) {
            {
              const e2 = this._storage.get(i2.id);
              if (e2) return e2.lastUsedFrameIdx = t2, e2.buf;
            }
            const s2 = o2.gl, r2 = s2.getBufferParameter(s2.ELEMENT_ARRAY_BUFFER, s2.BUFFER_SIZE), n2 = new ArrayBuffer(r2), a2 = new Int16Array(n2);
            s2.getBufferSubData(s2.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n2));
            const l2 = new e.eJ();
            for (let e2 = 0; e2 < r2 / 2; e2 += 3) {
              const t3 = a2[e2], i3 = a2[e2 + 1], o3 = a2[e2 + 2];
              l2.emplaceBack(t3, i3), l2.emplaceBack(i3, o3), l2.emplaceBack(o3, t3);
            }
            const c2 = o2.bindVertexArrayOES.current, h2 = new _a();
            return h2.buf = new $r(o2, l2), h2.lastUsedFrameIdx = t2, this._storage.set(i2.id, h2), o2.bindVertexArrayOES.set(c2), h2.buf;
          }
          update(e2) {
            for (const [t2, i2] of this._storage) e2 - i2.lastUsedFrameIdx > 30 && (i2.buf.destroy(), this._storage.delete(t2));
          }
          destroy() {
            for (const [e2, t2] of this._storage) t2.buf.destroy(), this._storage.delete(e2);
          }
        }
        class fa {
          constructor() {
            this.occluderSize = 30, this.depthOffset = -1e-4;
          }
        }
        const ma = e.ei([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
        class ga {
          constructor(e2) {
            this.revealStart = 11, this.revealRange = 2;
          }
        }
        const va = e.ei([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
        class ya {
          destroy() {
            this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
          }
          draw(t2, i2) {
            const o2 = t2.getOrCreateProgram("vignette");
            if (!this.vignetteVx || !this.vignetteIdx) {
              const i3 = new e.eK(), o3 = new e.b0();
              i3.emplaceBack(-1, -1), i3.emplaceBack(1, -1), i3.emplaceBack(1, 1), i3.emplaceBack(-1, 1), o3.emplaceBack(0, 1, 2), o3.emplaceBack(0, 2, 3), this.vignetteVx = t2.context.createVertexBuffer(i3, va.members), this.vignetteIdx = t2.context.createIndexBuffer(o3);
            }
            const s2 = e.bg.simpleSegment(0, 0, 4, 6);
            if (this.vignetteVx && this.vignetteIdx) {
              t2.uploadCommonUniforms(t2.context, o2);
              const e2 = { u_vignetteShape: (r2 = { vignetteShape: [i2.start, i2.range, Math.pow(10, i2.fadePower)], vignetteColor: [i2.color.r, i2.color.g, i2.color.b, i2.color.a * i2.strength] }).vignetteShape, u_vignetteColor: r2.vignetteColor };
              o2.draw(t2, t2.context.gl.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, e2, "vignette", this.vignetteVx, this.vignetteIdx, s2);
            }
            var r2;
          }
        }
        class xa {
          constructor() {
            this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
          }
          update(t2, i2) {
            const o2 = t2.getFreeCameraOptions().position, s2 = o2.toAltitude(), r2 = o2.toLngLat(), n2 = e.an(r2.lng), a2 = e.an(r2.lat), l2 = t2.pixelsPerMeter / i2, c2 = n2 * e.eM, h2 = e.eM * Math.log(Math.tan(Math.PI / 4 + a2 / 2));
            if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            else {
              const e2 = -this._offsetYPrev + h2, t3 = -this._elevationPrev + s2;
              this._accumulatedOffsetX += (-this._offsetXPrev + c2) * l2, this._accumulatedOffsetY += e2 * l2, this._accumulatedElevation += t3 * l2, this._offsetXPrev = c2, this._offsetYPrev = h2, this._elevationPrev = s2;
            }
          }
          getPosition() {
            return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
          }
        }
        function ba(e2, t2) {
          return [-(e2[0] - Math.floor(e2[0] / t2) * t2), -(e2[1] - Math.floor(e2[1] / t2) * t2), -(e2[2] - Math.floor(e2[2] / t2) * t2)];
        }
        function wa(t2) {
          const i2 = e.eq(1323123451230), o2 = [];
          for (let s2 = 0; s2 < t2; ++s2) {
            const t3 = 2 * i2() - 1, s3 = 2 * i2() - 1, r2 = 2 * i2() - 1;
            o2.push(e.d5(t3, s3, r2));
          }
          return o2;
        }
        function Ta(t2, i2, o2, s2, r2) {
          const n2 = e.aA((r2 - o2) / (s2 - o2), 0, 1);
          return (1 - n2) * t2 + n2 * i2;
        }
        class Ea {
          constructor(e2) {
            this._movement = new xa(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new ya(), this._ppmScaleFactor = e2;
          }
          destroy() {
            this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
          }
          updateOnRender(t2, i2) {
            const o2 = t2.transform;
            this._movement.update(o2, this._ppmScaleFactor);
            const s2 = o2.starsProjMatrix, r2 = e.c7([]);
            e.c9(r2, r2, e.an(90) - o2._pitch), e.c8(r2, r2, -o2.angle);
            const n2 = e.cc(new Float32Array(16), r2), a2 = e.eL(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l2 = e.eg([], a2), c2 = e.aB([], l2, n2), h2 = Date.now() / 1e3;
            return this._accumulatedTimeFromStart += (h2 - this._prevTime) * i2, this._prevTime = h2, { projectionMatrix: s2, modelviewMatrix: c2 };
          }
        }
        class Sa extends Ea {
          constructor(e2) {
            super(4.25), this._params = { overrideStyleParameters: false, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new ga("Precipitation > Rain"), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
          }
          update(t2) {
            const i2 = t2.context;
            if (!this.particlesVx) {
              const t3 = wa(this.particlesCount), o2 = new e.eN(), s2 = new e.b0();
              let r2 = 0;
              const n2 = e.eq(1323123451230);
              for (let e2 = 0; e2 < t3.length; ++e2) {
                const i3 = t3[e2], a2 = [2 * n2() - 1, n2(), n2(), n2()];
                o2.emplaceBack(i3[0], i3[1], i3[2], -1, -1, ...a2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, -1, ...a2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, 1, ...a2), o2.emplaceBack(i3[0], i3[1], i3[2], -1, 1, ...a2), s2.emplaceBack(r2 + 0, r2 + 1, r2 + 2), s2.emplaceBack(r2 + 0, r2 + 2, r2 + 3), r2 += 4;
              }
              this.particlesVx = i2.createVertexBuffer(o2, ma.members), this.particlesIdx = i2.createIndexBuffer(s2);
            }
          }
          draw(t2) {
            if (!this._params.overrideStyleParameters && !t2.style.rain) return;
            const i2 = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, o2 = t2.transform.zoom;
            if (i2.revealStart > o2) return;
            const s2 = Ta(0, 1, i2.revealStart, i2.revealStart + i2.revealRange, o2);
            if (!this.particlesVx || !this.particlesIdx) return;
            const r2 = structuredClone(this._params);
            let n2 = [-r2.direction.x, r2.direction.y, -100];
            e.aw(n2, n2);
            const a2 = structuredClone(this._vignetteParams);
            a2.strength *= s2, r2.overrideStyleParameters || (r2.intensity = t2.style.rain.state.density, r2.timeFactor = t2.style.rain.state.intensity, r2.color = structuredClone(t2.style.rain.state.color), n2 = structuredClone(t2.style.rain.state.direction), r2.screenThinning.intensity = t2.style.rain.state.centerThinning, r2.dropletSizeX = t2.style.rain.state.dropletSize[0], r2.dropletSizeYScale = t2.style.rain.state.dropletSize[1] / t2.style.rain.state.dropletSize[0], r2.distortionStrength = 100 * t2.style.rain.state.distortionStrength, a2.strength = 1, a2.color = structuredClone(t2.style.rain.state.vignetteColor));
            const l2 = this.updateOnRender(t2, r2.timeFactor), c2 = t2.context, h2 = c2.gl, d2 = t2.transform;
            this.screenTexture && this.screenTexture.size[0] === t2.width && this.screenTexture.size[1] === t2.height || (this.screenTexture = new e.T(c2, { width: t2.width, height: t2.height, data: null }, h2.RGBA8)), r2.distortionStrength > 0 && (c2.activeTexture.set(h2.TEXTURE0), this.screenTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), h2.copyTexSubImage2D(h2.TEXTURE_2D, 0, 0, 0, 0, 0, t2.width, t2.height));
            const u2 = t2.getOrCreateProgram("rainParticle");
            t2.uploadCommonUniforms(c2, u2), c2.activeTexture.set(h2.TEXTURE0), this.screenTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE);
            const _2 = [r2.color.r, r2.color.g, r2.color.b, r2.color.a], p2 = (i3, o3) => {
              const s3 = ba(this._movement.getPosition(), i3), a3 = r2.dropletSizeX, c3 = r2.dropletSizeX * r2.dropletSizeYScale, p3 = t2.width / 2, f2 = t2.height / 2, m2 = Ta(0, r2.screenThinning.start, 0, 1, r2.screenThinning.intensity), g2 = Ta(1e-3, r2.screenThinning.range, 0, 1, r2.screenThinning.intensity), v2 = Ta(0, r2.screenThinning.particleOffset, 0, 1, r2.screenThinning.intensity), y2 = (x2 = { modelview: l2.modelviewMatrix, projection: l2.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: s3, velocityConeAperture: r2.velocityConeAperture, velocity: r2.velocity, boxSize: i3, rainDropletSize: [a3, c3], distortionStrength: r2.distortionStrength, rainDirection: n2, color: _2, screenSize: [d2.width, d2.height], thinningCenterPos: [p3, f2], thinningShape: [m2, g2, Math.pow(10, r2.screenThinning.fadePower)], thinningAffectedRatio: r2.screenThinning.affectedRatio, thinningParticleOffset: v2, shapeDirectionalPower: r2.shapeDirPower, shapeNormalPower: r2.shapeNormalPower, mode: o3 ? 0 : 1 }, { u_modelview: Float32Array.from(x2.modelview), u_projection: Float32Array.from(x2.projection), u_time: x2.time, u_cam_pos: x2.camPos, u_texScreen: 0, u_velocityConeAperture: x2.velocityConeAperture, u_velocity: x2.velocity, u_boxSize: x2.boxSize, u_rainDropletSize: x2.rainDropletSize, u_distortionStrength: x2.distortionStrength, u_rainDirection: x2.rainDirection, u_color: x2.color, u_screenSize: x2.screenSize, u_thinningCenterPos: x2.thinningCenterPos, u_thinningShape: x2.thinningShape, u_thinningAffectedRatio: x2.thinningAffectedRatio, u_thinningParticleOffset: x2.thinningParticleOffset, u_shapeDirectionalPower: x2.shapeDirectionalPower, u_shapeNormalPower: x2.shapeNormalPower, u_mode: x2.mode });
              var x2;
              const b2 = Math.round(r2.intensity * this.particlesCount), w2 = e.bg.simpleSegment(0, 0, 4 * b2, 2 * b2);
              u2.draw(t2, h2.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, y2, "rain_particles", this.particlesVx, this.particlesIdx, w2);
            };
            r2.distortionStrength > 0 && p2(r2.boxSize, true), p2(r2.boxSize, false), this._vignette.draw(t2, a2);
          }
        }
        const Ia = e.ei([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
        class Ca extends Ea {
          constructor(e2) {
            super(2.25), this._params = { overrideStyleParameters: false, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new ga("Precipitation > Snow"), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
          }
          update(t2) {
            const i2 = t2.context;
            if (!this.particlesVx) {
              const t3 = wa(this.particlesCount), o2 = new e.eO(), s2 = new e.b0();
              let r2 = 0;
              const n2 = e.eq(1323123451230);
              for (let e2 = 0; e2 < t3.length; ++e2) {
                const i3 = t3[e2], a2 = n2(), l2 = n2(), c2 = n2(), h2 = [e2 / t3.length, a2, l2, c2], d2 = [n2(), n2()];
                o2.emplaceBack(i3[0], i3[1], i3[2], -1, -1, ...h2, ...d2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, -1, ...h2, ...d2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, 1, ...h2, ...d2), o2.emplaceBack(i3[0], i3[1], i3[2], -1, 1, ...h2, ...d2), s2.emplaceBack(r2 + 0, r2 + 1, r2 + 2), s2.emplaceBack(r2 + 0, r2 + 2, r2 + 3), r2 += 4;
              }
              this.particlesVx = i2.createVertexBuffer(o2, Ia.members), this.particlesIdx = i2.createIndexBuffer(s2);
            }
          }
          draw(t2) {
            if (!this._params.overrideStyleParameters && !t2.style.snow) return;
            const i2 = structuredClone(this._params);
            let o2 = [-i2.direction.x, i2.direction.y, -100];
            e.aw(o2, o2);
            const s2 = structuredClone(this._vignetteParams), r2 = i2.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, n2 = t2.transform.zoom;
            if (r2.revealStart > n2) return;
            const a2 = Ta(0, 1, r2.revealStart, r2.revealStart + r2.revealRange, n2);
            s2.strength *= a2, i2.overrideStyleParameters || (i2.intensity = t2.style.snow.state.density, i2.timeFactor = t2.style.snow.state.intensity, i2.color = structuredClone(t2.style.snow.state.color), o2 = structuredClone(t2.style.snow.state.direction), i2.screenThinning.intensity = t2.style.snow.state.centerThinning, i2.billboardSize = 2.79 * t2.style.snow.state.flakeSize, s2.strength = 1, s2.color = structuredClone(t2.style.snow.state.vignetteColor));
            const l2 = this.updateOnRender(t2, i2.timeFactor);
            if (!this.particlesVx || !this.particlesIdx) return;
            const c2 = t2.context, h2 = c2.gl, d2 = t2.transform, u2 = t2.getOrCreateProgram("snowParticle");
            t2.uploadCommonUniforms(c2, u2), ((i3, s3, r3) => {
              const n3 = ba(this._movement.getPosition(), i3), a3 = d2.width / 2, c3 = d2.height / 2, _2 = Ta(0, r3.screenThinning.start, 0, 1, r3.screenThinning.intensity), p2 = Ta(1e-3, r3.screenThinning.range, 0, 1, r3.screenThinning.intensity), f2 = Ta(0, r3.screenThinning.particleOffset, 0, 1, r3.screenThinning.intensity), m2 = (g2 = { modelview: l2.modelviewMatrix, projection: l2.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: n3, velocityConeAperture: r3.velocityConeAperture, velocity: r3.velocity, horizontalOscillationRadius: r3.horizontalOscillationRadius, horizontalOscillationRate: r3.horizontalOscillationRate, boxSize: i3, billboardSize: 1 * r3.billboardSize, simpleShapeParameters: [r3.shapeFadeStart, r3.shapeFadePower], screenSize: [d2.width, d2.height], thinningCenterPos: [a3, c3], thinningShape: [_2, p2, Math.pow(10, r3.screenThinning.fadePower)], thinningAffectedRatio: r3.screenThinning.affectedRatio, thinningParticleOffset: f2, color: [r3.color.r, r3.color.g, r3.color.b, r3.color.a], direction: o2 }, { u_modelview: Float32Array.from(g2.modelview), u_projection: Float32Array.from(g2.projection), u_time: g2.time, u_cam_pos: g2.camPos, u_velocityConeAperture: g2.velocityConeAperture, u_velocity: g2.velocity, u_horizontalOscillationRadius: g2.horizontalOscillationRadius, u_horizontalOscillationRate: g2.horizontalOscillationRate, u_boxSize: g2.boxSize, u_billboardSize: g2.billboardSize, u_simpleShapeParameters: g2.simpleShapeParameters, u_screenSize: g2.screenSize, u_thinningCenterPos: g2.thinningCenterPos, u_thinningShape: g2.thinningShape, u_thinningAffectedRatio: g2.thinningAffectedRatio, u_thinningParticleOffset: g2.thinningParticleOffset, u_particleColor: g2.color, u_direction: g2.direction });
              var g2;
              const v2 = Math.round(r3.intensity * this.particlesCount), y2 = e.bg.simpleSegment(0, 0, 4 * v2, 2 * v2);
              this.particlesVx && this.particlesIdx && u2.draw(t2, h2.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, m2, "snow_particles", this.particlesVx, this.particlesIdx, y2);
            })(i2.boxSize, 0, i2), this._vignette.draw(t2, s2);
          }
        }
        const Ra = { symbol: function(t2, i2, o2, s2, r2) {
          if ("translucent" !== t2.renderPass) return;
          const n2 = Yi.disabled, a2 = t2.colorModeForRenderPass(), l2 = o2.layout.get("text-variable-anchor"), c2 = o2.layout.get("text-size-scale-range"), h2 = e.aA(t2.scaleFactor, c2[0], c2[1]);
          l2 && function(t3, i3, o3, s3, r3, n3, a3, l3) {
            const c3 = i3.transform, h3 = "map" === r3, d3 = "map" === n3;
            for (const i4 of t3) {
              const t4 = s3.getTile(i4), r4 = t4.getBucket(o3);
              if (!r4 || !r4.text || !r4.text.segments.get().length) continue;
              const n4 = e.bK(r4.textSizeData, c3.zoom, l3), u3 = Qt(i4, r4.getProjection(), c3), _2 = c3.calculatePixelsToTileUnitsMatrix(t4), p2 = oi(u3, t4.tileID.canonical, d3, h3, c3, r4.getProjection(), _2), f2 = r4.hasIconTextFit() && r4.hasIconData();
              n4 && rn(r4, h3, d3, a3, c3, p2, i4, Math.pow(2, c3.zoom - t4.tileID.overscaledZ), n4, f2);
            }
          }(s2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), r2, h2);
          const d2 = 0 !== o2.paint.get("icon-opacity").constantOr(1), u2 = 0 !== o2.paint.get("text-opacity").constantOr(1);
          void 0 !== o2.layout.get("symbol-sort-key").constantOr(1) && (d2 || u2) ? nn(t2, i2, o2, s2, n2, a2) : (d2 && nn(t2, i2, o2, s2, n2, a2, { onlyIcons: true }), u2 && nn(t2, i2, o2, s2, n2, a2, { onlyText: true })), i2.map.showCollisionBoxes && (en(t2, i2, o2, s2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), en(t2, i2, o2, s2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
        }, circle: function(t2, i2, o2, s2) {
          if ("translucent" !== t2.renderPass) return;
          const r2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1), c2 = o2.paint.get("circle-emissive-strength");
          if (0 === r2.constantOr(1) && (0 === n2.constantOr(1) || 0 === a2.constantOr(1))) return;
          const h2 = t2.context, d2 = h2.gl, u2 = t2.transform, _2 = !(!t2.terrain || !t2.terrain.enabled), p2 = o2.layout.get("circle-elevation-reference"), f2 = t2.depthModeForSublayer(0, $i.ReadOnly), m2 = new $i(t2.context.gl.LEQUAL, $i.ReadOnly, t2.depthRangeFor3D), g2 = "none" === p2 || _2 ? f2 : m2, v2 = Yi.disabled, y2 = t2.colorModeForDrapableLayerRenderPass(c2), x2 = "globe" === u2.projection.name, b2 = [e.aF(u2.center.lng), e.aJ(u2.center.lat)], w2 = [];
          for (let r3 = 0; r3 < s2.length; r3++) {
            const n3 = s2[r3], a3 = i2.getTile(n3), c3 = a3.getBucket(o2);
            if (!c3 || c3.projection.name !== u2.projection.name) continue;
            const h3 = c3.programConfigurations.get(o2.id), d3 = c3.layoutVertexBuffer, _3 = c3.globeExtVertexBuffer, p3 = c3.indexBuffer, f3 = e.e0(o2), m3 = [_3], g3 = t2.isTileAffectedByFog(n3);
            x2 && f3.push("PROJECTION_GLOBE_VIEW"), f3.push("DEPTH_D24"), t2.terrain && u2.depthOcclusionForSymbolsAndCircles && f3.push("DEPTH_OCCLUSION"), c3.hasElevation && !t2.terrain && (f3.push("ELEVATED_ROADS"), m3.push(c3.elevatedLayoutVertexBuffer));
            const v3 = t2.getOrCreateProgram("circle", { config: h3, defines: f3, overrideFog: g3 }), y3 = u2.projection.createInversionMatrix(u2, n3.canonical), T3 = { programConfiguration: h3, program: v3, layoutVertexBuffer: d3, dynamicBuffers: m3, indexBuffer: p3, uniformValues: e.e1(t2, n3, a3, y3, b2, o2), tile: a3 };
            if (l2) {
              const t3 = c3.segments.get();
              for (const i3 of t3) w2.push({ segments: new e.bg([i3]), sortKey: i3.sortKey, state: T3 });
            } else w2.push({ segments: c3.segments, sortKey: 0, state: T3 });
          }
          l2 && w2.sort((e2, t3) => e2.sortKey - t3.sortKey);
          const T2 = { useDepthForOcclusion: u2.depthOcclusionForSymbolsAndCircles };
          for (const e2 of w2) {
            const { programConfiguration: i3, program: s3, layoutVertexBuffer: r3, dynamicBuffers: n3, indexBuffer: a3, uniformValues: l3, tile: c3 } = e2.state, _3 = e2.segments;
            t2.terrain && t2.terrain.setupElevationDraw(c3, s3, T2), t2.uploadCommonUniforms(h2, s3, c3.tileID.toUnwrapped()), s3.draw(t2, d2.TRIANGLES, g2, v2, y2, Qi.disabled, l3, o2.id, r3, a3, _3, o2.paint, u2.zoom, i3, n3);
          }
        }, heatmap: function(t2, i2, o2, s2) {
          if (0 !== o2.paint.get("heatmap-opacity")) if ("offscreen" === t2.renderPass) {
            const r2 = t2.context, n2 = r2.gl, a2 = Yi.disabled, l2 = new Wi([n2.ONE, n2.ONE, n2.ONE, n2.ONE], e.ao.transparent, [true, true, true, true]);
            !function(e2, t3, i3, o3) {
              const s3 = e2.gl, r3 = t3.width * o3, n3 = t3.height * o3;
              e2.activeTexture.set(s3.TEXTURE1), e2.viewport.set([0, 0, r3, n3]);
              let a3 = i3.heatmapFbo;
              if (!a3 || a3 && (a3.width !== r3 || a3.height !== n3)) {
                a3 && a3.destroy();
                const t4 = s3.createTexture();
                s3.bindTexture(s3.TEXTURE_2D, t4), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_MAG_FILTER, s3.LINEAR), a3 = i3.heatmapFbo = e2.createFramebuffer(r3, n3, 1, null), function(e3, t5, i4, o4, s4, r4) {
                  const n4 = e3.gl;
                  n4.texImage2D(n4.TEXTURE_2D, 0, e3.extRenderToTextureHalfFloat ? n4.RGBA16F : n4.RGBA, s4, r4, 0, n4.RGBA, e3.extRenderToTextureHalfFloat ? n4.HALF_FLOAT : n4.UNSIGNED_BYTE, null), o4.colorAttachment0.set(i4);
                }(e2, 0, t4, a3, r3, n3);
              } else s3.bindTexture(s3.TEXTURE_2D, a3.colorAttachment0.get()), e2.bindFramebuffer.set(a3.framebuffer);
            }(r2, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), r2.clear({ color: e.ao.transparent });
            const c2 = t2.transform, h2 = "globe" === c2.projection.name, d2 = h2 ? ["PROJECTION_GLOBE_VIEW"] : [], u2 = h2 ? Qi.frontCCW : Qi.disabled, _2 = [e.aF(c2.center.lng), e.aJ(c2.center.lat)];
            for (let e2 = 0; e2 < s2.length; e2++) {
              const p2 = s2[e2];
              if (i2.hasRenderableParent(p2)) continue;
              const f2 = i2.getTile(p2), m2 = f2.getBucket(o2);
              if (!m2 || m2.projection.name !== c2.projection.name) continue;
              const g2 = t2.isTileAffectedByFog(p2), v2 = m2.programConfigurations.get(o2.id), y2 = t2.getOrCreateProgram("heatmap", { config: v2, defines: d2, overrideFog: g2 }), { zoom: x2 } = t2.transform;
              t2.terrain && t2.terrain.setupElevationDraw(f2, y2), t2.uploadCommonUniforms(r2, y2, p2.toUnwrapped());
              const b2 = c2.projection.createInversionMatrix(c2, p2.canonical);
              y2.draw(t2, n2.TRIANGLES, $i.disabled, a2, l2, u2, Dr(t2, p2, f2, b2, _2, x2, o2.paint.get("heatmap-intensity")), o2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, o2.paint, t2.transform.zoom, v2, h2 ? [m2.globeExtVertexBuffer] : null);
            }
            r2.viewport.set([0, 0, t2.width, t2.height]);
          } else "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
            const o3 = t3.context, s3 = o3.gl, r2 = i3.heatmapFbo;
            if (!r2) return;
            o3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_2D, r2.colorAttachment0.get()), o3.activeTexture.set(s3.TEXTURE1);
            let n2 = i3.colorRampTexture;
            n2 || (n2 = i3.colorRampTexture = new e.T(o3, i3.colorRamp, s3.RGBA8)), n2.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), t3.getOrCreateProgram("heatmapTexture").draw(t3, s3.TRIANGLES, $i.disabled, Yi.disabled, t3.colorModeForRenderPass(), Qi.disabled, ((e2, t4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
          }(t2, o2));
        }, line: function(t2, i2, o2, s2) {
          if ("translucent" !== t2.renderPass) return;
          const r2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
          if (0 === r2.constantOr(1) || 0 === n2.constantOr(1)) return;
          const a2 = o2.paint.get("line-emissive-strength").isConstant(), l2 = o2.paint.get("line-emissive-strength").constantOr(0), c2 = o2.paint.get("line-occlusion-opacity"), h2 = o2.layout.get("line-elevation-reference"), d2 = "meters" === o2.layout.get("line-width-unit"), u2 = "sea" === h2, _2 = !(!t2.terrain || !t2.terrain.enabled), p2 = t2.context, f2 = p2.gl;
          if (o2.hasElevatedBuckets && "globe" === t2.transform.projection.name) return;
          const m2 = o2.layout.get("line-cross-slope"), g2 = void 0 !== m2, v2 = m2 < 1, y2 = t2.colorModeForDrapableLayerRenderPass(a2 ? l2 : null), x2 = t2.terrain && t2.terrain.renderingToTexture, b2 = x2 ? 1 : e.o.devicePixelRatio, w2 = o2.paint.get("line-dasharray"), T2 = w2.constantOr(1), E2 = o2.layout.get("line-cap"), S2 = w2.constantOr(null), I2 = E2.constantOr(null), C2 = o2.paint.get("line-pattern"), R2 = C2.constantOr(1), A2 = o2.paint.get("line-pattern-cross-fade"), L2 = C2.constantOr(null), D2 = o2.paint.get("line-opacity").constantOr(1);
          let P2 = !R2 && 1 !== D2 || t2.depthOcclusion && c2 > 0 && c2 < 1;
          const O2 = o2.paint.get("line-gradient"), z2 = R2 ? "linePattern" : "line", M2 = e.e2(o2);
          let F2;
          if (x2 && t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (P2 = false), 0 !== c2 && t2.depthOcclusion) {
            const t3 = o2.paint._values["line-opacity"];
            t3 && t3.value && "constant" === t3.value.kind ? F2 = t3.value : e.w(`Occlusion opacity for layer ${o2.id} is supported only when line-opacity isn't data-driven.`);
          }
          "constant" !== n2.value.kind && false === n2.value.isLineProgressConstant && M2.push("VARIABLE_LINE_WIDTH"), x2 && ("dual-source-blending" !== t2.emissiveMode || a2 ? "mrt-fallback" === t2.emissiveMode && M2.push("USE_MRT1") : M2.push("DUAL_SOURCE_BLENDING"));
          const B2 = (s3, r3, n3, a3, l3, h3) => {
            for (const _3 of s3) {
              const s4 = i2.getTile(_3);
              if (R2 && !s4.patternsLoaded()) continue;
              const m3 = s4.getBucket(o2);
              if (!m3) continue;
              if ("none" !== m3.elevationType && !l3 || "none" === m3.elevationType && l3) continue;
              t2.prepareDrawTile();
              const g3 = [...r3], v3 = t2.shadowRenderer, w3 = "road" === m3.elevationType && !!v3 && v3.enabled;
              let E3 = [0, 0, 0];
              if (w3) {
                const e2 = t2.style.directionalLight, i3 = t2.style.ambientLight;
                e2 && i3 && (E3 = go(t2.style, e2, i3)), g3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
              }
              const C3 = m3.programConfigurations.get(o2.id);
              let M3 = false;
              if (L2 && s4.imageAtlas) {
                const t3 = e.e3.from(L2), i3 = t3.getPrimary().scaleSelf(b2).toString(), o3 = s4.imageAtlas.patternPositions.get(i3), r4 = t3.getSecondary(), n4 = r4 ? s4.imageAtlas.patternPositions.get(r4.scaleSelf(b2).toString()) : null;
                M3 = !!o3 && !!n4, o3 && C3.setConstantPatternPositions(o3, n4);
              }
              A2 > 0 && (M3 || C3.getPatternTransitionVertexBuffer("line-pattern")) && g3.push("LINE_PATTERN_TRANSITION");
              const B3 = t2.isTileAffectedByFog(_3), k3 = t2.getOrCreateProgram(z2, { config: C3, defines: g3, overrideFog: B3 });
              if (!R2 && S2 && I2 && s4.lineAtlas) {
                const e2 = s4.lineAtlas.getDash(S2, I2);
                e2 && C3.setConstantPatternPositions(e2);
              }
              w3 && v3.setupShadows(s4.tileID.toUnwrapped(), k3, "vector-tile");
              let [N3, U2] = o2.paint.get("line-trim-offset");
              if ("round" === I2 || "square" === I2) {
                const e2 = 1;
                N3 !== U2 && (0 === N3 && (N3 -= e2), 1 === U2 && (U2 += e2));
              }
              const j2 = x2 ? _3.projMatrix : null, V2 = d2 ? 1 / m3.tileToMeter / e.ay(s4, 1, t2.transform.zoom) : 1, G2 = d2 ? 1 / m3.tileToMeter / e.ay(s4, 1, Math.floor(t2.transform.zoom)) : 1, H2 = R2 ? e.e4(t2, s4, o2, j2, b2, V2, G2, [N3, U2], E3, A2) : e.e5(t2, s4, o2, j2, m3.lineClipsArray.length, b2, V2, G2, [N3, U2], E3);
              if (O2) {
                const s5 = m3.gradients[o2.id];
                let r4 = s5.texture;
                if (o2.gradientVersion !== s5.version) {
                  let n4 = 256;
                  if (o2.stepInterpolant) {
                    const o3 = i2.getSource().maxzoom, s6 = _3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - _3.canonical.z) : 1;
                    n4 = e.aA(e.e6(m3.maxLineLength / e.al * 1024 * s6), 256, p2.maxTextureSize);
                  }
                  s5.gradient = e.e7({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: n4, image: s5.gradient || void 0, clips: m3.lineClipsArray }), s5.texture ? s5.texture.update(s5.gradient) : s5.texture = new e.T(p2, s5.gradient, f2.RGBA8), s5.version = o2.gradientVersion, r4 = s5.texture;
                }
                p2.activeTexture.set(f2.TEXTURE1), r4.bind(o2.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
              }
              T2 && (p2.activeTexture.set(f2.TEXTURE0), s4.lineAtlasTexture && s4.lineAtlasTexture.bind(f2.LINEAR, f2.REPEAT), C3.updatePaintBuffers()), R2 && (p2.activeTexture.set(f2.TEXTURE0), s4.imageAtlasTexture && s4.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), C3.updatePaintBuffers()), l3 && !u2 && t2.terrain.setupElevationDraw(s4, k3), t2.uploadCommonUniforms(p2, k3, _3.toUnwrapped());
              const q2 = (e2) => {
                null != F2 && (F2.value = D2 * c2), k3.draw(t2, f2.TRIANGLES, n3, e2, y2, Qi.disabled, H2, o2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, o2.paint, t2.transform.zoom, C3, [m3.layoutVertexBuffer2, m3.patternVertexBuffer, m3.zOffsetVertexBuffer]), null != F2 && (F2.value = D2);
              };
              if (P2 && !l3) {
                const e2 = t2.stencilModeForClipping(_3).ref;
                0 === e2 && x2 && p2.clear({ stencil: 0 });
                const i3 = { func: f2.EQUAL, mask: 255 };
                H2.u_alpha_discard_threshold = 0.8, q2(new Yi(i3, e2, 255, f2.KEEP, f2.KEEP, f2.INVERT)), H2.u_alpha_discard_threshold = 0, q2(new Yi(i3, e2, 255, f2.KEEP, f2.KEEP, f2.KEEP));
              } else H2.u_alpha_discard_threshold = P2 && l3 && h3 ? 0.8 : 0, q2(l3 ? a3 : t2.stencilModeForClipping(_3));
            }
          };
          let k2 = t2.depthModeForSublayer(0, $i.ReadOnly);
          const N2 = new $i(t2.depthOcclusion ? f2.GREATER : f2.LEQUAL, $i.ReadOnly, t2.depthRangeFor3D);
          if (o2.hasNonElevatedBuckets) {
            const i3 = !x2 && t2.terrain;
            0 !== c2 && i3 ? e.w(`Occlusion opacity for layer ${o2.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i3 ? e.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o2.id}.`) : B2(s2, M2, k2, Yi.disabled, false, true);
          }
          if (o2.hasElevatedBuckets) {
            "hd-road-markup" === h2 ? _2 || (k2 = N2, M2.push("ELEVATED_ROADS")) : (M2.push("ELEVATED"), k2 = N2, g2 && M2.push(v2 ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), u2 && M2.push("ELEVATION_REFERENCE_SEA"));
            const e2 = P2 ? t2.stencilModeFor3D() : Yi.disabled;
            t2.forceTerrainMode = true, B2(s2, M2, k2, e2, true, true), P2 && B2(s2, M2, k2, e2, true, false), t2.forceTerrainMode = false;
          }
          P2 && (t2.resetStencilClippingMasks(), x2 && p2.clear({ stencil: 0 })), 0 === c2 || t2.depthOcclusion || x2 || t2.layersWithOcclusionOpacity.push(t2.currentLayer);
        }, fill: function(t2, i2, o2, s2) {
          const r2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
          if (0 === n2.constantOr(1)) return;
          const a2 = o2.paint.get("fill-emissive-strength"), l2 = t2.colorModeForDrapableLayerRenderPass(a2), c2 = o2.paint.get("fill-pattern"), h2 = t2.opaquePassEnabledForLayer() && !c2.constantOr(1) && 1 === r2.constantOr(e.ao.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
          let d2 = "none";
          "none" !== o2.layout.get("fill-elevation-reference") ? d2 = "road" : 0 !== o2.paint.get("fill-z-offset").constantOr(1) && (d2 = "offset");
          const u2 = !(!t2.terrain || !t2.terrain.enabled), _2 = { painter: t2, sourceCache: i2, layer: o2, coords: s2, colorMode: l2, elevationType: d2, terrainEnabled: u2, pass: h2 };
          if ("shadow" === t2.renderPass) return void (t2.shadowRenderer && "road" === d2 && !u2 && function(e2) {
            const { painter: t3, sourceCache: i3, layer: o3, coords: s3 } = e2, r3 = t3.context.gl, n3 = e2.painter.shadowRenderer;
            for (const e3 of s3) {
              const s4 = i3.getTile(e3), a3 = s4.getBucket(o3);
              if (!a3) continue;
              const l3 = a3.elevatedStructures;
              if (!l3) continue;
              if (!l3.shadowCasterSegments || 0 === l3.shadowCasterSegments.segments[0].primitiveLength) continue;
              t3.prepareDrawTile();
              const c3 = a3.bufferData.programConfigurations.get(o3.id), h3 = t3.isTileAffectedByFog(e3), d3 = t3.getOrCreateProgram("elevatedStructuresDepth", { config: c3, overrideFog: h3 }), u3 = n3.calculateShadowPassMatrixFromTile(s4.tileID.toUnwrapped());
              t3.uploadCommonUniforms(t3.context, d3, e3.toUnwrapped());
              const _3 = br(u3, 0);
              d3.draw(t3, r3.TRIANGLES, n3.getShadowPassDepthMode(), Yi.disabled, n3.getShadowPassColorMode(), Qi.disabled, _3, o3.id, l3.vertexBuffer, l3.indexBuffer, l3.shadowCasterSegments, o3.paint, t3.transform.zoom, c3);
            }
          }(_2));
          const p2 = "mrt-fallback" === t2.emissiveMode;
          if ("offset" !== d2) {
            if (hn(_2, false, p2), "road" === d2) {
              const e2 = !u2 && "translucent" === t2.renderPass;
              e2 && cn(t2, i2, o2, s2, "geometry"), hn(_2, true, p2, Yi.disabled), e2 && function(e3) {
                const { painter: t3, sourceCache: i3, layer: o3, coords: s3, colorMode: r3 } = e3, n3 = t3.context.gl, a3 = e3.painter.shadowRenderer, l3 = !!a3 && a3.enabled, c3 = new $i(t3.context.gl.LEQUAL, $i.ReadOnly, t3.depthRangeFor3D);
                let h3 = [0, 0, 0];
                if (l3) {
                  const e4 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                  e4 && i4 && (h3 = go(t3.style, e4, i4));
                }
                const d3 = (e4) => {
                  for (const d4 of s3) {
                    const s4 = i3.getTile(d4), u3 = s4.getBucket(o3);
                    if (!u3) continue;
                    const _3 = u3.elevatedStructures;
                    if (!_3) continue;
                    let p3, f2;
                    if (e4 ? (p3 = _3.renderableBridgeSegments, f2 = _3.bridgeProgramConfigurations.get(o3.id)) : (p3 = _3.renderableTunnelSegments, f2 = _3.tunnelProgramConfigurations.get(o3.id)), !p3 || 0 === p3.segments[0].primitiveLength) continue;
                    f2.updatePaintBuffers(), t3.prepareDrawTile();
                    const m2 = t3.isTileAffectedByFog(d4), g2 = [];
                    l3 && g2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                    const v2 = t3.getOrCreateProgram("elevatedStructures", { config: f2, overrideFog: m2, defines: g2 }), y2 = t3.translatePosMatrix(d4.projMatrix, s4, o3.paint.get("fill-translate"), o3.paint.get("fill-translate-anchor"));
                    l3 && a3.setupShadows(s4.tileID.toUnwrapped(), v2, "vector-tile");
                    const x2 = wr(y2, h3);
                    t3.uploadCommonUniforms(t3.context, v2, d4.toUnwrapped()), v2.draw(t3, n3.TRIANGLES, c3, Yi.disabled, r3, Qi.backCCW, x2, o3.id, _3.vertexBuffer, _3.indexBuffer, p3, o3.paint, t3.transform.zoom, f2, [_3.vertexBufferNormal]);
                  }
                };
                d3(true), d3(false);
              }(_2);
            }
          } else hn(_2, false, p2, t2.stencilModeFor3D());
        }, "fill-extrusion": function(t2, i2, o2, s2) {
          const r2 = o2.paint.get("fill-extrusion-opacity"), n2 = t2.context, a2 = n2.gl, l2 = t2.terrain, c2 = l2 && l2.renderingToTexture;
          if (0 === r2) return;
          const h2 = "mrt-fallback" === t2.emissiveMode, d2 = t2.conflationActive && t2.style.isLayerClipped(o2, i2.getSource()), u2 = t2.style.order.indexOf(o2.fqid);
          if (d2 && function(e2, t3, i3, o3, s3) {
            for (const r3 of o3) {
              const o4 = t3.getTile(r3).getBucket(i3);
              o4 && (o4.updateReplacement(r3, e2.replacementSource, s3), o4.uploadCentroid(e2.context));
            }
          }(t2, i2, o2, s2, u2), l2 || d2) for (const e2 of s2) {
            const s3 = i2.getTile(e2).getBucket(o2);
            s3 && pn(t2.context, i2, e2, s3, o2, l2, d2);
          }
          if ("shadow" === t2.renderPass && t2.shadowRenderer) {
            const n3 = t2.shadowRenderer;
            if (l2 && r2 < 0.65 && o2._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.ad) return;
            const a3 = n3.getShadowPassDepthMode(), c3 = n3.getShadowPassColorMode();
            dn(t2, i2, o2, s2, a3, Yi.disabled, c3, d2);
          } else if ("translucent" === t2.renderPass) {
            const u3 = !o2.paint.get("fill-extrusion-pattern").constantOr(1), _2 = o2.paint.get("fill-extrusion-color").constantOr(e.ao.white);
            if (!c2 && 0 !== _2.a) {
              const e2 = new $i(t2.context.gl.LEQUAL, $i.ReadWrite, t2.depthRangeFor3D);
              1 === r2 && u3 ? dn(t2, i2, o2, s2, e2, Yi.disabled, Wi.unblended, d2) : (dn(t2, i2, o2, s2, e2, Yi.disabled, Wi.disabled, d2), dn(t2, i2, o2, s2, e2, t2.stencilModeFor3D(), t2.colorModeForRenderPass(), d2), t2.resetStencilClippingMasks());
            }
            if (t2.style.enable3dLights() && u3 && (!l2 && "globe" !== t2.transform.projection.name || c2)) {
              const r3 = o2.paint.get("fill-extrusion-opacity"), u4 = o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), _3 = o2.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), p2 = o2.paint.get("fill-extrusion-flood-light-intensity"), f2 = "none" === o2.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), m2 = o2.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(f2 ? null : o2.lut).toArray01().slice(0, 3), g2 = u4 > 0 && _3 > 0, v2 = p2 > 0, y2 = (e2, t3, i3) => (1 - i3) * e2 + i3 * t3, x2 = new un();
              x2.translate = o2.paint.get("fill-extrusion-translate"), x2.translateAnchor = o2.paint.get("fill-extrusion-translate-anchor"), x2.edgeRadius = o2.layout.get("fill-extrusion-edge-radius"), x2.cutoffFadeRange = o2.paint.get("fill-extrusion-cutoff-fade-range");
              const b2 = (n3) => {
                const l3 = t2.depthModeForSublayer(1, $i.ReadOnly, a2.LEQUAL, true), c3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), h3 = y2(0.1, 3, c3), f3 = t2._showOverdrawInspector;
                if (!f3) {
                  const c4 = new Yi({ func: a2.ALWAYS, mask: 255 }, 255, 255, a2.KEEP, a2.KEEP, a2.REPLACE), f4 = new Wi([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.ao.transparent, [false, false, false, true], a2.MIN);
                  _n(x2, t2, i2, o2, s2, l3, c4, f4, Qi.disabled, n3, "sdf", r3, u4, _3, p2, m2, h3, d2, false);
                }
                {
                  const c4 = f3 ? Yi.disabled : new Yi({ func: a2.EQUAL, mask: 255 }, 255, 255, a2.KEEP, a2.DECR, a2.DECR), g3 = f3 ? t2.colorModeForRenderPass() : new Wi([a2.ONE_MINUS_DST_ALPHA, a2.DST_ALPHA, a2.ONE, a2.ONE], e.ao.transparent, [true, true, true, true]);
                  _n(x2, t2, i2, o2, s2, l3, c4, g3, Qi.disabled, n3, "color", r3, u4, _3, p2, m2, h3, d2, false);
                }
              };
              if (c2) {
                const c3 = () => {
                  const t3 = l2.drapeBufferSize[0], i3 = l2.drapeBufferSize[1];
                  let o3 = l2.framebufferCopyTexture;
                  return o3 && (!o3 || o3.size[0] === t3 && o3.size[1] === i3) || (o3 && o3.destroy(), o3 = l2.framebufferCopyTexture = new e.T(n2, new e.q({ width: t3, height: i3 }), a2.RGBA8)), o3.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), a2.copyTexSubImage2D(a2.TEXTURE_2D, 0, 0, 0, 0, 0, t3, i3), o3;
                }, f3 = (n3, l3, f4) => {
                  const g3 = t2.depthModeForSublayer(1, $i.ReadOnly, a2.LEQUAL, false), v3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), b3 = y2(0.1, 3, v3);
                  {
                    const c4 = new Wi([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.ao.transparent, [false, false, false, true]);
                    _n(x2, t2, i2, o2, s2, g3, Yi.disabled, c4, Qi.disabled, n3, "clear", r3, u4, _3, p2, m2, b3, d2, l3);
                  }
                  {
                    const c4 = new Yi({ func: a2.ALWAYS, mask: 255 }, 255, 255, a2.KEEP, a2.KEEP, a2.REPLACE), h3 = new Wi([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.ao.transparent, [false, false, false, true], a2.MIN);
                    _n(x2, t2, i2, o2, s2, g3, c4, h3, Qi.disabled, n3, "sdf", r3, u4, _3, p2, m2, b3, d2, l3);
                  }
                  h2 && !n3 && (f4 = c3());
                  {
                    const c4 = n3 ? a2.ZERO : a2.ONE_MINUS_DST_ALPHA, h3 = new Yi({ func: a2.EQUAL, mask: 255 }, 255, 255, a2.KEEP, a2.DECR, a2.DECR), f5 = new Wi([c4, a2.DST_ALPHA, a2.ONE_MINUS_DST_ALPHA, a2.ZERO], e.ao.transparent, [true, true, true, true]);
                    _n(x2, t2, i2, o2, s2, g3, h3, f5, Qi.disabled, n3, "color", r3, u4, _3, p2, m2, b3, d2, l3);
                  }
                  if (!h2 || n3) {
                    const c4 = new Wi([a2.ONE, a2.ONE, a2.ONE, n3 ? a2.ZERO : a2.ONE], e.ao.transparent, [false, false, false, true], n3 ? a2.FUNC_ADD : a2.MAX);
                    _n(x2, t2, i2, o2, s2, g3, Yi.disabled, c4, Qi.disabled, n3, "clear", r3, u4, _3, p2, m2, b3, d2, l3, f4);
                  } else {
                    a2.drawBuffers([a2.NONE, a2.COLOR_ATTACHMENT1]);
                    const c4 = new Yi({ func: a2.EQUAL, mask: 255 }, 254, 255, a2.KEEP, a2.DECR, a2.DECR), h3 = new Wi([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.ao.transparent, [true, false, false, false], a2.MAX);
                    _n(x2, t2, i2, o2, s2, g3, c4, h3, Qi.disabled, n3, "emissive", r3, u4, _3, p2, m2, b3, d2, l3, f4), a2.drawBuffers([a2.COLOR_ATTACHMENT0]);
                  }
                };
                if (g2 || v2) {
                  let e2;
                  t2.prepareDrawTile(), h2 && !g2 || (e2 = c3()), g2 && f3(true, false, e2), v2 && f3(false, true, e2);
                }
              } else g2 && b2(true), v2 && b2(false), (g2 || v2) && t2.resetStencilClippingMasks();
            }
          }
        }, building: function(e2, t2, i2, o2) {
          e2.currentLayer < e2.firstLightBeamLayer && (e2.firstLightBeamLayer = e2.currentLayer);
          const s2 = i2.paint.get("building-ambient-occlusion-ground-intensity"), r2 = i2.paint.get("building-ambient-occlusion-ground-radius"), n2 = i2.paint.get("building-ambient-occlusion-ground-attenuation"), a2 = i2.paint.get("building-opacity");
          if (a2 <= 0) return;
          let l2 = s2 > 0 && r2 > 0, c2 = true;
          const h2 = i2.paint.get("building-vertical-scale");
          if (h2 <= 0) return;
          e2.shadowRenderer || (c2 = false);
          const d2 = e2.conflationActive && e2.style.isLayerClipped(i2, t2.getSource()), u2 = e2.style.order.indexOf(i2.fqid);
          if (function(e3, t3, i3, o3, s3, r3) {
            for (const n3 of r3) {
              const r4 = t3.getTile(n3).getBucket(i3);
              r4 && (s3 && r4.updateReplacement(n3, e3.replacementSource, o3), r4.uploadUpdatedIndexBuffer(e3.context));
            }
          }(e2, t2, i2, u2, d2, o2), function(e3, t3, i3, o3) {
            for (const s3 of o3) {
              const o4 = t3.getTile(s3).getBucket(i3);
              o4 && o4.needsEvaluation() && o4.uploadUpdatedColorBuffer(e3.context);
            }
          }(e2, t2, i2, o2), i2.resetLayerRenderingStats(e2), e2.shadowRenderer && (e2.shadowRenderer.useNormalOffset = true), "shadow" === e2.renderPass && e2.shadowRenderer) {
            const s3 = e2.shadowRenderer, r3 = [], n3 = s3.getShadowPassDepthMode();
            yn({ painter: e2, source: t2, layer: i2, coords: o2, defines: r3, blendMode: s3.getShadowPassColorMode(), depthMode: n3, opacity: a2, verticalScale: h2, facadeEmissiveChance: 0, facadeAOIntensity: 0, floodLightIntensity: 0, floodLightColor: [0, 0, 0] });
          } else if ("translucent" === e2.renderPass) {
            let u3 = ["HAS_ATTRIBUTE_a_part_color_emissive", "LIGHTING_3D_MODE"];
            c2 && (u3 = u3.concat("RENDER_SHADOWS", "DEPTH_TEXTURE")), e2.shadowRenderer && e2.shadowRenderer.useNormalOffset && (u3 = u3.concat("NORMAL_OFFSET"));
            const _2 = i2.paint.get("building-facade-emissive-chance"), p2 = i2.paint.get("building-ambient-occlusion-intensity"), f2 = i2.paint.get("building-flood-light-intensity"), m2 = "none" === i2.paint.get("building-flood-light-color-use-theme").constantOr("default"), g2 = i2.paint.get("building-flood-light-color").toNonPremultipliedRenderColor(m2 ? null : i2.lut).toArray01().slice(0, 3), v2 = i2.paint.get("building-flood-light-ground-attenuation"), y2 = f2 > 0, x2 = new $i(e2.context.gl.LEQUAL, $i.ReadWrite, e2.depthRangeFor3D);
            a2 < 1 && yn({ painter: e2, source: t2, layer: i2, coords: o2, defines: u3, blendMode: Wi.disabled, depthMode: x2, opacity: a2, verticalScale: h2, facadeEmissiveChance: _2, facadeAOIntensity: p2, floodLightIntensity: f2, floodLightColor: g2, depthOnly: true });
            const b2 = e2.colorModeForRenderPass();
            yn({ painter: e2, source: t2, layer: i2, coords: o2, defines: u3, blendMode: b2, depthMode: x2, opacity: a2, verticalScale: h2, facadeEmissiveChance: _2, facadeAOIntensity: p2, floodLightIntensity: f2, floodLightColor: g2 }), l2 && xn(e2, t2, i2, o2, true, a2, s2, r2, f2, g2, n2, d2), y2 && xn(e2, t2, i2, o2, false, a2, s2, r2, f2, g2, v2, d2);
          } else if ("light-beam" === e2.renderPass) {
            const s3 = ["HAS_ATTRIBUTE_a_part_color_emissive", "HAS_ATTRIBUTE_a_bloom_attenuation"], r3 = new $i(e2.context.gl.LEQUAL, $i.ReadOnly, e2.depthRangeFor3D);
            yn({ painter: e2, source: t2, layer: i2, coords: o2, defines: s3, blendMode: Wi.alphaBlended, depthMode: r3, opacity: a2, verticalScale: h2, facadeEmissiveChance: 0, facadeAOIntensity: 0, floodLightIntensity: 0, floodLightColor: [0, 0, 0] });
          }
          e2.shadowRenderer && (e2.shadowRenderer.useNormalOffset = false), e2.resetStencilClippingMasks();
        }, hillshade: function(e2, t2, i2, o2) {
          if ("offscreen" !== e2.renderPass && "translucent" !== e2.renderPass) return;
          if (e2.style.disableElevatedTerrain) return;
          const s2 = e2.context, r2 = e2.terrain && e2.terrain.renderingToTexture, [n2, a2] = "translucent" !== e2.renderPass || r2 ? [{}, o2] : e2.stencilConfigForOverlap(o2);
          for (const o3 of a2) {
            const s3 = t2.getTile(o3);
            if (s3.needsHillshadePrepare && "offscreen" === e2.renderPass) cs(e2, s3, i2);
            else if ("translucent" === e2.renderPass) {
              const t3 = e2.depthModeForSublayer(0, $i.ReadOnly), a3 = i2.paint.get("hillshade-emissive-strength"), l2 = e2.colorModeForDrapableLayerRenderPass(a3), c2 = r2 && e2.terrain ? e2.terrain.stencilModeForRTTOverlap(o3) : n2[o3.overscaledZ];
              as(e2, o3, s3, i2, t3, c2, l2);
            }
          }
          s2.viewport.set([0, 0, e2.width, e2.height]), e2.resetStencilClippingMasks();
        }, raster: function(t2, i2, o2, s2, r2, n2) {
          if ("translucent" !== t2.renderPass) return;
          if (0 === o2.paint.get("raster-opacity")) return;
          const a2 = "globe" === t2.transform.projection.name, l2 = 0 !== o2.paint.get("raster-elevation"), c2 = l2 && a2;
          if (t2.renderElevatedRasterBackface && !c2) return;
          const h2 = t2.context, d2 = h2.gl, u2 = i2.getSource(), _2 = function(t3, i3, o3, s3, r3) {
            const n3 = i3.paint.get("raster-color"), a3 = "raster-array" === t3.type, l3 = [], c3 = i3.paint.get("raster-resampling"), h3 = i3.paint.get("raster-color-mix");
            let d3 = i3.paint.get("raster-color-range");
            const u3 = [h3[0], h3[1], h3[2], 0], _3 = h3[3];
            let p3 = "nearest" === c3 ? s3.NEAREST : s3.LINEAR;
            if (a3 && (l3.push("RASTER_ARRAY"), n3 || l3.push("RASTER_COLOR"), "linear" === c3 && l3.push("RASTER_ARRAY_LINEAR"), p3 = s3.NEAREST, !d3 && t3.rasterLayers)) {
              const e2 = t3.rasterLayers.find(({ id: e3 }) => e3 === i3.sourceLayer);
              e2 && e2.fields && e2.fields.range && (d3 = e2.fields.range);
            }
            if (d3 = d3 || [0, 1], n3) {
              l3.push("RASTER_COLOR"), o3.activeTexture.set(s3.TEXTURE2), i3.updateColorRamp(d3);
              let t4 = i3.colorRampTexture;
              t4 || (t4 = i3.colorRampTexture = new e.T(o3, i3.colorRamp, s3.RGBA8)), t4.bind(p3, s3.CLAMP_TO_EDGE);
            }
            return r3 && l3.push("USE_MRT1"), { mix: u3, range: d3, offset: _3, defines: l3, resampling: p3 };
          }(u2, o2, h2, d2, t2.terrain && t2.terrain.renderingToTexture && "mrt-fallback" === t2.emissiveMode);
          if (u2 instanceof e.aU && !s2.length && !a2) return;
          const p2 = o2.paint.get("raster-emissive-strength"), f2 = t2.colorModeForDrapableLayerRenderPass(p2), m2 = t2.terrain && t2.terrain.renderingToTexture, g2 = !t2.options.moving, v2 = "nearest" === o2.paint.get("raster-resampling") ? d2.NEAREST : d2.LINEAR;
          if (u2 instanceof e.aU && !s2.length && (u2.onNorthPole || u2.onSouthPole)) {
            const e2 = l2 ? t2.stencilModeFor3D() : Yi.disabled;
            return void wn(!!u2.onNorthPole, null, t2, i2, o2, p2, _2, Qi.disabled, e2);
          }
          if (!s2.length) return;
          const [y2, x2] = u2 instanceof e.aU || m2 ? [{}, s2] : t2.stencilConfigForOverlap(s2), b2 = x2[x2.length - 1].overscaledZ;
          c2 && _2.defines.push("PROJECTION_GLOBE_VIEW"), l2 && _2.defines.push("RENDER_CUTOFF");
          const w2 = (s3, r3, x3) => {
            for (const w3 of s3) {
              const s4 = w3.toUnwrapped(), T2 = i2.getTile(w3);
              if (m2 && (!T2 || !T2.hasData())) continue;
              h2.activeTexture.set(d2.TEXTURE0);
              const E2 = En(T2, u2, o2, _2);
              if (!E2 || !E2.texture) continue;
              const { texture: S2, mix: I2, offset: C2, tileSize: R2, buffer: A2 } = E2;
              let L2, D2;
              m2 ? (L2 = $i.disabled, D2 = w3.projMatrix) : l2 ? (L2 = new $i(d2.LEQUAL, $i.ReadWrite, t2.depthRangeFor3D), D2 = a2 ? Float32Array.from(t2.transform.expandedFarZProjMatrix) : t2.transform.calculateProjMatrix(s4, g2)) : (L2 = t2.depthModeForSublayer(w3.overscaledZ - b2, 1 === o2.paint.get("raster-opacity") ? $i.ReadWrite : $i.ReadOnly, d2.LESS), D2 = t2.transform.calculateProjMatrix(s4, g2));
              const P2 = t2.terrain && m2 ? t2.terrain.stencilModeForRTTOverlap(w3) : y2[w3.overscaledZ], O2 = n2 ? 0 : o2.paint.get("raster-fade-duration");
              T2.registerFadeDuration(O2);
              const z2 = i2.findLoadedParent(w3, 0), M2 = ir(T2, z2, i2, t2.transform, O2);
              let F2, B2;
              !M2.isFading && T2.refreshedUponExpiration && (T2.refreshedUponExpiration = false), t2.terrain && t2.terrain.prepareDrawTile(), h2.activeTexture.set(d2.TEXTURE0), S2.bind(v2, d2.CLAMP_TO_EDGE), h2.activeTexture.set(d2.TEXTURE1), z2 ? (z2.texture && z2.texture.bind(v2, d2.CLAMP_TO_EDGE), F2 = Math.pow(2, z2.tileID.overscaledZ - T2.tileID.overscaledZ), B2 = [T2.tileID.canonical.x * F2 % 1, T2.tileID.canonical.y * F2 % 1]) : S2.bind(v2, d2.CLAMP_TO_EDGE), "useMipmap" in S2 && h2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && d2.texParameterf(d2.TEXTURE_2D, h2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h2.extTextureFilterAnisotropicMax);
              const k2 = t2.transform;
              let N2;
              const U2 = l2 ? Tn(k2) : [0, 0, 0, 0];
              let j2, V2, G2, H2, q2, Z2 = 0;
              if (c2 && u2 instanceof e.aU && u2.coordinates.length > 3) j2 = Float32Array.from(e.bk(e.dJ(new e.cD(0, 0, 0)))), V2 = Float32Array.from(k2.globeMatrix), G2 = Float32Array.from(e.dF(k2)), H2 = [e.aF(k2.center.lng), e.aJ(k2.center.lat)], N2 = u2.elevatedGlobePerspectiveTransform, q2 = u2.elevatedGlobeGridMatrix || new Float32Array(9);
              else if (c2) {
                const t3 = e.dG(w3.canonical);
                Z2 = e.dH(t3.getCenter().lat), j2 = Float32Array.from(e.bk(e.dJ(w3.canonical))), V2 = Float32Array.from(k2.globeMatrix), G2 = Float32Array.from(e.dF(k2)), H2 = [e.aF(k2.center.lng), e.aJ(k2.center.lat)], N2 = [0, 0], q2 = Float32Array.from(e.dI(w3.canonical, t3, Z2, k2.worldSize / k2._pixelsPerMercatorPixel));
              } else N2 = u2 instanceof e.aU ? u2.perspectiveTransform : [0, 0], j2 = new Float32Array(16), V2 = new Float32Array(9), G2 = new Float32Array(16), H2 = [0, 0], q2 = new Float32Array(9);
              const W2 = zr(D2, j2, V2, G2, q2, B2 || [0, 0], e.aj(t2.transform.zoom), H2, U2, F2 || 1, M2, o2, N2, l2 ? o2.paint.get("raster-elevation") : 0, 2, I2, C2, _2.range, R2, A2, p2), $2 = t2.isTileAffectedByFog(w3), X2 = t2.getOrCreateProgram("raster", { defines: _2.defines, overrideFog: $2 });
              if (t2.uploadCommonUniforms(h2, X2, s4), u2 instanceof e.aU) {
                const i3 = u2.elevatedGlobeVertexBuffer, s5 = u2.elevatedGlobeIndexBuffer;
                if (m2 || !a2) u2.boundsBuffer && u2.boundsSegments && X2.draw(t2, d2.TRIANGLES, L2, Yi.disabled, f2, Qi.disabled, W2, o2.id, u2.boundsBuffer, t2.quadTriangleIndexBuffer, u2.boundsSegments);
                else if (i3 && s5) {
                  const n3 = k2.zoom <= e.c_ ? u2.elevatedGlobeSegments : u2.getSegmentsForLongitude(k2.center.lng);
                  n3 && X2.draw(t2, d2.TRIANGLES, L2, Yi.disabled, f2, r3, W2, o2.id, i3, s5, n3);
                }
              } else if (c2) {
                L2 = new $i(d2.LEQUAL, $i.ReadOnly, t2.depthRangeFor3D);
                const e2 = t2.globeSharedBuffers;
                if (e2) {
                  const [i3, s5, n3] = e2.getGridBuffers(Z2, false);
                  X2.draw(t2, d2.TRIANGLES, L2, x3 || P2, t2.colorModeForRenderPass(), r3, W2, o2.id, i3, s5, n3);
                }
              } else {
                const { tileBoundsBuffer: e2, tileBoundsIndexBuffer: i3, tileBoundsSegments: s5 } = t2.getTileBoundsBuffers(T2);
                X2.draw(t2, d2.TRIANGLES, L2, P2, f2, Qi.disabled, W2, o2.id, e2, i3, s5);
              }
            }
            if (!(u2 instanceof e.aU) && c2) for (const e2 of s3) {
              const s4 = e2.canonical.y === (1 << e2.canonical.z) - 1;
              0 === e2.canonical.y && wn(true, e2, t2, i2, o2, p2, _2, r3, x3 || Yi.disabled), s4 && wn(false, e2, t2, i2, o2, p2, _2, r3 === Qi.frontCW ? Qi.backCW : Qi.frontCW, x3 || Yi.disabled);
            }
          };
          c2 ? w2(x2, t2.renderElevatedRasterBackface ? Qi.backCW : Qi.frontCW, t2.stencilModeFor3D()) : w2(x2, Qi.disabled, void 0), t2.resetStencilClippingMasks();
        }, "raster-particle": function(t2, i2, o2, s2, r2, n2) {
          "offscreen" === t2.renderPass && function(t3, i3, o3, s3) {
            if (!s3.length) return;
            const r3 = t3.context, n3 = r3.gl, a2 = i3.getSource();
            if (!(a2 instanceof pt)) return;
            const l2 = Math.ceil(Math.sqrt(o3.paint.get("raster-particle-count")));
            let c2 = o3.particlePositionRGBAImage;
            if (!c2 || c2.width !== l2) {
              const t4 = function(e2) {
                const t5 = e2 * e2, i4 = new Uint8Array(4 * t5), o4 = function(e3) {
                  return e3 |= 0, e3 = Math.imul(2747636419 ^ e3, 2654435769), e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769), ((e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769)) >>> 0) / 4294967296;
                }, s4 = 0.9090909090909091;
                for (let e3 = 0; e3 < t5; e3++) {
                  const t6 = s4 * (o4(2 * e3 + 0) + Fr), r4 = s4 * (o4(2 * e3 + 1) + Fr), n4 = 255 * t6 % 1, a3 = 255 * r4 % 1, l3 = n4, c3 = r4 - a3 / 255, h3 = a3;
                  i4[4 * e3 + 0] = 255 * (t6 - n4 / 255), i4[4 * e3 + 1] = 255 * l3, i4[4 * e3 + 2] = 255 * c3, i4[4 * e3 + 3] = 255 * h3;
                }
                return i4;
              }(l2);
              c2 = o3.particlePositionRGBAImage = new e.q({ width: l2, height: l2 }, t4);
            }
            let h2 = o3.particleFramebuffer;
            h2 ? h2.width !== l2 && (h2.destroy(), h2 = o3.particleFramebuffer = r3.createFramebuffer(l2, l2, 1, null)) : h2 = o3.particleFramebuffer = r3.createFramebuffer(l2, l2, 1, null);
            const d2 = [];
            for (const e2 of s3) {
              const t4 = i3.getTile(e2);
              if (!(t4 instanceof Ot)) continue;
              const s4 = Cn(t4, a2, o3);
              if (!s4) continue;
              const n4 = [t4.tileSize, t4.tileSize];
              let h3 = o3.tileFramebuffer;
              h3 || (h3 = o3.tileFramebuffer = r3.createFramebuffer(n4[0], n4[1], 1, null));
              let u3 = t4.rasterParticleState;
              u3 || (u3 = t4.rasterParticleState = new In(r3, e2, n4, c2));
              const _3 = u3.update(o3.lastInvalidatedAt);
              u3.particleTextureDimension !== l2 && u3.updateParticleTexture(e2, c2);
              const p2 = u3.targetColorTexture;
              u3.targetColorTexture = u3.backgroundColorTexture, u3.backgroundColorTexture = p2;
              const f2 = u3.particleTexture0;
              u3.particleTexture0 = u3.particleTexture1, u3.particleTexture1 = f2, d2.push([e2, s4, u3, _3]);
            }
            if (0 === d2.length) return;
            const u2 = e.o.now(), _2 = o3.previousDrawTimestamp ? 1e-3 * (u2 - o3.previousDrawTimestamp) : 0.0167;
            if (o3.previousDrawTimestamp = u2, o3.hasColorMap()) {
              r3.activeTexture.set(n3.TEXTURE0 + 2);
              let t4 = o3.colorRampTexture;
              t4 || (t4 = o3.colorRampTexture = new e.T(r3, o3.colorRamp, n3.RGBA8)), t4.bind(n3.LINEAR, n3.CLAMP_TO_EDGE);
            }
            r3.bindFramebuffer.set(o3.tileFramebuffer.framebuffer), function(t4, i4, o4) {
              const s4 = t4.context, r4 = s4.gl, n4 = i4.tileFramebuffer;
              s4.activeTexture.set(r4.TEXTURE0);
              const a3 = { u_texture: 0, u_opacity: 1.05 * (c3 = i4.paint.get("raster-particle-fade-opacity-factor")) / (c3 + 0.05) }, l3 = t4.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
              var c3;
              for (const c4 of o4) {
                const [, , o5, h3] = c4;
                n4.colorAttachment0.set(o5.targetColorTexture.texture), s4.viewport.set([0, 0, n4.width, n4.height]), s4.clear({ color: e.ao.transparent }), h3 && (o5.backgroundColorTexture.bind(r4.NEAREST, r4.CLAMP_TO_EDGE), l3.draw(t4, r4.TRIANGLES, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, a3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments));
              }
            }(t3, o3, d2), function(t4, i4, o4, s4) {
              const r4 = t4.context, n4 = r4.gl, a3 = o4.tileFramebuffer, l3 = "globe" === t4.transform.projection.name, c3 = o4.paint.get("raster-particle-max-speed");
              for (const h3 of s4) {
                const [s5, d3, u3] = h3;
                r4.activeTexture.set(n4.TEXTURE0 + 0), d3.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), a3.colorAttachment0.set(u3.targetColorTexture.texture);
                const _3 = t4.getOrCreateProgram("rasterParticleDraw", { defines: d3.defines, overrideFog: false });
                r4.activeTexture.set(n4.TEXTURE0 + 1);
                const p2 = d3.scalarData ? [] : [0, 1, 2, 3].map((t5) => e.e9[t5](s5));
                p2.push(s5);
                const f2 = s5.canonical.x, m2 = s5.canonical.y;
                for (const e2 of p2) {
                  const r5 = i4.getTile(l3 ? e2.wrapped() : e2);
                  if (!r5) continue;
                  const a4 = r5.rasterParticleState;
                  if (!a4) continue;
                  const h4 = e2.canonical.x + (1 << e2.canonical.z) * (e2.wrap - s5.wrap), u4 = e2.canonical.y;
                  a4.particleTexture0.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
                  const p3 = kr(1, a4.particleTexture0.size[0], [h4 - f2, u4 - m2], 0, d3.texture.size, 2, c3, d3.textureOffset, d3.scale, d3.offset);
                  _3.draw(t4, n4.POINTS, $i.disabled, Yi.disabled, Wi.alphaBlended, Qi.disabled, p3, o4.id, a4.particleIndexBuffer, void 0, a4.particleSegment);
                }
              }
            }(t3, i3, o3, d2), r3.bindFramebuffer.set(o3.particleFramebuffer.framebuffer), function(t4, i4, o4, s4) {
              const r4 = t4.context, n4 = r4.gl, a3 = i4.paint.get("raster-particle-max-speed"), l3 = s4 * i4.paint.get("raster-particle-speed-factor") * 0.15, c3 = function(e2) {
                return Math.pow(e2, 6);
              }(0.01 + 1 * i4.paint.get("raster-particle-reset-rate-factor")), h3 = i4.particleFramebuffer;
              r4.viewport.set([0, 0, h3.width, h3.height]);
              for (const s5 of o4) {
                const [, o5, d3] = s5;
                r4.activeTexture.set(n4.TEXTURE0 + 0), o5.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), r4.activeTexture.set(n4.TEXTURE0 + 1);
                const u3 = d3.particleTexture0;
                u3.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
                const _3 = Nr(1, u3.size[0], 0, o5.texture.size, a3, l3, c3, o5.textureOffset, o5.scale, o5.offset);
                h3.colorAttachment0.set(d3.particleTexture1.texture), r4.clear({ color: e.ao.transparent }), t4.getOrCreateProgram("rasterParticleUpdate", { defines: o5.defines }).draw(t4, n4.TRIANGLES, $i.disabled, Yi.disabled, Wi.unblended, Qi.disabled, _3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments);
              }
            }(t3, o3, d2, _2);
          }(t2, i2, o2, s2), "translucent" === t2.renderPass && (function(t3, i3, o3, s3) {
            const r3 = t3.context, n3 = r3.gl, a2 = i3.getSource().tileSize, l2 = 5 * (1 - e.ah(e.cL, e.cL + 1, t3.transform.zoom)) * a2 + o3.paint.get("raster-particle-elevation"), c2 = !t3.options.moving, h2 = "globe" === t3.transform.projection.name;
            if (!s3.length) return;
            const [d2, u2] = t3.stencilConfigForOverlap(s3), _2 = [];
            h2 && _2.push("PROJECTION_GLOBE_VIEW");
            const p2 = t3.stencilModeFor3D();
            for (const s4 of u2) {
              const a3 = s4.toUnwrapped(), u3 = i3.getTile(s4);
              if (!u3.rasterParticleState) continue;
              const f2 = u3.rasterParticleState, m2 = 100;
              u3.registerFadeDuration(m2);
              const g2 = i3.findLoadedParent(s4, 0), v2 = ir(u3, g2, i3, t3.transform, m2);
              let y2, x2;
              t3.terrain && t3.terrain.prepareDrawTile(), r3.activeTexture.set(n3.TEXTURE0), f2.targetColorTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), r3.activeTexture.set(n3.TEXTURE1), g2 && g2.rasterParticleState ? (g2.rasterParticleState.targetColorTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), y2 = Math.pow(2, g2.tileID.overscaledZ - u3.tileID.overscaledZ), x2 = [u3.tileID.canonical.x * y2 % 1, u3.tileID.canonical.y * y2 % 1]) : f2.targetColorTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE);
              const b2 = h2 ? Float32Array.from(t3.transform.expandedFarZProjMatrix) : t3.transform.calculateProjMatrix(a3, c2), w2 = t3.transform, T2 = Rn(w2), E2 = e.dG(s4.canonical), S2 = e.dH(E2.getCenter().lat);
              let I2, C2, R2, A2, L2;
              h2 ? (I2 = Float32Array.from(e.bk(e.dJ(s4.canonical))), C2 = Float32Array.from(w2.globeMatrix), R2 = Float32Array.from(e.dF(w2)), A2 = [e.aF(w2.center.lng), e.aJ(w2.center.lat)], L2 = Float32Array.from(e.dI(s4.canonical, E2, S2, w2.worldSize / w2._pixelsPerMercatorPixel))) : (I2 = new Float32Array(16), C2 = new Float32Array(9), R2 = new Float32Array(16), A2 = [0, 0], L2 = new Float32Array(9));
              const D2 = Br(b2, I2, C2, R2, L2, x2 || [0, 0], e.aj(t3.transform.zoom), A2, T2, y2 || 1, v2, l2), P2 = t3.isTileAffectedByFog(s4), O2 = t3.getOrCreateProgram("rasterParticle", { defines: _2, overrideFog: P2 });
              if (t3.uploadCommonUniforms(r3, O2, a3), h2) {
                const e2 = new $i(n3.LEQUAL, $i.ReadOnly, t3.depthRangeFor3D), i4 = 0, s5 = t3.globeSharedBuffers;
                if (s5) {
                  const [r4, a4, l3] = s5.getGridBuffers(S2, 0 !== i4);
                  O2.draw(t3, n3.TRIANGLES, e2, p2, Wi.alphaBlended, t3.renderElevatedRasterBackface ? Qi.frontCCW : Qi.backCCW, D2, o3.id, r4, a4, l3);
                }
              } else {
                const e2 = t3.depthModeForSublayer(0, $i.ReadOnly), i4 = d2[s4.overscaledZ], { tileBoundsBuffer: r4, tileBoundsIndexBuffer: a4, tileBoundsSegments: l3 } = t3.getTileBoundsBuffers(u3);
                O2.draw(t3, n3.TRIANGLES, e2, i4, Wi.alphaBlended, Qi.disabled, D2, o3.id, r4, a4, l3);
              }
            }
            t3.resetStencilClippingMasks();
          }(t2, i2, o2, s2), t2.style.map.triggerRepaint());
        }, background: function(t2, i2, o2, s2) {
          const r2 = o2.paint.get("background-color"), n2 = "none" === o2.paint.get("background-color-use-theme").constantOr("default"), a2 = o2.paint.get("background-opacity"), l2 = o2.paint.get("background-emissive-strength"), c2 = "viewport" === o2.paint.get("background-pitch-alignment");
          if (0 === a2) return;
          const h2 = t2.context, d2 = h2.gl, u2 = t2.transform, _2 = u2.tileSize, p2 = o2.paint.get("background-pattern");
          let f2;
          if (void 0 !== p2) {
            if (null === p2) return;
            if (f2 = t2.imageManager.getPattern(e.I.from(p2.toString()), o2.scope, t2.style.getLut(o2.scope)), !f2) return;
          }
          const m2 = !p2 && 1 === r2.a && 1 === a2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t2.renderPass !== m2) return;
          const g2 = Yi.disabled, v2 = t2.depthModeForSublayer(0, "opaque" === m2 ? $i.ReadWrite : $i.ReadOnly), y2 = t2.colorModeForDrapableLayerRenderPass(l2), x2 = p2 ? "backgroundPattern" : "background";
          let b2, w2 = s2;
          w2 || (b2 = t2.getBackgroundTiles(), w2 = Object.values(b2).map((e2) => e2.tileID)), p2 && (h2.activeTexture.set(d2.TEXTURE0), t2.imageManager.bind(t2.context, o2.scope));
          const T2 = [];
          if (t2.terrain && t2.terrain.renderingToTexture && "mrt-fallback" === t2.emissiveMode && T2.push("USE_MRT1"), c2) {
            const i3 = t2.getOrCreateProgram(x2, { overrideFog: false, overrideRtt: true, defines: T2 }), s3 = new Float32Array(e.bA([])), h3 = new e.aQ(0, 0, 0, 0, 0), u3 = p2 ? Gr(s3, l2, a2, t2, 0, o2.scope, f2, c2, { tileID: h3, tileSize: _2 }) : Vr(s3, l2, a2, r2.toPremultipliedRenderColor(n2 ? null : o2.lut));
            return void i3.draw(t2, d2.TRIANGLES, v2, g2, y2, Qi.disabled, u3, o2.id, t2.viewportBuffer, t2.quadTriangleIndexBuffer, t2.viewportSegments);
          }
          for (const e2 of w2) {
            const m3 = t2.isTileAffectedByFog(e2), w3 = t2.getOrCreateProgram(x2, { overrideFog: m3, defines: T2 }), E2 = e2.toUnwrapped(), S2 = s2 ? e2.projMatrix : t2.transform.calculateProjMatrix(E2);
            t2.prepareDrawTile();
            const I2 = i2 ? i2.getTile(e2) : b2 ? b2[e2.key] : new Pt(e2, _2, u2.zoom, t2), C2 = p2 ? Gr(S2, l2, a2, t2, 0, o2.scope, f2, c2, { tileID: e2, tileSize: _2 }) : Vr(S2, l2, a2, r2.toPremultipliedRenderColor(n2 ? null : o2.lut));
            t2.uploadCommonUniforms(h2, w3, E2);
            const { tileBoundsBuffer: R2, tileBoundsIndexBuffer: A2, tileBoundsSegments: L2 } = t2.getTileBoundsBuffers(I2);
            w3.draw(t2, d2.TRIANGLES, v2, g2, y2, Qi.disabled, C2, o2.id, R2, A2, L2);
          }
        }, sky: function(t2, i2, o2) {
          const s2 = t2._atmosphere ? e.aj(t2.transform.zoom) : 1, r2 = o2.paint.get("sky-opacity") * s2;
          if (0 === r2) return;
          const n2 = t2.context, a2 = o2.paint.get("sky-type"), l2 = new $i(n2.gl.LEQUAL, $i.ReadOnly, [0, 1]), c2 = t2.frameCounter / 1e3 % 1;
          "atmosphere" === a2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3) {
            const o3 = t3.context, s3 = o3.gl;
            let r3 = i3.skyboxFbo;
            if (!r3) {
              r3 = i3.skyboxFbo = o3.createFramebuffer(32, 32, 1, null), i3.skyboxGeometry = new Vn(o3), i3.skyboxTexture = o3.gl.createTexture(), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_CUBE_MAP, s3.TEXTURE_MAG_FILTER, s3.LINEAR);
              for (let e2 = 0; e2 < 6; ++e2) s3.texImage2D(s3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, s3.RGBA, 32, 32, 0, s3.RGBA, s3.UNSIGNED_BYTE, null);
            }
            o3.bindFramebuffer.set(r3.framebuffer), o3.viewport.set([0, 0, 32, 32]);
            const n3 = i3.getCenter(t3, true), a3 = t3.getOrCreateProgram("skyboxCapture"), l3 = new Float64Array(16);
            e.bA(l3), e.en(l3, l3, 0.5 * -Math.PI), Gn(t3, i3, a3, l3, n3, 0), e.bA(l3), e.en(l3, l3, 0.5 * Math.PI), Gn(t3, i3, a3, l3, n3, 1), e.bA(l3), e.cU(l3, l3, 0.5 * -Math.PI), Gn(t3, i3, a3, l3, n3, 2), e.bA(l3), e.cU(l3, l3, 0.5 * Math.PI), Gn(t3, i3, a3, l3, n3, 3), e.bA(l3), Gn(t3, i3, a3, l3, n3, 4), e.bA(l3), e.en(l3, l3, Math.PI), Gn(t3, i3, a3, l3, n3, 5), o3.viewport.set([0, 0, t3.width, t3.height]);
          }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(e2, t3, i3, o3, s3) {
            const r3 = e2.context, n3 = r3.gl, a3 = e2.transform, l3 = e2.getOrCreateProgram("skybox");
            r3.activeTexture.set(n3.TEXTURE0), n3.bindTexture(n3.TEXTURE_CUBE_MAP, t3.skyboxTexture);
            const c3 = /* @__PURE__ */ ((e3, t4, i4, o4, s4) => ({ u_matrix: e3, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: s4 }))(a3.skyboxMatrix, t3.getCenter(e2, false), 0, o3, s3);
            e2.uploadCommonUniforms(r3, l3), l3.draw(e2, n3.TRIANGLES, i3, Yi.disabled, e2.colorModeForRenderPass(), Qi.backCW, c3, "skybox", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
          }(t2, o2, l2, r2, c2) : "gradient" === a2 && "sky" === t2.renderPass && function(t3, i3, o3, s3, r3) {
            const n3 = t3.context, a3 = n3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skyboxGradient");
            i3.skyboxGeometry || (i3.skyboxGeometry = new Vn(n3)), n3.activeTexture.set(a3.TEXTURE0);
            let h2 = i3.colorRampTexture;
            h2 || (h2 = i3.colorRampTexture = new e.T(n3, i3.colorRamp, a3.RGBA8)), h2.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
            const d2 = ((t4, i4, o4, s4, r4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.an(o4), u_opacity: s4, u_temporal_offset: r4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), s3, r3);
            t3.uploadCommonUniforms(n3, c3), c3.draw(t3, a3.TRIANGLES, o3, Yi.disabled, t3.colorModeForRenderPass(), Qi.backCW, d2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
          }(t2, o2, l2, r2, c2);
        }, custom: function(t2, i2, o2, s2) {
          const r2 = t2.context, n2 = o2.implementation;
          if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isDraped(i2)) {
            if ("offscreen" === t2.renderPass) {
              const i3 = n2.prerender;
              if (i3) {
                if (t2.setCustomLayerDefaults(), r2.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                  const o3 = t2.transform.pointMerc;
                  i3.call(n2, r2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.aj(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
                } else i3.call(n2, r2.gl, t2.transform.customLayerMatrix());
                r2.setDirty(), t2.setBaseState();
              }
            } else if ("translucent" === t2.renderPass) {
              if (t2.terrain && t2.terrain.renderingToTexture) {
                const e2 = n2.renderToTile;
                if (e2) {
                  const i4 = s2[0].canonical, o3 = { x: i4.x + s2[0].wrap * (n2.wrapTileId ? 0 : 1 << i4.z), y: i4.y, z: i4.z };
                  r2.setDepthMode($i.disabled), r2.setStencilMode(Yi.disabled), r2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), e2.call(n2, r2.gl, o3), r2.setDirty(), t2.setBaseState();
                }
                return;
              }
              t2.setCustomLayerDefaults(), r2.setColorMode(t2.colorModeForRenderPass()), r2.setStencilMode(Yi.disabled);
              const i3 = "3d" === n2.renderingMode ? new $i(t2.context.gl.LEQUAL, $i.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, $i.ReadOnly);
              if (r2.setDepthMode(i3), "globe" === t2.transform.projection.name) {
                const i4 = t2.transform.pointMerc;
                n2.render(r2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.aj(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
              } else n2.render(r2.gl, t2.transform.customLayerMatrix());
              r2.setDirty(), t2.setBaseState(), r2.bindFramebuffer.set(null);
            }
          } else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        }, model: function(t2, i2, o2, s2) {
          if ("opaque" === t2.renderPass) return;
          const r2 = o2.paint.get("model-opacity").constantOr(1), n2 = o2.paint.get("model-elevation-reference"), a2 = "ground" === n2, l2 = "ground" === n2;
          if (0 === r2) return;
          const c2 = o2.paint.get("model-cast-shadows");
          if ("shadow" === t2.renderPass) {
            if (!c2) return;
            if (t2.terrain && r2 < 0.65 && o2._transitionablePaint._values["model-opacity"].value.expression instanceof e.ad) return;
          }
          const h2 = t2.shadowRenderer, d2 = o2.paint.get("model-receive-shadows");
          h2 && (h2.useNormalOffset = true, d2 || (h2.enabled = false));
          const u2 = () => {
            h2 && (h2.useNormalOffset = true, d2 || (h2.enabled = true));
          }, _2 = i2.getSource();
          if ("light-beam" === t2.renderPass && "batched-model" !== _2.type) return;
          if ("vector" === _2.type || "geojson" === _2.type) return function(t3, i3, o3, s3, r3) {
            const n3 = t3.transform, a3 = "globe" === n3.projection.name, l3 = n3.getFreeCameraOptions().position;
            if (!t3.modelManager) return;
            const c3 = t3.modelManager;
            o3.modelManager = c3;
            const h3 = t3.shadowRenderer;
            if (!o3._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
            const d3 = o3._unevaluatedLayout._values["model-id"], u3 = Object.assign({}, o3.layout.get("model-id").parameters), _3 = t3.style.order.indexOf(o3.fqid), p3 = o3.paint.get("model-opacity").constantOr(1);
            for (const f3 of s3) {
              const s4 = i3.getTile(f3).getBucket(o3);
              if (!s4 || s4.projection.name !== n3.projection.name) continue;
              const m3 = s4.getModelUris();
              if (m3 && !s4.modelsRequested && (c3.addModelsFromBucket(m3, r3), s4.modelsRequested = true), a3) u3.zoom = f3.overscaledZ;
              else {
                const e2 = aa(f3, n3);
                u3.zoom = e2;
              }
              const g3 = d3.possiblyEvaluate(u3);
              if (ra(t3, s4, f3), na.shadowUniformsInitialized = false, na.useSingleShadowCascade = !!h3 && 0 === h3.getMaxCascadeForTile(f3.toUnwrapped()), "shadow" === t3.renderPass && h3) {
                if (1 === t3.currentShadowCascade && s4.isInsideFirstShadowMapFrustum) continue;
                const i4 = n3.calculatePosMatrix(f3.toUnwrapped(), n3.worldSize);
                if (na.tileMatrix.set(i4), na.shadowTileMatrix = Float32Array.from(h3.calculateShadowPassMatrixFromMatrix(i4)), na.aabb.min = [0, 0, 0], na.aabb.max[0] = na.aabb.max[1] = e.al, na.aabb.max[2] = 0, ha(s4, na, t3, o3.scope)) continue;
              }
              const v3 = 1 << f3.canonical.z, y3 = [((l3.x - f3.wrap) * v3 - f3.canonical.x) * e.al, (l3.y * v3 - f3.canonical.y) * e.al, l3.z * v3 * e.al];
              t3.conflationActive && Object.keys(s4.instancesPerModel).length > 0 && t3.style.isLayerClipped(o3, i3.getSource()) && s4.updateReplacement(f3, t3.replacementSource, _3, o3.scope) && (s4.uploaded = false, s4.upload(t3.context));
              let x3 = 0;
              const b2 = new Array(), w2 = new Array(), T2 = new Array();
              for (let i4 in s4.instancesPerModel) {
                const n4 = s4.instancesPerModel[i4];
                n4.features.length > 0 && !a3 && (i4 = g3.evaluate(n4.features[0].feature, {}));
                const h4 = c3.getModel(i4, r3);
                if (h4 || c3.hasURLBeenRequested(i4) || s4.modelUris.includes(i4) || (s4.modelUris.push(i4), s4.modelsRequested = false), h4 && h4.uploaded) if (a3) {
                  const i5 = e.c5([], [l3.x, l3.y, l3.z], t3.transform.worldSize);
                  e.ew(i5, i5);
                  for (let o4 = 0; o4 < n4.instancedDataArray.length; ++o4) {
                    const r4 = [0, 0, 0], a4 = [1, 1, 1], l4 = e.ex(), c4 = n4.tileCoordinatesForInstance(o4), d4 = n4.transformForInstance(o4);
                    e.ey(a4, d4), e.ez(l4, d4), e.eA(r4, l4);
                    const u4 = n4.translationForInstance(o4), _4 = new e.aT(0, 0);
                    e.eB(s4.canonical, _4, c4.x, c4.y);
                    const f4 = e.bC();
                    e.eC(f4, h4, t3.transform, _4, r4, a4, u4, true, false, false);
                    const m4 = n4.colorForInstance(o4), g4 = e.bA([]), v4 = e.ef(_4.lat, t3.transform.zoom), y4 = e.bq([], [1, 1, 1 / v4]);
                    e.br(g4, g4, i5), T2.push({ zScaleMatrix: y4, negCameraPosMatrix: g4 });
                    for (const e2 of h4.nodes) ea(t3, e2, f4, t3.transform.expandedFarZProjMatrix, x3, b2, w2, h4.materialOverrides, p3, m4);
                    ++x3;
                  }
                } else for (const e2 of h4.nodes) la(t3, o3, e2, n4, y3, f3, na);
              }
              if (a3) if ("shadow" === t3.renderPass) {
                for (const e2 of w2) ta(e2.mesh, e2.nodeModelMatrix, t3, o3);
                for (const e2 of b2) ta(e2.mesh, e2.nodeModelMatrix, t3, o3);
              } else sa(t3, o3, b2, w2, T2);
            }
          }(t2, i2, o2, s2, Qn(t2, o2)), void u2();
          if (!_2.loaded()) return;
          if ("batched-model" === _2.type) return function(t3, i3, o3, s3) {
            o3.resetLayerRenderingStats(t3);
            const r3 = t3.context, n3 = t3.transform, a3 = t3.style.fog, l3 = t3.shadowRenderer;
            if ("mercator" !== n3.projection.name) return void e.w(`Drawing 3D landmark models for ${n3.projection.name} projection is not yet implemented`);
            const c3 = t3.transform.getFreeCameraOptions().position, h3 = e.c5([], [c3.x, c3.y, c3.z], t3.transform.worldSize), d3 = e.ew([], h3), u3 = e.bA([]), _3 = e.ef(n3.center.lat, n3.zoom), p3 = e.bq([], [1, 1, 1 / _3]);
            e.br(u3, u3, d3);
            const f3 = o3.paint.get("model-opacity").constantOr(1), m3 = new $i(r3.gl.LEQUAL, $i.ReadWrite, t3.depthRangeFor3D), g3 = new $i(r3.gl.LEQUAL, $i.ReadOnly, t3.depthRangeFor3D), v3 = new e.d9([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), y3 = "shadow" === t3.renderPass, x3 = y3 && l3 ? l3.getCurrentCascadeFrustum() : n3.getFrustum(n3.scaleZoom(n3.worldSize)), b2 = o3.paint.get("model-front-cutoff"), w2 = b2[2] < 1, T2 = co(t3, o3.paint.get("model-cutoff-fade-range")), E2 = o3.getLayerRenderingStats();
            (function(e2, t4, i4, o4) {
              const s4 = e2.terrain ? e2.terrain.exaggeration() : 0, r4 = e2.transform.zoom;
              for (const n4 of o4) {
                const o5 = t4.getTile(n4).getBucket(i4);
                o5 && (o5.setFilter(i4.filter), e2.conflationActive && o5.updateReplacement(n4, e2.replacementSource), o5.evaluateTransform(e2, i4), e2.terrain && s4 > 0 && o5.elevationUpdate(e2.terrain, s4, n4, i4.source), o5.needsReEvaluation(e2, r4, i4) && o5.evaluate(i4));
              }
            })(t3, i3, o3, s3), function() {
              let c4, d4, S2;
              w2 ? (c4 = s3.length - 1, d4 = -1, S2 = -1) : (c4 = 0, d4 = s3.length, S2 = 1);
              const I2 = new Float64Array(16), C2 = e.cA(), R2 = new e.P(0, 0);
              for (let A2 = c4; A2 !== d4; A2 += S2) {
                const c5 = s3[A2], d5 = i3.getTile(c5).getBucket(o3);
                if (!d5 || !d5.uploaded) continue;
                let S3 = false;
                l3 && (S3 = 0 === l3.getMaxCascadeForTile(c5.toUnwrapped()));
                const L2 = n3.calculatePosMatrix(c5.toUnwrapped(), n3.worldSize), D2 = d5.modelTraits;
                !y3 && w2 && (e.bl(I2, L2), e.af(C2, h3, I2), R2.x = C2[0], R2.y = C2[1]);
                const P2 = [];
                d5.setFilter(o3.filter);
                for (const i4 of d5.getNodesInfo()) {
                  if (i4.hiddenByReplacement) continue;
                  if (!i4.node.meshes) continue;
                  const o4 = i4.node;
                  let s4 = 0;
                  t3.terrain && o4.elevation && (s4 = o4.elevation * t3.terrain.exaggeration());
                  const r4 = (() => {
                    const t4 = i4.aabb;
                    return v3.min = [...t4.min], v3.max = [...t4.max], v3.min[2] += s4, v3.max[2] += s4, e.af(v3.min, v3.min, L2), e.af(v3.max, v3.max, L2), v3;
                  })(), a4 = i4.evaluatedScale;
                  if (a4[0] <= 1 && a4[1] <= 1 && a4[2] <= 1 && 0 === r4.intersects(x3)) continue;
                  if (!y3 && w2) {
                    const t4 = 1 / 6;
                    i4.cameraCollisionOpacity = h3[0] > r4.min[0] && h3[0] < r4.max[0] && h3[1] > r4.min[1] && h3[1] < r4.max[1] && h3[2] * _3 < r4.max[2] && o4.footprint && e.c0(R2, o4.footprint) ? Math.max(i4.cameraCollisionOpacity - t4, 0) : Math.min(1, i4.cameraCollisionOpacity + t4);
                  }
                  const l4 = [...L2], d6 = 1 / e.d7(c5.canonical), u4 = o4.anchor ? o4.anchor[0] : 0, p4 = o4.anchor ? o4.anchor[1] : 0;
                  e.br(l4, l4, [u4 * (a4[0] - 1) + i4.evaluatedTranslation[0] * d6, p4 * (a4[1] - 1) + i4.evaluatedTranslation[1] * d6, s4 + i4.evaluatedTranslation[2]]), e.cq(a4, e.eE) || e.cS(l4, l4, a4);
                  const m4 = e.aB([], l4, o4.globalMatrix), g4 = e.aB([], n3.expandedFarZProjMatrix, m4), E3 = e.aB([], n3.expandedFarZProjMatrix, l4), S4 = e.aC([], [u4, p4, s4, 1], g4)[2];
                  o4.hidden = false;
                  let I3 = f3;
                  y3 || (w2 && (I3 *= i4.cameraCollisionOpacity, I3 *= ua(l4, n3, i4.aabb, b2)), I3 *= da(T2, S4)), 0 !== I3 ? P2.push({ nodeInfo: i4, depth: S4, opacity: I3, wvpForNode: g4, wvpForTile: E3, nodeModelMatrix: m4, tileModelMatrix: l4 }) : o4.hidden = true;
                }
                y3 || P2.sort((e2, t4) => !w2 || 1 === e2.opacity && 1 === t4.opacity ? e2.depth < t4.depth ? -1 : 1 : 1 === e2.opacity ? -1 : 1 === t4.opacity ? 1 : e2.depth > t4.depth ? -1 : 1);
                for (const i4 of P2) {
                  const s4 = i4.nodeInfo, c6 = s4.node;
                  let h4 = e.aB([], p3, i4.tileModelMatrix);
                  e.aB(h4, u3, h4);
                  const d6 = e.bl([], h4);
                  e.eg(d6, d6), e.cS(d6, d6, ca), h4 = e.aB(h4, h4, c6.globalMatrix);
                  const _4 = "light-beam" === t3.renderPass, f4 = "none" === o3.paint.get("model-color-use-theme").constantOr("default"), v4 = D2 & e.eI.HasMapboxMeshFeatures, x4 = v4 ? 0 : s4.evaluatedRMEA[0][2];
                  for (let e2 = 0; e2 < c6.meshes.length; ++e2) {
                    const u4 = c6.meshes[e2], p4 = e2 === c6.lightMeshIndex;
                    let b3 = i4.wvpForNode;
                    if (p4) {
                      if (!_4 && !t3.terrain && t3.shadowRenderer) {
                        t3.currentLayer < t3.firstLightBeamLayer && (t3.firstLightBeamLayer = t3.currentLayer);
                        continue;
                      }
                      b3 = i4.wvpForTile;
                    } else if (_4) continue;
                    const w3 = { defines: [] }, T3 = [];
                    if (!y3 && l3 && (l3.useNormalOffset = !!u4.normalBuffer), Kn(w3.defines, T3, u4, t3, f4 ? null : o3.lut), v4 || w3.defines.push("DIFFUSE_SHADED"), S3 && w3.defines.push("SHADOWS_SINGLE_CASCADE"), E2 && (y3 ? E2.numRenderedVerticesInShadowPass += u4.vertexArray.length : E2.numRenderedVerticesInTransparentPass += u4.vertexArray.length), y3) {
                      ta(u4, i4.nodeModelMatrix, t3, o3);
                      continue;
                    }
                    let I3 = null;
                    if (a3) {
                      const e3 = Yn(i4.nodeModelMatrix, t3.transform);
                      if (I3 = new Float32Array(e3), "globe" !== n3.projection.name) {
                        const t4 = u4.aabb.min, i5 = u4.aabb.max, [o4, s5] = a3.getOpacityForBounds(e3, t4[0], t4[1], i5[0], i5[1]);
                        w3.overrideFog = o4 >= Ve || s5 >= Ve;
                      }
                    }
                    const C3 = u4.material;
                    let R3;
                    C3.occlusionTexture && C3.occlusionTexture.offsetScale && (R3 = C3.occlusionTexture.offsetScale, w3.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                    const A3 = t3.getOrCreateProgram("model", w3);
                    !y3 && l3 && l3.setupShadowsFromMatrix(i4.tileModelMatrix, A3, l3.useNormalOffset), t3.uploadCommonUniforms(r3, A3, null, I3);
                    const L3 = C3.pbrMetallicRoughness;
                    L3.metallicFactor = 0.9, L3.roughnessFactor = 0.5;
                    const D3 = qr(new Float32Array(b3), new Float32Array(h4), new Float32Array(d6), new Float32Array(c6.globalMatrix), t3, i4.opacity, L3.baseColorFactor, C3.emissiveFactor, L3.metallicFactor, L3.roughnessFactor, C3, x4, o3, [0, 0, 0], R3);
                    !p4 && (s4.hasTranslucentParts || i4.opacity < 1) && A3.draw(t3, r3.gl.TRIANGLES, m3, Yi.disabled, Wi.disabled, Qi.backCCW, D3, o3.id, u4.vertexBuffer, u4.indexBuffer, u4.segments, o3.paint, t3.transform.zoom, void 0, T3), A3.draw(t3, r3.gl.TRIANGLES, p4 ? g3 : m3, Yi.disabled, p4 || i4.opacity < 1 || s4.hasTranslucentParts ? Wi.alphaBlended : Wi.unblended, Qi.backCCW, D3, o3.id, u4.vertexBuffer, u4.indexBuffer, u4.segments, o3.paint, t3.transform.zoom, void 0, T3);
                  }
                }
              }
            }();
          }(t2, i2, o2, s2), void u2();
          if ("model" !== _2.type) return;
          const p2 = _2.getModels(), f2 = [], m2 = t2.transform.getFreeCameraOptions().position, g2 = e.c5([], [m2.x, m2.y, m2.z], t2.transform.worldSize);
          e.ew(g2, g2);
          const v2 = [], y2 = [];
          let x2 = 0;
          for (const s3 of p2) {
            const r3 = i2.getFeatureState("", s3.id), n3 = { type: "Unknown", id: s3.id, properties: s3.featureProperties }, c3 = o2.paint.get("model-rotation").evaluate(n3, r3), h3 = o2.paint.get("model-scale").evaluate(n3, r3), d3 = o2.paint.get("model-translation").evaluate(n3, r3), u3 = o2.paint.get("model-opacity").evaluate(n3, r3);
            ia(o2, s3.id, r3, s3.featureProperties, s3.nodeOverrideNames, s3.nodeOverrides), oa(o2, s3.id, r3, s3.featureProperties, s3.materialOverrideNames, s3.materialOverrides), s3.nodeOverrides.size > 0 && s3.computeBoundsAndApplyParent(), s3.computeModelMatrix(t2, c3, h3, d3, l2, a2, false);
            const _3 = e.bA([]), p3 = e.ef(s3.position.lat, t2.transform.zoom), m3 = e.bq([], [1, 1, 1 / p3]);
            e.br(_3, _3, g2), f2.push({ zScaleMatrix: m3, negCameraPosMatrix: _3 });
            for (const e2 of s3.nodes) ea(t2, e2, s3.matrix, t2.transform.expandedFarZProjMatrix, x2, v2, y2, s3.materialOverrides, u3);
            x2++;
          }
          if (v2.sort((e2, t3) => t3.depth - e2.depth), "shadow" !== t2.renderPass) sa(t2, o2, v2, y2, f2), u2();
          else {
            for (const e2 of y2) ta(e2.mesh, e2.nodeModelMatrix, t2, o2);
            for (const e2 of v2) ta(e2.mesh, e2.nodeModelMatrix, t2, o2);
            u2();
          }
        } }, Aa = { line: function(e2, t2, i2) {
          if (e2.hasElevatedBuckets = false, e2.hasNonElevatedBuckets = false, void 0 !== e2._unevaluatedLayout.getValue("line-elevation-reference") || void 0 !== e2._unevaluatedLayout.getValue("line-z-offset")) {
            if (t2) {
              const i3 = t2.getVisibleCoordinates();
              for (const o2 of i3) {
                const i4 = t2.getTile(o2).getBucket(e2);
                if (i4 && ("none" !== i4.elevationType ? e2.hasElevatedBuckets = true : e2.hasNonElevatedBuckets = true, e2.hasElevatedBuckets && e2.hasNonElevatedBuckets)) break;
              }
            }
          } else e2.hasNonElevatedBuckets = true;
        }, model: function(e2, t2, i2) {
          const o2 = t2.getSource();
          if (!o2.loaded()) return;
          if ("vector" === o2.type || "geojson" === o2.type) return void (i2.modelManager && i2.modelManager.upload(i2, Qn(i2, e2)));
          if ("batched-model" === o2.type) return;
          if ("model" !== o2.type) return;
          const s2 = o2.getModels();
          for (const e3 of s2) e3.upload(i2.context);
        }, raster: function(e2, t2, i2) {
          const o2 = t2.getSource();
          if (!(o2 instanceof pt && o2.loaded())) return;
          const s2 = e2.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
          if (!s2) return;
          const r2 = e2.paint.get("raster-array-band") || o2.getInitialBand(s2);
          if (null == r2) return;
          const n2 = t2.getIds().map((e3) => t2.getTileByID(e3));
          for (const t3 of n2) t3.updateNeeded(e2.id, r2) && o2.prepareTile(t3, s2, e2.id, r2);
        }, "raster-particle": function(e2, t2, i2) {
          const o2 = t2.getSource();
          if (!(o2 instanceof pt && o2.loaded())) return;
          const s2 = e2.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
          if (!s2) return;
          const r2 = e2.paint.get("raster-particle-array-band") || o2.getInitialBand(s2);
          if (null == r2) return;
          const n2 = t2.getIds().map((e3) => t2.getTileByID(e3));
          for (const t3 of n2) t3.updateNeeded(e2.id, r2) && o2.prepareTile(t3, s2, e2.id, r2);
        } }, La = { fill: cn }, Da = { fill: function(e2, t2, i2, o2) {
          if (!i2.layout || "none" === i2.layout.get("fill-elevation-reference") || 0 === i2.paint.get("fill-opacity").constantOr(1)) return;
          const s2 = e2.context.gl, r2 = new $i(s2.LEQUAL, $i.ReadOnly, e2.depthRangeFor3D), n2 = new Yi({ func: s2.ALWAYS, mask: 255 }, 255, 255, s2.KEEP, s2.KEEP, s2.REPLACE), a2 = e2.transform.getFreeCameraOptions().position, l2 = e2.getOrCreateProgram("elevatedStructuresDepthReconstruct");
          for (const c2 of o2) {
            const o3 = t2.getTile(c2), h2 = o3.getBucket(i2);
            if (!h2) continue;
            const d2 = h2.elevatedStructures;
            if (!d2 || 0 === d2.depthSegments.segments[0].primitiveLength) continue;
            const u2 = ln(c2.toUnwrapped(), a2), _2 = e2.translatePosMatrix(c2.projMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor")), p2 = Tr(_2, u2, 0, 1, 0);
            l2.draw(e2, s2.TRIANGLES, r2, n2, Wi.disabled, Qi.disabled, p2, i2.id, d2.vertexBuffer, d2.indexBuffer, d2.depthSegments, i2.paint, e2.transform.zoom);
          }
        } };
        class Pa {
          constructor(t2, i2, o2, s2, r2) {
            this.context = new Jr(t2, i2), this.transform = o2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this._timeStamp = e.o.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: false, showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
            const n2 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "building", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
            for (const e2 of n2) this._debugParams.enabledLayers[e2] = true;
            for (const e2 of n2) ;
            this.occlusionParams = new fa(), this.setup(), this.numSublayers = Ft.maxUnderzooming + Ft.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e.eP(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new po(this), this._wireframeDebugCache = new pa(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true, this.layersWithOcclusionOpacity = [];
            const a2 = new e.q({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
            this.emptyDepthTexture = new e.T(this.context, a2, t2.RGBA8), this._clippingActiveLastFrame = false, this.scaleFactor = s2, this.worldview = r2, this._forceEmissiveMode = false, this.emissiveMode = "constant";
          }
          updateTerrain(e2, t2) {
            const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
            if (!(i2 || this._terrain && this._terrain.enabled)) return;
            this._terrain || (this._terrain = new nr(this, e2));
            const o2 = this._terrain;
            this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2), this.transform.elevation && !o2.enabled && (this.transform.elevation = null);
          }
          _updateFog(e2) {
            const t2 = e2.fog;
            if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
            const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
            if (i2 > o2) return void (this.transform.fogCullDistSq = null);
            const s2 = i2 + 0.78 * (o2 - i2);
            this.transform.fogCullDistSq = s2 * s2;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
          }
          get forceTerrainMode() {
            return this._forceTerrainMode;
          }
          set forceTerrainMode(e2) {
            e2 && !this._terrain && (this._terrain = new nr(this, this.style)), this._forceTerrainMode = e2;
          }
          get shadowRenderer() {
            return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
          }
          get wireframeDebugCache() {
            return this._wireframeDebugCache;
          }
          resize(t2, i2) {
            if (this.width = t2 * e.o.devicePixelRatio, this.height = i2 * e.o.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e2 of this.style.order) this.style._mergedLayers[e2].resize();
          }
          setup() {
            const t2 = this.context, i2 = new e.bd();
            i2.emplaceBack(0, 0), i2.emplaceBack(e.al, 0), i2.emplaceBack(0, e.al), i2.emplaceBack(e.al, e.al), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.bf.members), this.tileExtentSegments = e.bg.simpleSegment(0, 0, 4, 2);
            const o2 = new e.bd();
            o2.emplaceBack(0, 0), o2.emplaceBack(e.al, 0), o2.emplaceBack(0, e.al), o2.emplaceBack(e.al, e.al), this.debugBuffer = t2.createVertexBuffer(o2, e.bf.members), this.debugSegments = e.bg.simpleSegment(0, 0, 4, 5);
            const s2 = new e.bd();
            s2.emplaceBack(-1, -1), s2.emplaceBack(1, -1), s2.emplaceBack(-1, 1), s2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(s2, e.bf.members), this.viewportSegments = e.bg.simpleSegment(0, 0, 4, 2);
            const r2 = new e.b1();
            r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(e.al, 0, e.al, 0), r2.emplaceBack(0, e.al, 0, e.al), r2.emplaceBack(e.al, e.al, e.al, e.al), this.mercatorBoundsBuffer = t2.createVertexBuffer(r2, e.bi.members), this.mercatorBoundsSegments = e.bg.simpleSegment(0, 0, 4, 2);
            const n2 = new e.b0();
            n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
            const a2 = new e.be();
            for (const e2 of [0, 1, 3, 2, 0]) a2.emplaceBack(e2);
            this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.T(t2, new e.q({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA8), this.identityMat = e.bC();
            const l2 = this.context.gl;
            this.stencilClearMode = new Yi({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(performance.now());
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e2) {
            return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const e2 = this.context.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e2.TRIANGLES, $i.disabled, this.stencilClearMode, Wi.disabled, Qi.disabled, tr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(e2, t2, i2) {
            if (!t2 || this.currentStencilSource === t2.id || !e2.isTileClipped() || !i2 || 0 === i2.length) return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e3 = false;
              for (const t3 of i2) if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                e3 = true;
                break;
              }
              if (!e3) return;
            }
            this.currentStencilSource = t2.id;
            const o2 = this.context, s2 = o2.gl;
            this.nextStencilID + i2.length > 256 && this.clearStencil(), o2.setColorMode(Wi.disabled), o2.setDepthMode($i.disabled);
            const r2 = this.getOrCreateProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const e3 of i2) {
              const i3 = t2.getTile(e3), o3 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++, { tileBoundsBuffer: n2, tileBoundsIndexBuffer: a2, tileBoundsSegments: l2 } = this.getTileBoundsBuffers(i3);
              r2.draw(this, s2.TRIANGLES, $i.disabled, new Yi({ func: s2.ALWAYS, mask: 0 }, o3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), Wi.disabled, Qi.disabled, tr(e3.projMatrix), "$clipping", n2, a2, l2);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e2 = this.nextStencilID++, t2 = this.context.gl;
            return new Yi({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
          }
          stencilModeForClipping(e2) {
            if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e2);
            const t2 = this.context.gl;
            return new Yi({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
          }
          stencilConfigForOverlap(e2) {
            const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, s2 = i2[0].overscaledZ - o2 + 1;
            if (s2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + s2 > 256 && this.clearStencil();
              const e3 = {};
              for (let i3 = 0; i3 < s2; i3++) e3[i3 + o2] = new Yi({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
              return this.nextStencilID += s2, [e3, i2];
            }
            return [{ [o2]: Yi.disabled }, i2];
          }
          colorModeForRenderPass() {
            const t2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new Wi([t2.CONSTANT_COLOR, t2.ONE, t2.CONSTANT_COLOR, t2.ONE], new e.ao(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Wi.unblended : Wi.alphaBlended;
          }
          colorModeForDrapableLayerRenderPass(t2) {
            const i2 = this.context.gl;
            return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? null != t2 && "mrt-fallback" !== this.emissiveMode || "constant" === this.emissiveMode ? new Wi([i2.ONE, i2.ONE_MINUS_SRC_ALPHA, i2.CONSTANT_ALPHA, i2.ONE_MINUS_SRC_ALPHA], new e.ao(0, 0, 0, null != t2 ? t2 : 0), [true, true, true, true]) : "dual-source-blending" === this.emissiveMode ? new Wi([i2.ONE, i2.ONE_MINUS_SRC_ALPHA, this.context.extBlendFuncExtended.SRC1_ALPHA_WEBGL, i2.ONE_MINUS_SRC_ALPHA], e.ao.transparent, [true, true, true, true]) : this.colorModeForRenderPass() : this.colorModeForRenderPass();
          }
          depthModeForSublayer(e2, t2, i2, o2 = false) {
            if (this.depthOcclusion) return new $i(this.context.gl.GREATER, $i.ReadOnly, this.depthRangeFor3D);
            if (!this.opaquePassEnabledForLayer() && !o2) return $i.disabled;
            const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
            return new $i(i2 || this.context.gl.LEQUAL, t2, [s2, s2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          blitDepth() {
            const t2 = this.context.gl, i2 = Math.ceil(this.width), o2 = Math.ceil(this.height), s2 = this.context.bindFramebuffer.get(), r2 = t2.getParameter(t2.TEXTURE_BINDING_2D);
            this.depthFBO && this.depthFBO.width === i2 && this.depthFBO.height === o2 || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i2 && 0 !== o2 && (this.depthFBO = new Kr(this.context, i2, o2, 0, "texture"), this.depthTexture = new e.T(this.context, { width: i2, height: o2, data: null }, t2.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s2), t2.bindTexture(t2.TEXTURE_2D, r2), this.depthFBO && (t2.bindFramebuffer(t2.READ_FRAMEBUFFER, null), t2.bindFramebuffer(t2.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t2.blitFramebuffer(0, 0, i2, o2, 0, 0, i2, o2, t2.DEPTH_BUFFER_BIT, t2.NEAREST), t2.bindFramebuffer(t2.FRAMEBUFFER, this.context.bindFramebuffer.current));
          }
          updateAverageFPS() {
            this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e2, t2) => e2 + t2 / this._fpsHistory.length, 0));
          }
          render(t2, i2) {
            const o2 = e.o.now();
            this._dt = o2 - this._timeStamp, this._timeStamp = o2, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t2.map.repaint, this.style = t2, this.options = i2;
            const s2 = this.style._mergedLayers, r2 = !(!this.terrain || !this.terrain.enabled), n2 = () => this.style._getOrder(r2).filter((e2) => {
              const t3 = s2[e2];
              return !(t3.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t3.type];
            });
            let a2 = n2(), l2 = false, c2 = false, h2 = null, d2 = 0, u2 = false;
            for (const e2 of a2) {
              const t3 = s2[e2];
              "none" !== t3.visibility && ("circle" === t3.type ? l2 = true : "building" === t3.type ? (h2 = t3, ++d2) : "symbol" === t3.type && (t3.hasOcclusionOpacityProperties ? c2 = true : l2 = true));
            }
            this.updateEmissiveMode();
            let _2 = a2.map((e2) => s2[e2]);
            const p2 = this.style._mergedSourceCaches;
            this.imageManager = t2.imageManager, this.modelManager = t2.modelManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.o.now()), this.imageManager.beginFrame();
            for (const e2 in p2) {
              const t3 = p2[e2];
              t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++d2);
            }
            let f2 = false;
            for (const e2 of _2) e2.isHidden(this.transform.zoom) || ("clip" === e2.type && (f2 = true), this.prepareLayer(e2));
            const m2 = {}, g2 = {}, v2 = {}, y2 = {}, x2 = {};
            for (const e2 in p2) {
              const t3 = p2[e2];
              m2[e2] = t3.getVisibleCoordinates(), g2[e2] = m2[e2].slice().reverse(), v2[e2] = t3.getVisibleCoordinates(true).reverse(), y2[e2] = t3.getShadowCasterCoordinates(), x2[e2] = t3.sortCoordinatesByDistance(m2[e2]);
            }
            const b2 = (e2) => {
              const t3 = this.style.getLayerSourceCache(e2);
              return t3 && t3.used ? t3.getSource() : null;
            };
            if (d2 || f2 || this._clippingActiveLastFrame) {
              const t3 = [], i3 = [];
              let o3 = 0;
              for (const e2 of _2) this.isSourceForClippingOrConflation(e2, b2(e2)) && (t3.push(e2), i3.push(o3)), o3++;
              if (t3 && (f2 || t3.length > 1) || this._clippingActiveLastFrame) {
                f2 = false;
                const o4 = [];
                for (let s3 = 0; s3 < t3.length; s3++) {
                  const r3 = t3[s3], n3 = i3[s3], a3 = this.style.getLayerSourceCache(r3);
                  if (!a3 || !a3.used || !a3.getSource().usedInConflation && "clip" !== r3.type && "building" !== r3.type) continue;
                  let l3 = e.eQ, c3 = e.b_.None;
                  const h3 = [];
                  let d3 = true;
                  if ("building" === r3.type) l3 = e.eS;
                  else if ("clip" === r3.type) if (l3 = n3, r3.isHidden(this.transform.zoom)) d3 = false;
                  else {
                    if (!r3.layout) {
                      d3 = false;
                      continue;
                    }
                    for (const t4 of r3.layout.get("clip-layer-types")) c3 |= "model" === t4 ? e.b_.Model : "symbol" === t4 ? e.b_.Symbol : e.b_.FillExtrusion;
                    for (const e2 of r3.layout.get("clip-layer-scope")) h3.push(e2);
                    f2 = true;
                  }
                  d3 && o4.push({ layer: r3.fqid, cache: a3, order: l3, clipMask: c3, clipScope: h3 });
                }
                this.replacementSource.setSources(o4), u2 = true;
              }
            }
            this._clippingActiveLastFrame = f2, u2 || this.replacementSource.clear(), this.conflationActive = u2, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
            for (let e2 = 0; e2 < _2.length; e2++) {
              const t3 = _2[e2];
              if ("none" === t3.visibility) continue;
              const i3 = t3.cutoffRange();
              if (this.longestCutoffRange = Math.max(i3, this.longestCutoffRange), i3 > 0) {
                const e3 = b2(t3);
                e3 && (this.minCutoffZoom = Math.max(e3.minzoom, this.minCutoffZoom)), t3.minzoom && (this.minCutoffZoom = Math.max(t3.minzoom, this.minCutoffZoom));
              }
              t3.is3D(r2) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e2), this._lastOcclusionLayer = e2);
            }
            const w2 = this.style && this.style.fog;
            w2 ? (this._fogVisible = 0 !== w2.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = w2.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(v2), this.opaquePassCutoff = 0, a2 = n2(), _2 = a2.map((e2) => s2[e2]));
            const T2 = this._shadowRenderer;
            if (T2) {
              T2.updateShadowParameters(this.transform, this.style.directionalLight);
              for (const e2 in p2) for (const t3 of m2[e2]) {
                let e3 = { min: 0, max: 0 };
                this.terrain && (e3 = this.terrain.getMinMaxForTile(t3) || e3), T2.addShadowReceiver(t3.toUnwrapped(), e3.min, e3.max);
              }
            }
            "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.eR(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new $n(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
            const E2 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), S2 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
            if (E2 && !this._snow && (this._snow = new Ca(this)), !E2 && this._snow && (this._snow.destroy(), delete this._snow), S2 && !this._rain && (this._rain = new Sa(this)), !S2 && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), h2) {
              this.buildingTileBorderManager || (this.buildingTileBorderManager = new Xn());
              const e2 = this.style.getLayerSourceCache(h2);
              this.buildingTileBorderManager.updateBorders(e2, h2);
            }
            if (!q.has(this.context.gl)) return;
            this.renderPass = "offscreen";
            for (const e2 of _2) {
              const i3 = t2.getLayerSourceCache(e2);
              if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom)) continue;
              const o3 = i3 ? g2[i3.id] : void 0;
              ("custom" === e2.type || "raster" === e2.type || "raster-particle" === e2.type || e2.isSky() || o3 && o3.length) && this.renderLayer(this, i3, e2, o3);
            }
            this.depthRangeFor3D = [0, 1 - (_2.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, y2)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
            const I2 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), C2 = (() => {
              if (i2.showOverdrawInspector) return e.ao.black;
              const t3 = this.style.fog;
              if (t3 && this.transform.projection.supportsFog) {
                const i3 = this.style.getLut(t3.scope);
                if (!I2) {
                  const o3 = "none" === t3.properties.get("color-use-theme"), s3 = t3.properties.get("color").toNonPremultipliedRenderColor(o3 ? null : i3).toArray01();
                  return new e.ao(...s3);
                }
                if (I2) {
                  const o3 = "none" === t3.properties.get("space-color-use-theme"), s3 = t3.properties.get("space-color").toNonPremultipliedRenderColor(o3 ? null : i3).toArray01();
                  return new e.ao(...s3);
                }
              }
              return e.ao.transparent;
            })();
            if (this.context.clear({ color: C2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I2 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = a2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e2 = _2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
              if (e2.isSky()) continue;
              const o3 = i3 ? (e2.is3D(r2) ? x2 : g2)[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, o3), this.renderLayer(this, i3, e2, o3);
            }
            if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I2 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.aj(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < a2.length; this.currentLayer++) {
              const e2 = _2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
              e2.isSky() && this.renderLayer(this, i3, e2, i3 ? g2[i3.id] : void 0);
            }
            function R2(e2, t3) {
              let i3;
              return t3 && (i3 = ("symbol" === e2.type ? v2 : e2.is3D(r2) ? x2 : g2)[t3.id]), i3;
            }
            if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
              for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < a2.length; ) {
                const e2 = _2[this.currentLayer];
                if ("raster" === e2.type || "raster-particle" === e2.type) {
                  const i3 = t2.getLayerSourceCache(e2);
                  this.renderLayer(this, i3, e2, R2(e2, i3));
                }
                ++this.currentLayer;
              }
              this.renderElevatedRasterBackface = false;
            }
            this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
            const A2 = T2 ? T2.getGroundShadowLayerIndex() : -1;
            let L2 = false, D2 = -1;
            for (let e2 = 0; e2 < a2.length; ++e2) {
              const t3 = _2[e2];
              t3.isHidden(this.transform.zoom) || t3.is3D(r2) && (D2 = e2);
            }
            c2 && -1 === D2 && (l2 = true);
            let P2 = false;
            for (; this.currentLayer < a2.length; ) {
              const e2 = _2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
              if (e2.isSky()) ++this.currentLayer;
              else if (this.terrain && this.style.isLayerDraped(e2)) {
                if (e2.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
              } else {
                if (!P2 && e2.is3D(r2) && !r2) {
                  const e3 = this.currentLayer, t3 = (e4) => {
                    for (this.currentLayer = 0; this.currentLayer < _2.length; this.currentLayer++) {
                      const t4 = _2[this.currentLayer];
                      if (La[t4.type]) {
                        const i4 = this.style.getLayerSourceCache(t4);
                        La[t4.type](this, i4, t4, R2(t4, i4), e4);
                      }
                    }
                  };
                  t3("initialize"), t3("reset"), this.currentLayer = e3, P2 = true;
                }
                if (l2 && !L2 && this.terrain && !this.transform.isOrthographic && (L2 = true, this.blitDepth()), c2 && -1 !== D2 && this.currentLayer === D2 + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e2, i3, i3 ? m2[i3.id] : void 0), this.renderLayer(this, i3, e2, R2(e2, i3)), !this.terrain && T2 && this.currentLayer === A2) {
                  {
                    this.clearStencil(), this.resetStencilClippingMasks();
                    const e3 = this.currentLayer;
                    for (this.currentLayer = 0; this.currentLayer < _2.length; this.currentLayer++) {
                      const e4 = _2[this.currentLayer];
                      if (Da[e4.type]) {
                        const t3 = this.style.getLayerSourceCache(e4);
                        Da[e4.type](this, t3, e4, R2(e4, t3));
                      }
                    }
                    this.currentLayer = e3;
                  }
                  if (T2.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer) {
                    const e3 = this.currentLayer;
                    for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e3; this.currentLayer++) {
                      const e4 = _2[this.currentLayer];
                      if (!e4.hasLightBeamPass()) continue;
                      const i4 = t2.getLayerSourceCache(e4);
                      this.renderLayer(this, i4, e4, i4 ? g2[i4.id] : void 0);
                    }
                    this.currentLayer = e3, this.renderPass = "translucent";
                  }
                }
                if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                  const e3 = this.currentLayer;
                  this.depthOcclusion = true;
                  for (const e4 of this.layersWithOcclusionOpacity) {
                    this.currentLayer = e4;
                    const i4 = _2[this.currentLayer], o3 = t2.getLayerSourceCache(i4), s3 = o3 ? g2[o3.id] : void 0;
                    this.terrain || this._renderTileClippingMasks(i4, o3, o3 ? m2[o3.id] : void 0), this.renderLayer(this, o3, i4, s3);
                  }
                  this.depthOcclusion = false, this.currentLayer = e3, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                }
                ++this.currentLayer;
              }
            }
            if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i3 = null;
              _2.forEach((e2) => {
                const o3 = t2.getLayerSourceCache(e2);
                o3 && !e2.isHidden(this.transform.zoom) && o3.getVisibleCoordinates().length && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
              }), i3 && this.options.showTileBoundaries && zn(this, i3, i3.getVisibleCoordinates(), e.ao.red, false, this.options.showParseStatus);
            }
            this.terrain && this._debugParams.showTerrainProxyTiles && zn(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.ao(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e2) {
              const t3 = e2.transform.padding;
              Fn(e2, e2.transform.height - (t3.top || 0), 3, An), Fn(e2, t3.bottom || 0, 3, Ln), Bn(e2, t3.left || 0, 3, Dn), Bn(e2, e2.transform.width - (t3.right || 0), 3, Pn);
              const i3 = e2.transform.centerPoint;
              !function(e3, t4, i4, o3) {
                kn(e3, t4 - 1, i4 - 10, 2, 20, o3), kn(e3, t4 - 10, i4 - 1, 20, 2, o3);
              }(e2, i3.x, e2.transform.height - i3.y, On);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), u2 || (this.conflationActive = false);
          }
          prepareLayer(e2) {
            this.gpuTimingStart(e2);
            const { unsupportedLayers: t2 } = this.transform.projection, i2 = !t2 || !t2.includes(e2.type);
            if (Aa[e2.type] && (i2 || this.terrain && "custom" === e2.type)) {
              const t3 = this.style.getLayerSourceCache(e2);
              Aa[e2.type](e2, t3, this);
            }
            this.gpuTimingEnd();
          }
          renderLayer(e2, t2, i2, o2) {
            i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || "model" === i2.type || "raster" === i2.type || "raster-particle" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), e2.transform.projection.unsupportedLayers && e2.transform.projection.unsupportedLayers.includes(i2.type) && (!e2.terrain || "custom" !== i2.type) || "clip" === i2.type || Ra[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e2) {
            if (!this.options.gpuTiming) return;
            const t2 = this.context.extTimerQuery, i2 = this.context.gl;
            let o2 = this.gpuTimers[e2.id];
            o2 || (o2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: i2.createQuery() }), o2.calls++, i2.beginQuery(t2.TIME_ELAPSED_EXT, o2.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const e2 = this.context.extTimerQuery, t2 = this.context.gl, i2 = t2.createQuery();
              this.deferredRenderGpuTimeQueries.push(i2), t2.beginQuery(e2.TIME_ELAPSED_EXT, i2);
            }
          }
          gpuTimingDeferredRenderEnd() {
            this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e2 = this.gpuTimers;
            return this.gpuTimers = {}, e2;
          }
          collectDeferredRenderGpuQueries() {
            const e2 = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], e2;
          }
          queryGpuTimers(e2) {
            const t2 = {};
            for (const i2 in e2) {
              const o2 = e2[i2], s2 = this.context.extTimerQuery, r2 = s2.getQueryParameter(o2.query, this.context.gl.QUERY_RESULT) / 1e6;
              s2.deleteQueryEXT(o2.query), t2[i2] = r2;
            }
            return t2;
          }
          queryGpuTimeDeferredRender(e2) {
            if (!this.options.gpuTimingDeferredRender) return 0;
            const t2 = this.context.gl;
            let i2 = 0;
            for (const o2 of e2) i2 += t2.getQueryParameter(o2, t2.QUERY_RESULT) / 1e6, t2.deleteQuery(o2);
            return i2;
          }
          translatePosMatrix(t2, i2, o2, s2, r2) {
            if (!o2[0] && !o2[1]) return t2;
            const n2 = r2 ? "map" === s2 ? this.transform.angle : 0 : "viewport" === s2 ? -this.transform.angle : 0;
            if (n2) {
              const e2 = Math.sin(n2), t3 = Math.cos(n2);
              o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
            }
            const a2 = [r2 ? o2[0] : e.ay(i2, o2[0], this.transform.zoom), r2 ? o2[1] : e.ay(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return e.br(l2, t2, a2), l2;
          }
          saveTileTexture(e2) {
            if (e2.context !== this.context) return;
            const t2 = e2.size[0], i2 = this._tileTextures[t2];
            i2 ? i2.push(e2) : this._tileTextures[t2] = [e2];
          }
          getTileTexture(e2) {
            const t2 = this._tileTextures[e2];
            return t2 && t2.length > 0 ? t2.pop() : null;
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
          }
          linearFloatFilteringSupported() {
            return null != this.context.extTextureFloatLinear;
          }
          currentGlobalDefines(e2, t2, i2) {
            const o2 = void 0 === i2 ? this.terrain && this.terrain.renderingToTexture : i2, s2 = [];
            return this.style && this.style.enable3dLights() && ("globeRaster" === e2 || "terrainRaster" === e2 ? (s2.push("LIGHTING_3D_MODE"), s2.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o2 || s2.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || s2.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s2.push("TERRAIN"), this.linearFloatFilteringSupported() && s2.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && s2.push("GLOBE"), !this._fogVisible || o2 || void 0 !== t2 && !t2 || s2.push("FOG"), o2 && s2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s2.push("OVERDRAW_INSPECTOR"), s2;
          }
          getOrCreateProgram(e2, t2) {
            this.cache = this.cache || {};
            const i2 = t2 && t2.defines || [], o2 = t2 && t2.config, s2 = this.currentGlobalDefines(e2, t2 && t2.overrideFog, t2 && t2.overrideRtt).concat(i2), r2 = hr.cacheKey(is[e2], e2, s2, o2);
            return this.cache[r2] || (this.cache[r2] = new hr(this.context, e2, is[e2], o2, Wr[e2], s2)), this.cache[r2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          uploadCommonLightUniforms(t2, i2) {
            if (this.style.enable3dLights()) {
              const o2 = this.style.directionalLight, s2 = this.style.ambientLight;
              if (o2 && s2) {
                const r2 = ((t3, i3, o3) => {
                  const s3 = t3.properties.get("direction"), r3 = "none" === t3.properties.get("color-use-theme"), n2 = t3.properties.get("color").toNonPremultipliedRenderColor(r3 ? null : o3.getLut(t3.scope)).toArray01(), a2 = t3.properties.get("intensity"), l2 = "none" === i3.properties.get("color-use-theme"), c2 = i3.properties.get("color").toNonPremultipliedRenderColor(l2 ? null : o3.getLut(i3.scope)).toArray01(), h2 = i3.properties.get("intensity"), d2 = [s3.x, s3.y, s3.z], u2 = e.dN(c2, h2), _2 = e.dN(n2, a2);
                  return { u_lighting_ambient_color: u2, u_lighting_directional_dir: d2, u_lighting_directional_color: _2, u_ground_radiance: ar(d2, _2, u2) };
                })(o2, s2, this.style);
                i2.setLightsUniformValues(t2, r2);
              }
            }
          }
          uploadCommonUniforms(t2, i2, o2, s2, r2) {
            if (this.uploadCommonLightUniforms(t2, i2), this.terrain && this.terrain.renderingToTexture) return;
            const n2 = this.style.fog;
            if (n2) {
              const r3 = n2.getOpacity(this.transform.pitch), a2 = ((t3, i3, o3, s3, r4, n3, a3, l2, c2, h2, d2, u2) => {
                const _2 = t3.transform, p2 = "none" === i3.properties.get("color-use-theme"), f2 = i3.properties.get("color").toNonPremultipliedRenderColor(p2 ? null : t3.style.getLut(i3.scope)).toArray01();
                f2[3] = s3;
                const m2 = t3.frameCounter / 1e3 % 1, [g2, v2] = i3.properties.get("vertical-range");
                return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : u2 || t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: f2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(g2, v2), v2], u_fog_temporal_offset: m2, u_frustum_tl: r4, u_frustum_tr: n3, u_frustum_br: a3, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h2, u_viewport: d2, u_globe_transition: e.aj(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
              })(this, n2, o2, r3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.o.devicePixelRatio, this.transform.height * e.o.devicePixelRatio], s2);
              i2.setFogUniformValues(t2, a2);
            }
            r2 && i2.setCutoffUniformValues(t2, r2.uniformValues);
          }
          setTileLoadedFlag(e2) {
            this.tileLoaded = e2;
          }
          saveCanvasCopy() {
            const e2 = this.canvasCopy();
            e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
          }
          canvasCopy() {
            const e2 = this.context.gl, t2 = e2.createTexture();
            return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation) return false;
            const e2 = this.style && this.style.fog;
            return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
          }
          getBackgroundTiles() {
            const e2 = this._backgroundTiles, t2 = this._backgroundTiles = {}, i2 = this.transform.coveringTiles({ tileSize: 512 });
            for (const o2 of i2) t2[o2.key] = e2[o2.key] || new Pt(o2, 512, this.transform.tileZoom, this, void 0, this.worldview);
            return t2;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
          isSourceForClippingOrConflation(e2, t2) {
            return !(!e2.is3D(!(!this.terrain || !this.terrain.enabled)) || "clip" !== e2.type && "building" !== e2.type && (e2.minzoom && e2.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e2.sourceLayer && "procedural_buildings" !== e2.sourceLayer) && (!t2 || "batched-model" !== t2.type)));
          }
          isTileAffectedByFog(e2) {
            if (!this.style || !this.style.fog) return false;
            if ("globe" === this.transform.projection.name) return true;
            let t2 = this._cachedTileFogOpacities[e2.key];
            return t2 || (this._cachedTileFogOpacities[e2.key] = t2 = this.style.fog.getOpacityForTile(e2)), t2[0] >= Ve || t2[1] >= Ve;
          }
          setupDepthForOcclusion(e2, t2, i2) {
            const o2 = this.context, s2 = o2.gl, r2 = !!i2;
            var n2;
            i2 || (i2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), o2.activeTexture.set(s2.TEXTURE3), e2 && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), i2.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i2.u_depth_range_unpack = [2 / ((n2 = this.depthRangeFor3D)[1] - n2[0]), -1 - 2 * n2[0] / (n2[1] - n2[0])], i2.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, i2.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), o2.activeTexture.set(s2.TEXTURE0), r2 || t2.setTerrainUniformValues(o2, i2);
          }
          updateEmissiveMode() {
            if (this._forceEmissiveMode) return;
            const e2 = this.style.hasDataDrivenEmissiveStrength();
            this.emissiveMode = e2 ? this.context.extBlendFuncExtended ? "dual-source-blending" : "mrt-fallback" : "constant";
          }
        }
        function Oa(e2, t2) {
          let i2 = false, o2 = null;
          const s2 = () => {
            o2 = null, i2 && (e2(), o2 = setTimeout(s2, t2), i2 = false);
          };
          return () => (i2 = true, o2 || s2(), o2);
        }
        class za {
          constructor(t2) {
            this._hashName = t2 && encodeURIComponent(t2), e.aY(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Oa(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(e2) {
            return this._map = e2, window.addEventListener("hashchange", this._onHashChange, false), e2.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const e2 = this._map;
            if (!e2) return "";
            const t2 = Ma(e2);
            if (this._hashName) {
              const e3 = this._hashName;
              let i2 = false;
              const o2 = location.hash.slice(1).split("&").map((o3) => {
                const s2 = o3.split("=")[0];
                return s2 === e3 ? (i2 = true, `${s2}=${t2}`) : o3;
              }).filter((e4) => e4);
              return i2 || o2.push(`${e3}=${t2}`), `#${o2.join("&")}`;
            }
            return `#${t2}`;
          }
          _getCurrentHash() {
            const e2 = location.hash.replace("#", "");
            if (this._hashName) {
              let t2;
              return e2.split("&").map((e3) => e3.split("=")).forEach((e3) => {
                e3[0] === this._hashName && (t2 = e3);
              }), (t2 && t2[1] || "").split("/");
            }
            return e2.split("/");
          }
          _onHashChange() {
            const e2 = this._map;
            if (!e2) return false;
            const t2 = this._getCurrentHash();
            if (t2.length >= 3 && !t2.some((e3) => isNaN(Number(e3)))) {
              const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
              return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
          }
        }
        function Ma(e2, t2) {
          const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, s2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), r2 = Math.pow(10, s2), n2 = Math.round(i2.lng * r2) / r2, a2 = Math.round(i2.lat * r2) / r2, l2 = e2.getBearing(), c2 = e2.getPitch();
          let h2 = t2 ? `/${n2}/${a2}/${o2}` : `${o2}/${a2}/${n2}`;
          return (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), h2;
        }
        const Fa = { linearity: 0.3, easing: e.eT(0, 0, 0.3, 1) }, Ba = Object.assign({ deceleration: 2500, maxSpeed: 1400 }, Fa), ka = Object.assign({ deceleration: 20, maxSpeed: 1400 }, Fa), Na = Object.assign({ deceleration: 1e3, maxSpeed: 360 }, Fa), Ua = Object.assign({ deceleration: 1e3, maxSpeed: 90 }, Fa);
        class ja {
          constructor(e2) {
            this._map = e2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.o.now(), settings: t2 });
          }
          _drainInertiaBuffer() {
            const t2 = this._inertiaBuffer, i2 = e.o.now();
            for (; t2.length > 0 && i2 - t2[0].time > 160; ) t2.shift();
          }
          _onMoveEnd(t2) {
            if (this._map._prefersReducedMotion()) return;
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e2 } of this._inertiaBuffer) i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
            const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
            if (i2.pan.mag()) {
              const e2 = Ga(i2.pan.mag(), o2, Object.assign({}, Ba, t2 || {}));
              s2.offset = i2.pan.mult(e2.amount / i2.pan.mag()), s2.center = this._map.transform.center, Va(s2, e2);
            }
            if (i2.zoom) {
              const e2 = Ga(i2.zoom, o2, ka);
              s2.zoom = this._map.transform.zoom + e2.amount, Va(s2, e2);
            }
            if (i2.bearing) {
              const t3 = Ga(i2.bearing, o2, Na);
              s2.bearing = this._map.transform.bearing + e.aA(t3.amount, -179, 179), Va(s2, t3);
            }
            if (i2.pitch) {
              const e2 = Ga(i2.pitch, o2, Ua);
              s2.pitch = this._map.transform.pitch + e2.amount, Va(s2, e2);
            }
            if (s2.zoom || s2.bearing) {
              const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              s2.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
            }
            return this.clear(), s2.noMoveStart = true, s2;
          }
        }
        function Va(e2, t2) {
          (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
        }
        function Ga(t2, i2, o2) {
          const { maxSpeed: s2, linearity: r2, deceleration: n2 } = o2, a2 = e.aA(t2 * r2 / (i2 / 1e3), -s2, s2), l2 = Math.abs(a2) / (n2 * r2);
          return { easing: o2.easing, duration: 1e3 * l2, amount: a2 * (l2 / 2) };
        }
        class Ha extends e.z {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, t2, i2, o2 = {}) {
            const s2 = g(t2.getCanvasContainer(), i2), r2 = t2.unproject(s2);
            super(e2, Object.assign({ point: s2, lngLat: r2, originalEvent: i2 }, o2)), this._defaultPrevented = false, this.target = t2;
          }
        }
        class qa extends e.z {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, o2) {
            const s2 = "touchend" === t2 ? o2.changedTouches : o2.touches, r2 = v(i2.getCanvasContainer(), s2), n2 = r2.map((e2) => i2.unproject(e2)), a2 = r2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.P(0, 0));
            super(t2, { points: r2, point: a2, lngLats: n2, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
          }
        }
        class Za extends e.z {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, t2) {
            super("wheel", { originalEvent: t2 }), this._defaultPrevented = false;
          }
        }
        class Wa {
          constructor(e2, t2) {
            this._map = e2, this._clickTolerance = t2.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(e2) {
            return this._firePreventable(new Za(this._map, e2));
          }
          mousedown(e2, t2) {
            return this._mousedownPos = t2, this._firePreventable(new Ha(e2.type, this._map, e2));
          }
          mouseup(e2) {
            this._map.fire(new Ha(e2.type, this._map, e2));
          }
          preclick(e2) {
            const t2 = new MouseEvent("preclick", e2);
            this._map.fire(new Ha(t2.type, this._map, t2));
          }
          click(e2, t2) {
            this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new Ha(e2.type, this._map, e2)));
          }
          dblclick(e2) {
            return this._firePreventable(new Ha(e2.type, this._map, e2));
          }
          mouseover(e2) {
            this._map.fire(new Ha(e2.type, this._map, e2));
          }
          mouseout(e2) {
            this._map.fire(new Ha(e2.type, this._map, e2));
          }
          touchstart(e2) {
            return this._firePreventable(new qa(e2.type, this._map, e2));
          }
          touchmove(e2) {
            this._map.fire(new qa(e2.type, this._map, e2));
          }
          touchend(e2) {
            this._map.fire(new qa(e2.type, this._map, e2));
          }
          touchcancel(e2) {
            this._map.fire(new qa(e2.type, this._map, e2));
          }
          _firePreventable(e2) {
            if (this._map.fire(e2), e2.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class $a {
          constructor(e2) {
            this._map = e2;
          }
          reset() {
            this._delayContextMenu = false, this._contextMenuEvent = void 0;
          }
          mousemove(e2) {
            this._map.fire(new Ha(e2.type, this._map, e2));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Ha("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e2) {
            this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new Ha(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Xa {
          constructor(e2, t2) {
            this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e2, t2) {
            this.isEnabled() && e2.shiftKey && 0 === e2.button && (_(), this._startPos = this._lastPos = t2, this._active = true);
          }
          mousemoveWindow(e2, t2) {
            if (!this._active) return;
            const i2 = t2, o2 = this._startPos, s2 = this._lastPos;
            if (!o2 || !s2 || s2.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance) return;
            this._lastPos = i2, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
            const r2 = Math.min(o2.x, i2.x), n2 = Math.max(o2.x, i2.x), a2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${r2}px,${a2}px)`, this._box.style.width = n2 - r2 + "px", this._box.style.height = c2 - a2 + "px");
            });
          }
          mouseupWindow(t2, i2) {
            if (!this._active) return;
            const o2 = this._startPos, s2 = i2;
            if (o2 && 0 === t2.button) {
              if (this.reset(), m(), o2.x !== s2.x || o2.y !== s2.y) return this._map.fire(new e.z("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, s2, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", t2);
            }
          }
          keydown(e2) {
            this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t2, i2) {
            return this._map.fire(new e.z(t2, { originalEvent: i2 }));
          }
        }
        function Ya(e2, t2) {
          const i2 = {};
          for (let o2 = 0; o2 < e2.length; o2++) i2[e2[o2].identifier] = t2[o2];
          return i2;
        }
        class Ka {
          constructor(e2) {
            this.reset(), this.numTouches = e2.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
          }
          touchstart(t2, i2, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
              const i3 = new e.P(0, 0);
              for (const e2 of t3) i3._add(e2);
              return i3.div(t3.length);
            }(i2), this.touches = Ya(o2, i2)));
          }
          touchmove(e2, t2, i2) {
            if (this.aborted || !this.centroid) return;
            const o2 = Ya(i2, t2);
            for (const e3 in this.touches) {
              const t3 = o2[e3];
              (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
            }
          }
          touchend(e2, t2, i2) {
            if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const e3 = !this.aborted && this.centroid;
              if (this.reset(), e3) return e3;
            }
          }
        }
        class Ja {
          constructor(e2) {
            this.singleTap = new Ka(e2), this.numTaps = e2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(e2, t2, i2) {
            this.singleTap.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this.singleTap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const o2 = this.singleTap.touchend(e2, t2, i2);
            if (o2) {
              const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps) return this.reset(), o2;
            }
          }
        }
        class Qa {
          constructor() {
            this._zoomIn = new Ja({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ja({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e2, t2, i2) {
            this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const o2 = this._zoomIn.touchend(e2, t2, i2), s2 = this._zoomOut.touchend(e2, t2, i2);
            return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : s2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(s2) }, { originalEvent: e2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const el = 0, tl = 2, il = { [el]: 1, [tl]: 2 }, ol = { Control: "ctrlKey", Alt: "altKey", Shift: "shiftKey", Meta: "metaKey" };
        class sl {
          constructor(e2) {
            this.reset(), this._clickTolerance = e2.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(e2, t2) {
            return false;
          }
          _move(e2, t2) {
            return {};
          }
          mousedown(e2, t2) {
            if (this._lastPoint) return;
            const i2 = y(e2);
            this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
          }
          mousemoveWindow(e2, t2) {
            const i2 = this._lastPoint;
            if (i2) {
              if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
                const i3 = il[t3];
                return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
              }(e2, this._eventButton)) this.reset();
              else if (this._moved || !(t2.dist(i2) < this._clickTolerance)) return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
            }
          }
          mouseupWindow(e2) {
            this._lastPoint && y(e2) === this._eventButton && (this._moved && m(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class rl extends sl {
          mousedown(e2, t2) {
            super.mousedown(e2, t2), this._lastPoint && (this._active = true);
          }
          _correctButton(e2, t2) {
            return 0 === t2 && !e2.ctrlKey;
          }
          _move(e2, t2) {
            return { around: t2, panDelta: t2.sub(e2) };
          }
        }
        class nl extends sl {
          constructor(e2) {
            super(e2), this._pitchRotateKey = e2.pitchRotateKey ? ol[e2.pitchRotateKey] : void 0;
          }
          _correctButton(e2, t2) {
            return this._pitchRotateKey ? 0 === t2 && e2[this._pitchRotateKey] : 0 === t2 && e2.ctrlKey || 2 === t2;
          }
          _move(e2, t2) {
            const i2 = 0.8 * (t2.x - e2.x);
            if (i2) return this._active = true, { bearingDelta: i2 };
          }
          contextmenu(e2) {
            this._pitchRotateKey || e2.preventDefault();
          }
        }
        class al extends sl {
          constructor(e2) {
            super(e2), this._pitchRotateKey = e2.pitchRotateKey ? ol[e2.pitchRotateKey] : void 0;
          }
          _correctButton(e2, t2) {
            return this._pitchRotateKey ? 0 === t2 && e2[this._pitchRotateKey] : 0 === t2 && e2.ctrlKey || 2 === t2;
          }
          _move(e2, t2) {
            const i2 = -0.5 * (t2.y - e2.y);
            if (i2) return this._active = true, { pitchDelta: i2 };
          }
          contextmenu(e2) {
            this._pitchRotateKey || e2.preventDefault();
          }
        }
        class ll {
          constructor(t2, i2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.aY(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
          }
          touchstart(e2, t2, i2) {
            return this._calculateTransform(e2, t2, i2);
          }
          touchmove(t2, i2, o2) {
            if (this._active && !(o2.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (1 === o2.length && !e.eU()) return void this._showTouchPanBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
            }
          }
          touchend(e2, t2, i2) {
            this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t2, i2, o2) {
            o2.length > 0 && (this._active = true);
            const s2 = Ya(o2, i2), r2 = new e.P(0, 0), n2 = new e.P(0, 0);
            let a2 = 0;
            for (const e2 in s2) {
              const t3 = s2[e2], i3 = this._touches[e2];
              i3 && (r2._add(t3), n2._add(t3.sub(i3)), a2++, s2[e2] = t3);
            }
            if (this._touches = s2, a2 < this._minTouches || !n2.mag()) return;
            const l2 = n2.div(a2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: r2.div(a2), panDelta: l2 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 500);
          }
        }
        class cl {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, this._firstTwoTouches = void 0;
          }
          _start(e2) {
          }
          _move(e2, t2, i2) {
            return {};
          }
          touchstart(e2, t2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
          }
          touchmove(e2, t2, i2) {
            const o2 = this._firstTwoTouches;
            if (!o2) return;
            e2.preventDefault();
            const [s2, r2] = o2, n2 = hl(i2, t2, s2), a2 = hl(i2, t2, r2);
            if (!n2 || !a2) return;
            const l2 = this._aroundCenter ? null : n2.add(a2).div(2);
            return this._move([n2, a2], l2, e2);
          }
          touchend(e2, t2, i2) {
            if (!this._firstTwoTouches) return;
            const [o2, s2] = this._firstTwoTouches, r2 = hl(i2, t2, o2), n2 = hl(i2, t2, s2);
            r2 && n2 || (this._active && m(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e2) {
            this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function hl(e2, t2, i2) {
          for (let o2 = 0; o2 < e2.length; o2++) if (e2[o2].identifier === i2) return t2[o2];
        }
        function dl(e2, t2) {
          return Math.log2(e2 / t2);
        }
        class ul extends cl {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(e2) {
            this._startDistance = this._distance = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._distance;
            if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(dl(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: dl(this._distance, i2), pinchAround: t2 };
          }
        }
        function _l(e2, t2) {
          return 180 * e2.angleWith(t2) / Math.PI;
        }
        class pl extends cl {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(e2) {
            this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._vector;
            if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: _l(this._vector, i2), pinchAround: t2 };
          }
          _isBelowThreshold(e2) {
            this._minDiameter = Math.min(this._minDiameter, e2.mag());
            const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
            if (!i2) return false;
            const o2 = _l(e2, i2);
            return Math.abs(o2) < t2;
          }
        }
        function fl(e2) {
          return Math.abs(e2.y) > Math.abs(e2.x);
        }
        class ml extends cl {
          constructor(e2) {
            super(), this._map = e2;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(e2) {
            this._lastPoints = e2, fl(e2[0].sub(e2[1])) && (this._valid = false);
          }
          _move(t2, i2, o2) {
            const s2 = this._lastPoints;
            if (!s2) return;
            const r2 = t2[0].sub(s2[0]), n2 = t2[1].sub(s2[1]);
            return this._map._cooperativeGestures && !e.eU() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r2, n2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (r2.y + n2.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(e2, t2, i2) {
            if (void 0 !== this._valid) return this._valid;
            const o2 = e2.mag() >= 2, s2 = t2.mag() >= 2;
            if (!o2 && !s2) return;
            if (!o2 || !s2) return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const r2 = e2.y > 0 == t2.y > 0;
            return fl(e2) && fl(t2) && r2;
          }
        }
        const gl = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class vl {
          constructor() {
            const e2 = gl;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e2) {
            if (e2.altKey || e2.ctrlKey || e2.metaKey) return;
            let t2 = 0, i2 = 0, o2 = 0, s2 = 0, r2 = 0;
            switch (e2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t2 = -1;
                break;
              case 37:
                e2.shiftKey ? i2 = -1 : (e2.preventDefault(), s2 = -1);
                break;
              case 39:
                e2.shiftKey ? i2 = 1 : (e2.preventDefault(), s2 = 1);
                break;
              case 38:
                e2.shiftKey ? o2 = 1 : (e2.preventDefault(), r2 = -1);
                break;
              case 40:
                e2.shiftKey ? o2 = -1 : (e2.preventDefault(), r2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (n2) => {
              const a2 = n2.getZoom();
              n2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: yl, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: n2.getBearing() + i2 * this._bearingStep, pitch: n2.getPitch() + o2 * this._pitchStep, offset: [-s2 * this._panStep, -r2 * this._panStep], center: n2.getCenter() }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function yl(e2) {
          return e2 * (2 - e2);
        }
        const xl = 4.000244140625, bl = 1 / 450;
        class wl {
          constructor(t2, i2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = bl, e.aY(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(e2) {
            this._defaultZoomRate = e2;
          }
          setWheelZoomRate(e2) {
            this._wheelZoomRate = e2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t2) {
            if (!this.isEnabled()) return;
            if (this._map._cooperativeGestures) {
              if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.eU())) return void this._showBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
            const o2 = e.o.now(), s2 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, 0 !== i2 && i2 % xl === 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : s2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = window.setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(s2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
          }
          _onTimeout(e2) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
          }
          _start(e2) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t2 = g(this._el, e2);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const t2 = this._map.transform;
            "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
            if (0 !== this._delta) {
              const e2 = "wheel" === this._type && Math.abs(this._delta) > xl ? this._wheelZoomRate : this._defaultZoomRate;
              let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
              this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
              const s3 = i2(), r3 = Math.pow(2, s3), n3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : r3;
              this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(n3 * o3))), "wheel" === this._type && (this._startZoom = s3, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
            }
            const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), s2 = this._startZoom, r2 = this._easing;
            let n2, a2 = false;
            if ("wheel" === this._type && s2 && r2) {
              const t3 = Math.min((e.o.now() - this._lastWheelEventTime) / 200, 1), i3 = r2(t3);
              n2 = e.ak(s2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
            } else n2 = o2, a2 = true;
            this._active = true, a2 && (this._active = false, this._finishTimeout = window.setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200));
            let l2 = n2 - i2();
            return l2 * this._lastDelta < 0 && (l2 = 0), { noInertia: true, needsRenderFrame: !a2, zoomDelta: l2, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t2) {
            let i2 = e.eV;
            if (this._prevEase) {
              const t3 = this._prevEase, o2 = (e.o.now() - t3.start) / t3.duration, s2 = t3.easing(o2 + 0.01) - t3.easing(o2), r2 = 0.27 / Math.sqrt(s2 * s2 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - r2 * r2);
              i2 = e.eT(r2, n2, 0.25, 1);
            }
            return this._prevEase = { start: e.o.now(), duration: t2, easing: i2 }, i2;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 200);
          }
        }
        class Tl {
          constructor(e2, t2) {
            this._clickZoom = e2, this._tapZoom = t2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class El {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e2, t2) {
            return e2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Sl {
          constructor() {
            this._tap = new Ja({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(e2, t2, i2) {
            this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
          }
          touchmove(e2, t2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch) return;
                const o2 = t2[0], s2 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: s2 / 128 };
              }
            } else this._tap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Il {
          constructor(e2, t2, i2) {
            this._el = e2, this._mousePan = t2, this._touchPan = i2;
          }
          enable(e2) {
            this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Cl {
          constructor(e2, t2, i2) {
            this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Rl {
          constructor(e2, t2, i2, o2) {
            this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e2) {
            this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const Al = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
        class Ll extends e.z {
        }
        class Dl {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t2, i2) {
            const o2 = e.av([], i2, t2);
            this.radius = e.ag(o2[2] < 0 ? e.eX([], o2, this.constants) : [o2[0], o2[1], 0]);
          }
          projectRay(t2) {
            e.eX(t2, t2, this.constants), e.aw(t2, t2), e.eY(t2, t2, this.constants);
            const i2 = e.c5([], t2, this.radius);
            if (i2[2] > 0) {
              const t3 = e.c5([], [0, 0, 1], e.bJ(i2, [0, 0, 1])), o2 = e.c5([], e.aw([], [i2[0], i2[1], 0]), this.radius), s2 = e.d8([], i2, e.c5([], e.av([], e.d8([], o2, t3), i2), 2));
              i2[0] = s2[0], i2[1] = s2[1];
            }
            return i2;
          }
        }
        function Pl(e2) {
          return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
        }
        class Ol {
          constructor(t2, i2) {
            this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ja(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Dl(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.aY(["handleEvent", "handleWindowEvent"], this);
            const o2 = this._el;
            this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [e2, t3, i3] of this._listeners) {
              const o3 = e2 === document ? this.handleWindowEvent : this.handleEvent;
              e2.addEventListener(t3, o3, i3);
            }
          }
          destroy() {
            for (const [e2, t2, i2] of this._listeners) {
              const o2 = e2 === document ? this.handleWindowEvent : this.handleEvent;
              e2.removeEventListener(t2, o2, i2);
            }
          }
          _addDefaultHandlers(e2) {
            const t2 = this._map, i2 = t2.getCanvasContainer();
            this._add("mapEvent", new Wa(t2, e2));
            const o2 = t2.boxZoom = new Xa(t2, e2);
            this._add("boxZoom", o2);
            const s2 = new Qa(), r2 = new El();
            t2.doubleClickZoom = new Tl(r2, s2), this._add("tapZoom", s2), this._add("clickZoom", r2);
            const n2 = new Sl();
            this._add("tapDragZoom", n2);
            const a2 = t2.touchPitch = new ml(t2);
            this._add("touchPitch", a2);
            const l2 = new nl(e2), c2 = new al(e2);
            t2.dragRotate = new Cl(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
            const h2 = new rl(e2), d2 = new ll(t2, e2);
            t2.dragPan = new Il(i2, h2, d2), this._add("mousePan", h2), this._add("touchPan", d2, ["touchZoom", "touchRotate"]);
            const u2 = new pl(), _2 = new ul();
            t2.touchZoomRotate = new Rl(i2, _2, u2, n2), this._add("touchRotate", u2, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new $a(t2));
            const p2 = t2.scrollZoom = new wl(t2, this);
            this._add("scrollZoom", p2, ["mousePan"]);
            const f2 = t2.keyboard = new vl();
            this._add("keyboard", f2);
            for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
          }
          _add(e2, t2, i2) {
            this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
          }
          stop(e2) {
            if (!this._updatingCamera) {
              for (const { handler: e3 } of this._handlers) e3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [], this._originalZoom = void 0;
            }
          }
          isActive() {
            for (const { handler: e2 } of this._handlers) if (e2.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Al(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(e2, t2, i2) {
            for (const o2 in e2) if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0)) return true;
            return false;
          }
          handleWindowEvent(e2) {
            this.handleEvent(e2, `${e2.type}Window`);
          }
          _getMapTouches(e2) {
            const t2 = [];
            for (const i2 of e2) this._el.contains(i2.target) && t2.push(i2);
            return t2;
          }
          handleEvent(e2, t2) {
            this._updatingCamera = true;
            const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, s2 = { needsRenderFrame: false }, r2 = {}, n2 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = a2 ? v(this._el, a2) : i2 ? void 0 : g(this._el, e2);
            for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
              if (!c3.isEnabled()) continue;
              let d2;
              this._blockedByActive(n2, h3, i3) ? c3.reset() : c3[t2 || e2.type] && (d2 = c3[t2 || e2.type](e2, l2, a2), this.mergeHandlerResult(s2, r2, d2, i3, o2), d2 && d2.needsRenderFrame && this._triggerRenderFrame()), (d2 || c3.isActive()) && (n2[i3] = c3);
            }
            const c2 = {};
            for (const e3 in this._previousActiveHandlers) n2[e3] || (c2[e3] = o2);
            this._previousActiveHandlers = n2, (Object.keys(c2).length || Pl(s2)) && (this._changes.push([s2, r2, c2]), this._triggerRenderFrame()), (Object.keys(n2).length || Pl(s2)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: h2 } = s2;
            h2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h2(this._map));
          }
          mergeHandlerResult(e2, t2, i2, o2, s2) {
            if (!i2) return;
            Object.assign(e2, i2);
            const r2 = { handlerName: o2, originalEvent: i2.originalEvent || s2 };
            void 0 !== i2.zoomDelta && (t2.zoom = r2), void 0 !== i2.panDelta && (t2.drag = r2), void 0 !== i2.pitchDelta && (t2.pitch = r2), void 0 !== i2.bearingDelta && (t2.rotate = r2);
          }
          _applyChanges() {
            const t2 = {}, i2 = {}, o2 = {};
            for (const [s2, r2, n2] of this._changes) s2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(s2.panDelta)), s2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (t2.around = s2.around), void 0 !== s2.aroundCoord && (t2.aroundCoord = s2.aroundCoord), void 0 !== s2.pinchAround && (t2.pinchAround = s2.pinchAround), s2.noInertia && (t2.noInertia = s2.noInertia), Object.assign(i2, r2), Object.assign(o2, n2);
            this._updateMapTransform(t2, i2, o2), this._changes = [];
          }
          _updateMapTransform(t2, i2, o2) {
            const s2 = this._map, r2 = s2.transform, n2 = (e2) => [e2.x, e2.y, e2.z];
            if ((() => {
              const e2 = this._eventsInProgress.drag;
              return e2 && !this._handlersById[e2.handlerName].isActive();
            })() && !Pl(t2)) {
              const e2 = r2.zoom;
              r2.cameraElevationReference = "sea", null != this._originalZoom && r2._orthographicProjectionAtLowPitch && "globe" !== r2.projection.name && 0 === r2.pitch ? (r2.cameraElevationReference = "ground", r2.zoom = this._originalZoom) : (r2.recenterOnTerrain(), r2.cameraElevationReference = "ground"), e2 !== r2.zoom && this._map._update(true);
            }
            if (r2._isCameraConstrained && s2._stop(true), !Pl(t2)) return void this._fireEvents(i2, o2, true);
            let { panDelta: a2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: d2, aroundCoord: u2, pinchAround: _2 } = t2;
            r2._isCameraConstrained && (l2 > 0 && (l2 = 0), r2._isCameraConstrained = false), void 0 !== _2 && (d2 = _2), (l2 || ((e2) => i2[e2] && !this._eventsInProgress[e2])("drag")) && d2 && (this._dragOrigin = n2(r2.pointCoordinate3D(d2)), this._originalZoom = r2.zoom, this._trackingEllipsoid.setup(r2._camera.position, this._dragOrigin)), r2.cameraElevationReference = "sea", s2._stop(true), d2 = d2 || s2.transform.centerPoint, c2 && (r2.bearing += c2), h2 && (r2.pitch += h2), r2._updateCameraState();
            const p2 = [0, 0, 0];
            if (a2) if ("mercator" === r2.projection.name) {
              const e2 = this._trackingEllipsoid.projectRay(r2.screenPointToMercatorRay(d2).dir), t3 = this._trackingEllipsoid.projectRay(r2.screenPointToMercatorRay(d2.sub(a2)).dir);
              p2[0] = t3[0] - e2[0], p2[1] = t3[1] - e2[1];
            } else {
              const t3 = r2.pointCoordinate(d2);
              if ("globe" === r2.projection.name) {
                a2 = a2.rotate(-r2.angle);
                const i3 = r2._pixelsPerMercatorPixel / r2.worldSize;
                p2[0] = -a2.x * e.eW(e.a$(t3.y)) * i3, p2[1] = -a2.y * e.eW(r2.center.lat) * i3;
              } else {
                const e2 = r2.pointCoordinate(d2.sub(a2));
                t3 && e2 && (p2[0] = e2.x - t3.x, p2[1] = e2.y - t3.y);
              }
            }
            const f2 = r2.zoom, m2 = [0, 0, 0];
            if (l2) {
              const t3 = n2(u2 || r2.pointCoordinate3D(d2)), i3 = { dir: e.aw([], e.av([], t3, r2._camera.position)) };
              if (i3.dir[2] < 0) {
                const o3 = r2.zoomDeltaToMovement(t3, l2);
                e.c5(m2, i3.dir, o3);
              }
            }
            const g2 = e.d8(p2, p2, m2);
            r2._translateCameraConstrained(g2), l2 && Math.abs(r2.zoom - f2) > 1e-4 && r2.recenterOnTerrain(), r2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
          }
          _fireEvents(t2, i2, o2) {
            const s2 = Al(this._eventsInProgress), r2 = Al(t2), n2 = {};
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._eventsInProgress[e2] || (n2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
            }
            !s2 && r2 && this._fireEvent("movestart", r2.originalEvent);
            for (const e2 in n2) this._fireEvent(e2, n2[e2]);
            r2 && this._fireEvent("move", r2.originalEvent);
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._fireEvent(e2, i3);
            }
            const a2 = {};
            let l2;
            for (const e2 in this._eventsInProgress) {
              const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
              this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, a2[`${e2}end`] = l2);
            }
            for (const e2 in a2) this._fireEvent(e2, a2[e2]);
            const c2 = Al(this._eventsInProgress);
            if (o2 && (s2 || r2) && !c2) {
              this._updatingCamera = true;
              const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
              t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.z("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t2, i2) {
            this._map.fire(new e.z(t2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
              this._frameId = void 0, this.handleEvent(new Ll("renderFrame", { timeStamp: e2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const zl = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Ml extends e.E {
          constructor(t2, i2) {
            super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, this._respectPrefersReducedMotion = false !== i2.respectPrefersReducedMotion, e.aY(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e.aT(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e2, t2) {
            return this.jumpTo({ center: e2 }, t2);
          }
          panBy(t2, i2, o2) {
            return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, Object.assign({ offset: t2 }, i2), o2);
          }
          panTo(e2, t2, i2) {
            return this.easeTo(Object.assign({ center: e2 }, t2), i2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e2, t2) {
            return this.jumpTo({ zoom: e2 }, t2), this;
          }
          zoomTo(e2, t2, i2) {
            return this.easeTo(Object.assign({ zoom: e2 }, t2), i2);
          }
          zoomIn(e2, t2) {
            return this.zoomTo(this.getZoom() + 1, e2, t2), this;
          }
          zoomOut(e2, t2) {
            return this.zoomTo(this.getZoom() - 1, e2, t2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e2, t2) {
            return this.jumpTo({ bearing: e2 }, t2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e2, t2) {
            return this.jumpTo({ padding: e2 }, t2), this;
          }
          rotateTo(e2, t2, i2) {
            return this.easeTo(Object.assign({ bearing: e2 }, t2), i2);
          }
          resetNorth(e2, t2) {
            return this.rotateTo(0, Object.assign({ duration: 1e3 }, e2), t2), this;
          }
          resetNorthPitch(e2, t2) {
            return this.easeTo(Object.assign({ bearing: 0, pitch: 0, duration: 1e3 }, e2), t2), this;
          }
          snapToNorth(e2, t2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e2, t2) {
            return this.jumpTo({ pitch: e2 }, t2), this;
          }
          cameraForBounds(t2, i2) {
            t2 = e.aI.convert(t2);
            const o2 = i2 && i2.bearing || 0, s2 = i2 && i2.pitch || 0, r2 = t2.getNorthWest(), n2 = t2.getSouthEast();
            return this._cameraForBounds(this.transform, r2, n2, o2, s2, i2);
          }
          _extendPadding(e2) {
            const t2 = { top: 0, right: 0, bottom: 0, left: 0 };
            return null == e2 ? Object.assign({}, t2, this.transform.padding) : "number" == typeof e2 ? { top: e2, bottom: e2, right: e2, left: e2 } : Object.assign({}, t2, e2);
          }
          _extendCameraOptions(e2) {
            return (e2 = Object.assign({ offset: [0, 0], maxZoom: this.transform.maxZoom }, e2)).padding = this._extendPadding(e2.padding), e2;
          }
          _minimumAABBFrustumDistance(e2, t2) {
            const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
            return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
          }
          _cameraForBoundsOnGlobe(t2, i2, o2, s2, r2, n2) {
            const a2 = t2.clone(), l2 = this._extendCameraOptions(n2);
            a2.bearing = s2, a2.pitch = r2;
            const c2 = e.aT.convert(i2), h2 = e.aT.convert(o2), d2 = 0.5 * (c2.lat + h2.lat), u2 = 0.5 * (c2.lng + h2.lng), _2 = e.eZ(d2, u2), p2 = e.aw([], _2), f2 = e.aw([], e.bI([], p2, [0, 1, 0])), m2 = e.bI([], f2, p2), g2 = [f2[0], f2[1], f2[2], 0, m2[0], m2[1], m2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v2 = [_2, e.eZ(c2.lat, c2.lng), e.eZ(h2.lat, c2.lng), e.eZ(h2.lat, h2.lng), e.eZ(c2.lat, h2.lng), e.eZ(d2, c2.lng), e.eZ(d2, h2.lng), e.eZ(c2.lat, u2), e.eZ(h2.lat, u2)];
            let y2 = e.d9.fromPoints(v2.map((t3) => [e.bJ(f2, t3), e.bJ(m2, t3), e.bJ(p2, t3)]));
            const x2 = e.af([], y2.center, g2);
            0 === e.e_(x2) && e.e$(x2, 0, 0, 1), e.aw(x2, x2), e.c5(x2, x2, e.aD), a2.center = e.f0(x2);
            const b2 = a2.getWorldToCameraMatrix(), w2 = e.bl(new Float64Array(16), b2);
            y2 = e.d9.applyTransform(y2, e.aB([], b2, g2));
            const T2 = this._extendAABB(y2, a2, l2, s2);
            if (!T2) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            y2 = T2, e.af(x2, x2, b2);
            const E2 = 0.5 * (y2.max[2] - y2.min[2]), S2 = this._minimumAABBFrustumDistance(a2, y2), I2 = e.c5([], [0, 0, 1], E2), C2 = e.d8(I2, x2, I2), R2 = S2 + (0 === a2.pitch ? 0 : e.bG(x2, C2)), A2 = a2.globeCenterInViewSpace, L2 = e.av([], x2, [A2[0], A2[1], A2[2]]);
            e.aw(L2, L2), e.c5(L2, L2, R2);
            const D2 = e.d8([], x2, L2);
            e.af(D2, D2, w2);
            const P2 = e.eM / e.aD, O2 = e.ag(D2), z2 = e.cf(Math.max(O2 * P2 - e.eM, Number.EPSILON), 0), M2 = Math.min(a2.zoomFromMercatorZAdjusted(z2), l2.maxZoom);
            return M2 > 0.5 * (e.c_ + e.cL) ? (a2.setProjection({ name: "mercator" }), a2.zoom = M2, this._cameraForBounds(a2, i2, o2, s2, r2, n2)) : { center: a2.center, zoom: M2, bearing: s2, pitch: r2 };
          }
          _extendAABB(t2, i2, o2, s2) {
            const r2 = 0.5 * ((o2.padding.left || 0) + (o2.padding.right || 0)), n2 = 0.5 * ((o2.padding.top || 0) + (o2.padding.bottom || 0)), a2 = n2, l2 = r2, c2 = r2, h2 = n2, d2 = i2.width - (l2 + c2), u2 = i2.height - (a2 + h2), _2 = e.av([], t2.max, t2.min), p2 = Math.min(d2 / _2[0], u2 / _2[1]), f2 = Math.min(i2.scaleZoom(i2.scale * p2), o2.maxZoom);
            if (isNaN(f2)) return null;
            const m2 = i2.scale / i2.zoomScale(f2), g2 = new e.d9([t2.min[0] - l2 * m2, t2.min[1] - h2 * m2, t2.min[2]], [t2.max[0] + c2 * m2, t2.max[1] + a2 * m2, t2.max[2]]), v2 = ("number" == typeof o2.offset.x && "number" == typeof o2.offset.y ? new e.P(o2.offset.x, o2.offset.y) : e.P.convert(o2.offset)).rotate(-e.an(s2));
            return g2.center[0] -= v2.x * m2, g2.center[1] += v2.y * m2, g2;
          }
          queryTerrainElevation(t2, i2) {
            const o2 = this.transform.elevation;
            return o2 ? (i2 = Object.assign({}, { exaggerated: true }, i2), o2.getAtPoint(e.ae.fromLngLat(t2), null, i2.exaggerated)) : null;
          }
          _cameraForBounds(t2, i2, o2, s2, r2, n2) {
            if ("globe" === t2.projection.name) return this._cameraForBoundsOnGlobe(t2, i2, o2, s2, r2, n2);
            const a2 = t2.clone(), l2 = this._extendCameraOptions(n2);
            a2.bearing = s2, a2.pitch = r2;
            const c2 = e.aT.convert(i2), h2 = e.aT.convert(o2), d2 = new e.aT(c2.lng, h2.lat), u2 = new e.aT(h2.lng, c2.lat), _2 = a2.project(c2), p2 = a2.project(h2), f2 = this.queryTerrainElevation(c2), m2 = this.queryTerrainElevation(h2), g2 = this.queryTerrainElevation(d2), v2 = this.queryTerrainElevation(u2), y2 = [[_2.x, _2.y, Math.min(f2 || 0, m2 || 0, g2 || 0, v2 || 0)], [p2.x, p2.y, Math.max(f2 || 0, m2 || 0, g2 || 0, v2 || 0)]];
            let x2 = e.d9.fromPoints(y2);
            const b2 = a2.getWorldToCameraMatrix(), w2 = e.bl(new Float64Array(16), b2);
            x2 = e.d9.applyTransform(x2, b2);
            const T2 = this._extendAABB(x2, a2, l2, s2);
            if (!T2) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            x2 = T2;
            const E2 = 0.5 * e.av([], x2.max, x2.min)[2], S2 = this._minimumAABBFrustumDistance(a2, x2), I2 = [0, 0, 1, 0];
            e.aC(I2, I2, b2), e.f1(I2, I2);
            const C2 = e.c5([], I2, S2 + E2), R2 = e.d8([], x2.center, C2);
            e.af(x2.center, x2.center, w2), e.af(R2, R2, w2);
            const A2 = a2.unproject(new e.P(x2.center[0], x2.center[1])), L2 = e.f2(a2.projection, A2), D2 = Math.pow(2, L2), P2 = Math.min(a2._zoomFromMercatorZ(R2[2] * a2.pixelsPerMeter * D2 / a2.worldSize), l2.maxZoom);
            return a2.mercatorFromTransition && P2 < 0.5 * (e.c_ + e.cL) ? (a2.setProjection({ name: "globe" }), a2.zoom = P2, this._cameraForBounds(a2, i2, o2, s2, r2, n2)) : { center: A2, zoom: P2, bearing: s2, pitch: r2 };
          }
          fitBounds(e2, t2, i2) {
            const o2 = this.cameraForBounds(e2, t2);
            return this._fitInternal(o2, t2, i2);
          }
          fitScreenCoordinates(t2, i2, o2, s2, r2) {
            const n2 = e.P.convert(t2), a2 = e.P.convert(i2), l2 = new e.P(Math.min(n2.x, a2.x), Math.min(n2.y, a2.y)), c2 = new e.P(Math.max(n2.x, a2.x), Math.max(n2.y, a2.y));
            if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n2, a2)) return this;
            const h2 = this.transform.pointLocation3D(l2), d2 = this.transform.pointLocation3D(c2), u2 = this.transform.pointLocation3D(new e.P(l2.x, c2.y)), _2 = this.transform.pointLocation3D(new e.P(c2.x, l2.y)), p2 = [Math.min(h2.lng, d2.lng, u2.lng, _2.lng), Math.min(h2.lat, d2.lat, u2.lat, _2.lat)], f2 = [Math.max(h2.lng, d2.lng, u2.lng, _2.lng), Math.max(h2.lat, d2.lat, u2.lat, _2.lat)], m2 = s2 && s2.pitch ? s2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, f2, o2, m2, s2);
            return this._fitInternal(g2, s2, r2);
          }
          _fitInternal(e2, t2, i2) {
            return e2 ? (t2 = Object.assign(e2, t2)).linear ? this.easeTo(t2, i2) : this.flyTo(t2, i2) : this;
          }
          jumpTo(t2, i2) {
            this.stop();
            const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
            let s2 = false, r2 = false, n2 = false;
            "zoom" in t2 && o2.zoom !== +t2.zoom && (s2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.aT.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (r2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (n2 = true, o2.pitch = +t2.pitch);
            const a2 = "number" == typeof t2.padding ? this._extendPadding(t2.padding) : t2.padding;
            if (null != t2.padding && !o2.isPaddingEqual(a2)) if (false === t2.retainPadding) {
              const e2 = o2.clone();
              e2.padding = a2, o2.setLocationAtPoint(o2.center, e2.centerPoint);
            } else o2.padding = a2;
            return t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.z("movestart", i2)).fire(new e.z("move", i2)), s2 && this.fire(new e.z("zoomstart", i2)).fire(new e.z("zoom", i2)).fire(new e.z("zoomend", i2)), r2 && this.fire(new e.z("rotatestart", i2)).fire(new e.z("rotate", i2)).fire(new e.z("rotateend", i2)), n2 && this.fire(new e.z("pitchstart", i2)).fire(new e.z("pitch", i2)).fire(new e.z("pitchend", i2)), this.fire(new e.z("moveend", i2)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e.w(zl), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t2, i2) {
            const o2 = this.transform;
            if (!o2.projection.supportsFreeCamera) return e.w(zl), this;
            this.stop();
            const s2 = o2.zoom, r2 = o2.pitch, n2 = o2.bearing;
            o2.setFreeCameraOptions(t2);
            const a2 = s2 !== o2.zoom, l2 = r2 !== o2.pitch, c2 = n2 !== o2.bearing;
            return this.fire(new e.z("movestart", i2)).fire(new e.z("move", i2)), a2 && this.fire(new e.z("zoomstart", i2)).fire(new e.z("zoom", i2)).fire(new e.z("zoomend", i2)), c2 && this.fire(new e.z("rotatestart", i2)).fire(new e.z("rotate", i2)).fire(new e.z("rotateend", i2)), l2 && this.fire(new e.z("pitchstart", i2)).fire(new e.z("pitch", i2)).fire(new e.z("pitchend", i2)), this.fire(new e.z("moveend", i2)), this;
          }
          easeTo(t2, i2) {
            this._stop(false, t2.easeId), (false === (t2 = Object.assign({ offset: [0, 0], duration: 500, easing: e.eV }, t2)).animate || this._prefersReducedMotion(t2)) && (t2.duration = 0);
            const o2 = this.transform, s2 = this.getZoom(), r2 = this.getBearing(), n2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : s2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, r2) : r2, h2 = "pitch" in t2 ? +t2.pitch : n2, d2 = this._extendPadding(t2.padding), u2 = e.P.convert(t2.offset);
            let _2, p2, f2;
            if ("globe" === o2.projection.name) {
              const i3 = e.ae.fromLngLat(o2.center), s3 = u2.rotate(-o2.angle);
              i3.x += s3.x / o2.worldSize, i3.y += s3.y / o2.worldSize;
              const r3 = i3.toLngLat(), n3 = e.aT.convert(t2.center || r3);
              this._normalizeCenter(n3), _2 = o2.centerPoint.add(s3), p2 = new e.P(i3.x, i3.y).mult(o2.worldSize), f2 = new e.P(e.aF(n3.lng), e.aJ(n3.lat)).mult(o2.worldSize).sub(p2);
            } else {
              _2 = o2.centerPoint.add(u2);
              const i3 = o2.pointLocation(_2), s3 = e.aT.convert(t2.center || i3);
              this._normalizeCenter(s3), p2 = o2.project(i3), f2 = o2.project(s3).sub(p2);
            }
            const m2 = o2.zoomScale(l2 - s2);
            let g2, v2;
            t2.around && (g2 = e.aT.convert(t2.around), v2 = o2.locationPoint(g2));
            const y2 = this._zooming || l2 !== s2, x2 = this._rotating || r2 !== c2, b2 = this._pitching || h2 !== n2, w2 = !o2.isPaddingEqual(d2), T2 = false === t2.retainPadding ? o2.clone() : o2, E2 = (o3) => (E3) => {
              if (y2 && (o3.zoom = e.ak(s2, l2, E3)), x2 && (o3.bearing = e.ak(r2, c2, E3)), b2 && (o3.pitch = e.ak(n2, h2, E3)), w2 && (T2.interpolatePadding(a2, d2, E3), _2 = T2.centerPoint.add(u2)), g2) o3.setLocationAtPoint(g2, v2);
              else {
                const e2 = o3.zoomScale(o3.zoom - s2), t3 = l2 > s2 ? Math.min(2, m2) : Math.max(0.5, m2), i3 = Math.pow(t3, 1 - E3), r3 = o3.unproject(p2.add(f2.mult(E3 * i3)).mult(e2));
                o3.setLocationAtPoint(o3.renderWorldCopies ? r3.wrap() : r3, _2);
              }
              return t2.preloadOnly || this._fireMoveEvents(i2), o3;
            };
            if (t2.preloadOnly) {
              const e2 = this._emulate(E2, t2.duration, o2);
              return this._preloadTiles(e2), this;
            }
            const S2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = y2, this._rotating = x2, this._pitching = b2, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, S2), this._ease(E2(o2), (e2) => {
              "sea" === o2.cameraElevationReference && o2.recenterOnTerrain(), this._afterEase(i2, e2);
            }, t2), this;
          }
          _prepareEase(t2, i2, o2 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i2 || o2.moving || this.fire(new e.z("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.z("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.z("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.z("pitchstart", t2));
          }
          _fireMoveEvents(t2) {
            this.fire(new e.z("move", t2)), this._zooming && this.fire(new e.z("zoom", t2)), this._rotating && this.fire(new e.z("rotate", t2)), this._pitching && this.fire(new e.z("pitch", t2));
          }
          _afterEase(t2, i2) {
            if (this._easeId && i2 && this._easeId === i2) return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const o2 = this._zooming, s2 = this._rotating, r2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.z("zoomend", t2)), s2 && this.fire(new e.z("rotateend", t2)), r2 && this.fire(new e.z("pitchend", t2)), this.fire(new e.z("moveend", t2));
          }
          flyTo(t2, i2) {
            if (this._prefersReducedMotion(t2)) {
              const o3 = e.aH(t2, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
              return this.jumpTo(o3, i2);
            }
            this.stop(), t2 = Object.assign({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.eV }, t2);
            const o2 = this.transform, s2 = this.getZoom(), r2 = this.getBearing(), n2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? e.aA(+t2.zoom, o2.minZoom, o2.maxZoom) : s2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, r2) : r2, h2 = "pitch" in t2 ? +t2.pitch : n2, d2 = this._extendPadding(t2.padding), u2 = o2.zoomScale(l2 - s2), _2 = e.P.convert(t2.offset);
            let p2 = o2.centerPoint.add(_2);
            const f2 = o2.pointLocation(p2), m2 = e.aT.convert(t2.center || f2);
            this._normalizeCenter(m2);
            const g2 = o2.project(f2), v2 = o2.project(m2).sub(g2);
            let y2 = t2.curve;
            const x2 = Math.max(o2.width, o2.height), b2 = x2 / u2, w2 = v2.mag();
            if ("minZoom" in t2) {
              const i3 = e.aA(Math.min(t2.minZoom, s2, l2), o2.minZoom, o2.maxZoom), r3 = x2 / o2.zoomScale(i3 - s2);
              y2 = Math.sqrt(r3 / w2 * 2);
            }
            const T2 = y2 * y2;
            function E2(e2) {
              const t3 = (b2 * b2 - x2 * x2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : x2) * T2 * w2);
              return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
            }
            function S2(e2) {
              return (Math.exp(e2) - Math.exp(-e2)) / 2;
            }
            function I2(e2) {
              return (Math.exp(e2) + Math.exp(-e2)) / 2;
            }
            const C2 = E2(0);
            let R2 = function(e2) {
              return I2(C2) / I2(C2 + y2 * e2);
            }, A2 = function(e2) {
              return x2 * ((I2(C2) * (S2(t3 = C2 + y2 * e2) / I2(t3)) - S2(C2)) / T2) / w2;
              var t3;
            }, L2 = (E2(1) - C2) / y2;
            if (Math.abs(w2) < 1e-6 || !isFinite(L2)) {
              if (Math.abs(x2 - b2) < 1e-6) return this.easeTo(t2, i2);
              const e2 = b2 < x2 ? -1 : 1;
              L2 = Math.abs(Math.log(b2 / x2)) / y2, A2 = function() {
                return 0;
              }, R2 = function(t3) {
                return Math.exp(e2 * y2 * t3);
              };
            }
            t2.duration = "duration" in t2 ? +t2.duration : 1e3 * L2 / ("screenSpeed" in t2 ? +t2.screenSpeed / y2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
            const D2 = r2 !== c2, P2 = h2 !== n2, O2 = !o2.isPaddingEqual(d2), z2 = false === t2.retainPadding ? o2.clone() : o2, M2 = (o3) => (u3) => {
              const f3 = u3 * L2, y3 = 1 / R2(f3);
              o3.zoom = 1 === u3 ? l2 : s2 + o3.scaleZoom(y3), D2 && (o3.bearing = e.ak(r2, c2, u3)), P2 && (o3.pitch = e.ak(n2, h2, u3)), O2 && (z2.interpolatePadding(a2, d2, u3), p2 = z2.centerPoint.add(_2));
              const x3 = 1 === u3 ? m2 : o3.unproject(g2.add(v2.mult(A2(f3))).mult(y3));
              return o3.setLocationAtPoint(o3.renderWorldCopies ? x3.wrap() : x3, p2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
            };
            if (t2.preloadOnly) {
              const e2 = this._emulate(M2, t2.duration, o2);
              return this._preloadTiles(e2), this;
            }
            return this._zooming = true, this._rotating = D2, this._pitching = P2, this._padding = O2, this._prepareEase(i2, false), this._ease(M2(o2), () => this._afterEase(i2), t2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _requestRenderFrame(e2) {
          }
          _cancelRenderFrame(e2) {
          }
          _stop(e2, t2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const e3 = this._onEaseEnd;
              this._onEaseEnd = void 0, e3.call(this, t2);
            }
            if (!e2) {
              const e3 = this.handlers;
              e3 && e3.stop(false);
            }
            return this;
          }
          _ease(t2, i2, o2) {
            false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.o.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t2 = Math.min((e.o.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
            i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t2, i2) {
            t2 = e.bT(t2, -180, 180);
            const o2 = Math.abs(t2 - i2);
            return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
          }
          _normalizeCenter(e2) {
            const t2 = this.transform;
            if (t2.maxBounds) return;
            if ("globe" !== t2.projection.name && !t2.renderWorldCopies) return;
            const i2 = e2.lng - t2.center.lng;
            e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t2) {
            return this._respectPrefersReducedMotion && e.o.prefersReducedMotion && !(t2 && t2.essential);
          }
          _emulate(e2, t2, i2) {
            const o2 = Math.ceil(15 * t2 / 1e3), s2 = [], r2 = e2(i2.clone());
            for (let e3 = 0; e3 <= o2; e3++) {
              const t3 = r2(e3 / o2);
              s2.push(t3.clone());
            }
            return s2;
          }
          _preloadTiles(e2, t2) {
          }
        }
        class Fl {
          constructor(t2 = {}) {
            this.options = t2, e.aY(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e2) {
            const t2 = this.options && this.options.compact, i2 = e2._getUIString("AttributionControl.ToggleAttribution");
            this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i2);
            const o2 = l("span", "mapboxgl-ctrl-icon", this._compactButton);
            return o2.setAttribute("aria-hidden", "true"), o2.setAttribute("title", i2), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t2 = this._editLink;
            t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN }];
            if (t2) {
              const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
              t2.href = `${e.e.FEEDBACK_URL}/${o2}#${Ma(this._map, true)}`, t2.rel = "noopener nofollow";
            }
          }
          _updateData(e2) {
            !e2 || ("source" !== e2.dataType || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType) && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e2 = [];
            if (this._map.style.stylesheet) {
              const e3 = this._map.style.stylesheet;
              this.styleOwner = e3.owner, this.styleId = e3.id;
            }
            const t2 = this._map.style._mergedSourceCaches;
            for (const i3 in t2) {
              const o2 = t2[i3];
              if (o2.used) {
                const t3 = o2.getSource();
                t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
              }
            }
            e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
              for (let o2 = i3 + 1; o2 < e2.length; o2++) if (e2[o2].indexOf(t3) >= 0) return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
            const i2 = e2.map((e3) => function(e4) {
              const t3 = new DOMParser().parseFromString(e4, "text/html");
              return Array.from(t3.body.querySelectorAll("*")).reverse().forEach((e5) => {
                const i3 = e5.textContent || "";
                if ("A" !== e5.tagName) return void e5.replaceWith(...e5.childNodes);
                const o2 = e5.getAttribute("href");
                if (!o2 || !/^(https?:|mailto:)/i.test(o2)) return void e5.replaceWith(t3.createTextNode(i3));
                const s2 = t3.createElement("a");
                s2.href = o2, s2.textContent = i3, s2.rel = "noopener nofollow";
                const r2 = e5.getAttribute("class");
                r2 && (s2.className = r2), e5.replaceWith(s2);
              }), t3.body.innerHTML;
            }(e3)).join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class Bl {
          constructor() {
            e.aY(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(e2) {
            this._map = e2, this._container = l("div", "mapboxgl-ctrl");
            const t2 = l("a", "mapboxgl-ctrl-logo");
            return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e2) {
            e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style) return true;
            const e2 = this._map.style._sourceCaches;
            if (0 === Object.entries(e2).length) return true;
            for (const t2 in e2) {
              const i2 = e2[t2].getSource();
              if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo) return false;
            }
            return true;
          }
          _updateCompact() {
            const e2 = this._container.children;
            if (e2.length) {
              const t2 = e2[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
            }
          }
        }
        class kl {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e2) {
            const t2 = ++this._id;
            return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
          }
          remove(e2) {
            const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
            for (const t3 of i2) if (t3.id === e2) return void (t3.cancelled = true);
          }
          run(e2 = 0) {
            const t2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of t2) if (!i2.cancelled && (i2.callback(e2), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        class Nl {
          constructor(e2) {
            this.jumpTo(e2);
          }
          getValue(t2) {
            if (t2 <= this._startTime) return this._start;
            if (t2 >= this._endTime) return this._end;
            const i2 = e.dD((t2 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i2) + this._end * i2;
          }
          isEasing(e2) {
            return e2 >= this._startTime && e2 <= this._endTime;
          }
          jumpTo(e2) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
          }
          easeTo(e2, t2, i2) {
            this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
          }
        }
        const Ul = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
        class jl extends e.z {
          constructor(e2, t2, i2, o2) {
            const { point: s2, lngLat: r2, originalEvent: n2, target: a2 } = e2;
            super(e2.type, { point: s2, lngLat: r2, originalEvent: n2, target: a2 }), this.preventDefault = () => {
              e2.preventDefault();
            }, this.id = t2, this.interaction = i2, this.feature = o2;
          }
        }
        class Vl {
          constructor(e2) {
            this.map = e2, this.interactionsByType = /* @__PURE__ */ new Map(), this.delegatedInteractions = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = /* @__PURE__ */ new Map(), this.prevHoveredFeatures = /* @__PURE__ */ new Map();
          }
          add(t2, i2) {
            if (this.typeById.has(t2)) throw new Error(`Interaction id "${t2}" already exists.`);
            const o2 = i2.filter;
            let s2 = i2.type;
            o2 && this.filters.set(t2, e.b6(o2)), "mouseover" === s2 && (s2 = "mouseenter"), "mouseout" === s2 && (s2 = "mouseleave");
            const r2 = this.interactionsByType.get(s2) || /* @__PURE__ */ new Map();
            "mouseenter" === s2 || "mouseleave" === s2 ? (0 === this.delegatedInteractions.size && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t2, i2)) : 0 === r2.size && this.map.on(s2, this.handleType), 0 === r2.size && this.interactionsByType.set(s2, r2), r2.set(t2, i2), this.typeById.set(t2, s2);
          }
          get(e2) {
            const t2 = this.typeById.get(e2);
            if (!t2) return;
            const i2 = this.interactionsByType.get(t2);
            return i2 ? i2.get(e2) : void 0;
          }
          remove(e2) {
            const t2 = this.typeById.get(e2);
            if (!t2) return;
            this.typeById.delete(e2), this.filters.delete(e2);
            const i2 = this.interactionsByType.get(t2);
            i2 && (i2.delete(e2), "mouseenter" === t2 || "mouseleave" === t2 ? (this.delegatedInteractions.delete(e2), 0 === this.delegatedInteractions.size && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : 0 === i2.size && this.map.off(t2, this.handleType));
          }
          queryTargets(e2, t2) {
            const i2 = [];
            for (const [e3, o2] of t2) o2.target && i2.push({ targetId: e3, target: o2.target, filter: this.filters.get(e3) });
            return this.map.style.queryRenderedTargets(e2, i2, this.map.transform);
          }
          handleMove(e2) {
            this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = /* @__PURE__ */ new Map();
            const t2 = this.queryTargets(e2.point, Array.from(this.delegatedInteractions).reverse());
            t2.length && (e2.type = "mouseenter", this.handleType(e2, t2));
            const i2 = /* @__PURE__ */ new Map();
            for (const [e3, { feature: t3 }] of this.prevHoveredFeatures) this.hoveredFeatures.has(e3) || i2.set(t3.id, t3);
            i2.size && (e2.type = "mouseleave", this.handleType(e2, Array.from(i2.values())));
          }
          handleOut(e2) {
            const t2 = Array.from(this.hoveredFeatures.values()).map(({ feature: e3 }) => e3);
            t2.length && (e2.type = "mouseleave", this.handleType(e2, t2)), this.hoveredFeatures.clear();
          }
          handleType(t2, i2) {
            const o2 = "mouseenter" === t2.type;
            if (o2 && !this.interactionsByType.has(t2.type)) return void e.w("mouseenter interaction required for mouseleave to work.");
            const s2 = Array.from(this.interactionsByType.get(t2.type)).reverse(), r2 = !!i2;
            i2 = i2 || this.queryTargets(t2.point, s2);
            let n2 = false;
            const a2 = /* @__PURE__ */ new Set();
            for (const l2 of i2) {
              for (const [i3, c2] of s2) {
                if (!c2.target) continue;
                const s3 = l2.variants ? l2.variants[i3] : null;
                if (s3) {
                  for (const h2 of s3) {
                    if (vt(h2, l2, a2, i3)) continue;
                    const s4 = new e.dx(l2, h2), d2 = gt(h2, l2, i3);
                    r2 && void 0 !== s4.id && (s4.state = this.map.getFeatureState(s4));
                    const u2 = o2 ? this.prevHoveredFeatures.get(d2) : null, _2 = new jl(t2, i3, c2, s4), p2 = u2 ? u2.stop : c2.handler(_2);
                    if (o2 && this.hoveredFeatures.set(d2, { feature: l2, stop: p2 }), false !== p2) {
                      n2 = true;
                      break;
                    }
                  }
                  if (n2) break;
                }
              }
              if (n2) break;
            }
            if (!n2) for (const [e2, i3] of s2) {
              const { handler: o3, target: s3 } = i3;
              if (!s3 && false !== o3(new jl(t2, e2, i3, null))) break;
            }
          }
        }
        function Gl(t2, i2) {
          if (Array.isArray(t2) && Array.isArray(i2)) {
            const e2 = new Set(t2), o2 = new Set(i2);
            return e2.size === o2.size && t2.every((e3) => o2.has(e3));
          }
          return e.by(t2, i2);
        }
        const Hl = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false, precompilePrograms: true, scaleFactor: 1, spriteFormat: "auto" }, ql = { showCompass: true, showZoom: true, visualizePitch: false };
        class Zl {
          constructor(t2, i2, o2 = false) {
            this._clickTolerance = 10, this.element = i2, this.mouseRotate = new nl({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new al({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.aY(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
          }
          down(e2, t2) {
            this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), _();
          }
          move(e2, t2) {
            const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), s2 = o2 && o2.bearingDelta;
            if (s2 && i2.setBearing(i2.getBearing() + s2), this.mousePitch) {
              const o3 = this.mousePitch.mousemoveWindow(e2, t2), s3 = o3 && o3.pitchDelta;
              s3 && i2.setPitch(i2.getPitch() + s3);
            }
          }
          off() {
            const e2 = this.element;
            e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(e2) {
            this.down(Object.assign({}, e2, { ctrlKey: true, preventDefault: () => e2.preventDefault() }), g(this.element, e2)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e2) {
            this.move(e2, g(this.element, e2));
          }
          mouseup(e2) {
            this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
          }
          touchstart(e2) {
            1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
          }
          touchmove(e2) {
            1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
          }
          touchend(e2) {
            0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        function Wl(t2, i2, o2) {
          if (t2 = new e.aT(t2.lng, t2.lat), i2) {
            const s2 = new e.aT(t2.lng - 360, t2.lat), r2 = new e.aT(t2.lng + 360, t2.lat), n2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint3D(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
            o2.locationPoint3D(s2).distSqr(i2) < a2 && (l2 || Math.abs(s2.lng - o2.center.lng) < n2) ? t2 = s2 : o2.locationPoint3D(r2).distSqr(i2) < a2 && (l2 || Math.abs(r2.lng - o2.center.lng) < n2) && (t2 = r2);
          }
          for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
            const e2 = o2.locationPoint3D(t2);
            if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height) break;
            t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
          }
          return t2;
        }
        const $l = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }, Xl = { rotation: 0, rotationAlignment: "auto", pitchAlignment: "auto", occludedOpacity: 0.2, altitude: 0 };
        class Yl extends e.E {
          constructor(t2, i2) {
            super(), (t2 instanceof HTMLElement || i2) && (t2 = Object.assign({ element: t2 }, i2)), e.aY(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this);
            const { anchor: o2 = "center", color: s2 = "#3FB1CE", scale: r2 = 1, draggable: n2 = false, clickTolerance: a2 = 0, rotation: l2 = Xl.rotation, rotationAlignment: c2 = Xl.rotationAlignment, pitchAlignment: h2 = Xl.pitchAlignment, occludedOpacity: d2 = Xl.occludedOpacity, altitude: u2 = Xl.altitude } = t2 || {};
            this._anchor = o2, this._color = s2, this._scale = r2, this._draggable = n2, this._clickTolerance = a2, this._rotation = l2, this._rotationAlignment = c2, this._pitchAlignment = h2, this._occludedOpacity = d2, this._altitude = u2, this._state = "inactive", this._isDragging = false, this._updateMoving = () => this._update(true), t2 && t2.element ? (this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0])) : (this._defaultMarker = true, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t2 && t2.offset || [0, -14])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
              e2.preventDefault();
            }), this._element.addEventListener("mousedown", (e2) => {
              e2.preventDefault();
            });
            const _2 = this._element.classList;
            for (const e2 in $l) _2.remove(`mapboxgl-marker-anchor-${e2}`);
            _2.add(`mapboxgl-marker-anchor-${this._anchor}`);
            const p2 = t2 && t2.className ? t2.className.trim().split(/\s+/) : [];
            _2.add(...p2), this._popup = null;
          }
          _createDefaultMarker() {
            const e2 = l("div"), t2 = c("svg", { display: "block", height: 41 * this._scale + "px", width: 27 * this._scale + "px", viewBox: "0 0 27 41" }, e2);
            if (0 === this._altitude) {
              const e3 = c("radialGradient", { id: "shadowGradient" }, c("defs", {}, t2));
              c("stop", { offset: "10%", "stop-opacity": 0.4 }, e3), c("stop", { offset: "100%", "stop-opacity": 0.05 }, e3), c("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, t2);
            }
            return c("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, t2), c("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, t2), c("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, t2), e2;
          }
          addTo(e2) {
            return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
          }
          remove() {
            const e2 = this._map;
            return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.aT.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          setAltitude(e2) {
            return e2 === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e2 || 0 !== this._altitude && 0 === e2) && (this._element = this._createDefaultMarker()), this._altitude = e2 || Xl.altitude, this._update()), this;
          }
          getAltitude() {
            return this._altitude;
          }
          getElement() {
            return this._element;
          }
          setPopup(e2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
              if (!("offset" in e2.options)) {
                const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
              }
              this._popup = e2, e2._marker = this, e2._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e2) {
            const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
            "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
          }
          _onMapClick(e2) {
            const t2 = e2.originalEvent.target, i2 = this._element;
            this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e2 = this._popup;
            return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const e2 = this._map, t2 = this._pos;
            if (!e2 || !t2) return false;
            const i2 = e2.unproject(t2, this._altitude), o2 = e2.getFreeCameraOptions();
            if (!o2.position) return false;
            const s2 = o2.position.toLngLat();
            return s2.distanceTo(i2) < 0.9 * s2.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t2 = this._map;
            if (!t2) return;
            const i2 = this._pos;
            if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height) return void this._clearFadeTimer();
            const o2 = t2.unproject(i2, this._altitude);
            let s2;
            t2._showingGlobe() && e.f5(t2.transform, this._lngLat) ? s2 = 0 : (s2 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (s2 *= this._occludedOpacity)), this._element.style.opacity = `${s2}`, this._element.style.pointerEvents = s2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(s2), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const e2 = this._pos;
            if (!e2 || !this._map) return;
            const t2 = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${$l[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
          }
          _calculateXYTransform() {
            const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
            if (!i2 || !t2 || "map" !== o2) return "";
            if (!i2._showingGlobe()) {
              const e2 = i2.getPitch();
              return e2 ? `rotateX(${e2}deg)` : "";
            }
            const s2 = e.cX(e.f6(i2.transform, this._lngLat)), r2 = t2.sub(e.f7(i2.transform)), n2 = Math.abs(r2.x) + Math.abs(r2.y);
            if (0 === n2) return "";
            const a2 = s2 / n2;
            return `rotateX(${-r2.y * a2}deg) rotateY(${r2.x * a2}deg)`;
          }
          _calculateZTransform() {
            const t2 = this._pos, i2 = this._map;
            if (!i2 || !t2) return "";
            let o2 = 0;
            const s2 = this.getRotationAlignment();
            if ("map" === s2) if (i2._showingGlobe()) {
              const t3 = i2.project(new e.aT(this._lngLat.lng, this._lngLat.lat + 1e-3), this._altitude), s3 = i2.project(new e.aT(this._lngLat.lng, this._lngLat.lat - 1e-3), this._altitude).sub(t3);
              o2 = e.cX(Math.atan2(s3.y, s3.x)) - 90;
            } else o2 = -i2.getBearing();
            else if ("horizon" === s2) {
              const s3 = e.ah(4, 6, i2.getZoom()), r2 = e.f7(i2.transform);
              r2.y += s3 * i2.transform.height;
              const n2 = t2.sub(r2), a2 = e.cX(Math.atan2(n2.y, n2.x));
              o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - s3);
            }
            return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
          }
          _update(e2) {
            cancelAnimationFrame(this._updateFrameId);
            const t2 = this._map;
            t2 && (t2.transform.renderWorldCopies && (this._lngLat = Wl(this._lngLat, this._pos, t2.transform)), this._pos = t2.project(this._lngLat, this._altitude), true === e2 ? this._updateFrameId = requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), t2._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t2._showingGlobe() || t2.getTerrain() || t2.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t2) {
            return this._offset = e.P.convert(t2), this._update(), this;
          }
          addClassName(e2) {
            return this._element.classList.add(e2), this;
          }
          removeClassName(e2) {
            return this._element.classList.remove(e2), this;
          }
          toggleClassName(e2) {
            return this._element.classList.toggle(e2);
          }
          _onMove(t2) {
            const i2 = this._map;
            if (!i2) return;
            const o2 = this._pointerdownPos, s2 = this._positionDelta;
            if (o2 && s2) {
              if (!this._isDragging) {
                const e2 = this._clickTolerance || i2._clickTolerance;
                if (t2.point.dist(o2) < e2) return;
                this._isDragging = true;
              }
              this._pos = t2.point.sub(s2), this._lngLat = i2.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.z("dragstart"))), this.fire(new e.z("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
            const t2 = this._map;
            t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.z("dragend")), this._state = "inactive";
          }
          _addDragHandler(e2) {
            const t2 = this._map, i2 = this._pos;
            t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
          }
          setDraggable(e2) {
            this._draggable = !!e2;
            const t2 = this._map;
            return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e2) {
            return this._rotation = e2 || Xl.rotation, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e2) {
            return this._rotationAlignment = e2 || Xl.rotationAlignment, this._update(), this;
          }
          getRotationAlignment() {
            return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(e2) {
            return this._pitchAlignment = e2 || Xl.pitchAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(e2) {
            return this._occludedOpacity = e2 || Xl.occludedOpacity, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const Kl = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false, showButton: true, followUserLocation: true }, Jl = { maxWidth: 100, unit: "metric" }, Ql = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, ec = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", altitude: 0 }, tc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function ic(t2 = new e.P(0, 0), i2 = "bottom") {
          if ("number" == typeof t2) {
            const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
            switch (i2) {
              case "top":
                return new e.P(0, t2);
              case "top-left":
                return new e.P(o2, o2);
              case "top-right":
                return new e.P(-o2, o2);
              case "bottom":
                return new e.P(0, -t2);
              case "bottom-left":
                return new e.P(o2, -o2);
              case "bottom-right":
                return new e.P(-o2, -o2);
              case "left":
                return new e.P(t2, 0);
              case "right":
                return new e.P(-t2, 0);
            }
            return new e.P(0, 0);
          }
          return t2 instanceof e.P || Array.isArray(t2) ? e.P.convert(t2) : e.P.convert(t2[i2] || [0, 0]);
        }
        const oc = { version: t, supported: a.supported, setRTLTextPlugin: e.fb, getRTLTextPluginStatus: e.fa, Map: class extends Ml {
          constructor(t2) {
            o.mark(i.create);
            const s2 = t2;
            if (null != (t2 = Object.assign({}, Hl, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t2.minPitch && t2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != t2.maxPitch && t2.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t2.antialias && e.f3(window) && (t2.antialias = false, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new lo(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies, null, null), t2), this._repaint = !!t2.repaint, this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new kl(), this._domRenderTaskQueue = new kl(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.b2(), this._locale = Object.assign({}, Ul, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._tessellationStep = t2.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._precompilePrograms = t2.precompilePrograms, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Nl(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._frameId = 0, this._scaleFactor = t2.scaleFactor, this._requestManager = new T(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, this._contextCreateOptions = t2.contextCreateOptions ? Object.assign({}, t2.contextCreateOptions) : {}, "string" == typeof t2.container) {
              const e2 = document.getElementById(t2.container);
              if (!e2) throw new Error(`Container '${t2.container.toString()}' not found.`);
              this._container = e2;
            } else {
              if (!(t2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t2.container;
            }
            if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), this._spriteFormat = t2.spriteFormat, e.aY(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
            if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new Ol(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, (t2.style || !t2.testMode) && this.setStyle(t2.style || e.e.DEFAULT_STYLE, { config: t2.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), t2.hash && (this._hash = new za("string" == typeof t2.hash && t2.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
              null == s2.center && null == s2.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch });
              const e2 = t2.bounds;
              e2 && (this.resize(), this.fitBounds(e2, Object.assign({}, t2.fitBoundsOptions, { duration: 0 })));
            }
            this.resize(), t2.attributionControl && this.addControl(new Fl({ customAttribution: t2.customAttribution })), this._logoControl = new Bl(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent(), this._postStyleWithAppearanceEvent();
            }), this.on("data", (t3) => {
              this._update("style" === t3.dataType), this.fire(new e.z(`${t3.dataType}data`, t3));
            }), this.on("dataloading", (t3) => {
              this.fire(new e.z(`${t3.dataType}dataloading`, t3));
            }), this._interactions = new Vl(this);
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t2, i2) {
            if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd) return this.fire(new e.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o2 = t2.onAdd(this);
            this._controls.push(t2);
            const s2 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? s2.insertBefore(o2, s2.firstChild) : s2.appendChild(o2), this;
          }
          removeControl(t2) {
            if (!t2 || !t2.onRemove) return this.fire(new e.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(t2);
            return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
          }
          hasControl(e2) {
            return this._controls.indexOf(e2) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t2) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i2 = !this._moving;
            return i2 && this.fire(new e.z("movestart", t2)).fire(new e.z("move", t2)), this.fire(new e.z("resize", t2)), i2 && this.fire(new e.z("moveend", t2)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t2) {
            return this.transform.setMaxBounds(e.aI.convert(t2)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = t2 ?? -2) >= -2 && t2 <= this.transform.maxZoom) return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = t2 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = t2 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch) return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = t2 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch) return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getScaleFactor() {
            return this._scaleFactor;
          }
          setScaleFactor(e2) {
            return this._scaleFactor = e2, this.painter.scaleFactor = e2, this.style && this.style._setLabelPlacementStale(), this.style._updateFilteredLayers((e3) => "symbol" === e3.type), this._update(true), this;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e2) {
            return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(e2) {
            return "auto" === e2 ? navigator.language : Array.isArray(e2) ? 0 === e2.length ? void 0 : e2.map((e3) => "auto" === e3 ? navigator.language : e3) : e2;
          }
          setLanguage(e2) {
            const t2 = this._parseLanguage(e2);
            if (!this.style || t2 === this._language) return this;
            this._language = t2, this.style.reloadSources();
            for (const e3 of this._controls) e3._setLanguage && e3._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(e2) {
            return this.style && e2 !== this._worldview ? (this._worldview = e2, this._styleDirty = true, this.style.reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return "globe" === this.transform.projection.name;
          }
          setProjection(e2) {
            return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.projection);
          }
          _updateProjectionTransition() {
            if ("globe" !== this.getProjection().name) return;
            const t2 = this.transform, i2 = t2.projection.name;
            let o2;
            "globe" === i2 && t2.zoom >= e.cL ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.cL && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate(), this._update(true));
          }
          _prioritizeAndUpdateProjection(e2, t2) {
            return this._updateProjection(e2 || t2 || { name: "mercator" });
          }
          _updateProjection(t2) {
            let i2;
            const o2 = this.transform.mercatorFromTransition;
            i2 = "globe" === t2.name && this.transform.zoom >= e.cL ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate();
            const s2 = "mercator" === this.transform.getProjection().name && o2 !== this.transform.mercatorFromTransition;
            return (i2 || s2) && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
          }
          project(t2, i2) {
            return this.transform.locationPoint3D(e.aT.convert(t2), i2);
          }
          unproject(t2, i2) {
            return this.transform.pointLocation3D(e.P.convert(t2), i2);
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || false;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || false;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || false;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || false;
          }
          _createDelegatedListener(e2, t2, i2) {
            const o2 = (e3) => {
              let i3 = [];
              if (Array.isArray(t2)) {
                const o3 = t2.filter((e4) => this.getLayer(e4));
                i3 = o3.length ? this.queryRenderedFeatures(e3, { layers: o3 }) : [];
              } else i3 = this.queryRenderedFeatures(e3, { target: t2 });
              return i3;
            };
            if ("mouseenter" === e2 || "mouseover" === e2) {
              let s2 = false;
              const r2 = (t3) => {
                const r3 = o2(t3.point);
                r3.length ? s2 || (s2 = true, i2.call(this, new Ha(e2, this, t3.originalEvent, { features: r3 }))) : s2 = false;
              };
              return { listener: i2, targets: t2, delegates: { mousemove: r2, mouseout: () => {
                s2 = false;
              } } };
            }
            if ("mouseleave" === e2 || "mouseout" === e2) {
              let s2 = false;
              const r2 = (t3) => {
                o2(t3.point).length ? s2 = true : s2 && (s2 = false, i2.call(this, new Ha(e2, this, t3.originalEvent)));
              }, n2 = (t3) => {
                s2 && (s2 = false, i2.call(this, new Ha(e2, this, t3.originalEvent)));
              };
              return { listener: i2, targets: t2, delegates: { mousemove: r2, mouseout: n2 } };
            }
            {
              const s2 = (e3) => {
                const t3 = o2(e3.point);
                t3.length && (e3.features = t3, i2.call(this, e3), delete e3.features);
              };
              return { listener: i2, targets: t2, delegates: { [e2]: s2 } };
            }
          }
          on(e2, t2, i2) {
            if ("function" == typeof t2 || void 0 === i2) return super.on(e2, t2);
            if ("string" == typeof t2 && (t2 = [t2]), !this._areTargetsValid(t2)) return this;
            const o2 = this._createDelegatedListener(e2, t2, i2);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
            for (const e3 in o2.delegates) this.on(e3, o2.delegates[e3]);
            return this;
          }
          once(e2, t2, i2) {
            if ("function" == typeof t2 || void 0 === i2) return super.once(e2, t2);
            if ("string" == typeof t2 && (t2 = [t2]), !this._areTargetsValid(t2)) return this;
            const o2 = this._createDelegatedListener(e2, t2, i2);
            for (const e3 in o2.delegates) this.once(e3, o2.delegates[e3]);
            return this;
          }
          off(e2, t2, i2) {
            if ("function" == typeof t2 || void 0 === i2) return super.off(e2, t2);
            if ("string" == typeof t2 && (t2 = [t2]), !this._areTargetsValid(t2)) return this;
            const o2 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
            return o2 && ((e3) => {
              for (let o3 = 0; o3 < e3.length; o3++) {
                const s2 = e3[o3];
                if (s2.listener === i2 && Gl(s2.targets, t2)) {
                  for (const e4 in s2.delegates) this.off(e4, s2.delegates[e4]);
                  return e3.splice(o3, 1), this;
                }
              }
            })(o2), this;
          }
          queryRenderedFeatures(t2, i2) {
            if (!this.style) return [];
            if (void 0 === t2 || t2 instanceof e.P || Array.isArray(t2) || void 0 !== i2 || (i2 = t2, t2 = void 0), t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], !i2) {
              const e2 = this.style.queryRenderedFeatures(t2, void 0, this.transform), i3 = this.style.queryRenderedFeatureset(t2, void 0, this.transform);
              return e2.concat(i3);
            }
            let o2 = true;
            if (i2.target && (o2 = this._isTargetValid(i2.target), o2 && !i2.layers)) return this.style.queryRenderedFeatureset(t2, i2, this.transform);
            let s2 = true;
            if (i2.layers && Array.isArray(i2.layers)) {
              for (const e2 of i2.layers) if (!this._isValidId(e2)) {
                s2 = false;
                break;
              }
              if (s2 && !i2.target) return this.style.queryRenderedFeatures(t2, i2, this.transform);
            }
            let r2 = [];
            return s2 && (r2 = r2.concat(this.style.queryRenderedFeatures(t2, i2, this.transform))), o2 && (r2 = r2.concat(this.style.queryRenderedFeatureset(t2, i2, this.transform))), r2;
          }
          querySourceFeatures(e2, t2) {
            return !e2 || "string" == typeof e2 && !this._isValidId(e2) ? [] : this.style.querySourceFeatures(e2, t2);
          }
          queryRasterValue(e2, t2, i2) {
            return this._isValidId(e2) ? this.style.queryRasterValue(e2, t2, i2) : Promise.resolve(null);
          }
          isPointOnSurface(t2) {
            const { name: i2 } = this.transform.projection;
            return "globe" !== i2 && "mercator" !== i2 && e.w(`${i2} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t2));
          }
          addInteraction(e2, t2) {
            return this._interactions.add(e2, t2), this;
          }
          removeInteraction(e2) {
            return this._interactions.remove(e2), this;
          }
          getCooperativeGestures() {
            return this._cooperativeGestures;
          }
          setCooperativeGestures(e2) {
            return this._cooperativeGestures = e2, this;
          }
          setStyle(t2, i2) {
            return i2 = Object.assign({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2), this.style && t2 && false !== i2.diff && i2.localFontFamily === this._localFontFamily && i2.localIdeographFontFamily === this._localIdeographFontFamily && !i2.config ? (this.style._diffStyle(t2, (o2, s2) => {
              if (o2) {
                const s3 = "string" == typeof o2 ? o2 : o2 instanceof Error ? o2.message : o2.error;
                e.w(`Unable to perform style diff: ${s3}. Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
              } else s2 && this._update(true);
            }, () => this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
          }
          _getUIString(e2) {
            const t2 = this._locale[e2];
            if (null == t2) throw new Error(`Missing UI string '${e2}'`);
            return t2;
          }
          _updateStyle(e2, t2) {
            if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2) {
              const i2 = Object.assign({}, t2);
              t2 && t2.config && (i2.initialConfig = t2.config, delete i2.config), this.style = new Oo(this, i2).load(e2), this.style.setEventedParent(this, { style: this.style });
            }
            return this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Oo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), false);
          }
          _isValidId(t2) {
            return null == t2 ? (this.fire(new e.y(new Error("IDs can't be empty."))), false) : !e.dr(t2) || (this.fire(new e.y(new Error(`IDs can't contain special symbols: "${t2}".`))), false);
          }
          _isTargetValid(e2) {
            return "featuresetId" in e2 ? this._isValidId("importId" in e2 ? e2.importId : e2.featuresetId) : "layerId" in e2 && this._isValidId(e2.layerId);
          }
          _areTargetsValid(e2) {
            if (Array.isArray(e2)) {
              for (const t2 of e2) if (!this._isValidId(t2)) return false;
              return true;
            }
            return this._isTargetValid(e2);
          }
          addSource(e2, t2) {
            return this._isValidId(e2) ? (this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true)) : this;
          }
          isSourceLoaded(e2) {
            return !!this._isValidId(e2) && !!this.style && this.style._isSourceCacheLoaded(e2);
          }
          areTilesLoaded() {
            return this.style.areTilesLoaded();
          }
          addSourceType(e2, t2, i2) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
          }
          removeSource(e2) {
            return this._isValidId(e2) ? (this.style.removeSource(e2), this._updateTerrain(), this._update(true)) : this;
          }
          getSource(e2) {
            return this._isValidId(e2) ? this.style.getOwnSource(e2) : null;
          }
          addImage(t2, i2, { pixelRatio: o2 = 1, sdf: s2 = false, stretchX: r2, stretchY: n2, content: a2 } = {}) {
            this._lazyInitEmptyStyle();
            const l2 = e.I.from(t2);
            if (i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap) {
              const { width: t3, height: c2, data: h2 } = e.o.getImageData(i2);
              this.style.addImage(l2, { data: new e.q({ width: t3, height: c2 }, h2), pixelRatio: o2, stretchX: r2, stretchY: n2, content: a2, sdf: s2, version: 0, usvg: false });
            } else if (void 0 === i2.width || void 0 === i2.height) this.fire(new e.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: c2, height: h2 } = i2, d2 = i2;
              this.style.addImage(l2, { data: new e.q({ width: c2, height: h2 }, new Uint8Array(d2.data)), pixelRatio: o2, stretchX: r2, stretchY: n2, content: a2, sdf: s2, usvg: false, version: 0, userImage: d2 }), d2.onAdd && d2.onAdd(this, t2);
            }
          }
          updateImage(t2, i2) {
            this._lazyInitEmptyStyle();
            const o2 = e.I.from(t2), s2 = this.style.getImage(o2);
            if (!s2) return void this.fire(new e.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r2 = i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap ? e.o.getImageData(i2) : i2, { width: n2, height: a2, data: l2 } = r2;
            if (void 0 === n2 || void 0 === a2) return void this.fire(new e.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (n2 !== (s2.usvg ? s2.icon.usvg_tree.width : s2.data.width) || a2 !== (s2.usvg ? s2.icon.usvg_tree.height : s2.data.height)) return void this.fire(new e.y(new Error(`The width and height of the updated image (${n2}, ${a2})
                must be that same as the previous version of the image
                (${s2.data.width}, ${s2.data.height})`)));
            const c2 = !(i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap);
            let h2 = false;
            s2.usvg ? (s2.data = new e.q({ width: n2, height: a2 }, new Uint8Array(l2)), s2.usvg = false, s2.icon = void 0, h2 = true) : s2.data.replace(l2, c2), this.style.updateImage(o2, s2, h2);
          }
          hasImage(t2) {
            return t2 ? !!this.style && !!this.style.getImage(e.I.from(t2)) : (this.fire(new e.y(new Error("Missing required image id"))), false);
          }
          removeImage(t2) {
            this.style.removeImage(e.I.from(t2));
          }
          loadImage(t2, i2) {
            e.n(this._requestManager.transformRequest(t2, e.R.Image), (t3, o2) => {
              i2(t3, o2 instanceof HTMLImageElement ? e.o.getImageData(o2) : o2);
            });
          }
          listImages() {
            return this.style.listImages().map((e2) => e2.name);
          }
          addModel(e2, t2) {
            this._lazyInitEmptyStyle(), this.style.addModel(e2, t2);
          }
          hasModel(t2) {
            return t2 ? this.style.hasModel(t2) : (this.fire(new e.y(new Error("Missing required model id"))), false);
          }
          removeModel(e2) {
            this.style.removeModel(e2);
          }
          listModels() {
            return this.style.listModels();
          }
          addLayer(e2, t2) {
            return this._isValidId(e2.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true)) : this;
          }
          getSlot(e2) {
            const t2 = this.getLayer(e2);
            return t2 && t2.slot || null;
          }
          setSlot(e2, t2) {
            return this.style.setSlot(e2, t2), this.style.mergeLayers(), this._update(true);
          }
          addImport(t2, i2) {
            return this.style.addImport(t2, i2).catch((t3) => this.fire(new e.y(new Error("Failed to add import", t3)))), this;
          }
          updateImport(e2, t2) {
            return "string" != typeof t2 && t2.id !== e2 ? (this.removeImport(e2), this.addImport(t2)) : (this.style.updateImport(e2, t2), this._update(true));
          }
          removeImport(e2) {
            return this.style.removeImport(e2), this;
          }
          moveImport(e2, t2) {
            return this.style.moveImport(e2, t2), this._update(true);
          }
          moveLayer(e2, t2) {
            return this._isValidId(e2) ? (this.style.moveLayer(e2, t2), this._update(true)) : this;
          }
          removeLayer(e2) {
            return this._isValidId(e2) ? (this.style.removeLayer(e2), this._update(true)) : this;
          }
          getLayer(e2) {
            if (!this._isValidId(e2)) return null;
            const t2 = this.style.getOwnLayer(e2);
            return t2 ? "custom" === t2.type ? t2.implementation : t2.serialize() : void 0;
          }
          getSlots() {
            return this.style.getSlots();
          }
          setLayerZoomRange(e2, t2, i2) {
            return this._isValidId(e2) ? (this.style.setLayerZoomRange(e2, t2, i2), this._update(true)) : this;
          }
          setFilter(e2, t2, i2 = {}) {
            return this._isValidId(e2) ? (this.style.setFilter(e2, t2, i2), this._update(true)) : this;
          }
          getFilter(e2) {
            return this._isValidId(e2) ? this.style.getFilter(e2) : null;
          }
          setPaintProperty(e2, t2, i2, o2 = {}) {
            return this._isValidId(e2) ? (this.style.setPaintProperty(e2, t2, i2, o2), this._update(true)) : this;
          }
          getPaintProperty(e2, t2) {
            return this._isValidId(e2) ? this.style.getPaintProperty(e2, t2) : null;
          }
          setLayoutProperty(e2, t2, i2, o2 = {}) {
            return this._isValidId(e2) ? (this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true)) : this;
          }
          getLayoutProperty(e2, t2) {
            return this._isValidId(e2) ? this.style.getLayoutProperty(e2, t2) : null;
          }
          setLayerProperty(e2, t2, i2, o2 = {}) {
            return this._isValidId(e2) ? ("appearances" === t2 && this._postAddingAppearancesToStyleEvent(), this.style.setLayerProperty(e2, t2, i2, o2), this._update(true)) : this;
          }
          getGlyphsUrl() {
            return this.style.getGlyphsUrl();
          }
          setGlyphsUrl(e2) {
            return this.style.setGlyphsUrl(e2), this._update(true);
          }
          getSchema(e2) {
            return this.style.getSchema(e2);
          }
          setSchema(e2, t2) {
            return this.style.setSchema(e2, t2), this._update(true);
          }
          getConfig(e2) {
            return this.style.getConfig(e2);
          }
          setConfig(e2, t2) {
            return this.style.setConfig(e2, t2), this._update(true);
          }
          getConfigProperty(e2, t2) {
            return this.style.getConfigProperty(e2, t2);
          }
          setConfigProperty(e2, t2, i2) {
            return this.style.setConfigProperty(e2, t2, i2), this._update(true);
          }
          getFeaturesetDescriptors(e2) {
            return this.style.getFeaturesetDescriptors(e2);
          }
          setLights(e2) {
            if (this._lazyInitEmptyStyle(), e2 && 1 === e2.length && "flat" === e2[0].type) {
              const t2 = e2[0];
              t2.properties ? this.style.setFlatLight(t2.properties, t2.id, {}) : this.style.setFlatLight({}, "flat");
            } else this.style.setLights(e2), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
            return this._update(true);
          }
          getLights() {
            const e2 = this.style.getLights() || [];
            return 0 === e2.length && e2.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e2;
          }
          setLight(e2, t2 = {}) {
            return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e2 }]);
          }
          getLight() {
            return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
          }
          setTerrain(e2) {
            return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e2) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          setSnow(e2) {
            return this._lazyInitEmptyStyle(), this.style.setSnow(e2), this._update(true);
          }
          getSnow() {
            return this.style ? this.style.getSnow() : null;
          }
          setRain(e2) {
            return this._lazyInitEmptyStyle(), this.style.setRain(e2), this._update(true);
          }
          getRain() {
            return this.style ? this.style.getRain() : null;
          }
          setColorTheme(e2) {
            return this._lazyInitEmptyStyle(), this.style.setColorTheme(e2), this._update(true);
          }
          setImportColorTheme(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e2, t2), this._update(true);
          }
          setCamera(e2) {
            return this.style.setCamera(e2), this._triggerCameraUpdate(e2);
          }
          _triggerCameraUpdate(e2) {
            return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e2["camera-projection"]));
          }
          getCamera() {
            return this.style.camera;
          }
          _queryFogOpacity(t2) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.aT.convert(t2), this.transform) : 0;
          }
          setFeatureState(e2, t2) {
            return e2.source && !this._isValidId(e2.source) ? this : (this.style.setFeatureState(e2, t2), this._update());
          }
          removeFeatureState(e2, t2) {
            return e2.source && !this._isValidId(e2.source) ? this : (this.style.removeFeatureState(e2, t2), this._update());
          }
          getFeatureState(e2) {
            return e2.source && !this._isValidId(e2.source) ? null : this.style.getFeatureState(e2);
          }
          _selectIndoorFloor(e2) {
            this.style.indoorManager.selectFloor(e2);
          }
          _setIndoorActiveFloorsVisibility(e2) {
            this.style.indoorManager.setActiveFloorsVisibility(e2);
          }
          getIndoorTileOptions(e2, t2) {
            return this.style.isIndoorEnabled() ? this.style.indoorManager.getIndoorTileOptions(e2, t2) : null;
          }
          _updateContainerDimensions() {
            if (!this._container) return;
            const e2 = this._container.getBoundingClientRect().width || 400, t2 = this._container.getBoundingClientRect().height || 300;
            let i2, o2, s2, r2 = this._container;
            for (; r2 && (!o2 || !s2); ) {
              const e3 = window.getComputedStyle(r2).transform;
              e3 && "none" !== e3 && (i2 = e3.match(/matrix.*\((.+)\)/)[1].split(", "), i2[0] && "0" !== i2[0] && "1" !== i2[0] && (o2 = i2[0]), i2[3] && "0" !== i2[3] && "1" !== i2[3] && (s2 = i2[3])), r2 = r2.parentElement;
            }
            this._containerWidth = o2 ? Math.abs(e2 / o2) : e2, this._containerHeight = s2 ? Math.abs(t2 / s2) : t2;
          }
          _detectMissingCSS() {
            "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e2 = this._container;
            e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
            const t2 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e2);
            this._canvas = l("canvas", "mapboxgl-canvas", t2), this._interactive && (t2.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i2 = this._controlContainer = l("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
            ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((e3) => {
              o2[e3] = l("div", `mapboxgl-ctrl-${e3}`, i2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t2, i2) {
            const o2 = e.o.devicePixelRatio || 1;
            this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
          }
          _addMarker(e2) {
            this._markers.push(e2);
          }
          _removeMarker(e2) {
            const t2 = this._markers.indexOf(e2);
            -1 !== t2 && this._markers.splice(t2, 1);
          }
          _addPopup(e2) {
            this._popups.push(e2);
          }
          _removePopup(e2) {
            const t2 = this._popups.indexOf(e2);
            -1 !== t2 && this._popups.splice(t2, 1);
          }
          _setupPainter() {
            const t2 = Object.assign({}, a.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), i2 = this._canvas.getContext("webgl2", t2);
            i2 ? (Z(i2, true), this.painter = new Pa(i2, this._contextCreateOptions, this.transform, this._scaleFactor, this._worldview), this.on("data", (e2) => {
              if ("source" === e2.dataType) {
                const t3 = this.transform.elevation ? this.transform.elevation._source() : null;
                t3 && e2.sourceCacheId === t3.id && this.style && this.style._setLabelPlacementStale(), this.painter.setTileLoadedFlag(true);
              }
            }), e.k.testSupport(i2)) : this.fire(new e.y(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t2) {
            t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.z("webglcontextlost", { originalEvent: t2 }));
          }
          _contextRestored(t2) {
            this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.clearLayers(), this.style.imageManager.destroyAtlasTextures(), this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e.z("webglcontextrestored", { originalEvent: t2 }));
          }
          _onMapScroll(e2) {
            if (e2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          idle() {
            return !this.isMoving() && this.loaded();
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          frameReady() {
            return this.loaded() && !this._placementDirty;
          }
          _update(e2) {
            return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e2) {
            return this._update(), this._renderTaskQueue.add(e2);
          }
          _cancelRenderFrame(e2) {
            this._renderTaskQueue.remove(e2);
          }
          _requestDomTask(e2) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
          }
          _render(t2) {
            let s2;
            this.fire(new e.z("renderstart")), ++this._frameId;
            const r2 = this.painter.context.extTimerQuery, n2 = e.o.now(), a2 = this.painter.context.gl;
            if (this.listens("gpu-timing-frame") && (s2 = a2.createQuery(), a2.beginQuery(r2.TIME_ELAPSED_EXT, s2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed) return;
            this._updateProjectionTransition();
            const l2 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t3 = this.transform.zoom, i2 = this.transform.pitch, o2 = e.o.now(), s3 = new e.ac(t3, { now: o2, fadeDuration: l2, pitch: i2, transition: this.style.transition, worldview: this._worldview });
              this.style.update(s3);
            }
            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
            let c2 = false;
            if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), c2 = this._updateAverageElevation(n2), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c2 = this._updateAverageElevation(n2), this.style && (this._placementDirty = this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, l2, this._crossSourceCollisions, this.painter.replacementSource)), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.z("render")), this.loaded() && !this._loaded && (this._loaded = true, o.mark(i.load), this.fire(new e.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = true), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = true), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s2) {
              const t3 = e.o.now() - n2;
              a2.endQuery(r2.TIME_ELAPSED_EXT), setTimeout(() => {
                const i2 = a2.getQueryParameter(s2, a2.QUERY_RESULT) / 1e6;
                a2.deleteQuery(s2), this.fire(new e.z("gpu-timing-frame", { cpuTime: t3, gpuTime: i2 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t3 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i2 = this.painter.queryGpuTimers(t3);
                this.fire(new e.z("gpu-timing-layer", { layerTimes: i2 }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const t3 = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const i2 = this.painter.queryGpuTimeDeferredRender(t3);
                this.fire(new e.z("gpu-timing-deferred-render", { gpuTime: i2 }));
              }, 50);
            }
            const h2 = this._sourcesDirty || this._styleDirty || this._placementDirty || c2;
            if (h2 || this._repaint) this.triggerRepaint();
            else {
              const t3 = this.idle();
              if (t3 && (c2 = this._updateAverageElevation(n2, true)), c2) this.triggerRepaint();
              else if (this._triggerFrame(false), t3 && (this.fire(new e.z("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t4 = this._calculateSpeedIndex();
                this.fire(new e.z("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
              }
            }
            !this._loaded || this._fullyLoaded || h2 || (this._fullyLoaded = true, o.mark(i.fullLoad), this._performanceMetricsCollection && V(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(e2) {
            for (const t2 of this._markers) e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
            for (const t2 of this._popups) !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
          }
          _updateAverageElevation(e2, t2 = false) {
            const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i2(0);
            const o2 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
            if (o2 || (t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
              const t3 = this.transform.averageElevation;
              let s2 = this.transform.sampleAverageElevation();
              null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s2) ? s2 = 0 : this._averageElevationLastSampledAt = e2;
              const r2 = Math.abs(t3 - s2);
              if (r2 > 1) {
                if (this._isInitialLoad || o2) return this._averageElevation.jumpTo(s2), i2(s2);
                this._averageElevation.easeTo(s2, e2, 300);
              } else if (r2 > 1e-4) return this._averageElevation.jumpTo(s2), i2(s2);
            }
            return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
          }
          _authenticate() {
            H(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
              if (t2 && (t2.message === w || 401 === t2.status)) {
                const t3 = this.painter.context.gl;
                Z(t3, false), this._logoControl instanceof Bl && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), z(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _postStyleLoadEvent() {
            this.style.globalId && F(this._requestManager._customAccessToken, { map: this, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
          }
          _postStyleWithAppearanceEvent() {
            this.style.globalId && this.style.hasAppearances() && k(this._requestManager._customAccessToken);
          }
          _postAddingAppearancesToStyleEvent() {
            U(this._requestManager._customAccessToken);
          }
          _updateTerrain() {
            const e2 = this._isDragging();
            this.painter.updateTerrain(this.style, e2);
          }
          _calculateSpeedIndex() {
            const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
            t2.timeStamps.push(performance.now());
            const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
            function s2(e3) {
              i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
              const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
              return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
            }
            return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(s2(e2), t2.canvasCopies.map(s2), t2.timeStamps);
          }
          _canvasPixelComparison(e2, t2, i2) {
            let o2 = i2[1] - i2[0];
            const s2 = e2.length / 4;
            for (let r2 = 0; r2 < t2.length; r2++) {
              const n2 = t2[r2];
              let a2 = 0;
              for (let t3 = 0; t3 < n2.length; t3 += 4) n2[t3] === e2[t3] && n2[t3 + 1] === e2[t3 + 1] && n2[t3 + 2] === e2[t3 + 2] && n2[t3 + 3] === e2[t3 + 3] && (a2 += 1);
              o2 += (i2[r2 + 2] - i2[r2 + 1]) * (1 - a2 / s2);
            }
            return o2;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e2 of this._controls) e2.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
            const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), q.delete(this.painter.context.gl), G.remove(), O.remove(), this._removed = true, this.fire(new e.z("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t2) {
            this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.o.frame((e2) => {
              const t3 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
            }));
          }
          _preloadTiles(t2) {
            const i2 = this.style ? this.style.getSourceCaches() : [];
            return e.bw(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e2) {
            this._trackResize && this.resize({ originalEvent: e2 })._update();
          }
          _onVisibilityChange() {
            "hidden" === document.visibilityState && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e2) {
            this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
          }
          get showParseStatus() {
            return !!this._showParseStatus;
          }
          set showParseStatus(e2) {
            this._showParseStatus !== e2 && (this._showParseStatus = e2, this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e2) {
            this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
          }
          get showLayers2DWireframe() {
            return !!this._showLayers2DWireframe;
          }
          set showLayers2DWireframe(e2) {
            this._showLayers2DWireframe !== e2 && (this._showLayers2DWireframe = e2, this._update());
          }
          get showLayers3DWireframe() {
            return !!this._showLayers3DWireframe;
          }
          set showLayers3DWireframe(e2) {
            this._showLayers3DWireframe !== e2 && (this._showLayers3DWireframe = e2, this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e2) {
            this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e2) {
            this._showPadding !== e2 && (this._showPadding = e2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e2) {
            this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, this.style && e2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e2) {
            this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e2) {
            this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e2) {
            this._vertices = e2, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(e2) {
            this._showTileAABBs !== e2 && (this._showTileAABBs = e2, e2 && this._update());
          }
          _setCacheLimits(t2, i2) {
            e.f4(t2, i2);
          }
          get version() {
            return t;
          }
        }, NavigationControl: class {
          constructor(t2 = {}) {
            this.options = Object.assign({}, ql, t2), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.aY(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
              this._map && this._map.zoomIn({}, { originalEvent: e2 });
            }), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
              this._map && this._map.zoomOut({}, { originalEvent: e2 });
            }), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aY(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
              const t3 = this._map;
              t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
            }), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const e2 = this._map;
            if (!e2) return;
            const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
            this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
          }
          _rotateCompassArrow() {
            const e2 = this._map;
            if (!e2) return;
            const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
            e2._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t2);
            });
          }
          onAdd(e2) {
            return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Zl(e2, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const e2 = this._map;
            e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(e2, t2) {
            const i2 = l("button", e2, this._container);
            return i2.type = "button", i2.addEventListener("click", t2), i2;
          }
          _setButtonTitle(e2, t2) {
            if (!this._map) return;
            const i2 = this._map._getUIString(`NavigationControl.${t2}`);
            e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
          }
        }, GeolocateControl: class extends e.E {
          constructor(t2 = {}) {
            super();
            const i2 = navigator.geolocation;
            this.options = Object.assign({ geolocation: i2 }, Kl, t2), e.aY(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Oa(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(e2) {
            return this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            this._clearRequestTimeout(), void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
          }
          _checkGeolocationSupport(e2) {
            const t2 = (t3 = !!this.options.geolocation) => {
              this._supportsGeolocation = t3, e2(t3);
            };
            void 0 !== this._supportsGeolocation ? e2(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e3) => t2("denied" !== e3.state)).catch(() => t2()) : t2();
          }
          _isOutOfMapMaxBounds(e2) {
            const t2 = this._map.getMaxBounds(), i2 = e2.coords;
            return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t2) {
            if (this._map) {
              if (this._clearRequestTimeout(), this._isOutOfMapMaxBounds(t2)) return this._setErrorState(), this.fire(new e.z("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t2, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this.options.followUserLocation ? (this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active")) : (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"));
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.followUserLocation && (!this.options.trackUserLocation || "ACTIVE_LOCK" === this._watchState) && this._updateCamera(t2), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("geolocate", Object.assign({ coords: t2.coords, timestamp: t2.timestamp }, t2.toJSON ? { toJSON: t2.toJSON.bind(t2) } : {}))), this._finish();
            }
          }
          _updateCamera(t2) {
            const i2 = new e.aT(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, s2 = this._map.getBearing(), r2 = Object.assign({ bearing: s2 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i2.toBounds(o2), r2, { geolocateSource: true });
          }
          _updateMarker(t2) {
            if (t2) {
              const i2 = new e.aT(t2.coords.longitude, t2.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t2 = this._map.transform, i2 = e.cf(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
            this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t2) {
            if (this._map) {
              if (this._clearRequestTimeout(), this.options.trackUserLocation) if (1 === t2.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === t2.code && this._noTimeout) return;
                this._setErrorState();
              }
              "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("error", { code: t2.code, message: t2.message, PERMISSION_DENIED: t2.PERMISSION_DENIED, POSITION_UNAVAILABLE: t2.POSITION_UNAVAILABLE, TIMEOUT: t2.TIMEOUT })), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _startRequestTimeout() {
            this._clearRequestTimeout();
            const e2 = this.options.positionOptions.timeout;
            e2 && (this._requestTimeoutId = window.setTimeout(() => {
              this._onError({ code: 3, message: "Geolocation request timed out" });
            }, e2));
          }
          _clearRequestTimeout() {
            void 0 !== this._requestTimeoutId && (clearTimeout(this._requestTimeoutId), this._requestTimeoutId = void 0);
          }
          _setupUI(t2) {
            if (void 0 !== this._map) {
              if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
                e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
              } else {
                const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Yl({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Yl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.showButton || (this._container.style.display = "none"), this.options.trackUserLocation && this._map.on("movestart", (t3) => {
                t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.z("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(e2) {
            this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup) return e.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e.z("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.z("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e2;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this._startRequestTimeout(), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._startRequestTimeout(), this._timeoutId = window.setTimeout(this._finish, 1e4);
            return true;
          }
          setFollowUserLocation(t2) {
            return this.options.followUserLocation = null != t2 ? t2 : Kl.followUserLocation, this.options.trackUserLocation && "OFF" !== this._watchState && (this.options.followUserLocation ? "BACKGROUND" !== this._watchState && "BACKGROUND_ERROR" !== this._watchState || (this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z("trackuserlocationstart"))) : "ACTIVE_LOCK" !== this._watchState && "ACTIVE_ERROR" !== this._watchState || (this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this.fire(new e.z("trackuserlocationend")))), this;
          }
          _addDeviceOrientationListener() {
            const e2 = () => {
              const e3 = "ondeviceorientationabsolute" in window ? "deviceorientationabsolute" : "deviceorientation";
              window.addEventListener(e3, this._onDeviceOrientation);
            };
            "function" == typeof DeviceOrientationEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t2) => {
              "granted" === t2 && e2();
            }).catch(console.error) : e2();
          }
          _clearWatch() {
            this._clearRequestTimeout(), this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Fl, ScaleControl: class {
          constructor(t2 = {}) {
            this.options = Object.assign({}, Jl, t2), e.aY(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, s2 = t2.unproject([o2, i2]), r2 = t2.unproject([o2 + e2, i2]), n2 = s2.distanceTo(r2);
            if ("imperial" === this.options.unit) {
              const t3 = 3.2808 * n2;
              t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
            } else "nautical" === this.options.unit ? this._setScale(e2, n2 / 1852, "nautical-mile") : n2 >= 1e3 ? this._setScale(e2, n2 / 1e3, "kilometer") : this._setScale(e2, n2, "meter");
          }
          _setScale(e2, t2, i2) {
            this._map._requestDomTask(() => {
              const o2 = function(e3) {
                const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
                let i3 = e3 / t3;
                return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                  const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                  return Math.round(e4 * t4) / t4;
                }(i3), t3 * i3;
              }(t2), s2 = o2 / t2;
              this._container.innerHTML = "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i2 }).format(o2) : `${o2}&nbsp;${Ql[i2]}`, this._container.style.width = e2 * s2 + "px";
            });
          }
          onAdd(e2) {
            return this._map = e2, this._language = e2.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(e2) {
            this._language = e2, this._update();
          }
          setUnit(e2) {
            this.options.unit = e2, this._update();
          }
        }, FullscreenControl: class {
          constructor(t2 = {}) {
            this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), e.aY(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t2) {
            return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const e2 = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            l("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, IndoorControl: So, Popup: class extends e.E {
          constructor(t2) {
            super(), this.options = Object.assign(Object.create(ec), t2), this._altitude = this.options.altitude, e.aY(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
          }
          addTo(t2) {
            return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.z("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const t2 = this._map;
            return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.z("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            this._lngLat = e.aT.convert(t2), this._pos = null, this._trackPointer = false, this._update();
            const i2 = this._map;
            return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          getAltitude() {
            return this._altitude;
          }
          setAltitude(e2) {
            return this._altitude = e2, this._update(), this;
          }
          trackPointer() {
            this._trackPointer = true, this._pos = null, this._update();
            const e2 = this._map;
            return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(e2) {
            return this.setDOMContent(document.createTextNode(e2));
          }
          setHTML(e2) {
            const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
            let o2;
            for (i2.innerHTML = e2; o2 = i2.firstChild, o2; ) t2.appendChild(o2);
            return this.setDOMContent(t2);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e2) {
            return this.options.maxWidth = e2, this._update(), this;
          }
          setDOMContent(e2) {
            let t2 = this._content;
            if (t2) for (; t2.hasChildNodes(); ) t2.firstChild && t2.removeChild(t2.firstChild);
            else t2 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
            if (t2.appendChild(e2), this.options.closeButton) {
              const e3 = this._closeButton = l("button", "mapboxgl-popup-close-button", t2);
              e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.innerHTML = '<span aria-hidden="true">&#215;</span>', e3.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(e2) {
            return this._classList.add(e2), this._updateClassList(), this;
          }
          removeClassName(e2) {
            return this._classList.delete(e2), this._updateClassList(), this;
          }
          setOffset(e2) {
            return this.options.offset = e2, this._update(), this;
          }
          toggleClassName(e2) {
            let t2;
            return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
          }
          _onMouseEvent(e2) {
            this._update(e2.point);
          }
          _getAnchor(e2) {
            if (this.options.anchor) return this.options.anchor;
            const t2 = this._map, i2 = this._container, o2 = this._pos;
            if (!t2 || !i2 || !o2) return "bottom";
            const s2 = i2.offsetWidth, r2 = i2.offsetHeight, n2 = o2.x < s2 / 2, a2 = o2.x > t2.transform.width - s2 / 2;
            if (o2.y + e2 < r2) return n2 ? "top-left" : a2 ? "top-right" : "top";
            if (o2.y > t2.transform.height - r2) {
              if (n2) return "bottom-left";
              if (a2) return "bottom-right";
            }
            return n2 ? "left" : a2 ? "right" : "bottom";
          }
          _updateClassList() {
            const e2 = this._container;
            if (!e2) return;
            const t2 = [...this._classList];
            t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
          }
          _update(t2) {
            const i2 = this._map, o2 = this._content;
            if (!i2 || !this._lngLat && !this._trackPointer || !o2) return;
            let s2 = this._container;
            if (s2 || (s2 = this._container = l("div", "mapboxgl-popup", i2.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", s2), s2.appendChild(o2)), this.options.maxWidth && s2.style.maxWidth !== this.options.maxWidth && (s2.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Wl(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
              const o3 = this._pos = this._trackPointer && t2 instanceof e.P ? t2 : i2.project(this._lngLat, this._altitude), s3 = ic(this.options.offset), r2 = this._anchor = this._getAnchor(s3.y), n2 = ic(this.options.offset, r2), a2 = o3.add(n2).round();
              i2._requestDomTask(() => {
                this._container && r2 && (this._container.style.transform = `${$l[r2]} translate(${a2.x}px,${a2.y}px)`);
              });
            }
            if (!this._marker && i2._showingGlobe()) {
              const t3 = e.f5(i2.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(t3);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const e2 = this._container.querySelector(tc);
            e2 && e2.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e2) {
            this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
          }
        }, Marker: Yl, Style: Oo, LngLat: e.aT, LngLatBounds: e.aI, Point: e.P, MercatorCoordinate: e.ae, FreeCameraOptions: oo, Evented: e.E, config: e.e, prewarm: e.f9, clearPrewarmedResources: e.f8, get accessToken() {
          return e.e.ACCESS_TOKEN;
        }, set accessToken(t2) {
          e.e.ACCESS_TOKEN = t2;
        }, get baseApiUrl() {
          return e.e.API_URL;
        }, set baseApiUrl(t2) {
          e.e.API_URL = t2;
        }, get workerCount() {
          return e.fi.workerCount;
        }, set workerCount(t2) {
          e.fi.workerCount = t2;
        }, get maxParallelImageRequests() {
          return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t2) {
          e.e.MAX_PARALLEL_IMAGE_REQUESTS = t2;
        }, clearStorage(t2) {
          e.fh(t2);
        }, get workerUrl() {
          return e.fg.workerUrl;
        }, set workerUrl(t2) {
          e.fg.workerUrl = t2;
        }, get workerClass() {
          return e.fg.workerClass;
        }, set workerClass(t2) {
          e.fg.workerClass = t2;
        }, get workerParams() {
          return e.fg.workerParams;
        }, set workerParams(t2) {
          e.fg.workerParams = t2;
        }, get dracoUrl() {
          return e.ff();
        }, set dracoUrl(t2) {
          e.fe(t2);
        }, get meshoptUrl() {
          return e.fd();
        }, set meshoptUrl(t2) {
          e.fc(t2);
        }, setNow: e.o.setNow, restoreNow: e.o.restoreNow };
        return oc;
      });
      var mapboxgl$1 = mapboxgl;
      return mapboxgl$1;
    });
  }
});
export default require_mapbox_gl();
//# sourceMappingURL=mapbox-gl.js.map
